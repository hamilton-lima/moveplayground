import{b as gL,c as yL,f as aae,g as xL}from"./chunk-LJ5XHLMQ.js";import{a as et,b as mn,d as bn,e as ur,f as If,g as iae,h as L}from"./chunk-FK42CRUA.js";var ZV=bn(YV=>{"use strict";(function(){"use strict";var r;function t(v){var S=0;return function(){return S<v.length?{done:!1,value:v[S++]}:{done:!0}}}var e=typeof Object.defineProperties=="function"?Object.defineProperty:function(v,S,k){return v==Array.prototype||v==Object.prototype||(v[S]=k.value),v};function n(v){v=[typeof globalThis=="object"&&globalThis,v,typeof window=="object"&&window,typeof self=="object"&&self,typeof global=="object"&&global];for(var S=0;S<v.length;++S){var k=v[S];if(k&&k.Math==Math)return k}throw Error("Cannot find global object")}var o=n(this);function s(v,S){if(S)e:{var k=o;v=v.split(".");for(var M=0;M<v.length-1;M++){var W=v[M];if(!(W in k))break e;k=k[W]}v=v[v.length-1],M=k[v],S=S(M),S!=M&&S!=null&&e(k,v,{configurable:!0,writable:!0,value:S})}}s("Symbol",function(v){function S(q){if(this instanceof S)throw new TypeError("Symbol is not a constructor");return new k(M+(q||"")+"_"+W++,q)}function k(q,H){this.h=q,e(this,"description",{configurable:!0,writable:!0,value:H})}if(v)return v;k.prototype.toString=function(){return this.h};var M="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",W=0;return S}),s("Symbol.iterator",function(v){if(v)return v;v=Symbol("Symbol.iterator");for(var S="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),k=0;k<S.length;k++){var M=o[S[k]];typeof M=="function"&&typeof M.prototype[v]!="function"&&e(M.prototype,v,{configurable:!0,writable:!0,value:function(){return i(t(this))}})}return v});function i(v){return v={next:v},v[Symbol.iterator]=function(){return this},v}function a(v){var S=typeof Symbol<"u"&&Symbol.iterator&&v[Symbol.iterator];return S?S.call(v):{next:t(v)}}function u(v){if(!(v instanceof Array)){v=a(v);for(var S,k=[];!(S=v.next()).done;)k.push(S.value);v=k}return v}var l=typeof Object.assign=="function"?Object.assign:function(v,S){for(var k=1;k<arguments.length;k++){var M=arguments[k];if(M)for(var W in M)Object.prototype.hasOwnProperty.call(M,W)&&(v[W]=M[W])}return v};s("Object.assign",function(v){return v||l});var c=typeof Object.create=="function"?Object.create:function(v){function S(){}return S.prototype=v,new S},p;if(typeof Object.setPrototypeOf=="function")p=Object.setPrototypeOf;else{var d;e:{var f={a:!0},h={};try{h.__proto__=f,d=h.a;break e}catch{}d=!1}p=d?function(v,S){if(v.__proto__=S,v.__proto__!==S)throw new TypeError(v+" is not extensible");return v}:null}var m=p;function g(v,S){if(v.prototype=c(S.prototype),v.prototype.constructor=v,m)m(v,S);else for(var k in S)if(k!="prototype")if(Object.defineProperties){var M=Object.getOwnPropertyDescriptor(S,k);M&&Object.defineProperty(v,k,M)}else v[k]=S[k];v.za=S.prototype}function y(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function x(v){if(v.m)throw new TypeError("Generator is already running");v.m=!0}y.prototype.u=function(v){this.i=v};function w(v,S){v.l={ma:S,na:!0},v.h=v.s||v.v}y.prototype.return=function(v){this.l={return:v},this.h=this.v};function C(v,S,k){return v.h=k,{value:S}}function I(v){this.h=new y,this.i=v}function N(v,S){x(v.h);var k=v.h.j;return k?A(v,"return"in k?k.return:function(M){return{value:M,done:!0}},S,v.h.return):(v.h.return(S),O(v))}function A(v,S,k,M){try{var W=S.call(v.h.j,k);if(!(W instanceof Object))throw new TypeError("Iterator result "+W+" is not an object");if(!W.done)return v.h.m=!1,W;var q=W.value}catch(H){return v.h.j=null,w(v.h,H),O(v)}return v.h.j=null,M.call(v.h,q),O(v)}function O(v){for(;v.h.h;)try{var S=v.i(v.h);if(S)return v.h.m=!1,{value:S.value,done:!1}}catch(k){v.h.i=void 0,w(v.h,k)}if(v.h.m=!1,v.h.l){if(S=v.h.l,v.h.l=null,S.na)throw S.ma;return{value:S.return,done:!0}}return{value:void 0,done:!0}}function $(v){this.next=function(S){return x(v.h),v.h.j?S=A(v,v.h.j.next,S,v.h.u):(v.h.u(S),S=O(v)),S},this.throw=function(S){return x(v.h),v.h.j?S=A(v,v.h.j.throw,S,v.h.u):(w(v.h,S),S=O(v)),S},this.return=function(S){return N(v,S)},this[Symbol.iterator]=function(){return this}}function z(v){function S(M){return v.next(M)}function k(M){return v.throw(M)}return new Promise(function(M,W){function q(H){H.done?M(H.value):Promise.resolve(H.value).then(S,k).then(q,W)}q(v.next())})}function G(v){return z(new $(new I(v)))}s("Promise",function(v){function S(H){this.i=0,this.j=void 0,this.h=[],this.u=!1;var ee=this.l();try{H(ee.resolve,ee.reject)}catch(ue){ee.reject(ue)}}function k(){this.h=null}function M(H){return H instanceof S?H:new S(function(ee){ee(H)})}if(v)return v;k.prototype.i=function(H){if(this.h==null){this.h=[];var ee=this;this.j(function(){ee.m()})}this.h.push(H)};var W=o.setTimeout;k.prototype.j=function(H){W(H,0)},k.prototype.m=function(){for(;this.h&&this.h.length;){var H=this.h;this.h=[];for(var ee=0;ee<H.length;++ee){var ue=H[ee];H[ee]=null;try{ue()}catch(Ce){this.l(Ce)}}}this.h=null},k.prototype.l=function(H){this.j(function(){throw H})},S.prototype.l=function(){function H(Ce){return function(De){ue||(ue=!0,Ce.call(ee,De))}}var ee=this,ue=!1;return{resolve:H(this.I),reject:H(this.m)}},S.prototype.I=function(H){if(H===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(H instanceof S)this.L(H);else{e:switch(typeof H){case"object":var ee=H!=null;break e;case"function":ee=!0;break e;default:ee=!1}ee?this.F(H):this.s(H)}},S.prototype.F=function(H){var ee=void 0;try{ee=H.then}catch(ue){this.m(ue);return}typeof ee=="function"?this.M(ee,H):this.s(H)},S.prototype.m=function(H){this.v(2,H)},S.prototype.s=function(H){this.v(1,H)},S.prototype.v=function(H,ee){if(this.i!=0)throw Error("Cannot settle("+H+", "+ee+"): Promise already settled in state"+this.i);this.i=H,this.j=ee,this.i===2&&this.K(),this.H()},S.prototype.K=function(){var H=this;W(function(){if(H.D()){var ee=o.console;typeof ee<"u"&&ee.error(H.j)}},1)},S.prototype.D=function(){if(this.u)return!1;var H=o.CustomEvent,ee=o.Event,ue=o.dispatchEvent;return typeof ue>"u"?!0:(typeof H=="function"?H=new H("unhandledrejection",{cancelable:!0}):typeof ee=="function"?H=new ee("unhandledrejection",{cancelable:!0}):(H=o.document.createEvent("CustomEvent"),H.initCustomEvent("unhandledrejection",!1,!0,H)),H.promise=this,H.reason=this.j,ue(H))},S.prototype.H=function(){if(this.h!=null){for(var H=0;H<this.h.length;++H)q.i(this.h[H]);this.h=null}};var q=new k;return S.prototype.L=function(H){var ee=this.l();H.T(ee.resolve,ee.reject)},S.prototype.M=function(H,ee){var ue=this.l();try{H.call(ee,ue.resolve,ue.reject)}catch(Ce){ue.reject(Ce)}},S.prototype.then=function(H,ee){function ue(rt,Pe){return typeof rt=="function"?function(mt){try{Ce(rt(mt))}catch(Ft){De(Ft)}}:Pe}var Ce,De,ht=new S(function(rt,Pe){Ce=rt,De=Pe});return this.T(ue(H,Ce),ue(ee,De)),ht},S.prototype.catch=function(H){return this.then(void 0,H)},S.prototype.T=function(H,ee){function ue(){switch(Ce.i){case 1:H(Ce.j);break;case 2:ee(Ce.j);break;default:throw Error("Unexpected state: "+Ce.i)}}var Ce=this;this.h==null?q.i(ue):this.h.push(ue),this.u=!0},S.resolve=M,S.reject=function(H){return new S(function(ee,ue){ue(H)})},S.race=function(H){return new S(function(ee,ue){for(var Ce=a(H),De=Ce.next();!De.done;De=Ce.next())M(De.value).T(ee,ue)})},S.all=function(H){var ee=a(H),ue=ee.next();return ue.done?M([]):new S(function(Ce,De){function ht(mt){return function(Ft){rt[mt]=Ft,Pe--,Pe==0&&Ce(rt)}}var rt=[],Pe=0;do rt.push(void 0),Pe++,M(ue.value).T(ht(rt.length-1),De),ue=ee.next();while(!ue.done)})},S});function K(v,S){v instanceof String&&(v+="");var k=0,M=!1,W={next:function(){if(!M&&k<v.length){var q=k++;return{value:S(q,v[q]),done:!1}}return M=!0,{done:!0,value:void 0}}};return W[Symbol.iterator]=function(){return W},W}s("Array.prototype.keys",function(v){return v||function(){return K(this,function(S){return S})}}),s("Array.prototype.fill",function(v){return v||function(S,k,M){var W=this.length||0;for(0>k&&(k=Math.max(0,W+k)),(M==null||M>W)&&(M=W),M=Number(M),0>M&&(M=Math.max(0,W+M)),k=Number(k||0);k<M;k++)this[k]=S;return this}});function Z(v){return v||Array.prototype.fill}s("Int8Array.prototype.fill",Z),s("Uint8Array.prototype.fill",Z),s("Uint8ClampedArray.prototype.fill",Z),s("Int16Array.prototype.fill",Z),s("Uint16Array.prototype.fill",Z),s("Int32Array.prototype.fill",Z),s("Uint32Array.prototype.fill",Z),s("Float32Array.prototype.fill",Z),s("Float64Array.prototype.fill",Z),s("Object.is",function(v){return v||function(S,k){return S===k?S!==0||1/S===1/k:S!==S&&k!==k}}),s("Array.prototype.includes",function(v){return v||function(S,k){var M=this;M instanceof String&&(M=String(M));var W=M.length;for(k=k||0,0>k&&(k=Math.max(k+W,0));k<W;k++){var q=M[k];if(q===S||Object.is(q,S))return!0}return!1}}),s("String.prototype.includes",function(v){return v||function(S,k){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(S instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(S,k||0)!==-1}});var Q=this||self;function J(v,S){v=v.split(".");var k=Q;v[0]in k||typeof k.execScript>"u"||k.execScript("var "+v[0]);for(var M;v.length&&(M=v.shift());)v.length||S===void 0?k[M]&&k[M]!==Object.prototype[M]?k=k[M]:k=k[M]={}:k[M]=S}function te(v){var S;e:{if((S=Q.navigator)&&(S=S.userAgent))break e;S=""}return S.indexOf(v)!=-1}var ie=Array.prototype.map?function(v,S){return Array.prototype.map.call(v,S,void 0)}:function(v,S){for(var k=v.length,M=Array(k),W=typeof v=="string"?v.split(""):v,q=0;q<k;q++)q in W&&(M[q]=S.call(void 0,W[q],q,v));return M},ne={},ae=null;function ye(v){var S=v.length,k=3*S/4;k%3?k=Math.floor(k):"=.".indexOf(v[S-1])!=-1&&(k="=.".indexOf(v[S-2])!=-1?k-2:k-1);var M=new Uint8Array(k),W=0;return ge(v,function(q){M[W++]=q}),W!==k?M.subarray(0,W):M}function ge(v,S){function k(ue){for(;M<v.length;){var Ce=v.charAt(M++),De=ae[Ce];if(De!=null)return De;if(!/^[\s\xa0]*$/.test(Ce))throw Error("Unknown base64 encoding at char: "+Ce)}return ue}Se();for(var M=0;;){var W=k(-1),q=k(0),H=k(64),ee=k(64);if(ee===64&&W===-1)break;S(W<<2|q>>4),H!=64&&(S(q<<4&240|H>>2),ee!=64&&S(H<<6&192|ee))}}function Se(){if(!ae){ae={};for(var v="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),S=["+/=","+/","-_=","-_.","-_"],k=0;5>k;k++){var M=v.concat(S[k].split(""));ne[k]=M;for(var W=0;W<M.length;W++){var q=M[W];ae[q]===void 0&&(ae[q]=W)}}}}var be=typeof Uint8Array<"u",ke=!(te("Trident")||te("MSIE"))&&typeof Q.btoa=="function";function Te(v){if(!ke){var S;S===void 0&&(S=0),Se(),S=ne[S];for(var k=Array(Math.floor(v.length/3)),M=S[64]||"",W=0,q=0;W<v.length-2;W+=3){var H=v[W],ee=v[W+1],ue=v[W+2],Ce=S[H>>2];H=S[(H&3)<<4|ee>>4],ee=S[(ee&15)<<2|ue>>6],ue=S[ue&63],k[q++]=Ce+H+ee+ue}switch(Ce=0,ue=M,v.length-W){case 2:Ce=v[W+1],ue=S[(Ce&15)<<2]||M;case 1:v=v[W],k[q]=S[v>>2]+S[(v&3)<<4|Ce>>4]+ue+M}return k.join("")}for(S="";10240<v.length;)S+=String.fromCharCode.apply(null,v.subarray(0,10240)),v=v.subarray(10240);return S+=String.fromCharCode.apply(null,v),btoa(S)}var Oe=RegExp("[-_.]","g");function Ge(v){switch(v){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function Ke(v){if(!ke)return ye(v);Oe.test(v)&&(v=v.replace(Oe,Ge)),v=atob(v);for(var S=new Uint8Array(v.length),k=0;k<v.length;k++)S[k]=v.charCodeAt(k);return S}var Ze;function lt(){return Ze||(Ze=new Uint8Array(0))}var _e={},Ct=typeof Uint8Array.prototype.slice=="function",ze=0,nt=0;function Lt(v){var S=0>v;v=Math.abs(v);var k=v>>>0;v=Math.floor((v-k)/4294967296),S&&(k=a(vr(k,v)),S=k.next().value,v=k.next().value,k=S),ze=k>>>0,nt=v>>>0}var tt=typeof BigInt=="function";function vr(v,S){return S=~S,v?v=~v+1:S+=1,[v,S]}function Or(v,S){this.i=v>>>0,this.h=S>>>0}function ei(v){if(!v)return Dn||(Dn=new Or(0,0));if(!/^-?\d+$/.test(v))return null;if(16>v.length)Lt(Number(v));else if(tt)v=BigInt(v),ze=Number(v&BigInt(4294967295))>>>0,nt=Number(v>>BigInt(32)&BigInt(4294967295));else{var S=+(v[0]==="-");nt=ze=0;for(var k=v.length,M=S,W=(k-S)%6+S;W<=k;M=W,W+=6)M=Number(v.slice(M,W)),nt*=1e6,ze=1e6*ze+M,4294967296<=ze&&(nt+=ze/4294967296|0,ze%=4294967296);S&&(S=a(vr(ze,nt)),v=S.next().value,S=S.next().value,ze=v,nt=S)}return new Or(ze,nt)}var Dn;function zi(v,S){return Error("Invalid wire type: "+v+" (at position "+S+")")}function ho(){return Error("Failed to read varint, encoding is invalid.")}function gu(v,S){return Error("Tried to read past the end of the data "+S+" > "+v)}function Kn(){throw Error("Invalid UTF8")}function ti(v,S){return S=String.fromCharCode.apply(null,S),v==null?S:v+S}var Ps=void 0,ri,yu=typeof TextDecoder<"u",op,Lx=typeof TextEncoder<"u",ym;function Gw(v){if(v!==_e)throw Error("illegal external caller")}function xu(v,S){if(Gw(S),this.V=v,v!=null&&v.length===0)throw Error("ByteString should be constructed with non-empty values")}function zx(){return ym||(ym=new xu(null,_e))}function Ww(v){Gw(_e);var S=v.V;return S=S==null||be&&S!=null&&S instanceof Uint8Array?S:typeof S=="string"?Ke(S):null,S==null?S:v.V=S}function yie(v){if(typeof v=="string")return{buffer:Ke(v),C:!1};if(Array.isArray(v))return{buffer:new Uint8Array(v),C:!1};if(v.constructor===Uint8Array)return{buffer:v,C:!1};if(v.constructor===ArrayBuffer)return{buffer:new Uint8Array(v),C:!1};if(v.constructor===xu)return{buffer:Ww(v)||lt(),C:!0};if(v instanceof Uint8Array)return{buffer:new Uint8Array(v.buffer,v.byteOffset,v.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function MP(v,S){this.i=null,this.m=!1,this.h=this.j=this.l=0,kN(this,v,S)}function kN(v,S,k){k=k===void 0?{}:k,v.S=k.S===void 0?!1:k.S,S&&(S=yie(S),v.i=S.buffer,v.m=S.C,v.l=0,v.j=v.i.length,v.h=v.l)}MP.prototype.reset=function(){this.h=this.l};function wf(v,S){if(v.h=S,S>v.j)throw gu(v.j,S)}function Bx(v){var S=v.i,k=v.h,M=S[k++],W=M&127;if(M&128&&(M=S[k++],W|=(M&127)<<7,M&128&&(M=S[k++],W|=(M&127)<<14,M&128&&(M=S[k++],W|=(M&127)<<21,M&128&&(M=S[k++],W|=M<<28,M&128&&S[k++]&128&&S[k++]&128&&S[k++]&128&&S[k++]&128&&S[k++]&128)))))throw ho();return wf(v,k),W}function FP(v,S){if(0>S)throw Error("Tried to read a negative byte length: "+S);var k=v.h,M=k+S;if(M>v.j)throw gu(S,v.j-k);return v.h=M,k}var $P=[];function NN(){this.h=[]}NN.prototype.length=function(){return this.h.length},NN.prototype.end=function(){var v=this.h;return this.h=[],v};function PP(v,S,k){for(;0<k||127<S;)v.h.push(S&127|128),S=(S>>>7|k<<25)>>>0,k>>>=7;v.h.push(S)}function Cf(v,S){for(;127<S;)v.h.push(S&127|128),S>>>=7;v.h.push(S)}function DN(v,S){if($P.length){var k=$P.pop();kN(k,v,S),v=k}else v=new MP(v,S);this.h=v,this.j=this.h.h,this.i=this.l=-1,this.setOptions(S)}DN.prototype.setOptions=function(v){v=v===void 0?{}:v,this.ca=v.ca===void 0?!1:v.ca},DN.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};function LP(v){var S=v.h;if(S.h==S.j)return!1;v.j=v.h.h;var k=Bx(v.h)>>>0;if(S=k>>>3,k&=7,!(0<=k&&5>=k))throw zi(k,v.j);if(1>S)throw Error("Invalid field number: "+S+" (at position "+v.j+")");return v.l=S,v.i=k,!0}function jw(v){switch(v.i){case 0:if(v.i!=0)jw(v);else e:{v=v.h;for(var S=v.h,k=S+10,M=v.i;S<k;)if(!(M[S++]&128)){wf(v,S);break e}throw ho()}break;case 1:v=v.h,wf(v,v.h+8);break;case 2:v.i!=2?jw(v):(S=Bx(v.h)>>>0,v=v.h,wf(v,v.h+S));break;case 5:v=v.h,wf(v,v.h+4);break;case 3:S=v.l;do{if(!LP(v))throw Error("Unmatched start-group tag: stream EOF");if(v.i==4){if(v.l!=S)throw Error("Unmatched end-group tag");break}jw(v)}while(!0);break;default:throw zi(v.i,v.j)}}var Hw=[];function xie(){this.j=[],this.i=0,this.h=new NN}function xm(v,S){S.length!==0&&(v.j.push(S),v.i+=S.length)}function vie(v,S){if(S=S.R){xm(v,v.h.end());for(var k=0;k<S.length;k++)xm(v,Ww(S[k])||lt())}}var tc=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol():void 0;function Sf(v,S){return tc?v[tc]|=S:v.A!==void 0?v.A|=S:(Object.defineProperties(v,{A:{value:S,configurable:!0,writable:!0,enumerable:!1}}),S)}function zP(v,S){tc?v[tc]&&(v[tc]&=~S):v.A!==void 0&&(v.A&=~S)}function An(v){var S;return tc?S=v[tc]:S=v.A,S??0}function vu(v,S){tc?v[tc]=S:v.A!==void 0?v.A=S:Object.defineProperties(v,{A:{value:S,configurable:!0,writable:!0,enumerable:!1}})}function AN(v){return Sf(v,1),v}function bie(v,S){vu(S,(v|0)&-51)}function qw(v,S){vu(S,(v|18)&-41)}var RN={};function Kw(v){return v!==null&&typeof v=="object"&&!Array.isArray(v)&&v.constructor===Object}var Vx,BP=[];vu(BP,23),Vx=Object.freeze(BP);function ON(v){if(An(v.o)&2)throw Error("Cannot mutate an immutable Message")}function MN(v){var S=v.length;(S=S?v[S-1]:void 0)&&Kw(S)?S.g=1:(S={},v.push((S.g=1,S)))}function VP(v){var S=v.i+v.G;return v.B||(v.B=v.o[S]={})}function Bi(v,S){return S===-1?null:S>=v.i?v.B?v.B[S]:void 0:v.o[S+v.G]}function bu(v,S,k,M){ON(v),Ux(v,S,k,M)}function Ux(v,S,k,M){v.j&&(v.j=void 0),S>=v.i||M?VP(v)[S]=k:(v.o[S+v.G]=k,(v=v.B)&&S in v&&delete v[S])}function FN(v,S,k,M){var W=Bi(v,S);Array.isArray(W)||(W=Vx);var q=An(W);if(q&1||AN(W),M)q&2||Sf(W,2),k&1||Object.freeze(W);else{M=!(k&2);var H=q&2;k&1||!H?M&&q&16&&!H&&zP(W,16):(W=AN(Array.prototype.slice.call(W)),Ux(v,S,W))}return W}function $N(v,S){var k=Bi(v,S),M=k==null?k:typeof k=="number"||k==="NaN"||k==="Infinity"||k==="-Infinity"?Number(k):void 0;return M!=null&&M!==k&&Ux(v,S,M),M}function UP(v,S,k,M,W){v.h||(v.h={});var q=v.h[k],H=FN(v,k,3,W);if(!q){var ee=H;q=[];var ue=!!(An(v.o)&16);H=!!(An(ee)&2);var Ce=ee;!W&&H&&(ee=Array.prototype.slice.call(ee));for(var De=H,ht=0;ht<ee.length;ht++){var rt=ee[ht],Pe=S,mt=!1;if(mt=mt===void 0?!1:mt,rt=Array.isArray(rt)?new Pe(rt):mt?new Pe:void 0,rt!==void 0){Pe=rt.o;var Ft=mt=An(Pe);H&&(Ft|=2),ue&&(Ft|=16),Ft!=mt&&vu(Pe,Ft),Pe=Ft,De=De||!!(2&Pe),q.push(rt)}}return v.h[k]=q,ue=An(ee),S=ue|33,S=De?S&-9:S|8,ue!=S&&(De=ee,Object.isFrozen(De)&&(De=Array.prototype.slice.call(De)),vu(De,S),ee=De),Ce!==ee&&Ux(v,k,ee),(W||M&&H)&&Sf(q,2),M&&Object.freeze(q),q}return W||(W=Object.isFrozen(q),M&&!W?Object.freeze(q):!M&&W&&(q=Array.prototype.slice.call(q),v.h[k]=q)),q}function PN(v,S,k){var M=!!(An(v.o)&2);if(S=UP(v,S,k,M,M),v=FN(v,k,3,M),!(M||An(v)&8)){for(M=0;M<S.length;M++){if(k=S[M],An(k.o)&2){var W=KP(k,!1);W.j=k}else W=k;k!==W&&(S[M]=W,v[M]=W.o)}Sf(v,8)}return S}function wu(v,S,k){if(k!=null&&typeof k!="number")throw Error("Value of float/double field must be a number|null|undefined, found "+typeof k+": "+k);bu(v,S,k)}function GP(v,S,k,M,W){ON(v);var q=UP(v,k,S,!1,!1);return k=M??new k,v=FN(v,S,2,!1),W!=null?(q.splice(W,0,k),v.splice(W,0,k.o)):(q.push(k),v.push(k.o)),k.C()&&zP(v,8),k}function Xw(v,S){return v??S}function Cu(v,S,k){return k=k===void 0?0:k,Xw($N(v,S),k)}var Yw;function wie(v){switch(typeof v){case"number":return isFinite(v)?v:String(v);case"object":if(v)if(Array.isArray(v)){if(An(v)&128)return v=Array.prototype.slice.call(v),MN(v),v}else{if(be&&v!=null&&v instanceof Uint8Array)return Te(v);if(v instanceof xu){var S=v.V;return S==null?"":typeof S=="string"?S:v.V=Te(S)}}}return v}function WP(v,S,k,M){if(v!=null){if(Array.isArray(v))v=LN(v,S,k,M!==void 0);else if(Kw(v)){var W={},q;for(q in v)W[q]=WP(v[q],S,k,M);v=W}else v=S(v,M);return v}}function LN(v,S,k,M){var W=An(v);M=M?!!(W&16):void 0,v=Array.prototype.slice.call(v);for(var q=0;q<v.length;q++)v[q]=WP(v[q],S,k,M);return k(W,v),v}function Cie(v){return v.ja===RN?v.toJSON():wie(v)}function Sie(v,S){v&128&&MN(S)}function jP(v,S,k){if(k=k===void 0?qw:k,v!=null){if(be&&v instanceof Uint8Array)return v.length?new xu(new Uint8Array(v),_e):zx();if(Array.isArray(v)){var M=An(v);return M&2?v:S&&!(M&32)&&(M&16||M===0)?(vu(v,M|2),v):(v=LN(v,jP,M&4?qw:k,!0),S=An(v),S&4&&S&2&&Object.freeze(v),v)}return v.ja===RN?qP(v):v}}function HP(v,S,k,M,W,q,H){if(v=v.h&&v.h[k]){if(M=An(v),M&2?M=v:(q=ie(v,qP),qw(M,q),Object.freeze(q),M=q),ON(S),H=M==null?Vx:AN([]),M!=null){for(q=!!M.length,v=0;v<M.length;v++){var ee=M[v];q=q&&!(An(ee.o)&2),H[v]=ee.o}q=(q?8:0)|1,v=An(H),(v&q)!==q&&(Object.isFrozen(H)&&(H=Array.prototype.slice.call(H)),vu(H,v|q)),S.h||(S.h={}),S.h[k]=M}else S.h&&(S.h[k]=void 0);Ux(S,k,H,W)}else bu(S,k,jP(M,q,H),W)}function qP(v){return An(v.o)&2||(v=KP(v,!0),Sf(v.o,2)),v}function KP(v,S){var k=v.o,M=[];Sf(M,16);var W=v.constructor.h;if(W&&M.push(W),W=v.B,W){M.length=k.length,M.fill(void 0,M.length,k.length);var q={};M[M.length-1]=q}An(k)&128&&MN(M),S=S||v.C()?qw:bie,q=v.constructor,Yw=M,M=new q(M),Yw=void 0,v.R&&(M.R=v.R.slice()),q=!!(An(k)&16);for(var H=W?k.length-1:k.length,ee=0;ee<H;ee++)HP(v,M,ee-v.G,k[ee],!1,q,S);if(W)for(var ue in W)HP(v,M,+ue,W[ue],!0,q,S);return M}function ps(v,S,k){v==null&&(v=Yw),Yw=void 0;var M=this.constructor.i||0,W=0<M,q=this.constructor.h,H=!1;if(v==null){v=q?[q]:[];var ee=48,ue=!0;W&&(M=0,ee|=128),vu(v,ee)}else{if(!Array.isArray(v)||q&&q!==v[0])throw Error();var Ce=ee=Sf(v,0);if((ue=(16&Ce)!==0)&&((H=(32&Ce)!==0)||(Ce|=32)),W){if(128&Ce)M=0;else if(0<v.length){var De=v[v.length-1];if(Kw(De)&&"g"in De){M=0,Ce|=128,delete De.g;var ht=!0,rt;for(rt in De){ht=!1;break}ht&&v.pop()}}}else if(128&Ce)throw Error();ee!==Ce&&vu(v,Ce)}this.G=(q?0:-1)-M,this.h=void 0,this.o=v;e:{if(q=this.o.length,M=q-1,q&&(q=this.o[M],Kw(q))){this.B=q,this.i=M-this.G;break e}S!==void 0&&-1<S?(this.i=Math.max(S,M+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE}if(!W&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(k){S=ue&&!H&&!0,W=this.i;var Pe;for(ue=0;ue<k.length;ue++)H=k[ue],H<W?(H+=this.G,(M=v[H])?XP(M,S):v[H]=Vx):(Pe||(Pe=VP(this)),(M=Pe[H])?XP(M,S):Pe[H]=Vx)}}ps.prototype.toJSON=function(){return LN(this.o,Cie,Sie)},ps.prototype.C=function(){return!!(An(this.o)&2)};function XP(v,S){if(Array.isArray(v)){var k=An(v),M=1;!S||k&2||(M|=16),(k&M)!==M&&vu(v,k|M)}}ps.prototype.ja=RN,ps.prototype.toString=function(){return this.o.toString()};function YP(v,S,k){if(k){var M={},W;for(W in k){var q=k[W],H=q.ra;H||(M.J=q.xa||q.oa.W,q.ia?(M.aa=tL(q.ia),H=function(ee){return function(ue,Ce,De){return ee.J(ue,Ce,De,ee.aa)}}(M)):q.ka?(M.Z=rL(q.da.P,q.ka),H=function(ee){return function(ue,Ce,De){return ee.J(ue,Ce,De,ee.Z)}}(M)):H=M.J,q.ra=H),H(S,v,q.da),M={J:M.J,aa:M.aa,Z:M.Z}}}vie(S,v)}var Zw=Symbol();function ZP(v,S,k){return v[Zw]||(v[Zw]=function(M,W){return S(M,W,k)})}function QP(v){var S=v[Zw];if(!S){var k=BN(v);S=function(M,W){return nL(M,W,k)},v[Zw]=S}return S}function Iie(v){var S=v.ia;if(S)return QP(S);if(S=v.wa)return ZP(v.da.P,S,v.ka)}function Tie(v){var S=Iie(v),k=v.da,M=v.oa.U;return S?function(W,q){return M(W,q,k,S)}:function(W,q){return M(W,q,k)}}function JP(v,S){var k=v[S];return typeof k=="function"&&k.length===0&&(k=k(),v[S]=k),Array.isArray(k)&&(Wx in k||Gx in k||0<k.length&&typeof k[0]=="function")?k:void 0}function eL(v,S,k,M,W,q){S.P=v[0];var H=1;if(v.length>H&&typeof v[H]!="number"){var ee=v[H++];k(S,ee)}for(;H<v.length;){k=v[H++];for(var ue=H+1;ue<v.length&&typeof v[ue]!="number";)ue++;switch(ee=v[H++],ue-=H,ue){case 0:M(S,k,ee);break;case 1:(ue=JP(v,H))?(H++,W(S,k,ee,ue)):M(S,k,ee,v[H++]);break;case 2:ue=H++,ue=JP(v,ue),W(S,k,ee,ue,v[H++]);break;case 3:q(S,k,ee,v[H++],v[H++],v[H++]);break;case 4:q(S,k,ee,v[H++],v[H++],v[H++],v[H++]);break;default:throw Error("unexpected number of binary field arguments: "+ue)}}return S}var Qw=Symbol();function tL(v){var S=v[Qw];if(!S){var k=zN(v);S=function(M,W){return oL(M,W,k)},v[Qw]=S}return S}function rL(v,S){var k=v[Qw];return k||(k=function(M,W){return YP(M,W,S)},v[Qw]=k),k}var Gx=Symbol();function _ie(v,S){v.push(S)}function Eie(v,S,k){v.push(S,k.W)}function kie(v,S,k,M){var W=tL(M),q=zN(M).P,H=k.W;v.push(S,function(ee,ue,Ce){return H(ee,ue,Ce,q,W)})}function Nie(v,S,k,M,W,q){var H=rL(M,q),ee=k.W;v.push(S,function(ue,Ce,De){return ee(ue,Ce,De,M,H)})}function zN(v){var S=v[Gx];return S||(S=eL(v,v[Gx]=[],_ie,Eie,kie,Nie),Wx in v&&Gx in v&&(v.length=0),S)}var Wx=Symbol();function Die(v,S){v[0]=S}function Aie(v,S,k,M){var W=k.U;v[S]=M?function(q,H,ee){return W(q,H,ee,M)}:W}function Rie(v,S,k,M,W){var q=k.U,H=QP(M),ee=BN(M).P;v[S]=function(ue,Ce,De){return q(ue,Ce,De,ee,H,W)}}function Oie(v,S,k,M,W,q,H){var ee=k.U,ue=ZP(M,W,q);v[S]=function(Ce,De,ht){return ee(Ce,De,ht,M,ue,H)}}function BN(v){var S=v[Wx];return S||(S=eL(v,v[Wx]={},Die,Aie,Rie,Oie),Wx in v&&Gx in v&&(v.length=0),S)}function nL(v,S,k){for(;LP(S)&&S.i!=4;){var M=S.l,W=k[M];if(!W){var q=k[0];q&&(q=q[M])&&(W=k[M]=Tie(q))}if(!W||!W(S,v,M)){W=S,M=v,q=W.j,jw(W);var H=W;if(!H.ca){if(W=H.h.h-q,H.h.h=q,H=H.h,W==0)W=zx();else{if(q=FP(H,W),H.S&&H.m)W=H.i.subarray(q,q+W);else{H=H.i;var ee=q;W=q+W,W=ee===W?lt():Ct?H.slice(ee,W):new Uint8Array(H.subarray(ee,W))}W=W.length==0?zx():new xu(W,_e)}(q=M.R)?q.push(W):M.R=[W]}}}return v}function oL(v,S,k){for(var M=k.length,W=M%2==1,q=W?1:0;q<M;q+=2)(0,k[q+1])(S,v,k[q]);YP(v,S,W?k[0]:void 0)}function jx(v,S){return{U:v,W:S}}var Vi=jx(function(v,S,k){if(v.i!==5)return!1;v=v.h;var M=v.i,W=v.h,q=M[W],H=M[W+1],ee=M[W+2];return M=M[W+3],wf(v,v.h+4),H=(q<<0|H<<8|ee<<16|M<<24)>>>0,v=2*(H>>31)+1,q=H>>>23&255,H&=8388607,bu(S,k,q==255?H?NaN:1/0*v:q==0?v*Math.pow(2,-149)*H:v*Math.pow(2,q-150)*(H+Math.pow(2,23))),!0},function(v,S,k){if(S=$N(S,k),S!=null){Cf(v.h,8*k+5),v=v.h;var M=+S;M===0?0<1/M?ze=nt=0:(nt=0,ze=2147483648):isNaN(M)?(nt=0,ze=2147483647):(M=(k=0>M?-2147483648:0)?-M:M,34028234663852886e22<M?(nt=0,ze=(k|2139095040)>>>0):11754943508222875e-54>M?(M=Math.round(M/Math.pow(2,-149)),nt=0,ze=(k|M)>>>0):(S=Math.floor(Math.log(M)/Math.LN2),M*=Math.pow(2,-S),M=Math.round(8388608*M),16777216<=M&&++S,nt=0,ze=(k|S+127<<23|M&8388607)>>>0)),k=ze,v.h.push(k>>>0&255),v.h.push(k>>>8&255),v.h.push(k>>>16&255),v.h.push(k>>>24&255)}}),Mie=jx(function(v,S,k){if(v.i!==0)return!1;var M=v.h,W=0,q=v=0,H=M.i,ee=M.h;do{var ue=H[ee++];W|=(ue&127)<<q,q+=7}while(32>q&&ue&128);for(32<q&&(v|=(ue&127)>>4),q=3;32>q&&ue&128;q+=7)ue=H[ee++],v|=(ue&127)<<q;if(wf(M,ee),128>ue)M=W>>>0,ue=v>>>0,(v=ue&2147483648)&&(M=~M+1>>>0,ue=~ue>>>0,M==0&&(ue=ue+1>>>0)),M=4294967296*ue+(M>>>0);else throw ho();return bu(S,k,v?-M:M),!0},function(v,S,k){S=Bi(S,k),S!=null&&(typeof S=="string"&&ei(S),S!=null&&(Cf(v.h,8*k),typeof S=="number"?(v=v.h,Lt(S),PP(v,ze,nt)):(k=ei(S),PP(v.h,k.i,k.h))))}),Fie=jx(function(v,S,k){return v.i!==0?!1:(bu(S,k,Bx(v.h)),!0)},function(v,S,k){if(S=Bi(S,k),S!=null&&S!=null)if(Cf(v.h,8*k),v=v.h,k=S,0<=k)Cf(v,k);else{for(S=0;9>S;S++)v.h.push(k&127|128),k>>=7;v.h.push(1)}}),sL=jx(function(v,S,k){if(v.i!==2)return!1;var M=Bx(v.h)>>>0;v=v.h;var W=FP(v,M);if(v=v.i,yu){var q=v,H;(H=ri)||(H=ri=new TextDecoder("utf-8",{fatal:!0})),v=W+M,q=W===0&&v===q.length?q:q.subarray(W,v);try{var ee=H.decode(q)}catch(ht){if(Ps===void 0){try{H.decode(new Uint8Array([128]))}catch{}try{H.decode(new Uint8Array([97])),Ps=!0}catch{Ps=!1}}throw!Ps&&(ri=void 0),ht}}else{ee=W,M=ee+M,W=[];for(var ue=null,Ce,De;ee<M;)Ce=v[ee++],128>Ce?W.push(Ce):224>Ce?ee>=M?Kn():(De=v[ee++],194>Ce||(De&192)!==128?(ee--,Kn()):W.push((Ce&31)<<6|De&63)):240>Ce?ee>=M-1?Kn():(De=v[ee++],(De&192)!==128||Ce===224&&160>De||Ce===237&&160<=De||((q=v[ee++])&192)!==128?(ee--,Kn()):W.push((Ce&15)<<12|(De&63)<<6|q&63)):244>=Ce?ee>=M-2?Kn():(De=v[ee++],(De&192)!==128||(Ce<<28)+(De-144)>>30||((q=v[ee++])&192)!==128||((H=v[ee++])&192)!==128?(ee--,Kn()):(Ce=(Ce&7)<<18|(De&63)<<12|(q&63)<<6|H&63,Ce-=65536,W.push((Ce>>10&1023)+55296,(Ce&1023)+56320))):Kn(),8192<=W.length&&(ue=ti(ue,W),W.length=0);ee=ti(ue,W)}return bu(S,k,ee),!0},function(v,S,k){if(S=Bi(S,k),S!=null){var M=!1;if(M=M===void 0?!1:M,Lx){if(M&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(S))throw Error("Found an unpaired surrogate");S=(op||(op=new TextEncoder)).encode(S)}else{for(var W=0,q=new Uint8Array(3*S.length),H=0;H<S.length;H++){var ee=S.charCodeAt(H);if(128>ee)q[W++]=ee;else{if(2048>ee)q[W++]=ee>>6|192;else{if(55296<=ee&&57343>=ee){if(56319>=ee&&H<S.length){var ue=S.charCodeAt(++H);if(56320<=ue&&57343>=ue){ee=1024*(ee-55296)+ue-56320+65536,q[W++]=ee>>18|240,q[W++]=ee>>12&63|128,q[W++]=ee>>6&63|128,q[W++]=ee&63|128;continue}else H--}if(M)throw Error("Found an unpaired surrogate");ee=65533}q[W++]=ee>>12|224,q[W++]=ee>>6&63|128}q[W++]=ee&63|128}}S=W===q.length?q:q.subarray(0,W)}Cf(v.h,8*k+2),Cf(v.h,S.length),xm(v,v.h.end()),xm(v,S)}}),iL=jx(function(v,S,k,M,W){if(v.i!==2)return!1;S=GP(S,k,M),k=v.h.j,M=Bx(v.h)>>>0;var q=v.h.h+M,H=q-k;if(0>=H&&(v.h.j=q,W(S,v,void 0,void 0,void 0),H=q-v.h.h),H)throw Error("Message parsing ended unexpectedly. Expected to read "+(M+" bytes, instead read "+(M-H)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return v.h.h=q,v.h.j=k,!0},function(v,S,k,M,W){if(S=PN(S,M,k),S!=null)for(M=0;M<S.length;M++){var q=v;Cf(q.h,8*k+2);var H=q.h.end();xm(q,H),H.push(q.i),q=H,W(S[M],v),H=v;var ee=q.pop();for(ee=H.i+H.h.length()-ee;127<ee;)q.push(ee&127|128),ee>>>=7,H.i++;q.push(ee),H.i++}});function VN(v){return function(S,k){e:{if(Hw.length){var M=Hw.pop();M.setOptions(k),kN(M.h,S,k),S=M}else S=new DN(S,k);try{var W=BN(v),q=nL(new W.P,S,W);break e}finally{W=S.h,W.i=null,W.m=!1,W.l=0,W.j=0,W.h=0,W.S=!1,S.l=-1,S.i=-1,100>Hw.length&&Hw.push(S)}q=void 0}return q}}function UN(v){return function(){var S=new xie;oL(this,S,zN(v)),xm(S,S.h.end());for(var k=new Uint8Array(S.i),M=S.j,W=M.length,q=0,H=0;H<W;H++){var ee=M[H];k.set(ee,q),q+=ee.length}return S.j=[k],k}}function vm(v){ps.call(this,v)}g(vm,ps);var aL=[vm,1,Fie,2,Vi,3,sL,4,sL];vm.prototype.l=UN(aL);function GN(v){ps.call(this,v,-1,$ie)}g(GN,ps),GN.prototype.addClassification=function(v,S){return GP(this,1,vm,v,S),this};var $ie=[1],Pie=VN([GN,1,iL,aL]);function Hx(v){ps.call(this,v)}g(Hx,ps);var uL=[Hx,1,Vi,2,Vi,3,Vi,4,Vi,5,Vi];Hx.prototype.l=UN(uL);function lL(v){ps.call(this,v,-1,Lie)}g(lL,ps);var Lie=[1],zie=VN([lL,1,iL,uL]);function Jw(v){ps.call(this,v)}g(Jw,ps);var cL=[Jw,1,Vi,2,Vi,3,Vi,4,Vi,5,Vi,6,Mie],Bie=VN(cL);Jw.prototype.l=UN(cL);function pL(v,S,k){if(k=v.createShader(k===0?v.VERTEX_SHADER:v.FRAGMENT_SHADER),v.shaderSource(k,S),v.compileShader(k),!v.getShaderParameter(k,v.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+v.getShaderInfoLog(k));return k}function Vie(v){return PN(v,vm,1).map(function(S){var k=Bi(S,1);return{index:k??0,qa:Cu(S,2),label:Bi(S,3)!=null?Xw(Bi(S,3),""):void 0,displayName:Bi(S,4)!=null?Xw(Bi(S,4),""):void 0}})}function Uie(v){return{x:Cu(v,1),y:Cu(v,2),z:Cu(v,3),visibility:$N(v,4)!=null?Cu(v,4):void 0}}function WN(v){return PN(zie(v),Hx,1).map(Uie)}function jN(v,S){this.i=v,this.h=S,this.m=0}function dL(v,S,k){return Gie(v,S),typeof v.h.canvas.transferToImageBitmap=="function"?Promise.resolve(v.h.canvas.transferToImageBitmap()):k?Promise.resolve(v.h.canvas):typeof createImageBitmap=="function"?createImageBitmap(v.h.canvas):(v.j===void 0&&(v.j=document.createElement("canvas")),new Promise(function(M){v.j.height=v.h.canvas.height,v.j.width=v.h.canvas.width,v.j.getContext("2d",{}).drawImage(v.h.canvas,0,0,v.h.canvas.width,v.h.canvas.height),M(v.j)}))}function Gie(v,S){var k=v.h;if(v.s===void 0){var M=pL(k,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),W=pL(k,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),q=k.createProgram();if(k.attachShader(q,M),k.attachShader(q,W),k.linkProgram(q),!k.getProgramParameter(q,k.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+k.getProgramInfoLog(q));M=v.s=q,k.useProgram(M),W=k.getUniformLocation(M,"sampler0"),v.l={O:k.getAttribLocation(M,"aVertex"),N:k.getAttribLocation(M,"aTex"),ya:W},v.v=k.createBuffer(),k.bindBuffer(k.ARRAY_BUFFER,v.v),k.enableVertexAttribArray(v.l.O),k.vertexAttribPointer(v.l.O,2,k.FLOAT,!1,0,0),k.bufferData(k.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),k.STATIC_DRAW),k.bindBuffer(k.ARRAY_BUFFER,null),v.u=k.createBuffer(),k.bindBuffer(k.ARRAY_BUFFER,v.u),k.enableVertexAttribArray(v.l.N),k.vertexAttribPointer(v.l.N,2,k.FLOAT,!1,0,0),k.bufferData(k.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),k.STATIC_DRAW),k.bindBuffer(k.ARRAY_BUFFER,null),k.uniform1i(W,0)}M=v.l,k.useProgram(v.s),k.canvas.width=S.width,k.canvas.height=S.height,k.viewport(0,0,S.width,S.height),k.activeTexture(k.TEXTURE0),v.i.bindTexture2d(S.glName),k.enableVertexAttribArray(M.O),k.bindBuffer(k.ARRAY_BUFFER,v.v),k.vertexAttribPointer(M.O,2,k.FLOAT,!1,0,0),k.enableVertexAttribArray(M.N),k.bindBuffer(k.ARRAY_BUFFER,v.u),k.vertexAttribPointer(M.N,2,k.FLOAT,!1,0,0),k.bindFramebuffer(k.DRAW_FRAMEBUFFER?k.DRAW_FRAMEBUFFER:k.FRAMEBUFFER,null),k.clearColor(0,0,0,0),k.clear(k.COLOR_BUFFER_BIT),k.colorMask(!0,!0,!0,!0),k.drawArrays(k.TRIANGLE_FAN,0,4),k.disableVertexAttribArray(M.O),k.disableVertexAttribArray(M.N),k.bindBuffer(k.ARRAY_BUFFER,null),v.i.bindTexture2d(0)}function Wie(v){this.h=v}var jie=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function Hie(v,S){return S+v}function fL(v,S){window[v]=S}function qie(v){var S=document.createElement("script");return S.setAttribute("src",v),S.setAttribute("crossorigin","anonymous"),new Promise(function(k){S.addEventListener("load",function(){k()},!1),S.addEventListener("error",function(){k()},!1),document.body.appendChild(S)})}function Kie(){return G(function(v){switch(v.h){case 1:return v.s=2,C(v,WebAssembly.instantiate(jie),4);case 4:v.h=3,v.s=0;break;case 2:return v.s=0,v.l=null,v.return(!1);case 3:return v.return(!0)}})}function HN(v){if(this.h=v,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=v&&v.locateFile||Hie,typeof window=="object")var S=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")S=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.ha=S,v.options){S=a(Object.keys(v.options));for(var k=S.next();!k.done;k=S.next()){k=k.value;var M=v.options[k].default;M!==void 0&&(this.l[k]=typeof M=="function"?M():M)}}}r=HN.prototype,r.close=function(){return this.j&&this.j.delete(),Promise.resolve()};function Xie(v){var S,k,M,W,q,H,ee,ue,Ce,De,ht;return G(function(rt){switch(rt.h){case 1:return v.ga?(S=v.h.files===void 0?[]:typeof v.h.files=="function"?v.h.files(v.l):v.h.files,C(rt,Kie(),2)):rt.return();case 2:if(k=rt.i,typeof window=="object")return fL("createMediapipeSolutionsWasm",{locateFile:v.locateFile}),fL("createMediapipeSolutionsPackedAssets",{locateFile:v.locateFile}),H=S.filter(function(Pe){return Pe.data!==void 0}),ee=S.filter(function(Pe){return Pe.data===void 0}),ue=Promise.all(H.map(function(Pe){var mt=eC(v,Pe.url);if(Pe.path!==void 0){var Ft=Pe.path;mt=mt.then(function(nn){return v.overrideFile(Ft,nn),Promise.resolve(nn)})}return mt})),Ce=Promise.all(ee.map(function(Pe){return Pe.simd===void 0||Pe.simd&&k||!Pe.simd&&!k?qie(v.locateFile(Pe.url,v.ha)):Promise.resolve()})).then(function(){var Pe,mt,Ft;return G(function(nn){if(nn.h==1)return Pe=window.createMediapipeSolutionsWasm,mt=window.createMediapipeSolutionsPackedAssets,Ft=v,C(nn,Pe(mt),2);Ft.i=nn.i,nn.h=0})}),De=function(){return G(function(Pe){return v.h.graph&&v.h.graph.url?Pe=C(Pe,eC(v,v.h.graph.url),0):(Pe.h=0,Pe=void 0),Pe})}(),C(rt,Promise.all([Ce,ue,De]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return M=S.filter(function(Pe){return Pe.simd===void 0||Pe.simd&&k||!Pe.simd&&!k}).map(function(Pe){return v.locateFile(Pe.url,v.ha)}),importScripts.apply(null,u(M)),W=v,C(rt,createMediapipeSolutionsWasm(Module),6);case 6:W.i=rt.i,v.m=new OffscreenCanvas(1,1),v.i.canvas=v.m,q=v.i.GL.createContext(v.m,{antialias:!1,alpha:!1,va:typeof WebGL2RenderingContext<"u"?2:1}),v.i.GL.makeContextCurrent(q),rt.h=4;break;case 7:if(v.m=document.createElement("canvas"),ht=v.m.getContext("webgl2",{}),!ht&&(ht=v.m.getContext("webgl",{}),!ht))return alert("Failed to create WebGL canvas context when passing video frame."),rt.return();v.K=ht,v.i.canvas=v.m,v.i.createContext(v.m,!0,!0,{});case 4:v.j=new v.i.SolutionWasm,v.ga=!1,rt.h=0}})}function Yie(v){var S,k,M,W,q,H,ee,ue;return G(function(Ce){if(Ce.h==1){if(v.h.graph&&v.h.graph.url&&v.fa===v.h.graph.url)return Ce.return();if(v.u=!0,!v.h.graph||!v.h.graph.url){Ce.h=2;return}return v.fa=v.h.graph.url,C(Ce,eC(v,v.h.graph.url),3)}for(Ce.h!=2&&(S=Ce.i,v.j.loadGraph(S)),k=a(Object.keys(v.D)),M=k.next();!M.done;M=k.next())W=M.value,v.j.overrideFile(W,v.D[W]);if(v.D={},v.h.listeners)for(q=a(v.h.listeners),H=q.next();!H.done;H=q.next())ee=H.value,eae(v,ee);ue=v.l,v.l={},v.setOptions(ue),Ce.h=0})}r.reset=function(){var v=this;return G(function(S){v.j&&(v.j.reset(),v.s={},v.v={}),S.h=0})},r.setOptions=function(v,S){var k=this;if(S=S||this.h.options){for(var M=[],W=[],q={},H=a(Object.keys(v)),ee=H.next();!ee.done;q={X:q.X,Y:q.Y},ee=H.next())if(ee=ee.value,!(ee in this.l&&this.l[ee]===v[ee])){this.l[ee]=v[ee];var ue=S[ee];ue!==void 0&&(ue.onChange&&(q.X=ue.onChange,q.Y=v[ee],M.push(function(Ce){return function(){var De;return G(function(ht){if(ht.h==1)return C(ht,Ce.X(Ce.Y),2);De=ht.i,De===!0&&(k.u=!0),ht.h=0})}}(q))),ue.graphOptionXref&&(ee=Object.assign({},{calculatorName:"",calculatorIndex:0},ue.graphOptionXref,{valueNumber:ue.type===1?v[ee]:0,valueBoolean:ue.type===0?v[ee]:!1,valueString:ue.type===2?v[ee]:""}),W.push(ee)))}(M.length!==0||W.length!==0)&&(this.u=!0,this.H=(this.H===void 0?[]:this.H).concat(W),this.F=(this.F===void 0?[]:this.F).concat(M))}};function Zie(v){var S,k,M,W,q,H,ee;return G(function(ue){switch(ue.h){case 1:if(!v.u)return ue.return();if(!v.F){ue.h=2;break}S=a(v.F),k=S.next();case 3:if(k.done){ue.h=5;break}return M=k.value,C(ue,M(),4);case 4:k=S.next(),ue.h=3;break;case 5:v.F=void 0;case 2:if(v.H){for(W=new v.i.GraphOptionChangeRequestList,q=a(v.H),H=q.next();!H.done;H=q.next())ee=H.value,W.push_back(ee);v.j.changeOptions(W),W.delete(),v.H=void 0}v.u=!1,ue.h=0}})}r.initialize=function(){var v=this;return G(function(S){return S.h==1?C(S,Xie(v),2):S.h!=3?C(S,Yie(v),3):C(S,Zie(v),0)})};function eC(v,S){var k,M;return G(function(W){return S in v.L?W.return(v.L[S]):(k=v.locateFile(S,""),M=fetch(k).then(function(q){return q.arrayBuffer()}),v.L[S]=M,W.return(M))})}r.overrideFile=function(v,S){this.j?this.j.overrideFile(v,S):this.D[v]=S},r.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},r.send=function(v,S){var k=this,M,W,q,H,ee,ue,Ce,De,ht;return G(function(rt){switch(rt.h){case 1:return k.h.inputs?(M=1e3*(S??performance.now()),C(rt,k.I,2)):rt.return();case 2:return C(rt,k.initialize(),3);case 3:for(W=new k.i.PacketDataList,q=a(Object.keys(v)),H=q.next();!H.done;H=q.next())if(ee=H.value,ue=k.h.inputs[ee]){e:{var Pe=v[ee];switch(ue.type){case"video":var mt=k.s[ue.stream];if(mt||(mt=new jN(k.i,k.K),k.s[ue.stream]=mt),mt.m===0&&(mt.m=mt.i.createTexture()),typeof HTMLVideoElement<"u"&&Pe instanceof HTMLVideoElement)var Ft=Pe.videoWidth,nn=Pe.videoHeight;else typeof HTMLImageElement<"u"&&Pe instanceof HTMLImageElement?(Ft=Pe.naturalWidth,nn=Pe.naturalHeight):(Ft=Pe.width,nn=Pe.height);nn={glName:mt.m,width:Ft,height:nn},Ft=mt.h,Ft.canvas.width=nn.width,Ft.canvas.height=nn.height,Ft.activeTexture(Ft.TEXTURE0),mt.i.bindTexture2d(mt.m),Ft.texImage2D(Ft.TEXTURE_2D,0,Ft.RGBA,Ft.RGBA,Ft.UNSIGNED_BYTE,Pe),mt.i.bindTexture2d(0),mt=nn;break e;case"detections":for(mt=k.s[ue.stream],mt||(mt=new Wie(k.i),k.s[ue.stream]=mt),mt.data||(mt.data=new mt.h.DetectionListData),mt.data.reset(Pe.length),nn=0;nn<Pe.length;++nn){Ft=Pe[nn];var Zr=mt.data,mo=Zr.setBoundingBox,ni=nn,ds=Ft.la,fr=new Jw;if(wu(fr,1,ds.sa),wu(fr,2,ds.ta),wu(fr,3,ds.height),wu(fr,4,ds.width),wu(fr,5,ds.rotation),bu(fr,6,ds.pa),ds=fr.l(),mo.call(Zr,ni,ds),Ft.ea)for(Zr=0;Zr<Ft.ea.length;++Zr){fr=Ft.ea[Zr],mo=mt.data,ni=mo.addNormalizedLandmark,ds=nn,fr=Object.assign({},fr,{visibility:fr.visibility?fr.visibility:0});var go=new Hx;wu(go,1,fr.x),wu(go,2,fr.y),wu(go,3,fr.z),fr.visibility&&wu(go,4,fr.visibility),fr=go.l(),ni.call(mo,ds,fr)}if(Ft.ba)for(Zr=0;Zr<Ft.ba.length;++Zr)mo=mt.data,ni=mo.addClassification,ds=nn,fr=Ft.ba[Zr],go=new vm,wu(go,2,fr.qa),fr.index&&bu(go,1,fr.index),fr.label&&bu(go,3,fr.label),fr.displayName&&bu(go,4,fr.displayName),fr=go.l(),ni.call(mo,ds,fr)}mt=mt.data;break e;default:mt={}}}switch(Ce=mt,De=ue.stream,ue.type){case"video":W.pushTexture2d(Object.assign({},Ce,{stream:De,timestamp:M}));break;case"detections":ht=Ce,ht.stream=De,ht.timestamp=M,W.pushDetectionList(ht);break;default:throw Error("Unknown input config type: '"+ue.type+"'")}}return k.j.send(W),C(rt,k.I,4);case 4:W.delete(),rt.h=0}})};function Qie(v,S,k){var M,W,q,H,ee,ue,Ce,De,ht,rt,Pe,mt,Ft,nn;return G(function(Zr){switch(Zr.h){case 1:if(!k)return Zr.return(S);for(M={},W=0,q=a(Object.keys(k)),H=q.next();!H.done;H=q.next())ee=H.value,ue=k[ee],typeof ue!="string"&&ue.type==="texture"&&S[ue.stream]!==void 0&&++W;1<W&&(v.M=!1),Ce=a(Object.keys(k)),H=Ce.next();case 2:if(H.done){Zr.h=4;break}if(De=H.value,ht=k[De],typeof ht=="string")return Ft=M,nn=De,C(Zr,Jie(v,De,S[ht]),14);if(rt=S[ht.stream],ht.type==="detection_list"){if(rt){for(var mo=rt.getRectList(),ni=rt.getLandmarksList(),ds=rt.getClassificationsList(),fr=[],go=0;go<mo.size();++go){var sp=Bie(mo.get(go)),tae=Cu(sp,1),rae=Cu(sp,2),nae=Cu(sp,3),oae=Cu(sp,4),sae=Cu(sp,5,0),tC=void 0;tC=tC===void 0?0:tC,sp={la:{sa:tae,ta:rae,height:nae,width:oae,rotation:sae,pa:Xw(Bi(sp,6),tC)},ea:WN(ni.get(go)),ba:Vie(Pie(ds.get(go)))},fr.push(sp)}mo=fr}else mo=[];M[De]=mo,Zr.h=7;break}if(ht.type==="proto_list"){if(rt){for(mo=Array(rt.size()),ni=0;ni<rt.size();ni++)mo[ni]=rt.get(ni);rt.delete()}else mo=[];M[De]=mo,Zr.h=7;break}if(rt===void 0){Zr.h=3;break}if(ht.type==="float_list"){M[De]=rt,Zr.h=7;break}if(ht.type==="proto"){M[De]=rt,Zr.h=7;break}if(ht.type!=="texture")throw Error("Unknown output config type: '"+ht.type+"'");return Pe=v.v[De],Pe||(Pe=new jN(v.i,v.K),v.v[De]=Pe),C(Zr,dL(Pe,rt,v.M),13);case 13:mt=Zr.i,M[De]=mt;case 7:ht.transform&&M[De]&&(M[De]=ht.transform(M[De])),Zr.h=3;break;case 14:Ft[nn]=Zr.i;case 3:H=Ce.next(),Zr.h=2;break;case 4:return Zr.return(M)}})}function Jie(v,S,k){var M;return G(function(W){return typeof k=="number"||k instanceof Uint8Array||k instanceof v.i.Uint8BlobList?W.return(k):k instanceof v.i.Texture2dDataOut?(M=v.v[S],M||(M=new jN(v.i,v.K),v.v[S]=M),W.return(dL(M,k,v.M))):W.return(void 0)})}function eae(v,S){for(var k=S.name||"$",M=[].concat(u(S.wants)),W=new v.i.StringList,q=a(S.wants),H=q.next();!H.done;H=q.next())W.push_back(H.value);q=v.i.PacketListener.implement({onResults:function(ee){for(var ue={},Ce=0;Ce<S.wants.length;++Ce)ue[M[Ce]]=ee.get(Ce);var De=v.listeners[k];De&&(v.I=Qie(v,ue,S.outs).then(function(ht){ht=De(ht);for(var rt=0;rt<S.wants.length;++rt){var Pe=ue[M[rt]];typeof Pe=="object"&&Pe.hasOwnProperty&&Pe.hasOwnProperty("delete")&&Pe.delete()}ht&&(v.I=ht)}))}}),v.j.attachMultiListener(W,q),W.delete()}r.onResults=function(v,S){this.listeners[S||"$"]=v},J("Solution",HN),J("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"});function hL(v){switch(v===void 0&&(v=0),v){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function mL(v){var S=this;v=v||{},this.h=new HN({locateFile:v.locateFile,files:function(k){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:hL(k.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:WN},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:WN},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window!="object"||window.navigator===void 0?!1:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(k){var M,W,q;return G(function(H){return H.h==1?(M=hL(k),W="third_party/mediapipe/modules/pose_landmark/"+M,C(H,eC(S.h,M),2)):(q=H.i,S.h.overrideFile(W,q),H.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}r=mL.prototype,r.reset=function(){this.h.reset()},r.close=function(){return this.h.close(),Promise.resolve()},r.onResults=function(v){this.h.onResults(v)},r.initialize=function(){var v=this;return G(function(S){return C(S,v.h.initialize(),0)})},r.send=function(v,S){var k=this;return G(function(M){return C(M,k.h.send(v,S),0)})},r.setOptions=function(v){this.h.setOptions(v)},J("Pose",mL),J("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),J("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),J("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),J("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),J("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),J("VERSION","0.5.1675469404")}).call(YV)});var vU=bn((MHe,xU)=>{"use strict";xU.exports=Qr;var gi=null;try{gi=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Qr(r,t,e){this.low=r|0,this.high=t|0,this.unsigned=!!e}Qr.prototype.__isLong__;Object.defineProperty(Qr.prototype,"__isLong__",{value:!0});function bs(r){return(r&&r.__isLong__)===!0}Qr.isLong=bs;var lU={},cU={};function sh(r,t){var e,n,o;return t?(r>>>=0,(o=0<=r&&r<256)&&(n=cU[r],n)?n:(e=Jr(r,(r|0)<0?-1:0,!0),o&&(cU[r]=e),e)):(r|=0,(o=-128<=r&&r<128)&&(n=lU[r],n)?n:(e=Jr(r,r<0?-1:0,!1),o&&(lU[r]=e),e))}Qr.fromInt=sh;function yi(r,t){if(isNaN(r))return t?oh:xi;if(t){if(r<0)return oh;if(r>=hU)return yU}else{if(r<=-dU)return vs;if(r+1>=dU)return gU}return r<0?yi(-r,t).neg():Jr(r%Tg|0,r/Tg|0,t)}Qr.fromNumber=yi;function Jr(r,t,e){return new Qr(r,t,e)}Qr.fromBits=Jr;var J0=Math.pow;function x2(r,t,e){if(r.length===0)throw Error("empty string");if(r==="NaN"||r==="Infinity"||r==="+Infinity"||r==="-Infinity")return xi;if(typeof t=="number"?(e=t,t=!1):t=!!t,e=e||10,e<2||36<e)throw RangeError("radix");var n;if((n=r.indexOf("-"))>0)throw Error("interior hyphen");if(n===0)return x2(r.substring(1),t,e).neg();for(var o=yi(J0(e,8)),s=xi,i=0;i<r.length;i+=8){var a=Math.min(8,r.length-i),u=parseInt(r.substring(i,i+a),e);if(a<8){var l=yi(J0(e,a));s=s.mul(l).add(yi(u))}else s=s.mul(o),s=s.add(yi(u))}return s.unsigned=t,s}Qr.fromString=x2;function Wa(r,t){return typeof r=="number"?yi(r,t):typeof r=="string"?x2(r,t):Jr(r.low,r.high,typeof t=="boolean"?t:r.unsigned)}Qr.fromValue=Wa;var pU=65536,xme=1<<24,Tg=pU*pU,hU=Tg*Tg,dU=hU/2,fU=sh(xme),xi=sh(0);Qr.ZERO=xi;var oh=sh(0,!0);Qr.UZERO=oh;var Ig=sh(1);Qr.ONE=Ig;var mU=sh(1,!0);Qr.UONE=mU;var y2=sh(-1);Qr.NEG_ONE=y2;var gU=Jr(-1,2147483647,!1);Qr.MAX_VALUE=gU;var yU=Jr(-1,-1,!0);Qr.MAX_UNSIGNED_VALUE=yU;var vs=Jr(0,-2147483648,!1);Qr.MIN_VALUE=vs;var Ae=Qr.prototype;Ae.toInt=function(){return this.unsigned?this.low>>>0:this.low};Ae.toNumber=function(){return this.unsigned?(this.high>>>0)*Tg+(this.low>>>0):this.high*Tg+(this.low>>>0)};Ae.toString=function(t){if(t=t||10,t<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(vs)){var e=yi(t),n=this.div(e),o=n.mul(e).sub(this);return n.toString(t)+o.toInt().toString(t)}else return"-"+this.neg().toString(t);for(var s=yi(J0(t,6),this.unsigned),i=this,a="";;){var u=i.div(s),l=i.sub(u.mul(s)).toInt()>>>0,c=l.toString(t);if(i=u,i.isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}};Ae.getHighBits=function(){return this.high};Ae.getHighBitsUnsigned=function(){return this.high>>>0};Ae.getLowBits=function(){return this.low};Ae.getLowBitsUnsigned=function(){return this.low>>>0};Ae.getNumBitsAbs=function(){if(this.isNegative())return this.eq(vs)?64:this.neg().getNumBitsAbs();for(var t=this.high!=0?this.high:this.low,e=31;e>0&&!(t&1<<e);e--);return this.high!=0?e+33:e+1};Ae.isZero=function(){return this.high===0&&this.low===0};Ae.eqz=Ae.isZero;Ae.isNegative=function(){return!this.unsigned&&this.high<0};Ae.isPositive=function(){return this.unsigned||this.high>=0};Ae.isOdd=function(){return(this.low&1)===1};Ae.isEven=function(){return(this.low&1)===0};Ae.equals=function(t){return bs(t)||(t=Wa(t)),this.unsigned!==t.unsigned&&this.high>>>31===1&&t.high>>>31===1?!1:this.high===t.high&&this.low===t.low};Ae.eq=Ae.equals;Ae.notEquals=function(t){return!this.eq(t)};Ae.neq=Ae.notEquals;Ae.ne=Ae.notEquals;Ae.lessThan=function(t){return this.comp(t)<0};Ae.lt=Ae.lessThan;Ae.lessThanOrEqual=function(t){return this.comp(t)<=0};Ae.lte=Ae.lessThanOrEqual;Ae.le=Ae.lessThanOrEqual;Ae.greaterThan=function(t){return this.comp(t)>0};Ae.gt=Ae.greaterThan;Ae.greaterThanOrEqual=function(t){return this.comp(t)>=0};Ae.gte=Ae.greaterThanOrEqual;Ae.ge=Ae.greaterThanOrEqual;Ae.compare=function(t){if(bs(t)||(t=Wa(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1};Ae.comp=Ae.compare;Ae.negate=function(){return!this.unsigned&&this.eq(vs)?vs:this.not().add(Ig)};Ae.neg=Ae.negate;Ae.add=function(t){bs(t)||(t=Wa(t));var e=this.high>>>16,n=this.high&65535,o=this.low>>>16,s=this.low&65535,i=t.high>>>16,a=t.high&65535,u=t.low>>>16,l=t.low&65535,c=0,p=0,d=0,f=0;return f+=s+l,d+=f>>>16,f&=65535,d+=o+u,p+=d>>>16,d&=65535,p+=n+a,c+=p>>>16,p&=65535,c+=e+i,c&=65535,Jr(d<<16|f,c<<16|p,this.unsigned)};Ae.subtract=function(t){return bs(t)||(t=Wa(t)),this.add(t.neg())};Ae.sub=Ae.subtract;Ae.multiply=function(t){if(this.isZero())return xi;if(bs(t)||(t=Wa(t)),gi){var e=gi.mul(this.low,this.high,t.low,t.high);return Jr(e,gi.get_high(),this.unsigned)}if(t.isZero())return xi;if(this.eq(vs))return t.isOdd()?vs:xi;if(t.eq(vs))return this.isOdd()?vs:xi;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(fU)&&t.lt(fU))return yi(this.toNumber()*t.toNumber(),this.unsigned);var n=this.high>>>16,o=this.high&65535,s=this.low>>>16,i=this.low&65535,a=t.high>>>16,u=t.high&65535,l=t.low>>>16,c=t.low&65535,p=0,d=0,f=0,h=0;return h+=i*c,f+=h>>>16,h&=65535,f+=s*c,d+=f>>>16,f&=65535,f+=i*l,d+=f>>>16,f&=65535,d+=o*c,p+=d>>>16,d&=65535,d+=s*l,p+=d>>>16,d&=65535,d+=i*u,p+=d>>>16,d&=65535,p+=n*c+o*l+s*u+i*a,p&=65535,Jr(f<<16|h,p<<16|d,this.unsigned)};Ae.mul=Ae.multiply;Ae.divide=function(t){if(bs(t)||(t=Wa(t)),t.isZero())throw Error("division by zero");if(gi){if(!this.unsigned&&this.high===-2147483648&&t.low===-1&&t.high===-1)return this;var e=(this.unsigned?gi.div_u:gi.div_s)(this.low,this.high,t.low,t.high);return Jr(e,gi.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?oh:xi;var n,o,s;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return oh;if(t.gt(this.shru(1)))return mU;s=oh}else{if(this.eq(vs)){if(t.eq(Ig)||t.eq(y2))return vs;if(t.eq(vs))return Ig;var i=this.shr(1);return n=i.div(t).shl(1),n.eq(xi)?t.isNegative()?Ig:y2:(o=this.sub(t.mul(n)),s=n.add(o.div(t)),s)}else if(t.eq(vs))return this.unsigned?oh:xi;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();s=xi}for(o=this;o.gte(t);){n=Math.max(1,Math.floor(o.toNumber()/t.toNumber()));for(var a=Math.ceil(Math.log(n)/Math.LN2),u=a<=48?1:J0(2,a-48),l=yi(n),c=l.mul(t);c.isNegative()||c.gt(o);)n-=u,l=yi(n,this.unsigned),c=l.mul(t);l.isZero()&&(l=Ig),s=s.add(l),o=o.sub(c)}return s};Ae.div=Ae.divide;Ae.modulo=function(t){if(bs(t)||(t=Wa(t)),gi){var e=(this.unsigned?gi.rem_u:gi.rem_s)(this.low,this.high,t.low,t.high);return Jr(e,gi.get_high(),this.unsigned)}return this.sub(this.div(t).mul(t))};Ae.mod=Ae.modulo;Ae.rem=Ae.modulo;Ae.not=function(){return Jr(~this.low,~this.high,this.unsigned)};Ae.and=function(t){return bs(t)||(t=Wa(t)),Jr(this.low&t.low,this.high&t.high,this.unsigned)};Ae.or=function(t){return bs(t)||(t=Wa(t)),Jr(this.low|t.low,this.high|t.high,this.unsigned)};Ae.xor=function(t){return bs(t)||(t=Wa(t)),Jr(this.low^t.low,this.high^t.high,this.unsigned)};Ae.shiftLeft=function(t){return bs(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?Jr(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):Jr(0,this.low<<t-32,this.unsigned)};Ae.shl=Ae.shiftLeft;Ae.shiftRight=function(t){return bs(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?Jr(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):Jr(this.high>>t-32,this.high>=0?0:-1,this.unsigned)};Ae.shr=Ae.shiftRight;Ae.shiftRightUnsigned=function(t){if(bs(t)&&(t=t.toInt()),t&=63,t===0)return this;var e=this.high;if(t<32){var n=this.low;return Jr(n>>>t|e<<32-t,e>>>t,this.unsigned)}else return t===32?Jr(e,0,this.unsigned):Jr(e>>>t-32,0,this.unsigned)};Ae.shru=Ae.shiftRightUnsigned;Ae.shr_u=Ae.shiftRightUnsigned;Ae.toSigned=function(){return this.unsigned?Jr(this.low,this.high,!1):this};Ae.toUnsigned=function(){return this.unsigned?this:Jr(this.low,this.high,!0)};Ae.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()};Ae.toBytesLE=function(){var t=this.high,e=this.low;return[e&255,e>>>8&255,e>>>16&255,e>>>24,t&255,t>>>8&255,t>>>16&255,t>>>24]};Ae.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,t&255,e>>>24,e>>>16&255,e>>>8&255,e&255]};Qr.fromBytes=function(t,e,n){return n?Qr.fromBytesLE(t,e):Qr.fromBytesBE(t,e)};Qr.fromBytesLE=function(t,e){return new Qr(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)};Qr.fromBytesBE=function(t,e){return new Qr(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)}});var lG=bn((Mg,uG)=>{"use strict";var oge=function(){if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof global<"u")return global;throw new Error("unable to locate global object")},fh=oge();uG.exports=Mg=fh.fetch;fh.fetch&&(Mg.default=fh.fetch.bind(fh));Mg.Headers=fh.Headers;Mg.Request=fh.Request;Mg.Response=fh.Response});var cG=bn(()=>{"use strict"});var zG=bn((LG,j2)=>{"use strict";(function(r,t,e){function n(a){var u=this,l=i();u.next=function(){var c=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=c-(u.c=c|0)},u.c=1,u.s0=l(" "),u.s1=l(" "),u.s2=l(" "),u.s0-=l(a),u.s0<0&&(u.s0+=1),u.s1-=l(a),u.s1<0&&(u.s1+=1),u.s2-=l(a),u.s2<0&&(u.s2+=1),l=null}function o(a,u){return u.c=a.c,u.s0=a.s0,u.s1=a.s1,u.s2=a.s2,u}function s(a,u){var l=new n(a),c=u&&u.state,p=l.next;return p.int32=function(){return l.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,c&&(typeof c=="object"&&o(c,l),p.state=function(){return o(l,{})}),p}function i(){var a=4022871197,u=function(l){l=String(l);for(var c=0;c<l.length;c++){a+=l.charCodeAt(c);var p=.02519603282416938*a;a=p>>>0,p-=a,p*=a,a=p>>>0,p-=a,a+=p*4294967296}return(a>>>0)*23283064365386963e-26};return u}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.alea=s})(LG,typeof j2=="object"&&j2,typeof define=="function"&&define)});var VG=bn((BG,H2)=>{"use strict";(function(r,t,e){function n(i){var a=this,u="";a.x=0,a.y=0,a.z=0,a.w=0,a.next=function(){var c=a.x^a.x<<11;return a.x=a.y,a.y=a.z,a.z=a.w,a.w^=a.w>>>19^c^c>>>8},i===(i|0)?a.x=i:u+=i;for(var l=0;l<u.length+64;l++)a.x^=u.charCodeAt(l)|0,a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,d=(u.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xor128=s})(BG,typeof H2=="object"&&H2,typeof define=="function"&&define)});var GG=bn((UG,q2)=>{"use strict";(function(r,t,e){function n(i){var a=this,u="";a.next=function(){var c=a.x^a.x>>>2;return a.x=a.y,a.y=a.z,a.z=a.w,a.w=a.v,(a.d=a.d+362437|0)+(a.v=a.v^a.v<<4^(c^c<<1))|0},a.x=0,a.y=0,a.z=0,a.w=0,a.v=0,i===(i|0)?a.x=i:u+=i;for(var l=0;l<u.length+64;l++)a.x^=u.charCodeAt(l)|0,l==u.length&&(a.d=a.x<<10^a.x>>>4),a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a.v=i.v,a.d=i.d,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,d=(u.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xorwow=s})(UG,typeof q2=="object"&&q2,typeof define=="function"&&define)});var jG=bn((WG,K2)=>{"use strict";(function(r,t,e){function n(i){var a=this;a.next=function(){var l=a.x,c=a.i,p,d,f;return p=l[c],p^=p>>>7,d=p^p<<24,p=l[c+1&7],d^=p^p>>>10,p=l[c+3&7],d^=p^p>>>3,p=l[c+4&7],d^=p^p<<7,p=l[c+7&7],p=p^p<<13,d^=p^p<<9,l[c]=d,a.i=c+1&7,d};function u(l,c){var p,d,f=[];if(c===(c|0))d=f[0]=c;else for(c=""+c,p=0;p<c.length;++p)f[p&7]=f[p&7]<<15^c.charCodeAt(p)+f[p+1&7]<<13;for(;f.length<8;)f.push(0);for(p=0;p<8&&f[p]===0;++p);for(p==8?d=f[7]=-1:d=f[p],l.x=f,l.i=0,p=256;p>0;--p)l.next()}u(a,i)}function o(i,a){return a.x=i.x.slice(),a.i=i.i,a}function s(i,a){i==null&&(i=+new Date);var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,d=(u.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(l.x&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xorshift7=s})(WG,typeof K2=="object"&&K2,typeof define=="function"&&define)});var qG=bn((HG,X2)=>{"use strict";(function(r,t,e){function n(i){var a=this;a.next=function(){var l=a.w,c=a.X,p=a.i,d,f;return a.w=l=l+1640531527|0,f=c[p+34&127],d=c[p=p+1&127],f^=f<<13,d^=d<<17,f^=f>>>15,d^=d>>>12,f=c[p]=f^d,a.i=p,f+(l^l>>>16)|0};function u(l,c){var p,d,f,h,m,g=[],y=128;for(c===(c|0)?(d=c,c=null):(c=c+"\0",d=0,y=Math.max(y,c.length)),f=0,h=-32;h<y;++h)c&&(d^=c.charCodeAt((h+32)%c.length)),h===0&&(m=d),d^=d<<10,d^=d>>>15,d^=d<<4,d^=d>>>13,h>=0&&(m=m+1640531527|0,p=g[h&127]^=d+m,f=p==0?f+1:0);for(f>=128&&(g[(c&&c.length||0)&127]=-1),f=127,h=4*128;h>0;--h)d=g[f+34&127],p=g[f=f+1&127],d^=d<<13,p^=p<<17,d^=d>>>15,p^=p>>>12,g[f]=d^p;l.w=m,l.X=g,l.i=f}u(a,i)}function o(i,a){return a.i=i.i,a.w=i.w,a.X=i.X.slice(),a}function s(i,a){i==null&&(i=+new Date);var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,d=(u.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(l.X&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xor4096=s})(HG,typeof X2=="object"&&X2,typeof define=="function"&&define)});var XG=bn((KG,Y2)=>{"use strict";(function(r,t,e){function n(i){var a=this,u="";a.next=function(){var c=a.b,p=a.c,d=a.d,f=a.a;return c=c<<25^c>>>7^p,p=p-d|0,d=d<<24^d>>>8^f,f=f-c|0,a.b=c=c<<20^c>>>12^p,a.c=p=p-d|0,a.d=d<<16^p>>>16^f,a.a=f-c|0},a.a=0,a.b=0,a.c=-1640531527,a.d=1367130551,i===Math.floor(i)?(a.a=i/4294967296|0,a.b=i|0):u+=i;for(var l=0;l<u.length+20;l++)a.b^=u.charCodeAt(l)|0,a.next()}function o(i,a){return a.a=i.a,a.b=i.b,a.c=i.c,a.d=i.d,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,d=(u.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.tychei=s})(KG,typeof Y2=="object"&&Y2,typeof define=="function"&&define)});var YG=bn(()=>{"use strict"});var QG=bn((ZG,QS)=>{"use strict";(function(r,t,e){var n=256,o=6,s=52,i="random",a=e.pow(n,o),u=e.pow(2,s),l=u*2,c=n-1,p;function d(w,C,I){var N=[];C=C==!0?{entropy:!0}:C||{};var A=g(m(C.entropy?[w,x(t)]:w??y(),3),N),O=new f(N),$=function(){for(var z=O.g(o),G=a,K=0;z<u;)z=(z+K)*n,G*=n,K=O.g(1);for(;z>=l;)z/=2,G/=2,K>>>=1;return(z+K)/G};return $.int32=function(){return O.g(4)|0},$.quick=function(){return O.g(4)/4294967296},$.double=$,g(x(O.S),t),(C.pass||I||function(z,G,K,Z){return Z&&(Z.S&&h(Z,O),z.state=function(){return h(O,{})}),K?(e[i]=z,G):z})($,A,"global"in C?C.global:this==e,C.state)}function f(w){var C,I=w.length,N=this,A=0,O=N.i=N.j=0,$=N.S=[];for(I||(w=[I++]);A<n;)$[A]=A++;for(A=0;A<n;A++)$[A]=$[O=c&O+w[A%I]+(C=$[A])],$[O]=C;(N.g=function(z){for(var G,K=0,Z=N.i,Q=N.j,J=N.S;z--;)G=J[Z=c&Z+1],K=K*n+J[c&(J[Z]=J[Q=c&Q+G])+(J[Q]=G)];return N.i=Z,N.j=Q,K})(n)}function h(w,C){return C.i=w.i,C.j=w.j,C.S=w.S.slice(),C}function m(w,C){var I=[],N=typeof w,A;if(C&&N=="object")for(A in w)try{I.push(m(w[A],C-1))}catch{}return I.length?I:N=="string"?w:w+"\0"}function g(w,C){for(var I=w+"",N,A=0;A<I.length;)C[c&A]=c&(N^=C[c&A]*19)+I.charCodeAt(A++);return x(C)}function y(){try{var w;return p&&(w=p.randomBytes)?w=w(n):(w=new Uint8Array(n),(r.crypto||r.msCrypto).getRandomValues(w)),x(w)}catch{var C=r.navigator,I=C&&C.plugins;return[+new Date,r,I,r.screen,x(t)]}}function x(w){return String.fromCharCode.apply(0,w)}if(g(e.random(),t),typeof QS=="object"&&QS.exports){QS.exports=d;try{p=YG()}catch{}}else typeof define=="function"&&define.amd?define(function(){return d}):e["seed"+i]=d})(typeof self<"u"?self:ZG,[],Math)});var eb=bn((Cot,JG)=>{"use strict";var Gxe=zG(),Wxe=VG(),jxe=GG(),Hxe=jG(),qxe=qG(),Kxe=XG(),bh=QG();bh.alea=Gxe;bh.xor128=Wxe;bh.xorwow=jxe;bh.xorshift7=Hxe;bh.xor4096=qxe;bh.tychei=Kxe;JG.exports=bh});var xse=bn(hP=>{"use strict";Object.defineProperty(hP,"__esModule",{value:!0});var fP=class extends Error{constructor(t){super(t.message),this.name="PostgrestError",this.details=t.details,this.hint=t.hint,this.code=t.code}};hP.default=fP});var gP=bn(Tw=>{"use strict";var vse=Tw&&Tw.__importDefault||function(r){return r&&r.__esModule?r:{default:r}};Object.defineProperty(Tw,"__esModule",{value:!0});var r3e=vse((xL(),iae(aae))),n3e=vse(xse()),mP=class{constructor(t){this.shouldThrowOnError=!1,this.method=t.method,this.url=t.url,this.headers=t.headers,this.schema=t.schema,this.body=t.body,this.shouldThrowOnError=t.shouldThrowOnError,this.signal=t.signal,this.isMaybeSingle=t.isMaybeSingle,t.fetch?this.fetch=t.fetch:typeof fetch>"u"?this.fetch=r3e.default:this.fetch=fetch}throwOnError(){return this.shouldThrowOnError=!0,this}then(t,e){this.schema===void 0||(["GET","HEAD"].includes(this.method)?this.headers["Accept-Profile"]=this.schema:this.headers["Content-Profile"]=this.schema),this.method!=="GET"&&this.method!=="HEAD"&&(this.headers["Content-Type"]="application/json");let n=this.fetch,o=n(this.url.toString(),{method:this.method,headers:this.headers,body:JSON.stringify(this.body),signal:this.signal}).then(s=>L(this,null,function*(){var i,a,u;let l=null,c=null,p=null,d=s.status,f=s.statusText;if(s.ok){if(this.method!=="HEAD"){let y=yield s.text();y===""||(this.headers.Accept==="text/csv"||this.headers.Accept&&this.headers.Accept.includes("application/vnd.pgrst.plan+text")?c=y:c=JSON.parse(y))}let m=(i=this.headers.Prefer)===null||i===void 0?void 0:i.match(/count=(exact|planned|estimated)/),g=(a=s.headers.get("content-range"))===null||a===void 0?void 0:a.split("/");m&&g&&g.length>1&&(p=parseInt(g[1])),this.isMaybeSingle&&this.method==="GET"&&Array.isArray(c)&&(c.length>1?(l={code:"PGRST116",details:`Results contain ${c.length} rows, application/vnd.pgrst.object+json requires 1 row`,hint:null,message:"JSON object requested, multiple (or no) rows returned"},c=null,p=null,d=406,f="Not Acceptable"):c.length===1?c=c[0]:c=null)}else{let m=yield s.text();try{l=JSON.parse(m),Array.isArray(l)&&s.status===404&&(c=[],l=null,d=200,f="OK")}catch{s.status===404&&m===""?(d=204,f="No Content"):l={message:m}}if(l&&this.isMaybeSingle&&(!((u=l?.details)===null||u===void 0)&&u.includes("0 rows"))&&(l=null,d=200,f="OK"),l&&this.shouldThrowOnError)throw new n3e.default(l)}return{error:l,data:c,count:p,status:d,statusText:f}}));return this.shouldThrowOnError||(o=o.catch(s=>{var i,a,u;return{error:{message:`${(i=s?.name)!==null&&i!==void 0?i:"FetchError"}: ${s?.message}`,details:`${(a=s?.stack)!==null&&a!==void 0?a:""}`,hint:"",code:`${(u=s?.code)!==null&&u!==void 0?u:""}`},data:null,count:null,status:0,statusText:""}})),o.then(t,e)}};Tw.default=mP});var xP=bn(_w=>{"use strict";var o3e=_w&&_w.__importDefault||function(r){return r&&r.__esModule?r:{default:r}};Object.defineProperty(_w,"__esModule",{value:!0});var s3e=o3e(gP()),yP=class extends s3e.default{select(t){let e=!1,n=(t??"*").split("").map(o=>/\s/.test(o)&&!e?"":(o==='"'&&(e=!e),o)).join("");return this.url.searchParams.set("select",n),this.headers.Prefer&&(this.headers.Prefer+=","),this.headers.Prefer+="return=representation",this}order(t,{ascending:e=!0,nullsFirst:n,foreignTable:o,referencedTable:s=o}={}){let i=s?`${s}.order`:"order",a=this.url.searchParams.get(i);return this.url.searchParams.set(i,`${a?`${a},`:""}${t}.${e?"asc":"desc"}${n===void 0?"":n?".nullsfirst":".nullslast"}`),this}limit(t,{foreignTable:e,referencedTable:n=e}={}){let o=typeof n>"u"?"limit":`${n}.limit`;return this.url.searchParams.set(o,`${t}`),this}range(t,e,{foreignTable:n,referencedTable:o=n}={}){let s=typeof o>"u"?"offset":`${o}.offset`,i=typeof o>"u"?"limit":`${o}.limit`;return this.url.searchParams.set(s,`${t}`),this.url.searchParams.set(i,`${e-t+1}`),this}abortSignal(t){return this.signal=t,this}single(){return this.headers.Accept="application/vnd.pgrst.object+json",this}maybeSingle(){return this.method==="GET"?this.headers.Accept="application/json":this.headers.Accept="application/vnd.pgrst.object+json",this.isMaybeSingle=!0,this}csv(){return this.headers.Accept="text/csv",this}geojson(){return this.headers.Accept="application/geo+json",this}explain({analyze:t=!1,verbose:e=!1,settings:n=!1,buffers:o=!1,wal:s=!1,format:i="text"}={}){var a;let u=[t?"analyze":null,e?"verbose":null,n?"settings":null,o?"buffers":null,s?"wal":null].filter(Boolean).join("|"),l=(a=this.headers.Accept)!==null&&a!==void 0?a:"application/json";return this.headers.Accept=`application/vnd.pgrst.plan+${i}; for="${l}"; options=${u};`,i==="json"?this:this}rollback(){var t;return((t=this.headers.Prefer)!==null&&t!==void 0?t:"").trim().length>0?this.headers.Prefer+=",tx=rollback":this.headers.Prefer="tx=rollback",this}returns(){return this}};_w.default=yP});var Qk=bn(Ew=>{"use strict";var i3e=Ew&&Ew.__importDefault||function(r){return r&&r.__esModule?r:{default:r}};Object.defineProperty(Ew,"__esModule",{value:!0});var a3e=i3e(xP()),vP=class extends a3e.default{eq(t,e){return this.url.searchParams.append(t,`eq.${e}`),this}neq(t,e){return this.url.searchParams.append(t,`neq.${e}`),this}gt(t,e){return this.url.searchParams.append(t,`gt.${e}`),this}gte(t,e){return this.url.searchParams.append(t,`gte.${e}`),this}lt(t,e){return this.url.searchParams.append(t,`lt.${e}`),this}lte(t,e){return this.url.searchParams.append(t,`lte.${e}`),this}like(t,e){return this.url.searchParams.append(t,`like.${e}`),this}likeAllOf(t,e){return this.url.searchParams.append(t,`like(all).{${e.join(",")}}`),this}likeAnyOf(t,e){return this.url.searchParams.append(t,`like(any).{${e.join(",")}}`),this}ilike(t,e){return this.url.searchParams.append(t,`ilike.${e}`),this}ilikeAllOf(t,e){return this.url.searchParams.append(t,`ilike(all).{${e.join(",")}}`),this}ilikeAnyOf(t,e){return this.url.searchParams.append(t,`ilike(any).{${e.join(",")}}`),this}is(t,e){return this.url.searchParams.append(t,`is.${e}`),this}in(t,e){let n=Array.from(new Set(e)).map(o=>typeof o=="string"&&new RegExp("[,()]").test(o)?`"${o}"`:`${o}`).join(",");return this.url.searchParams.append(t,`in.(${n})`),this}contains(t,e){return typeof e=="string"?this.url.searchParams.append(t,`cs.${e}`):Array.isArray(e)?this.url.searchParams.append(t,`cs.{${e.join(",")}}`):this.url.searchParams.append(t,`cs.${JSON.stringify(e)}`),this}containedBy(t,e){return typeof e=="string"?this.url.searchParams.append(t,`cd.${e}`):Array.isArray(e)?this.url.searchParams.append(t,`cd.{${e.join(",")}}`):this.url.searchParams.append(t,`cd.${JSON.stringify(e)}`),this}rangeGt(t,e){return this.url.searchParams.append(t,`sr.${e}`),this}rangeGte(t,e){return this.url.searchParams.append(t,`nxl.${e}`),this}rangeLt(t,e){return this.url.searchParams.append(t,`sl.${e}`),this}rangeLte(t,e){return this.url.searchParams.append(t,`nxr.${e}`),this}rangeAdjacent(t,e){return this.url.searchParams.append(t,`adj.${e}`),this}overlaps(t,e){return typeof e=="string"?this.url.searchParams.append(t,`ov.${e}`):this.url.searchParams.append(t,`ov.{${e.join(",")}}`),this}textSearch(t,e,{config:n,type:o}={}){let s="";o==="plain"?s="pl":o==="phrase"?s="ph":o==="websearch"&&(s="w");let i=n===void 0?"":`(${n})`;return this.url.searchParams.append(t,`${s}fts${i}.${e}`),this}match(t){return Object.entries(t).forEach(([e,n])=>{this.url.searchParams.append(e,`eq.${n}`)}),this}not(t,e,n){return this.url.searchParams.append(t,`not.${e}.${n}`),this}or(t,{foreignTable:e,referencedTable:n=e}={}){let o=n?`${n}.or`:"or";return this.url.searchParams.append(o,`(${t})`),this}filter(t,e,n){return this.url.searchParams.append(t,`${e}.${n}`),this}};Ew.default=vP});var wP=bn(Nw=>{"use strict";var u3e=Nw&&Nw.__importDefault||function(r){return r&&r.__esModule?r:{default:r}};Object.defineProperty(Nw,"__esModule",{value:!0});var kw=u3e(Qk()),bP=class{constructor(t,{headers:e={},schema:n,fetch:o}){this.url=t,this.headers=e,this.schema=n,this.fetch=o}select(t,{head:e=!1,count:n}={}){let o=e?"HEAD":"GET",s=!1,i=(t??"*").split("").map(a=>/\s/.test(a)&&!s?"":(a==='"'&&(s=!s),a)).join("");return this.url.searchParams.set("select",i),n&&(this.headers.Prefer=`count=${n}`),new kw.default({method:o,url:this.url,headers:this.headers,schema:this.schema,fetch:this.fetch,allowEmpty:!1})}insert(t,{count:e,defaultToNull:n=!0}={}){let o="POST",s=[];if(this.headers.Prefer&&s.push(this.headers.Prefer),e&&s.push(`count=${e}`),n||s.push("missing=default"),this.headers.Prefer=s.join(","),Array.isArray(t)){let i=t.reduce((a,u)=>a.concat(Object.keys(u)),[]);if(i.length>0){let a=[...new Set(i)].map(u=>`"${u}"`);this.url.searchParams.set("columns",a.join(","))}}return new kw.default({method:o,url:this.url,headers:this.headers,schema:this.schema,body:t,fetch:this.fetch,allowEmpty:!1})}upsert(t,{onConflict:e,ignoreDuplicates:n=!1,count:o,defaultToNull:s=!0}={}){let i="POST",a=[`resolution=${n?"ignore":"merge"}-duplicates`];if(e!==void 0&&this.url.searchParams.set("on_conflict",e),this.headers.Prefer&&a.push(this.headers.Prefer),o&&a.push(`count=${o}`),s||a.push("missing=default"),this.headers.Prefer=a.join(","),Array.isArray(t)){let u=t.reduce((l,c)=>l.concat(Object.keys(c)),[]);if(u.length>0){let l=[...new Set(u)].map(c=>`"${c}"`);this.url.searchParams.set("columns",l.join(","))}}return new kw.default({method:i,url:this.url,headers:this.headers,schema:this.schema,body:t,fetch:this.fetch,allowEmpty:!1})}update(t,{count:e}={}){let n="PATCH",o=[];return this.headers.Prefer&&o.push(this.headers.Prefer),e&&o.push(`count=${e}`),this.headers.Prefer=o.join(","),new kw.default({method:n,url:this.url,headers:this.headers,schema:this.schema,body:t,fetch:this.fetch,allowEmpty:!1})}delete({count:t}={}){let e="DELETE",n=[];return t&&n.push(`count=${t}`),this.headers.Prefer&&n.unshift(this.headers.Prefer),this.headers.Prefer=n.join(","),new kw.default({method:e,url:this.url,headers:this.headers,schema:this.schema,fetch:this.fetch,allowEmpty:!1})}};Nw.default=bP});var bse=bn(Jk=>{"use strict";Object.defineProperty(Jk,"__esModule",{value:!0});Jk.version=void 0;Jk.version="0.0.0-automated"});var wse=bn(eN=>{"use strict";Object.defineProperty(eN,"__esModule",{value:!0});eN.DEFAULT_HEADERS=void 0;var l3e=bse();eN.DEFAULT_HEADERS={"X-Client-Info":`postgrest-js/${l3e.version}`}});var Sse=bn(Dw=>{"use strict";var Cse=Dw&&Dw.__importDefault||function(r){return r&&r.__esModule?r:{default:r}};Object.defineProperty(Dw,"__esModule",{value:!0});var c3e=Cse(wP()),p3e=Cse(Qk()),d3e=wse(),CP=class r{constructor(t,{headers:e={},schema:n,fetch:o}={}){this.url=t,this.headers=Object.assign(Object.assign({},d3e.DEFAULT_HEADERS),e),this.schemaName=n,this.fetch=o}from(t){let e=new URL(`${this.url}/${t}`);return new c3e.default(e,{headers:Object.assign({},this.headers),schema:this.schemaName,fetch:this.fetch})}schema(t){return new r(this.url,{headers:this.headers,schema:t,fetch:this.fetch})}rpc(t,e={},{head:n=!1,get:o=!1,count:s}={}){let i,a=new URL(`${this.url}/rpc/${t}`),u;n||o?(i=n?"HEAD":"GET",Object.entries(e).filter(([c,p])=>p!==void 0).map(([c,p])=>[c,Array.isArray(p)?`{${p.join(",")}}`:`${p}`]).forEach(([c,p])=>{a.searchParams.append(c,p)})):(i="POST",u=e);let l=Object.assign({},this.headers);return s&&(l.Prefer=`count=${s}`),new p3e.default({method:i,url:a,headers:l,schema:this.schemaName,body:u,fetch:this.fetch,allowEmpty:!1})}};Dw.default=CP});var Nse=bn(cs=>{"use strict";var Aw=cs&&cs.__importDefault||function(r){return r&&r.__esModule?r:{default:r}};Object.defineProperty(cs,"__esModule",{value:!0});cs.PostgrestBuilder=cs.PostgrestTransformBuilder=cs.PostgrestFilterBuilder=cs.PostgrestQueryBuilder=cs.PostgrestClient=void 0;var Ise=Aw(Sse());cs.PostgrestClient=Ise.default;var Tse=Aw(wP());cs.PostgrestQueryBuilder=Tse.default;var _se=Aw(Qk());cs.PostgrestFilterBuilder=_se.default;var Ese=Aw(xP());cs.PostgrestTransformBuilder=Ese.default;var kse=Aw(gP());cs.PostgrestBuilder=kse.default;cs.default={PostgrestClient:Ise.default,PostgrestQueryBuilder:Tse.default,PostgrestFilterBuilder:_se.default,PostgrestTransformBuilder:Ese.default,PostgrestBuilder:kse.default}});var KN=null;var qN=1,vL=Symbol("SIGNAL");function br(r){let t=KN;return KN=r,t}function bL(){return KN}var XN={version:0,lastCleanEpoch:0,dirty:!1,producerNode:void 0,producerLastReadVersion:void 0,producerIndexOfThis:void 0,nextProducerIndex:0,liveConsumerNode:void 0,liveConsumerIndexOfThis:void 0,consumerAllowSignalWrites:!1,consumerIsAlwaysLive:!1,producerMustRecompute:()=>!1,producerRecomputeValue:()=>{},consumerMarkedDirty:()=>{},consumerOnSignalRead:()=>{}};function uae(r){if(!(eD(r)&&!r.dirty)&&!(!r.dirty&&r.lastCleanEpoch===qN)){if(!r.producerMustRecompute(r)&&!ZN(r)){r.dirty=!1,r.lastCleanEpoch=qN;return}r.producerRecomputeValue(r),r.dirty=!1,r.lastCleanEpoch=qN}}function YN(r){return r&&(r.nextProducerIndex=0),br(r)}function wL(r,t){if(br(t),!(!r||r.producerNode===void 0||r.producerIndexOfThis===void 0||r.producerLastReadVersion===void 0)){if(eD(r))for(let e=r.nextProducerIndex;e<r.producerNode.length;e++)JN(r.producerNode[e],r.producerIndexOfThis[e]);for(;r.producerNode.length>r.nextProducerIndex;)r.producerNode.pop(),r.producerLastReadVersion.pop(),r.producerIndexOfThis.pop()}}function ZN(r){tD(r);for(let t=0;t<r.producerNode.length;t++){let e=r.producerNode[t],n=r.producerLastReadVersion[t];if(n!==e.version||(uae(e),n!==e.version))return!0}return!1}function QN(r){if(tD(r),eD(r))for(let t=0;t<r.producerNode.length;t++)JN(r.producerNode[t],r.producerIndexOfThis[t]);r.producerNode.length=r.producerLastReadVersion.length=r.producerIndexOfThis.length=0,r.liveConsumerNode&&(r.liveConsumerNode.length=r.liveConsumerIndexOfThis.length=0)}function JN(r,t){if(lae(r),r.liveConsumerNode.length===1&&cae(r))for(let n=0;n<r.producerNode.length;n++)JN(r.producerNode[n],r.producerIndexOfThis[n]);let e=r.liveConsumerNode.length-1;if(r.liveConsumerNode[t]=r.liveConsumerNode[e],r.liveConsumerIndexOfThis[t]=r.liveConsumerIndexOfThis[e],r.liveConsumerNode.length--,r.liveConsumerIndexOfThis.length--,t<r.liveConsumerNode.length){let n=r.liveConsumerIndexOfThis[t],o=r.liveConsumerNode[t];tD(o),o.producerIndexOfThis[n]=t}}function eD(r){return r.consumerIsAlwaysLive||(r?.liveConsumerNode?.length??0)>0}function tD(r){r.producerNode??=[],r.producerIndexOfThis??=[],r.producerLastReadVersion??=[]}function lae(r){r.liveConsumerNode??=[],r.liveConsumerIndexOfThis??=[]}function cae(r){return r.producerNode!==void 0}function pae(){throw new Error}var dae=pae;function CL(r){dae=r}function _t(r){return typeof r=="function"}function bm(r){let e=r(n=>{Error.call(n),n.stack=new Error().stack});return e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e}var rC=bm(r=>function(e){r(this),this.message=e?`${e.length} errors occurred during unsubscription:
${e.map((n,o)=>`${o+1}) ${n.toString()}`).join(`
  `)}`:"",this.name="UnsubscriptionError",this.errors=e});function Tf(r,t){if(r){let e=r.indexOf(t);0<=e&&r.splice(e,1)}}var wn=class r{constructor(t){this.initialTeardown=t,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let t;if(!this.closed){this.closed=!0;let{_parentage:e}=this;if(e)if(this._parentage=null,Array.isArray(e))for(let s of e)s.remove(this);else e.remove(this);let{initialTeardown:n}=this;if(_t(n))try{n()}catch(s){t=s instanceof rC?s.errors:[s]}let{_finalizers:o}=this;if(o){this._finalizers=null;for(let s of o)try{SL(s)}catch(i){t=t??[],i instanceof rC?t=[...t,...i.errors]:t.push(i)}}if(t)throw new rC(t)}}add(t){var e;if(t&&t!==this)if(this.closed)SL(t);else{if(t instanceof r){if(t.closed||t._hasParent(this))return;t._addParent(this)}(this._finalizers=(e=this._finalizers)!==null&&e!==void 0?e:[]).push(t)}}_hasParent(t){let{_parentage:e}=this;return e===t||Array.isArray(e)&&e.includes(t)}_addParent(t){let{_parentage:e}=this;this._parentage=Array.isArray(e)?(e.push(t),e):e?[e,t]:t}_removeParent(t){let{_parentage:e}=this;e===t?this._parentage=null:Array.isArray(e)&&Tf(e,t)}remove(t){let{_finalizers:e}=this;e&&Tf(e,t),t instanceof r&&t._removeParent(this)}};wn.EMPTY=(()=>{let r=new wn;return r.closed=!0,r})();var rD=wn.EMPTY;function nC(r){return r instanceof wn||r&&"closed"in r&&_t(r.remove)&&_t(r.add)&&_t(r.unsubscribe)}function SL(r){_t(r)?r():r.unsubscribe()}var Ui={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1};var wm={setTimeout(r,t,...e){let{delegate:n}=wm;return n?.setTimeout?n.setTimeout(r,t,...e):setTimeout(r,t,...e)},clearTimeout(r){let{delegate:t}=wm;return(t?.clearTimeout||clearTimeout)(r)},delegate:void 0};function oC(r){wm.setTimeout(()=>{let{onUnhandledError:t}=Ui;if(t)t(r);else throw r})}function qx(){}var IL=nD("C",void 0,void 0);function TL(r){return nD("E",void 0,r)}function _L(r){return nD("N",r,void 0)}function nD(r,t,e){return{kind:r,value:t,error:e}}var _f=null;function Cm(r){if(Ui.useDeprecatedSynchronousErrorHandling){let t=!_f;if(t&&(_f={errorThrown:!1,error:null}),r(),t){let{errorThrown:e,error:n}=_f;if(_f=null,e)throw n}}else r()}function EL(r){Ui.useDeprecatedSynchronousErrorHandling&&_f&&(_f.errorThrown=!0,_f.error=r)}var Ef=class extends wn{constructor(t){super(),this.isStopped=!1,t?(this.destination=t,nC(t)&&t.add(this)):this.destination=mae}static create(t,e,n){return new ip(t,e,n)}next(t){this.isStopped?sD(_L(t),this):this._next(t)}error(t){this.isStopped?sD(TL(t),this):(this.isStopped=!0,this._error(t))}complete(){this.isStopped?sD(IL,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(t){this.destination.next(t)}_error(t){try{this.destination.error(t)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}},fae=Function.prototype.bind;function oD(r,t){return fae.call(r,t)}var iD=class{constructor(t){this.partialObserver=t}next(t){let{partialObserver:e}=this;if(e.next)try{e.next(t)}catch(n){sC(n)}}error(t){let{partialObserver:e}=this;if(e.error)try{e.error(t)}catch(n){sC(n)}else sC(t)}complete(){let{partialObserver:t}=this;if(t.complete)try{t.complete()}catch(e){sC(e)}}},ip=class extends Ef{constructor(t,e,n){super();let o;if(_t(t)||!t)o={next:t??void 0,error:e??void 0,complete:n??void 0};else{let s;this&&Ui.useDeprecatedNextContext?(s=Object.create(t),s.unsubscribe=()=>this.unsubscribe(),o={next:t.next&&oD(t.next,s),error:t.error&&oD(t.error,s),complete:t.complete&&oD(t.complete,s)}):o=t}this.destination=new iD(o)}};function sC(r){Ui.useDeprecatedSynchronousErrorHandling?EL(r):oC(r)}function hae(r){throw r}function sD(r,t){let{onStoppedNotification:e}=Ui;e&&wm.setTimeout(()=>e(r,t))}var mae={closed:!0,next:qx,error:hae,complete:qx};var Sm=typeof Symbol=="function"&&Symbol.observable||"@@observable";function Ls(r){return r}function aD(...r){return uD(r)}function uD(r){return r.length===0?Ls:r.length===1?r[0]:function(e){return r.reduce((n,o)=>o(n),e)}}var hr=(()=>{class r{constructor(e){e&&(this._subscribe=e)}lift(e){let n=new r;return n.source=this,n.operator=e,n}subscribe(e,n,o){let s=yae(e)?e:new ip(e,n,o);return Cm(()=>{let{operator:i,source:a}=this;s.add(i?i.call(s,a):a?this._subscribe(s):this._trySubscribe(s))}),s}_trySubscribe(e){try{return this._subscribe(e)}catch(n){e.error(n)}}forEach(e,n){return n=kL(n),new n((o,s)=>{let i=new ip({next:a=>{try{e(a)}catch(u){s(u),i.unsubscribe()}},error:s,complete:o});this.subscribe(i)})}_subscribe(e){var n;return(n=this.source)===null||n===void 0?void 0:n.subscribe(e)}[Sm](){return this}pipe(...e){return uD(e)(this)}toPromise(e){return e=kL(e),new e((n,o)=>{let s;this.subscribe(i=>s=i,i=>o(i),()=>n(s))})}}return r.create=t=>new r(t),r})();function kL(r){var t;return(t=r??Ui.Promise)!==null&&t!==void 0?t:Promise}function gae(r){return r&&_t(r.next)&&_t(r.error)&&_t(r.complete)}function yae(r){return r&&r instanceof Ef||gae(r)&&nC(r)}function lD(r){return _t(r?.lift)}function nr(r){return t=>{if(lD(t))return t.lift(function(e){try{return r(e,this)}catch(n){this.error(n)}});throw new TypeError("Unable to lift unknown Observable type")}}function Ht(r,t,e,n,o){return new cD(r,t,e,n,o)}var cD=class extends Ef{constructor(t,e,n,o,s,i){super(t),this.onFinalize=s,this.shouldUnsubscribe=i,this._next=e?function(a){try{e(a)}catch(u){t.error(u)}}:super._next,this._error=o?function(a){try{o(a)}catch(u){t.error(u)}finally{this.unsubscribe()}}:super._error,this._complete=n?function(){try{n()}catch(a){t.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var t;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){let{closed:e}=this;super.unsubscribe(),!e&&((t=this.onFinalize)===null||t===void 0||t.call(this))}}};function Im(){return nr((r,t)=>{let e=null;r._refCount++;let n=Ht(t,void 0,void 0,void 0,()=>{if(!r||r._refCount<=0||0<--r._refCount){e=null;return}let o=r._connection,s=e;e=null,o&&(!s||o===s)&&o.unsubscribe(),t.unsubscribe()});r.subscribe(n),n.closed||(e=r.connect())})}var Tm=class extends hr{constructor(t,e){super(),this.source=t,this.subjectFactory=e,this._subject=null,this._refCount=0,this._connection=null,lD(t)&&(this.lift=t.lift)}_subscribe(t){return this.getSubject().subscribe(t)}getSubject(){let t=this._subject;return(!t||t.isStopped)&&(this._subject=this.subjectFactory()),this._subject}_teardown(){this._refCount=0;let{_connection:t}=this;this._subject=this._connection=null,t?.unsubscribe()}connect(){let t=this._connection;if(!t){t=this._connection=new wn;let e=this.getSubject();t.add(this.source.subscribe(Ht(e,void 0,()=>{this._teardown(),e.complete()},n=>{this._teardown(),e.error(n)},()=>this._teardown()))),t.closed&&(this._connection=null,t=wn.EMPTY)}return t}refCount(){return Im()(this)}};var NL=bm(r=>function(){r(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});var Mr=(()=>{class r extends hr{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(e){let n=new iC(this,this);return n.operator=e,n}_throwIfClosed(){if(this.closed)throw new NL}next(e){Cm(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(let n of this.currentObservers)n.next(e)}})}error(e){Cm(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=e;let{observers:n}=this;for(;n.length;)n.shift().error(e)}})}complete(){Cm(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;let{observers:e}=this;for(;e.length;)e.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var e;return((e=this.observers)===null||e===void 0?void 0:e.length)>0}_trySubscribe(e){return this._throwIfClosed(),super._trySubscribe(e)}_subscribe(e){return this._throwIfClosed(),this._checkFinalizedStatuses(e),this._innerSubscribe(e)}_innerSubscribe(e){let{hasError:n,isStopped:o,observers:s}=this;return n||o?rD:(this.currentObservers=null,s.push(e),new wn(()=>{this.currentObservers=null,Tf(s,e)}))}_checkFinalizedStatuses(e){let{hasError:n,thrownError:o,isStopped:s}=this;n?e.error(o):s&&e.complete()}asObservable(){let e=new hr;return e.source=this,e}}return r.create=(t,e)=>new iC(t,e),r})(),iC=class extends Mr{constructor(t,e){super(),this.destination=t,this.source=e}next(t){var e,n;(n=(e=this.destination)===null||e===void 0?void 0:e.next)===null||n===void 0||n.call(e,t)}error(t){var e,n;(n=(e=this.destination)===null||e===void 0?void 0:e.error)===null||n===void 0||n.call(e,t)}complete(){var t,e;(e=(t=this.destination)===null||t===void 0?void 0:t.complete)===null||e===void 0||e.call(t)}_subscribe(t){var e,n;return(n=(e=this.source)===null||e===void 0?void 0:e.subscribe(t))!==null&&n!==void 0?n:rD}};var yo=class extends Mr{constructor(t){super(),this._value=t}get value(){return this.getValue()}_subscribe(t){let e=super._subscribe(t);return!e.closed&&t.next(this._value),e}getValue(){let{hasError:t,thrownError:e,_value:n}=this;if(t)throw e;return this._throwIfClosed(),n}next(t){super.next(this._value=t)}};var pD={now(){return(pD.delegate||Date).now()},delegate:void 0};var aC=class extends wn{constructor(t,e){super()}schedule(t,e=0){return this}};var Kx={setInterval(r,t,...e){let{delegate:n}=Kx;return n?.setInterval?n.setInterval(r,t,...e):setInterval(r,t,...e)},clearInterval(r){let{delegate:t}=Kx;return(t?.clearInterval||clearInterval)(r)},delegate:void 0};var uC=class extends aC{constructor(t,e){super(t,e),this.scheduler=t,this.work=e,this.pending=!1}schedule(t,e=0){var n;if(this.closed)return this;this.state=t;let o=this.id,s=this.scheduler;return o!=null&&(this.id=this.recycleAsyncId(s,o,e)),this.pending=!0,this.delay=e,this.id=(n=this.id)!==null&&n!==void 0?n:this.requestAsyncId(s,this.id,e),this}requestAsyncId(t,e,n=0){return Kx.setInterval(t.flush.bind(t,this),n)}recycleAsyncId(t,e,n=0){if(n!=null&&this.delay===n&&this.pending===!1)return e;e!=null&&Kx.clearInterval(e)}execute(t,e){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;let n=this._execute(t,e);if(n)return n;this.pending===!1&&this.id!=null&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(t,e){let n=!1,o;try{this.work(t)}catch(s){n=!0,o=s||new Error("Scheduled action threw falsy error")}if(n)return this.unsubscribe(),o}unsubscribe(){if(!this.closed){let{id:t,scheduler:e}=this,{actions:n}=e;this.work=this.state=this.scheduler=null,this.pending=!1,Tf(n,this),t!=null&&(this.id=this.recycleAsyncId(e,t,null)),this.delay=null,super.unsubscribe()}}};var _m=class r{constructor(t,e=r.now){this.schedulerActionCtor=t,this.now=e}schedule(t,e=0,n){return new this.schedulerActionCtor(this,t).schedule(n,e)}};_m.now=pD.now;var lC=class extends _m{constructor(t,e=_m.now){super(t,e),this.actions=[],this._active=!1}flush(t){let{actions:e}=this;if(this._active){e.push(t);return}let n;this._active=!0;do if(n=t.execute(t.state,t.delay))break;while(t=e.shift());if(this._active=!1,n){for(;t=e.shift();)t.unsubscribe();throw n}}};var xae=new lC(uC),DL=xae;var zs=new hr(r=>r.complete());function cC(r){return r&&_t(r.schedule)}function AL(r){return r[r.length-1]}function pC(r){return _t(AL(r))?r.pop():void 0}function ap(r){return cC(AL(r))?r.pop():void 0}function OL(r,t,e,n){function o(s){return s instanceof e?s:new e(function(i){i(s)})}return new(e||(e=Promise))(function(s,i){function a(c){try{l(n.next(c))}catch(p){i(p)}}function u(c){try{l(n.throw(c))}catch(p){i(p)}}function l(c){c.done?s(c.value):o(c.value).then(a,u)}l((n=n.apply(r,t||[])).next())})}function RL(r){var t=typeof Symbol=="function"&&Symbol.iterator,e=t&&r[t],n=0;if(e)return e.call(r);if(r&&typeof r.length=="number")return{next:function(){return r&&n>=r.length&&(r=void 0),{value:r&&r[n++],done:!r}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}function kf(r){return this instanceof kf?(this.v=r,this):new kf(r)}function ML(r,t,e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var n=e.apply(r,t||[]),o,s=[];return o={},a("next"),a("throw"),a("return",i),o[Symbol.asyncIterator]=function(){return this},o;function i(f){return function(h){return Promise.resolve(h).then(f,p)}}function a(f,h){n[f]&&(o[f]=function(m){return new Promise(function(g,y){s.push([f,m,g,y])>1||u(f,m)})},h&&(o[f]=h(o[f])))}function u(f,h){try{l(n[f](h))}catch(m){d(s[0][3],m)}}function l(f){f.value instanceof kf?Promise.resolve(f.value.v).then(c,p):d(s[0][2],f)}function c(f){u("next",f)}function p(f){u("throw",f)}function d(f,h){f(h),s.shift(),s.length&&u(s[0][0],s[0][1])}}function FL(r){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var t=r[Symbol.asyncIterator],e;return t?t.call(r):(r=typeof RL=="function"?RL(r):r[Symbol.iterator](),e={},n("next"),n("throw"),n("return"),e[Symbol.asyncIterator]=function(){return this},e);function n(s){e[s]=r[s]&&function(i){return new Promise(function(a,u){i=r[s](i),o(a,u,i.done,i.value)})}}function o(s,i,a,u){Promise.resolve(u).then(function(l){s({value:l,done:a})},i)}}var dC=r=>r&&typeof r.length=="number"&&typeof r!="function";function fC(r){return _t(r?.then)}function hC(r){return _t(r[Sm])}function mC(r){return Symbol.asyncIterator&&_t(r?.[Symbol.asyncIterator])}function gC(r){return new TypeError(`You provided ${r!==null&&typeof r=="object"?"an invalid object":`'${r}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}function vae(){return typeof Symbol!="function"||!Symbol.iterator?"@@iterator":Symbol.iterator}var yC=vae();function xC(r){return _t(r?.[yC])}function vC(r){return ML(this,arguments,function*(){let e=r.getReader();try{for(;;){let{value:n,done:o}=yield kf(e.read());if(o)return yield kf(void 0);yield yield kf(n)}}finally{e.releaseLock()}})}function bC(r){return _t(r?.getReader)}function Fn(r){if(r instanceof hr)return r;if(r!=null){if(hC(r))return bae(r);if(dC(r))return wae(r);if(fC(r))return Cae(r);if(mC(r))return $L(r);if(xC(r))return Sae(r);if(bC(r))return Iae(r)}throw gC(r)}function bae(r){return new hr(t=>{let e=r[Sm]();if(_t(e.subscribe))return e.subscribe(t);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}function wae(r){return new hr(t=>{for(let e=0;e<r.length&&!t.closed;e++)t.next(r[e]);t.complete()})}function Cae(r){return new hr(t=>{r.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,oC)})}function Sae(r){return new hr(t=>{for(let e of r)if(t.next(e),t.closed)return;t.complete()})}function $L(r){return new hr(t=>{Tae(r,t).catch(e=>t.error(e))})}function Iae(r){return $L(vC(r))}function Tae(r,t){var e,n,o,s;return OL(this,void 0,void 0,function*(){try{for(e=FL(r);n=yield e.next(),!n.done;){let i=n.value;if(t.next(i),t.closed)return}}catch(i){o={error:i}}finally{try{n&&!n.done&&(s=e.return)&&(yield s.call(e))}finally{if(o)throw o.error}}t.complete()})}function fs(r,t,e,n=0,o=!1){let s=t.schedule(function(){e(),o?r.add(this.schedule(null,n)):this.unsubscribe()},n);if(r.add(s),!o)return s}function wC(r,t=0){return nr((e,n)=>{e.subscribe(Ht(n,o=>fs(n,r,()=>n.next(o),t),()=>fs(n,r,()=>n.complete(),t),o=>fs(n,r,()=>n.error(o),t)))})}function CC(r,t=0){return nr((e,n)=>{n.add(r.schedule(()=>e.subscribe(n),t))})}function PL(r,t){return Fn(r).pipe(CC(t),wC(t))}function LL(r,t){return Fn(r).pipe(CC(t),wC(t))}function zL(r,t){return new hr(e=>{let n=0;return t.schedule(function(){n===r.length?e.complete():(e.next(r[n++]),e.closed||this.schedule())})})}function BL(r,t){return new hr(e=>{let n;return fs(e,t,()=>{n=r[yC](),fs(e,t,()=>{let o,s;try{({value:o,done:s}=n.next())}catch(i){e.error(i);return}s?e.complete():e.next(o)},0,!0)}),()=>_t(n?.return)&&n.return()})}function SC(r,t){if(!r)throw new Error("Iterable cannot be null");return new hr(e=>{fs(e,t,()=>{let n=r[Symbol.asyncIterator]();fs(e,t,()=>{n.next().then(o=>{o.done?e.complete():e.next(o.value)})},0,!0)})})}function VL(r,t){return SC(vC(r),t)}function UL(r,t){if(r!=null){if(hC(r))return PL(r,t);if(dC(r))return zL(r,t);if(fC(r))return LL(r,t);if(mC(r))return SC(r,t);if(xC(r))return BL(r,t);if(bC(r))return VL(r,t)}throw gC(r)}function Xn(r,t){return t?UL(r,t):Fn(r)}function Nt(...r){let t=ap(r);return Xn(r,t)}function Em(r,t){let e=_t(r)?r:()=>r,n=o=>o.error(e());return new hr(t?o=>t.schedule(n,0,o):n)}function dD(r){return!!r&&(r instanceof hr||_t(r.lift)&&_t(r.subscribe))}var Gi=bm(r=>function(){r(this),this.name="EmptyError",this.message="no elements in sequence"});function fD(r,t){let e=typeof t=="object";return new Promise((n,o)=>{let s=new ip({next:i=>{n(i),s.unsubscribe()},error:o,complete:()=>{e?n(t.defaultValue):o(new Gi)}});r.subscribe(s)})}function GL(r){return r instanceof Date&&!isNaN(r)}function Jt(r,t){return nr((e,n)=>{let o=0;e.subscribe(Ht(n,s=>{n.next(r.call(t,s,o++))}))})}var{isArray:_ae}=Array;function Eae(r,t){return _ae(t)?r(...t):r(t)}function IC(r){return Jt(t=>Eae(r,t))}var{isArray:kae}=Array,{getPrototypeOf:Nae,prototype:Dae,keys:Aae}=Object;function TC(r){if(r.length===1){let t=r[0];if(kae(t))return{args:t,keys:null};if(Rae(t)){let e=Aae(t);return{args:e.map(n=>t[n]),keys:e}}}return{args:r,keys:null}}function Rae(r){return r&&typeof r=="object"&&Nae(r)===Dae}function _C(r,t){return r.reduce((e,n,o)=>(e[n]=t[o],e),{})}function EC(...r){let t=ap(r),e=pC(r),{args:n,keys:o}=TC(r);if(n.length===0)return Xn([],t);let s=new hr(Oae(n,t,o?i=>_C(o,i):Ls));return e?s.pipe(IC(e)):s}function Oae(r,t,e=Ls){return n=>{WL(t,()=>{let{length:o}=r,s=new Array(o),i=o,a=o;for(let u=0;u<o;u++)WL(t,()=>{let l=Xn(r[u],t),c=!1;l.subscribe(Ht(n,p=>{s[u]=p,c||(c=!0,a--),a||n.next(e(s.slice()))},()=>{--i||n.complete()}))},n)},n)}}function WL(r,t,e){r?fs(e,r,t):t()}function jL(r,t,e,n,o,s,i,a){let u=[],l=0,c=0,p=!1,d=()=>{p&&!u.length&&!l&&t.complete()},f=m=>l<n?h(m):u.push(m),h=m=>{s&&t.next(m),l++;let g=!1;Fn(e(m,c++)).subscribe(Ht(t,y=>{o?.(y),s?f(y):t.next(y)},()=>{g=!0},void 0,()=>{if(g)try{for(l--;u.length&&l<n;){let y=u.shift();i?fs(t,i,()=>h(y)):h(y)}d()}catch(y){t.error(y)}}))};return r.subscribe(Ht(t,f,()=>{p=!0,d()})),()=>{a?.()}}function Yn(r,t,e=1/0){return _t(t)?Yn((n,o)=>Jt((s,i)=>t(n,s,o,i))(Fn(r(n,o))),e):(typeof t=="number"&&(e=t),nr((n,o)=>jL(n,o,r,e)))}function hD(r=1/0){return Yn(Ls,r)}function HL(){return hD(1)}function km(...r){return HL()(Xn(r,ap(r)))}function kC(r){return new hr(t=>{Fn(r()).subscribe(t)})}function mD(...r){let t=pC(r),{args:e,keys:n}=TC(r),o=new hr(s=>{let{length:i}=e;if(!i){s.complete();return}let a=new Array(i),u=i,l=i;for(let c=0;c<i;c++){let p=!1;Fn(e[c]).subscribe(Ht(s,d=>{p||(p=!0,l--),a[c]=d},()=>u--,void 0,()=>{(!u||!p)&&(l||s.next(n?_C(n,a):a),s.complete())}))}});return t?o.pipe(IC(t)):o}function gD(r=0,t,e=DL){let n=-1;return t!=null&&(cC(t)?e=t:n=t),new hr(o=>{let s=GL(r)?+r-e.now():r;s<0&&(s=0);let i=0;return e.schedule(function(){o.closed||(o.next(i++),0<=n?this.schedule(void 0,n):o.complete())},s)})}function hs(r,t){return nr((e,n)=>{let o=0;e.subscribe(Ht(n,s=>r.call(t,s,o++)&&n.next(s)))})}function up(r){return nr((t,e)=>{let n=null,o=!1,s;n=t.subscribe(Ht(e,void 0,void 0,i=>{s=Fn(r(i,up(r)(t))),n?(n.unsubscribe(),n=null,s.subscribe(e)):o=!0})),o&&(n.unsubscribe(),n=null,s.subscribe(e))})}function qL(r,t,e,n,o){return(s,i)=>{let a=e,u=t,l=0;s.subscribe(Ht(i,c=>{let p=l++;u=a?r(u,c,p):(a=!0,c),n&&i.next(u)},o&&(()=>{a&&i.next(u),i.complete()})))}}function Nm(r,t){return _t(t)?Yn(r,t,1):Yn(r,1)}function lp(r){return nr((t,e)=>{let n=!1;t.subscribe(Ht(e,o=>{n=!0,e.next(o)},()=>{n||e.next(r),e.complete()}))})}function oi(r){return r<=0?()=>zs:nr((t,e)=>{let n=0;t.subscribe(Ht(e,o=>{++n<=r&&(e.next(o),r<=n&&e.complete())}))})}function yD(r){return Jt(()=>r)}function NC(r=Mae){return nr((t,e)=>{let n=!1;t.subscribe(Ht(e,o=>{n=!0,e.next(o)},()=>n?e.complete():e.error(r())))})}function Mae(){return new Gi}function Xx(r){return nr((t,e)=>{try{t.subscribe(e)}finally{e.add(r)}})}function Su(r,t){let e=arguments.length>=2;return n=>n.pipe(r?hs((o,s)=>r(o,s,n)):Ls,oi(1),e?lp(t):NC(()=>new Gi))}function Dm(r){return r<=0?()=>zs:nr((t,e)=>{let n=[];t.subscribe(Ht(e,o=>{n.push(o),r<n.length&&n.shift()},()=>{for(let o of n)e.next(o);e.complete()},void 0,()=>{n=null}))})}function xD(r,t){let e=arguments.length>=2;return n=>n.pipe(r?hs((o,s)=>r(o,s,n)):Ls,Dm(1),e?lp(t):NC(()=>new Gi))}function vD(r,t){return nr(qL(r,t,arguments.length>=2,!0))}function bD(...r){let t=ap(r);return nr((e,n)=>{(t?km(r,e,t):km(r,e)).subscribe(n)})}function Wi(r,t){return nr((e,n)=>{let o=null,s=0,i=!1,a=()=>i&&!o&&n.complete();e.subscribe(Ht(n,u=>{o?.unsubscribe();let l=0,c=s++;Fn(r(u,c)).subscribe(o=Ht(n,p=>n.next(t?t(u,p,c,l++):p),()=>{o=null,a()}))},()=>{i=!0,a()}))})}function wD(r){return nr((t,e)=>{Fn(r).subscribe(Ht(e,()=>e.complete(),qx)),!e.closed&&t.subscribe(e)})}function xo(r,t,e){let n=_t(r)||t||e?{next:r,error:t,complete:e}:r;return n?nr((o,s)=>{var i;(i=n.subscribe)===null||i===void 0||i.call(n);let a=!0;o.subscribe(Ht(s,u=>{var l;(l=n.next)===null||l===void 0||l.call(n,u),s.next(u)},()=>{var u;a=!1,(u=n.complete)===null||u===void 0||u.call(n),s.complete()},u=>{var l;a=!1,(l=n.error)===null||l===void 0||l.call(n,u),s.error(u)},()=>{var u,l;a&&((u=n.unsubscribe)===null||u===void 0||u.call(n)),(l=n.finalize)===null||l===void 0||l.call(n)}))}):Ls}var gt=class extends Error{constructor(t,e){super(vA(t,e)),this.code=t}};function vA(r,t){return`${`NG0${Math.abs(r)}`}${t?": "+t:""}`}function uv(r){return{toString:r}.toString()}var DC="__parameters__";function Fae(r){return function(...e){if(r){let n=r(...e);for(let o in n)this[o]=n[o]}}}function D3(r,t,e){return uv(()=>{let n=Fae(t);function o(...s){if(this instanceof o)return n.apply(this,s),this;let i=new o(...s);return a.annotation=i,a;function a(u,l,c){let p=u.hasOwnProperty(DC)?u[DC]:Object.defineProperty(u,DC,{value:[]})[DC];for(;p.length<=c;)p.push(null);return(p[c]=p[c]||[]).push(i),u}}return e&&(o.prototype=Object.create(e.prototype)),o.prototype.ngMetadataName=r,o.annotationCls=o,o})}function Lr(r){for(let t in r)if(r[t]===Lr)return t;throw Error("Could not find renamed property on target object.")}function ms(r){if(typeof r=="string")return r;if(Array.isArray(r))return"["+r.map(ms).join(", ")+"]";if(r==null)return""+r;if(r.overriddenName)return`${r.overriddenName}`;if(r.name)return`${r.name}`;let t=r.toString();if(t==null)return""+t;let e=t.indexOf(`
`);return e===-1?t:t.substring(0,e)}function KL(r,t){return r==null||r===""?t===null?"":t:t==null||t===""?r:r+" "+t}var $ae=Lr({__forward_ref__:Lr});function A3(r){return r.__forward_ref__=A3,r.toString=function(){return ms(this())},r}function ii(r){return R3(r)?r():r}function R3(r){return typeof r=="function"&&r.hasOwnProperty($ae)&&r.__forward_ref__===A3}function Qe(r){return{token:r.token,providedIn:r.providedIn||null,factory:r.factory,value:void 0}}function o0(r){return{providers:r.providers||[],imports:r.imports||[]}}function s0(r){return XL(r,M3)||XL(r,F3)}function O3(r){return s0(r)!==null}function XL(r,t){return r.hasOwnProperty(t)?r[t]:null}function Pae(r){let t=r&&(r[M3]||r[F3]);return t||null}function YL(r){return r&&(r.hasOwnProperty(ZL)||r.hasOwnProperty(Lae))?r[ZL]:null}var M3=Lr({\u0275prov:Lr}),ZL=Lr({\u0275inj:Lr}),F3=Lr({ngInjectableDef:Lr}),Lae=Lr({ngInjectorDef:Lr}),Ot=class{constructor(t,e){this._desc=t,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,typeof e=="number"?this.__NG_ELEMENT_ID__=e:e!==void 0&&(this.\u0275prov=Qe({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}};function $3(r){return r&&!!r.\u0275providers}var zae=Lr({\u0275cmp:Lr}),Bae=Lr({\u0275dir:Lr}),Vae=Lr({\u0275pipe:Lr}),Uae=Lr({\u0275mod:Lr}),LC=Lr({\u0275fac:Lr}),Zx=Lr({__NG_ELEMENT_ID__:Lr}),QL=Lr({__NG_ENV_ID__:Lr});function Qx(r){return typeof r=="string"?r:r==null?"":String(r)}function Gae(r){return typeof r=="function"?r.name||r.toString():typeof r=="object"&&r!=null&&typeof r.type=="function"?r.type.name||r.type.toString():Qx(r)}function Wae(r,t){let e=t?`. Dependency path: ${t.join(" > ")} > ${r}`:"";throw new gt(-200,r)}function bA(r,t){throw new gt(-201,!1)}var $t=function(r){return r[r.Default=0]="Default",r[r.Host=1]="Host",r[r.Self=2]="Self",r[r.SkipSelf=4]="SkipSelf",r[r.Optional=8]="Optional",r}($t||{}),DD;function P3(){return DD}function si(r){let t=DD;return DD=r,t}function L3(r,t,e){let n=s0(r);if(n&&n.providedIn=="root")return n.value===void 0?n.value=n.factory():n.value;if(e&$t.Optional)return null;if(t!==void 0)return t;bA(r,"Injector")}var jae={},Jx=jae,AD="__NG_DI_FLAG__",zC="ngTempTokenPath",Hae="ngTokenPath",qae=/\n/gm,Kae="\u0275",JL="__source",Mm;function Xae(){return Mm}function cp(r){let t=Mm;return Mm=r,t}function Yae(r,t=$t.Default){if(Mm===void 0)throw new gt(-203,!1);return Mm===null?L3(r,void 0,t):Mm.get(r,t&$t.Optional?null:void 0,t)}function St(r,t=$t.Default){return(P3()||Yae)(ii(r),t)}function We(r,t=$t.Default){return St(r,i0(t))}function i0(r){return typeof r>"u"||typeof r=="number"?r:0|(r.optional&&8)|(r.host&&1)|(r.self&&2)|(r.skipSelf&&4)}function RD(r){let t=[];for(let e=0;e<r.length;e++){let n=ii(r[e]);if(Array.isArray(n)){if(n.length===0)throw new gt(900,!1);let o,s=$t.Default;for(let i=0;i<n.length;i++){let a=n[i],u=Zae(a);typeof u=="number"?u===-1?o=a.token:s|=u:o=a}t.push(St(o,s))}else t.push(St(n))}return t}function z3(r,t){return r[AD]=t,r.prototype[AD]=t,r}function Zae(r){return r[AD]}function Qae(r,t,e,n){let o=r[zC];throw t[JL]&&o.unshift(t[JL]),r.message=Jae(`
`+r.message,o,e,n),r[Hae]=o,r[zC]=null,r}function Jae(r,t,e,n=null){r=r&&r.charAt(0)===`
`&&r.charAt(1)==Kae?r.slice(2):r;let o=ms(t);if(Array.isArray(t))o=t.map(ms).join(" -> ");else if(typeof t=="object"){let s=[];for(let i in t)if(t.hasOwnProperty(i)){let a=t[i];s.push(i+":"+(typeof a=="string"?JSON.stringify(a):ms(a)))}o=`{${s.join(", ")}}`}return`${e}${n?"("+n+")":""}[${o}]: ${r.replace(qae,`
  `)}`}var wA=z3(D3("Optional"),8);var B3=z3(D3("SkipSelf"),4);function $m(r,t){let e=r.hasOwnProperty(LC);return e?r[LC]:null}function eue(r,t,e){if(r.length!==t.length)return!1;for(let n=0;n<r.length;n++){let o=r[n],s=t[n];if(e&&(o=e(o),s=e(s)),s!==o)return!1}return!0}function tue(r){return r.flat(Number.POSITIVE_INFINITY)}function CA(r,t){r.forEach(e=>Array.isArray(e)?CA(e,t):t(e))}function V3(r,t,e){t>=r.length?r.push(e):r.splice(t,0,e)}function BC(r,t){return t>=r.length-1?r.pop():r.splice(t,1)[0]}var ev={},Iu=[],Pm=new Ot(""),U3=new Ot("",-1),G3=new Ot(""),VC=class{get(t,e=Jx){if(e===Jx){let n=new Error(`NullInjectorError: No provider for ${ms(t)}!`);throw n.name="NullInjectorError",n}return e}},W3=function(r){return r[r.OnPush=0]="OnPush",r[r.Default=1]="Default",r}(W3||{}),Eu=function(r){return r[r.Emulated=0]="Emulated",r[r.None=2]="None",r[r.ShadowDom=3]="ShadowDom",r}(Eu||{}),fp=function(r){return r[r.None=0]="None",r[r.SignalBased=1]="SignalBased",r[r.HasDecoratorInputTransform=2]="HasDecoratorInputTransform",r}(fp||{});function rue(r,t,e){let n=r.length;for(;;){let o=r.indexOf(t,e);if(o===-1)return o;if(o===0||r.charCodeAt(o-1)<=32){let s=t.length;if(o+s===n||r.charCodeAt(o+s)<=32)return o}e=o+1}}function OD(r,t,e){let n=0;for(;n<e.length;){let o=e[n];if(typeof o=="number"){if(o!==0)break;n++;let s=e[n++],i=e[n++],a=e[n++];r.setAttribute(t,i,a,s)}else{let s=o,i=e[++n];oue(s)?r.setProperty(t,s,i):r.setAttribute(t,s,i),n++}}return n}function nue(r){return r===3||r===4||r===6}function oue(r){return r.charCodeAt(0)===64}function SA(r,t){if(!(t===null||t.length===0))if(r===null||r.length===0)r=t.slice();else{let e=-1;for(let n=0;n<t.length;n++){let o=t[n];typeof o=="number"?e=o:e===0||(e===-1||e===2?e3(r,e,o,null,t[++n]):e3(r,e,o,null,null))}}return r}function e3(r,t,e,n,o){let s=0,i=r.length;if(t===-1)i=-1;else for(;s<r.length;){let a=r[s++];if(typeof a=="number"){if(a===t){i=-1;break}else if(a>t){i=s-1;break}}}for(;s<r.length;){let a=r[s];if(typeof a=="number")break;if(a===e){if(n===null){o!==null&&(r[s+1]=o);return}else if(n===r[s+1]){r[s+2]=o;return}}s++,n!==null&&s++,o!==null&&s++}i!==-1&&(r.splice(i,0,t),s=i+1),r.splice(s++,0,e),n!==null&&r.splice(s++,0,n),o!==null&&r.splice(s++,0,o)}var j3="ng-template";function sue(r,t,e,n){let o=0;if(n){for(;o<t.length&&typeof t[o]=="string";o+=2)if(t[o]==="class"&&rue(t[o+1].toLowerCase(),e,0)!==-1)return!0}else if(IA(r))return!1;if(o=t.indexOf(1,o),o>-1){let s;for(;++o<t.length&&typeof(s=t[o])=="string";)if(s.toLowerCase()===e)return!0}return!1}function IA(r){return r.type===4&&r.value!==j3}function iue(r,t,e){let n=r.type===4&&!e?j3:r.value;return t===n}function aue(r,t,e){let n=4,o=r.attrs,s=o!==null?cue(o):0,i=!1;for(let a=0;a<t.length;a++){let u=t[a];if(typeof u=="number"){if(!i&&!ji(n)&&!ji(u))return!1;if(i&&ji(u))continue;i=!1,n=u|n&1;continue}if(!i)if(n&4){if(n=2|n&1,u!==""&&!iue(r,u,e)||u===""&&t.length===1){if(ji(n))return!1;i=!0}}else if(n&8){if(o===null||!sue(r,o,u,e)){if(ji(n))return!1;i=!0}}else{let l=t[++a],c=uue(u,o,IA(r),e);if(c===-1){if(ji(n))return!1;i=!0;continue}if(l!==""){let p;if(c>s?p="":p=o[c+1].toLowerCase(),n&2&&l!==p){if(ji(n))return!1;i=!0}}}}return ji(n)||i}function ji(r){return(r&1)===0}function uue(r,t,e,n){if(t===null)return-1;let o=0;if(n||!e){let s=!1;for(;o<t.length;){let i=t[o];if(i===r)return o;if(i===3||i===6)s=!0;else if(i===1||i===2){let a=t[++o];for(;typeof a=="string";)a=t[++o];continue}else{if(i===4)break;if(i===0){o+=4;continue}}o+=s?1:2}return-1}else return pue(t,r)}function lue(r,t,e=!1){for(let n=0;n<t.length;n++)if(aue(r,t[n],e))return!0;return!1}function cue(r){for(let t=0;t<r.length;t++){let e=r[t];if(nue(e))return t}return r.length}function pue(r,t){let e=r.indexOf(4);if(e>-1)for(e++;e<r.length;){let n=r[e];if(typeof n=="number")return-1;if(n===t)return e;e++}return-1}function t3(r,t){return r?":not("+t.trim()+")":t}function due(r){let t=r[0],e=1,n=2,o="",s=!1;for(;e<r.length;){let i=r[e];if(typeof i=="string")if(n&2){let a=r[++e];o+="["+i+(a.length>0?'="'+a+'"':"")+"]"}else n&8?o+="."+i:n&4&&(o+=" "+i);else o!==""&&!ji(i)&&(t+=t3(s,o),o=""),n=i,s=s||!ji(n);e++}return o!==""&&(t+=t3(s,o)),t}function fue(r){return r.map(due).join(",")}function hue(r){let t=[],e=[],n=1,o=2;for(;n<r.length;){let s=r[n];if(typeof s=="string")o===2?s!==""&&t.push(s,r[++n]):o===8&&e.push(s);else{if(!ji(o))break;o=s}n++}return{attrs:t,classes:e}}function or(r){return uv(()=>{let t=Y3(r),e=mn(et({},t),{decls:r.decls,vars:r.vars,template:r.template,consts:r.consts||null,ngContentSelectors:r.ngContentSelectors,onPush:r.changeDetection===W3.OnPush,directiveDefs:null,pipeDefs:null,dependencies:t.standalone&&r.dependencies||null,getStandaloneInjector:null,signals:r.signals??!1,data:r.data||{},encapsulation:r.encapsulation||Eu.Emulated,styles:r.styles||Iu,_:null,schemas:r.schemas||null,tView:null,id:""});Z3(e);let n=r.dependencies;return e.directiveDefs=n3(n,!1),e.pipeDefs=n3(n,!0),e.id=yue(e),e})}function mue(r){return Af(r)||H3(r)}function gue(r){return r!==null}function a0(r){return uv(()=>({type:r.type,bootstrap:r.bootstrap||Iu,declarations:r.declarations||Iu,imports:r.imports||Iu,exports:r.exports||Iu,transitiveCompileScopes:null,schemas:r.schemas||null,id:r.id||null}))}function r3(r,t){if(r==null)return ev;let e={};for(let n in r)if(r.hasOwnProperty(n)){let o=r[n],s,i,a=fp.None;Array.isArray(o)?(a=o[0],s=o[1],i=o[2]??s):(s=o,i=o),t?(e[s]=a!==fp.None?[n,a]:n,t[s]=i):e[s]=n}return e}function Wm(r){return uv(()=>{let t=Y3(r);return Z3(t),t})}function Af(r){return r[zae]||null}function H3(r){return r[Bae]||null}function q3(r){return r[Vae]||null}function K3(r){let t=Af(r)||H3(r)||q3(r);return t!==null?t.standalone:!1}function X3(r,t){let e=r[Uae]||null;if(!e&&t===!0)throw new Error(`Type ${ms(r)} does not have '\u0275mod' property.`);return e}function Y3(r){let t={};return{type:r.type,providersResolver:null,factory:null,hostBindings:r.hostBindings||null,hostVars:r.hostVars||0,hostAttrs:r.hostAttrs||null,contentQueries:r.contentQueries||null,declaredInputs:t,inputTransforms:null,inputConfig:r.inputs||ev,exportAs:r.exportAs||null,standalone:r.standalone===!0,signals:r.signals===!0,selectors:r.selectors||Iu,viewQuery:r.viewQuery||null,features:r.features||null,setInput:null,findHostDirectiveDefs:null,hostDirectives:null,inputs:r3(r.inputs,t),outputs:r3(r.outputs),debugInfo:null}}function Z3(r){r.features?.forEach(t=>t(r))}function n3(r,t){if(!r)return null;let e=t?q3:mue;return()=>(typeof r=="function"?r():r).map(n=>e(n)).filter(gue)}function yue(r){let t=0,e=[r.selectors,r.ngContentSelectors,r.hostVars,r.hostAttrs,r.consts,r.vars,r.decls,r.encapsulation,r.standalone,r.signals,r.exportAs,JSON.stringify(r.inputs),JSON.stringify(r.outputs),Object.getOwnPropertyNames(r.type.prototype),!!r.contentQueries,!!r.viewQuery].join("|");for(let o of e)t=Math.imul(31,t)+o.charCodeAt(0)<<0;return t+=2147483648,"c"+t}function u0(r){return{\u0275providers:r}}function xue(...r){return{\u0275providers:Q3(!0,r),\u0275fromNgModule:!0}}function Q3(r,...t){let e=[],n=new Set,o,s=i=>{e.push(i)};return CA(t,i=>{let a=i;MD(a,s,[],n)&&(o||=[],o.push(a))}),o!==void 0&&J3(o,s),e}function J3(r,t){for(let e=0;e<r.length;e++){let{ngModule:n,providers:o}=r[e];TA(o,s=>{t(s,n)})}}function MD(r,t,e,n){if(r=ii(r),!r)return!1;let o=null,s=YL(r),i=!s&&Af(r);if(!s&&!i){let u=r.ngModule;if(s=YL(u),s)o=u;else return!1}else{if(i&&!i.standalone)return!1;o=r}let a=n.has(o);if(i){if(a)return!1;if(n.add(o),i.dependencies){let u=typeof i.dependencies=="function"?i.dependencies():i.dependencies;for(let l of u)MD(l,t,e,n)}}else if(s){if(s.imports!=null&&!a){n.add(o);let l;try{CA(s.imports,c=>{MD(c,t,e,n)&&(l||=[],l.push(c))})}finally{}l!==void 0&&J3(l,t)}if(!a){let l=$m(o)||(()=>new o);t({provide:o,useFactory:l,deps:Iu},o),t({provide:G3,useValue:o,multi:!0},o),t({provide:Pm,useValue:()=>St(o),multi:!0},o)}let u=s.providers;if(u!=null&&!a){let l=r;TA(u,c=>{t(c,l)})}}else return!1;return o!==r&&r.providers!==void 0}function TA(r,t){for(let e of r)$3(e)&&(e=e.\u0275providers),Array.isArray(e)?TA(e,t):t(e)}var vue=Lr({provide:String,useValue:Lr});function ez(r){return r!==null&&typeof r=="object"&&vue in r}function bue(r){return!!(r&&r.useExisting)}function wue(r){return!!(r&&r.useFactory)}function FD(r){return typeof r=="function"}var l0=new Ot(""),RC={},Cue={},CD;function _A(){return CD===void 0&&(CD=new VC),CD}var ui=class{},tv=class extends ui{get destroyed(){return this._destroyed}constructor(t,e,n,o){super(),this.parent=e,this.source=n,this.scopes=o,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,PD(t,i=>this.processProvider(i)),this.records.set(U3,Am(void 0,this)),o.has("environment")&&this.records.set(ui,Am(void 0,this));let s=this.records.get(l0);s!=null&&typeof s.value=="string"&&this.scopes.add(s.value),this.injectorDefTypes=new Set(this.get(G3,Iu,$t.Self))}destroy(){this.assertNotDestroyed(),this._destroyed=!0;let t=br(null);try{for(let n of this._ngOnDestroyHooks)n.ngOnDestroy();let e=this._onDestroyHooks;this._onDestroyHooks=[];for(let n of e)n()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),br(t)}}onDestroy(t){return this.assertNotDestroyed(),this._onDestroyHooks.push(t),()=>this.removeOnDestroy(t)}runInContext(t){this.assertNotDestroyed();let e=cp(this),n=si(void 0),o;try{return t()}finally{cp(e),si(n)}}get(t,e=Jx,n=$t.Default){if(this.assertNotDestroyed(),t.hasOwnProperty(QL))return t[QL](this);n=i0(n);let o,s=cp(this),i=si(void 0);try{if(!(n&$t.SkipSelf)){let u=this.records.get(t);if(u===void 0){let l=kue(t)&&s0(t);l&&this.injectableDefInScope(l)?u=Am($D(t),RC):u=null,this.records.set(t,u)}if(u!=null)return this.hydrate(t,u)}let a=n&$t.Self?_A():this.parent;return e=n&$t.Optional&&e===Jx?null:e,a.get(t,e)}catch(a){if(a.name==="NullInjectorError"){if((a[zC]=a[zC]||[]).unshift(ms(t)),s)throw a;return Qae(a,t,"R3InjectorError",this.source)}else throw a}finally{si(i),cp(s)}}resolveInjectorInitializers(){let t=br(null),e=cp(this),n=si(void 0),o;try{let s=this.get(Pm,Iu,$t.Self);for(let i of s)i()}finally{cp(e),si(n),br(t)}}toString(){let t=[],e=this.records;for(let n of e.keys())t.push(ms(n));return`R3Injector[${t.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new gt(205,!1)}processProvider(t){t=ii(t);let e=FD(t)?t:ii(t&&t.provide),n=Iue(t);if(!FD(t)&&t.multi===!0){let o=this.records.get(e);o||(o=Am(void 0,RC,!0),o.factory=()=>RD(o.multi),this.records.set(e,o)),e=t,o.multi.push(t)}this.records.set(e,n)}hydrate(t,e){let n=br(null);try{return e.value===RC&&(e.value=Cue,e.value=e.factory()),typeof e.value=="object"&&e.value&&Eue(e.value)&&this._ngOnDestroyHooks.add(e.value),e.value}finally{br(n)}}injectableDefInScope(t){if(!t.providedIn)return!1;let e=ii(t.providedIn);return typeof e=="string"?e==="any"||this.scopes.has(e):this.injectorDefTypes.has(e)}removeOnDestroy(t){let e=this._onDestroyHooks.indexOf(t);e!==-1&&this._onDestroyHooks.splice(e,1)}};function $D(r){let t=s0(r),e=t!==null?t.factory:$m(r);if(e!==null)return e;if(r instanceof Ot)throw new gt(204,!1);if(r instanceof Function)return Sue(r);throw new gt(204,!1)}function Sue(r){if(r.length>0)throw new gt(204,!1);let e=Pae(r);return e!==null?()=>e.factory(r):()=>new r}function Iue(r){if(ez(r))return Am(void 0,r.useValue);{let t=Tue(r);return Am(t,RC)}}function Tue(r,t,e){let n;if(FD(r)){let o=ii(r);return $m(o)||$D(o)}else if(ez(r))n=()=>ii(r.useValue);else if(wue(r))n=()=>r.useFactory(...RD(r.deps||[]));else if(bue(r))n=()=>St(ii(r.useExisting));else{let o=ii(r&&(r.useClass||r.provide));if(_ue(r))n=()=>new o(...RD(r.deps));else return $m(o)||$D(o)}return n}function Am(r,t,e=!1){return{factory:r,value:t,multi:e?[]:void 0}}function _ue(r){return!!r.deps}function Eue(r){return r!==null&&typeof r=="object"&&typeof r.ngOnDestroy=="function"}function kue(r){return typeof r=="function"||typeof r=="object"&&r instanceof Ot}function PD(r,t){for(let e of r)Array.isArray(e)?PD(e,t):e&&$3(e)?PD(e.\u0275providers,t):t(e)}function oc(r,t){r instanceof tv&&r.assertNotDestroyed();let e,n=cp(r),o=si(void 0);try{return t()}finally{cp(n),si(o)}}function Nue(){return P3()!==void 0||Xae()!=null}function Due(r){return typeof r=="function"}var sc=0,Pt=1,vt=2,No=3,Hi=4,Ki=5,UC=6,GC=7,qi=8,Lm=9,rc=10,Ho=11,rv=12,o3=13,jm=14,ku=15,Rf=16,Rm=17,nc=18,c0=19,tz=20,pp=21,SD=22,ai=23,hp=25,rz=1;var Of=7,WC=8,zm=9,Bs=10,jC=function(r){return r[r.None=0]="None",r[r.HasTransplantedViews=2]="HasTransplantedViews",r}(jC||{});function dp(r){return Array.isArray(r)&&typeof r[rz]=="object"}function ic(r){return Array.isArray(r)&&r[rz]===!0}function nz(r){return(r.flags&4)!==0}function p0(r){return r.componentOffset>-1}function EA(r){return(r.flags&1)===1}function lv(r){return!!r.template}function LD(r){return(r[vt]&512)!==0}var zD=class{constructor(t,e,n){this.previousValue=t,this.currentValue=e,this.firstChange=n}isFirstChange(){return this.firstChange}};function oz(r,t,e,n){t!==null?t.applyValueToInputSignal(t,n):r[e]=n}function yp(){return sz}function sz(r){return r.type.prototype.ngOnChanges&&(r.setInput=Rue),Aue}yp.ngInherit=!0;function Aue(){let r=az(this),t=r?.current;if(t){let e=r.previous;if(e===ev)r.previous=t;else for(let n in t)e[n]=t[n];r.current=null,this.ngOnChanges(t)}}function Rue(r,t,e,n,o){let s=this.declaredInputs[n],i=az(r)||Oue(r,{previous:ev,current:null}),a=i.current||(i.current={}),u=i.previous,l=u[s];a[s]=new zD(l&&l.currentValue,e,u===ev),oz(r,t,o,e)}var iz="__ngSimpleChanges__";function az(r){return r[iz]||null}function Oue(r,t){return r[iz]=t}var s3=null;var Tu=function(r,t,e){s3?.(r,t,e)},Mue="svg",Fue="math";function Nu(r){for(;Array.isArray(r);)r=r[sc];return r}function $ue(r,t){return Nu(t[r])}function Xi(r,t){return Nu(t[r.index])}function uz(r,t){return r.data[t]}function xp(r,t){let e=t[r];return dp(e)?e:e[sc]}function Pue(r){return(r[vt]&4)===4}function kA(r){return(r[vt]&128)===128}function Lue(r){return ic(r[No])}function HC(r,t){return t==null?null:r[t]}function lz(r){r[Rm]=0}function cz(r){r[vt]&1024||(r[vt]|=1024,kA(r)&&d0(r))}function zue(r,t){for(;r>0;)t=t[jm],r--;return t}function nv(r){return!!(r[vt]&9216||r[ai]?.dirty)}function BD(r){r[rc].changeDetectionScheduler?.notify(7),r[vt]&64&&(r[vt]|=1024),nv(r)&&d0(r)}function d0(r){r[rc].changeDetectionScheduler?.notify(0);let t=Mf(r);for(;t!==null&&!(t[vt]&8192||(t[vt]|=8192,!kA(t)));)t=Mf(t)}function pz(r,t){if((r[vt]&256)===256)throw new gt(911,!1);r[pp]===null&&(r[pp]=[]),r[pp].push(t)}function Bue(r,t){if(r[pp]===null)return;let e=r[pp].indexOf(t);e!==-1&&r[pp].splice(e,1)}function Mf(r){let t=r[No];return ic(t)?t[No]:t}var zt={lFrame:wz(null),bindingsEnabled:!0,skipHydrationRootTNode:null};var dz=!1;function Vue(){return zt.lFrame.elementDepthCount}function Uue(){zt.lFrame.elementDepthCount++}function Gue(){zt.lFrame.elementDepthCount--}function fz(){return zt.bindingsEnabled}function Wue(){return zt.skipHydrationRootTNode!==null}function jue(r){return zt.skipHydrationRootTNode===r}function Hue(){zt.skipHydrationRootTNode=null}function fn(){return zt.lFrame.lView}function ac(){return zt.lFrame.tView}function Bf(r){return zt.lFrame.contextLView=r,r[qi]}function Vf(r){return zt.lFrame.contextLView=null,r}function li(){let r=hz();for(;r!==null&&r.type===64;)r=r.parent;return r}function hz(){return zt.lFrame.currentTNode}function que(){let r=zt.lFrame,t=r.currentTNode;return r.isParent?t:t.parent}function cv(r,t){let e=zt.lFrame;e.currentTNode=r,e.isParent=t}function mz(){return zt.lFrame.isParent}function Kue(){zt.lFrame.isParent=!1}function gz(){return dz}function i3(r){dz=r}function Xue(){let r=zt.lFrame,t=r.bindingRootIndex;return t===-1&&(t=r.bindingRootIndex=r.tView.bindingStartIndex),t}function Yue(){return zt.lFrame.bindingIndex}function Zue(r){return zt.lFrame.bindingIndex=r}function yz(){return zt.lFrame.bindingIndex++}function Que(r){let t=zt.lFrame,e=t.bindingIndex;return t.bindingIndex=t.bindingIndex+r,e}function Jue(){return zt.lFrame.inI18n}function ele(r,t){let e=zt.lFrame;e.bindingIndex=e.bindingRootIndex=r,VD(t)}function tle(){return zt.lFrame.currentDirectiveIndex}function VD(r){zt.lFrame.currentDirectiveIndex=r}function xz(){return zt.lFrame.currentQueryIndex}function NA(r){zt.lFrame.currentQueryIndex=r}function rle(r){let t=r[Pt];return t.type===2?t.declTNode:t.type===1?r[Ki]:null}function vz(r,t,e){if(e&$t.SkipSelf){let o=t,s=r;for(;o=o.parent,o===null&&!(e&$t.Host);)if(o=rle(s),o===null||(s=s[jm],o.type&10))break;if(o===null)return!1;t=o,r=s}let n=zt.lFrame=bz();return n.currentTNode=t,n.lView=r,!0}function DA(r){let t=bz(),e=r[Pt];zt.lFrame=t,t.currentTNode=e.firstChild,t.lView=r,t.tView=e,t.contextLView=r,t.bindingIndex=e.bindingStartIndex,t.inI18n=!1}function bz(){let r=zt.lFrame,t=r===null?null:r.child;return t===null?wz(r):t}function wz(r){let t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:r,child:null,inI18n:!1};return r!==null&&(r.child=t),t}function Cz(){let r=zt.lFrame;return zt.lFrame=r.parent,r.currentTNode=null,r.lView=null,r}var Sz=Cz;function AA(){let r=Cz();r.isParent=!0,r.tView=null,r.selectedIndex=-1,r.contextLView=null,r.elementDepthCount=0,r.currentDirectiveIndex=-1,r.currentNamespace=null,r.bindingRootIndex=-1,r.bindingIndex=-1,r.currentQueryIndex=0}function nle(r){return(zt.lFrame.contextLView=zue(r,zt.lFrame.contextLView))[qi]}function f0(){return zt.lFrame.selectedIndex}function Ff(r){zt.lFrame.selectedIndex=r}function ole(){let r=zt.lFrame;return uz(r.tView,r.selectedIndex)}function sle(){return zt.lFrame.currentNamespace}var Iz=!0;function RA(){return Iz}function OA(r){Iz=r}function ile(r,t,e){let{ngOnChanges:n,ngOnInit:o,ngDoCheck:s}=t.type.prototype;if(n){let i=sz(t);(e.preOrderHooks??=[]).push(r,i),(e.preOrderCheckHooks??=[]).push(r,i)}o&&(e.preOrderHooks??=[]).push(0-r,o),s&&((e.preOrderHooks??=[]).push(r,s),(e.preOrderCheckHooks??=[]).push(r,s))}function MA(r,t){for(let e=t.directiveStart,n=t.directiveEnd;e<n;e++){let s=r.data[e].type.prototype,{ngAfterContentInit:i,ngAfterContentChecked:a,ngAfterViewInit:u,ngAfterViewChecked:l,ngOnDestroy:c}=s;i&&(r.contentHooks??=[]).push(-e,i),a&&((r.contentHooks??=[]).push(e,a),(r.contentCheckHooks??=[]).push(e,a)),u&&(r.viewHooks??=[]).push(-e,u),l&&((r.viewHooks??=[]).push(e,l),(r.viewCheckHooks??=[]).push(e,l)),c!=null&&(r.destroyHooks??=[]).push(e,c)}}function OC(r,t,e){Tz(r,t,3,e)}function MC(r,t,e,n){(r[vt]&3)===e&&Tz(r,t,e,n)}function ID(r,t){let e=r[vt];(e&3)===t&&(e&=16383,e+=1,r[vt]=e)}function Tz(r,t,e,n){let o=n!==void 0?r[Rm]&65535:0,s=n??-1,i=t.length-1,a=0;for(let u=o;u<i;u++)if(typeof t[u+1]=="number"){if(a=t[u],n!=null&&a>=n)break}else t[u]<0&&(r[Rm]+=65536),(a<s||s==-1)&&(ale(r,e,t,u),r[Rm]=(r[Rm]&4294901760)+u+2),u++}function a3(r,t){Tu(4,r,t);let e=br(null);try{t.call(r)}finally{br(e),Tu(5,r,t)}}function ale(r,t,e,n){let o=e[n]<0,s=e[n+1],i=o?-e[n]:e[n],a=r[i];o?r[vt]>>14<r[Rm]>>16&&(r[vt]&3)===t&&(r[vt]+=16384,a3(a,s)):a3(a,s)}var Fm=-1,ov=class{constructor(t,e,n){this.factory=t,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=n}};function ule(r){return r instanceof ov}function lle(r){return(r.flags&8)!==0}function cle(r){return(r.flags&16)!==0}var TD={},UD=class{constructor(t,e){this.injector=t,this.parentInjector=e}get(t,e,n){n=i0(n);let o=this.injector.get(t,TD,n);return o!==TD||e===TD?o:this.parentInjector.get(t,e,n)}};function _z(r){return r!==Fm}function qC(r){return r&32767}function ple(r){return r>>16}function KC(r,t){let e=ple(r),n=t;for(;e>0;)n=n[jm],e--;return n}var GD=!0;function u3(r){let t=GD;return GD=r,t}var dle=256,Ez=dle-1,kz=5,fle=0,_u={};function hle(r,t,e){let n;typeof e=="string"?n=e.charCodeAt(0)||0:e.hasOwnProperty(Zx)&&(n=e[Zx]),n==null&&(n=e[Zx]=fle++);let o=n&Ez,s=1<<o;t.data[r+(o>>kz)]|=s}function Nz(r,t){let e=Dz(r,t);if(e!==-1)return e;let n=t[Pt];n.firstCreatePass&&(r.injectorIndex=t.length,_D(n.data,r),_D(t,null),_D(n.blueprint,null));let o=FA(r,t),s=r.injectorIndex;if(_z(o)){let i=qC(o),a=KC(o,t),u=a[Pt].data;for(let l=0;l<8;l++)t[s+l]=a[i+l]|u[i+l]}return t[s+8]=o,s}function _D(r,t){r.push(0,0,0,0,0,0,0,0,t)}function Dz(r,t){return r.injectorIndex===-1||r.parent&&r.parent.injectorIndex===r.injectorIndex||t[r.injectorIndex+8]===null?-1:r.injectorIndex}function FA(r,t){if(r.parent&&r.parent.injectorIndex!==-1)return r.parent.injectorIndex;let e=0,n=null,o=t;for(;o!==null;){if(n=Fz(o),n===null)return Fm;if(e++,o=o[jm],n.injectorIndex!==-1)return n.injectorIndex|e<<16}return Fm}function mle(r,t,e){hle(r,t,e)}function Az(r,t,e){if(e&$t.Optional||r!==void 0)return r;bA(t,"NodeInjector")}function Rz(r,t,e,n){if(e&$t.Optional&&n===void 0&&(n=null),!(e&($t.Self|$t.Host))){let o=r[Lm],s=si(void 0);try{return o?o.get(t,n,e&$t.Optional):L3(t,n,e&$t.Optional)}finally{si(s)}}return Az(n,t,e)}function Oz(r,t,e,n=$t.Default,o){if(r!==null){if(t[vt]&2048&&!(n&$t.Self)){let i=vle(r,t,e,n,_u);if(i!==_u)return i}let s=Mz(r,t,e,n,_u);if(s!==_u)return s}return Rz(t,e,n,o)}function Mz(r,t,e,n,o){let s=yle(e);if(typeof s=="function"){if(!vz(t,r,n))return n&$t.Host?Az(o,e,n):Rz(t,e,n,o);try{let i;if(i=s(n),i==null&&!(n&$t.Optional))bA(e);else return i}finally{Sz()}}else if(typeof s=="number"){let i=null,a=Dz(r,t),u=Fm,l=n&$t.Host?t[ku][Ki]:null;for((a===-1||n&$t.SkipSelf)&&(u=a===-1?FA(r,t):t[a+8],u===Fm||!c3(n,!1)?a=-1:(i=t[Pt],a=qC(u),t=KC(u,t)));a!==-1;){let c=t[Pt];if(l3(s,a,c.data)){let p=gle(a,t,e,i,n,l);if(p!==_u)return p}u=t[a+8],u!==Fm&&c3(n,t[Pt].data[a+8]===l)&&l3(s,a,t)?(i=c,a=qC(u),t=KC(u,t)):a=-1}}return o}function gle(r,t,e,n,o,s){let i=t[Pt],a=i.data[r+8],u=n==null?p0(a)&&GD:n!=i&&(a.type&3)!==0,l=o&$t.Host&&s===a,c=FC(a,i,e,u,l);return c!==null?Bm(t,i,c,a):_u}function FC(r,t,e,n,o){let s=r.providerIndexes,i=t.data,a=s&1048575,u=r.directiveStart,l=r.directiveEnd,c=s>>20,p=n?a:a+c,d=o?a+c:l;for(let f=p;f<d;f++){let h=i[f];if(f<u&&e===h||f>=u&&h.type===e)return f}if(o){let f=i[u];if(f&&lv(f)&&f.type===e)return u}return null}function Bm(r,t,e,n){let o=r[e],s=t.data;if(ule(o)){let i=o;i.resolving&&Wae(Gae(s[e]));let a=u3(i.canSeeViewProviders);i.resolving=!0;let u,l=i.injectImpl?si(i.injectImpl):null,c=vz(r,n,$t.Default);try{o=r[e]=i.factory(void 0,s,r,n),t.firstCreatePass&&e>=n.directiveStart&&ile(e,s[e],t)}finally{l!==null&&si(l),u3(a),i.resolving=!1,Sz()}}return o}function yle(r){if(typeof r=="string")return r.charCodeAt(0)||0;let t=r.hasOwnProperty(Zx)?r[Zx]:void 0;return typeof t=="number"?t>=0?t&Ez:xle:t}function l3(r,t,e){let n=1<<r;return!!(e[t+(r>>kz)]&n)}function c3(r,t){return!(r&$t.Self)&&!(r&$t.Host&&t)}var Df=class{constructor(t,e){this._tNode=t,this._lView=e}get(t,e,n){return Oz(this._tNode,this._lView,t,i0(n),e)}};function xle(){return new Df(li(),fn())}function $A(r){return uv(()=>{let t=r.prototype.constructor,e=t[LC]||WD(t),n=Object.prototype,o=Object.getPrototypeOf(r.prototype).constructor;for(;o&&o!==n;){let s=o[LC]||WD(o);if(s&&s!==e)return s;o=Object.getPrototypeOf(o)}return s=>new s})}function WD(r){return R3(r)?()=>{let t=WD(ii(r));return t&&t()}:$m(r)}function vle(r,t,e,n,o){let s=r,i=t;for(;s!==null&&i!==null&&i[vt]&2048&&!(i[vt]&512);){let a=Mz(s,i,e,n|$t.Self,_u);if(a!==_u)return a;let u=s.parent;if(!u){let l=i[tz];if(l){let c=l.get(e,_u,n);if(c!==_u)return c}u=Fz(i),i=i[jm]}s=u}return o}function Fz(r){let t=r[Pt],e=t.type;return e===2?t.declTNode:e===1?r[Ki]:null}function p3(r,t=null,e=null,n){let o=$z(r,t,e,n);return o.resolveInjectorInitializers(),o}function $z(r,t=null,e=null,n,o=new Set){let s=[e||Iu,xue(r)];return n=n||(typeof r=="object"?void 0:ms(r)),new tv(s,t||_A(),n||null,o)}var Nf=class Nf{static create(t,e){if(Array.isArray(t))return p3({name:""},e,t,"");{let n=t.name??"";return p3({name:n},t.parent,t.providers,n)}}};Nf.THROW_IF_NOT_FOUND=Jx,Nf.NULL=new VC,Nf.\u0275prov=Qe({token:Nf,providedIn:"any",factory:()=>St(U3)}),Nf.__NG_ELEMENT_ID__=-1;var $f=Nf;var ble=new Ot("");ble.__NG_ELEMENT_ID__=r=>{let t=li();if(t===null)throw new gt(204,!1);if(t.type&2)return t.value;if(r&$t.Optional)return null;throw new gt(204,!1)};var wle="ngOriginalError";function ED(r){return r[wle]}var Pz=(()=>{let t=class t{};t.__NG_ELEMENT_ID__=Cle,t.__NG_ENV_ID__=n=>n;let r=t;return r})(),jD=class extends Pz{constructor(t){super(),this._lView=t}onDestroy(t){return pz(this._lView,t),()=>Bue(this._lView,t)}};function Cle(){return new jD(fn())}var Hm=(()=>{let t=class t{constructor(){this.taskId=0,this.pendingTasks=new Set,this.hasPendingTasks=new yo(!1)}get _hasPendingTasks(){return this.hasPendingTasks.value}add(){this._hasPendingTasks||this.hasPendingTasks.next(!0);let n=this.taskId++;return this.pendingTasks.add(n),n}remove(n){this.pendingTasks.delete(n),this.pendingTasks.size===0&&this._hasPendingTasks&&this.hasPendingTasks.next(!1)}ngOnDestroy(){this.pendingTasks.clear(),this._hasPendingTasks&&this.hasPendingTasks.next(!1)}};t.\u0275prov=Qe({token:t,providedIn:"root",factory:()=>new t});let r=t;return r})();var HD=class extends Mr{constructor(t=!1){super(),this.destroyRef=void 0,this.pendingTasks=void 0,this.__isAsync=t,Nue()&&(this.destroyRef=We(Pz,{optional:!0})??void 0,this.pendingTasks=We(Hm,{optional:!0})??void 0)}emit(t){let e=br(null);try{super.next(t)}finally{br(e)}}subscribe(t,e,n){let o=t,s=e||(()=>null),i=n;if(t&&typeof t=="object"){let u=t;o=u.next?.bind(u),s=u.error?.bind(u),i=u.complete?.bind(u)}this.__isAsync&&(s=this.wrapInTimeout(s),o&&(o=this.wrapInTimeout(o)),i&&(i=this.wrapInTimeout(i)));let a=super.subscribe({next:o,error:s,complete:i});return t instanceof wn&&t.add(a),a}wrapInTimeout(t){return e=>{let n=this.pendingTasks?.add();setTimeout(()=>{t(e),n!==void 0&&this.pendingTasks?.remove(n)})}}},dn=HD;function XC(...r){}function Lz(r){let t,e;function n(){r=XC;try{e!==void 0&&typeof cancelAnimationFrame=="function"&&cancelAnimationFrame(e),t!==void 0&&clearTimeout(t)}catch{}}return t=setTimeout(()=>{r(),n()}),typeof requestAnimationFrame=="function"&&(e=requestAnimationFrame(()=>{r(),n()})),()=>n()}function d3(r){return queueMicrotask(()=>r()),()=>{r=XC}}var PA="isAngularZone",YC=PA+"_ID",Sle=0,Zn=class r{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:n=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new dn(!1),this.onMicrotaskEmpty=new dn(!1),this.onStable=new dn(!1),this.onError=new dn(!1),typeof Zone>"u")throw new gt(908,!1);Zone.assertZonePatched();let o=this;o._nesting=0,o._outer=o._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(o._inner=o._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(o._inner=o._inner.fork(Zone.longStackTraceZoneSpec)),o.shouldCoalesceEventChangeDetection=!n&&e,o.shouldCoalesceRunChangeDetection=n,o.callbackScheduled=!1,_le(o)}static isInAngularZone(){return typeof Zone<"u"&&Zone.current.get(PA)===!0}static assertInAngularZone(){if(!r.isInAngularZone())throw new gt(909,!1)}static assertNotInAngularZone(){if(r.isInAngularZone())throw new gt(909,!1)}run(t,e,n){return this._inner.run(t,e,n)}runTask(t,e,n,o){let s=this._inner,i=s.scheduleEventTask("NgZoneEvent: "+o,t,Ile,XC,XC);try{return s.runTask(i,e,n)}finally{s.cancelTask(i)}}runGuarded(t,e,n){return this._inner.runGuarded(t,e,n)}runOutsideAngular(t){return this._outer.run(t)}},Ile={};function LA(r){if(r._nesting==0&&!r.hasPendingMicrotasks&&!r.isStable)try{r._nesting++,r.onMicrotaskEmpty.emit(null)}finally{if(r._nesting--,!r.hasPendingMicrotasks)try{r.runOutsideAngular(()=>r.onStable.emit(null))}finally{r.isStable=!0}}}function Tle(r){r.isCheckStableRunning||r.callbackScheduled||(r.callbackScheduled=!0,Zone.root.run(()=>{Lz(()=>{r.callbackScheduled=!1,qD(r),r.isCheckStableRunning=!0,LA(r),r.isCheckStableRunning=!1})}),qD(r))}function _le(r){let t=()=>{Tle(r)},e=Sle++;r._inner=r._inner.fork({name:"angular",properties:{[PA]:!0,[YC]:e,[YC+e]:!0},onInvokeTask:(n,o,s,i,a,u)=>{if(Ele(u))return n.invokeTask(s,i,a,u);try{return f3(r),n.invokeTask(s,i,a,u)}finally{(r.shouldCoalesceEventChangeDetection&&i.type==="eventTask"||r.shouldCoalesceRunChangeDetection)&&t(),h3(r)}},onInvoke:(n,o,s,i,a,u,l)=>{try{return f3(r),n.invoke(s,i,a,u,l)}finally{r.shouldCoalesceRunChangeDetection&&!r.callbackScheduled&&!kle(u)&&t(),h3(r)}},onHasTask:(n,o,s,i)=>{n.hasTask(s,i),o===s&&(i.change=="microTask"?(r._hasPendingMicrotasks=i.microTask,qD(r),LA(r)):i.change=="macroTask"&&(r.hasPendingMacrotasks=i.macroTask))},onHandleError:(n,o,s,i)=>(n.handleError(s,i),r.runOutsideAngular(()=>r.onError.emit(i)),!1)})}function qD(r){r._hasPendingMicrotasks||(r.shouldCoalesceEventChangeDetection||r.shouldCoalesceRunChangeDetection)&&r.callbackScheduled===!0?r.hasPendingMicrotasks=!0:r.hasPendingMicrotasks=!1}function f3(r){r._nesting++,r.isStable&&(r.isStable=!1,r.onUnstable.emit(null))}function h3(r){r._nesting--,LA(r)}var KD=class{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new dn,this.onMicrotaskEmpty=new dn,this.onStable=new dn,this.onError=new dn}run(t,e,n){return t.apply(e,n)}runGuarded(t,e,n){return t.apply(e,n)}runOutsideAngular(t){return t()}runTask(t,e,n,o){return t.apply(e,n)}};function Ele(r){return zz(r,"__ignore_ng_zone__")}function kle(r){return zz(r,"__scheduler_tick__")}function zz(r,t){return!Array.isArray(r)||r.length!==1?!1:r[0]?.data?.[t]===!0}var mp=class{constructor(){this._console=console}handleError(t){let e=this._findOriginalError(t);this._console.error("ERROR",t),e&&this._console.error("ORIGINAL ERROR",e)}_findOriginalError(t){let e=t&&ED(t);for(;e&&ED(e);)e=ED(e);return e||null}},Nle=new Ot("",{providedIn:"root",factory:()=>{let r=We(Zn),t=We(mp);return e=>r.runOutsideAngular(()=>t.handleError(e))}});function Dle(){return qm(li(),fn())}function qm(r,t){return new vp(Xi(r,t))}var vp=(()=>{let t=class t{constructor(n){this.nativeElement=n}};t.__NG_ELEMENT_ID__=Dle;let r=t;return r})();function Ale(r){return r instanceof vp?r.nativeElement:r}function Rle(){return this._results[Symbol.iterator]()}var XD=class r{get changes(){return this._changes??=new dn}constructor(t=!1){this._emitDistinctChangesOnly=t,this.dirty=!0,this._onDirty=void 0,this._results=[],this._changesDetected=!1,this._changes=void 0,this.length=0,this.first=void 0,this.last=void 0;let e=r.prototype;e[Symbol.iterator]||(e[Symbol.iterator]=Rle)}get(t){return this._results[t]}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,e){return this._results.reduce(t,e)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t,e){this.dirty=!1;let n=tue(t);(this._changesDetected=!eue(this._results,n,e))&&(this._results=n,this.length=n.length,this.last=n[this.length-1],this.first=n[0])}notifyOnChanges(){this._changes!==void 0&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}onDirty(t){this._onDirty=t}setDirty(){this.dirty=!0,this._onDirty?.()}destroy(){this._changes!==void 0&&(this._changes.complete(),this._changes.unsubscribe())}};function Bz(r){return(r.flags&128)===128}var Vz=new Map,Ole=0;function Mle(){return Ole++}function Fle(r){Vz.set(r[c0],r)}function $le(r){Vz.delete(r[c0])}var m3="__ngContext__";function Pf(r,t){dp(t)?(r[m3]=t[c0],Fle(t)):r[m3]=t}function Uz(r){return Wz(r[rv])}function Gz(r){return Wz(r[Hi])}function Wz(r){for(;r!==null&&!ic(r);)r=r[Hi];return r}var YD;function jz(r){YD=r}function Ple(){if(YD!==void 0)return YD;if(typeof document<"u")return document;throw new gt(210,!1)}var zA=new Ot("",{providedIn:"root",factory:()=>Lle}),Lle="ng",BA=new Ot(""),Km=new Ot("",{providedIn:"platform",factory:()=>"unknown"});var VA=new Ot("",{providedIn:"root",factory:()=>Ple().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce")||null});var zle="h",Ble="b";var Vle=()=>null;function UA(r,t,e=!1){return Vle(r,t,e)}var Hz=!1,Ule=new Ot("",{providedIn:"root",factory:()=>Hz});function qz(r){return r.ownerDocument}function Kz(r){return r instanceof Function?r():r}var Uf=function(r){return r[r.Important=1]="Important",r[r.DashCase=2]="DashCase",r}(Uf||{}),Gle;function GA(r,t){return Gle(r,t)}function Om(r,t,e,n,o){if(n!=null){let s,i=!1;ic(n)?s=n:dp(n)&&(i=!0,n=n[sc]);let a=Nu(n);r===0&&e!==null?o==null?Jz(t,e,a):ZC(t,e,a,o||null,!0):r===1&&e!==null?ZC(t,e,a,o||null,!0):r===2?oce(t,a,i):r===3&&t.destroyNode(a),s!=null&&ice(t,r,s,e,o)}}function Wle(r,t){return r.createText(t)}function jle(r,t,e){r.setValue(t,e)}function Xz(r,t,e){return r.createElement(t,e)}function Hle(r,t){Yz(r,t),t[sc]=null,t[Ki]=null}function qle(r,t,e,n,o,s){n[sc]=o,n[Ki]=t,h0(r,n,e,1,o,s)}function Yz(r,t){t[rc].changeDetectionScheduler?.notify(8),h0(r,t,t[Ho],2,null,null)}function Kle(r){let t=r[rv];if(!t)return kD(r[Pt],r);for(;t;){let e=null;if(dp(t))e=t[rv];else{let n=t[Bs];n&&(e=n)}if(!e){for(;t&&!t[Hi]&&t!==r;)dp(t)&&kD(t[Pt],t),t=t[No];t===null&&(t=r),dp(t)&&kD(t[Pt],t),e=t&&t[Hi]}t=e}}function Xle(r,t,e,n){let o=Bs+n,s=e.length;n>0&&(e[o-1][Hi]=t),n<s-Bs?(t[Hi]=e[o],V3(e,Bs+n,t)):(e.push(t),t[Hi]=null),t[No]=e;let i=t[Rf];i!==null&&e!==i&&Zz(i,t);let a=t[nc];a!==null&&a.insertView(r),BD(t),t[vt]|=128}function Zz(r,t){let e=r[zm],n=t[No];if(dp(n))r[vt]|=jC.HasTransplantedViews;else{let o=n[No][ku];t[ku]!==o&&(r[vt]|=jC.HasTransplantedViews)}e===null?r[zm]=[t]:e.push(t)}function WA(r,t){let e=r[zm],n=e.indexOf(t);e.splice(n,1)}function ZD(r,t){if(r.length<=Bs)return;let e=Bs+t,n=r[e];if(n){let o=n[Rf];o!==null&&o!==r&&WA(o,n),t>0&&(r[e-1][Hi]=n[Hi]);let s=BC(r,Bs+t);Hle(n[Pt],n);let i=s[nc];i!==null&&i.detachView(s[Pt]),n[No]=null,n[Hi]=null,n[vt]&=-129}return n}function Qz(r,t){if(!(t[vt]&256)){let e=t[Ho];e.destroyNode&&h0(r,t,e,3,null,null),Kle(t)}}function kD(r,t){if(t[vt]&256)return;let e=br(null);try{t[vt]&=-129,t[vt]|=256,t[ai]&&QN(t[ai]),Zle(r,t),Yle(r,t),t[Pt].type===1&&t[Ho].destroy();let n=t[Rf];if(n!==null&&ic(t[No])){n!==t[No]&&WA(n,t);let o=t[nc];o!==null&&o.detachView(r)}$le(t)}finally{br(e)}}function Yle(r,t){let e=r.cleanup,n=t[GC];if(e!==null)for(let s=0;s<e.length-1;s+=2)if(typeof e[s]=="string"){let i=e[s+3];i>=0?n[i]():n[-i].unsubscribe(),s+=2}else{let i=n[e[s+1]];e[s].call(i)}n!==null&&(t[GC]=null);let o=t[pp];if(o!==null){t[pp]=null;for(let s=0;s<o.length;s++){let i=o[s];i()}}}function Zle(r,t){let e;if(r!=null&&(e=r.destroyHooks)!=null)for(let n=0;n<e.length;n+=2){let o=t[e[n]];if(!(o instanceof ov)){let s=e[n+1];if(Array.isArray(s))for(let i=0;i<s.length;i+=2){let a=o[s[i]],u=s[i+1];Tu(4,a,u);try{u.call(a)}finally{Tu(5,a,u)}}else{Tu(4,o,s);try{s.call(o)}finally{Tu(5,o,s)}}}}}function Qle(r,t,e){return Jle(r,t.parent,e)}function Jle(r,t,e){let n=t;for(;n!==null&&n.type&168;)t=n,n=t.parent;if(n===null)return e[sc];{let{componentOffset:o}=n;if(o>-1){let{encapsulation:s}=r.data[n.directiveStart+o];if(s===Eu.None||s===Eu.Emulated)return null}return Xi(n,e)}}function ZC(r,t,e,n,o){r.insertBefore(t,e,n,o)}function Jz(r,t,e){r.appendChild(t,e)}function g3(r,t,e,n,o){n!==null?ZC(r,t,e,n,o):Jz(r,t,e)}function eB(r,t){return r.parentNode(t)}function ece(r,t){return r.nextSibling(t)}function tce(r,t,e){return nce(r,t,e)}function rce(r,t,e){return r.type&40?Xi(r,e):null}var nce=rce,y3;function jA(r,t,e,n){let o=Qle(r,n,t),s=t[Ho],i=n.parent||t[Ki],a=tce(i,n,t);if(o!=null)if(Array.isArray(e))for(let u=0;u<e.length;u++)g3(s,o,e[u],a,!1);else g3(s,o,e,a,!1);y3!==void 0&&y3(s,n,t,e,o)}function Yx(r,t){if(t!==null){let e=t.type;if(e&3)return Xi(t,r);if(e&4)return QD(-1,r[t.index]);if(e&8){let n=t.child;if(n!==null)return Yx(r,n);{let o=r[t.index];return ic(o)?QD(-1,o):Nu(o)}}else{if(e&128)return Yx(r,t.next);if(e&32)return GA(t,r)()||Nu(r[t.index]);{let n=tB(r,t);if(n!==null){if(Array.isArray(n))return n[0];let o=Mf(r[ku]);return Yx(o,n)}else return Yx(r,t.next)}}}return null}function tB(r,t){if(t!==null){let n=r[ku][Ki],o=t.projection;return n.projection[o]}return null}function QD(r,t){let e=Bs+r+1;if(e<t.length){let n=t[e],o=n[Pt].firstChild;if(o!==null)return Yx(n,o)}return t[Of]}function oce(r,t,e){r.removeChild(null,t,e)}function HA(r,t,e,n,o,s,i){for(;e!=null;){if(e.type===128){e=e.next;continue}let a=n[e.index],u=e.type;if(i&&t===0&&(a&&Pf(Nu(a),n),e.flags|=2),(e.flags&32)!==32)if(u&8)HA(r,t,e.child,n,o,s,!1),Om(t,r,o,a,s);else if(u&32){let l=GA(e,n),c;for(;c=l();)Om(t,r,o,c,s);Om(t,r,o,a,s)}else u&16?sce(r,t,n,e,o,s):Om(t,r,o,a,s);e=i?e.projectionNext:e.next}}function h0(r,t,e,n,o,s){HA(e,n,r.firstChild,t,o,s,!1)}function sce(r,t,e,n,o,s){let i=e[ku],u=i[Ki].projection[n.projection];if(Array.isArray(u))for(let l=0;l<u.length;l++){let c=u[l];Om(t,r,o,c,s)}else{let l=u,c=i[No];Bz(n)&&(l.flags|=128),HA(r,t,l,c,o,s,!0)}}function ice(r,t,e,n,o){let s=e[Of],i=Nu(e);s!==i&&Om(t,r,n,s,o);for(let a=Bs;a<e.length;a++){let u=e[a];h0(u[Pt],u,r,t,n,s)}}function ace(r,t,e){r.setAttribute(t,"style",e)}function rB(r,t,e){e===""?r.removeAttribute(t,"class"):r.setAttribute(t,"class",e)}function nB(r,t,e){let{mergedAttrs:n,classes:o,styles:s}=e;n!==null&&OD(r,t,n),o!==null&&rB(r,t,o),s!==null&&ace(r,t,s)}var Gf={};function qt(r=1){oB(ac(),fn(),f0()+r,!1)}function oB(r,t,e,n){if(!n)if((t[vt]&3)===3){let s=r.preOrderCheckHooks;s!==null&&OC(t,s,e)}else{let s=r.preOrderHooks;s!==null&&MC(t,s,0,e)}Ff(e)}function it(r,t=$t.Default){let e=fn();if(e===null)return St(r,t);let n=li();return Oz(n,e,ii(r),t)}function sB(r,t,e,n,o,s){let i=br(null);try{let a=null;o&fp.SignalBased&&(a=t[n][vL]),a!==null&&a.transformFn!==void 0&&(s=a.transformFn(s)),o&fp.HasDecoratorInputTransform&&(s=r.inputTransforms[n].call(t,s)),r.setInput!==null?r.setInput(t,a,s,e,n):oz(t,a,n,s)}finally{br(i)}}function uce(r,t){let e=r.hostBindingOpCodes;if(e!==null)try{for(let n=0;n<e.length;n++){let o=e[n];if(o<0)Ff(~o);else{let s=o,i=e[++n],a=e[++n];ele(i,s);let u=t[s];a(2,u)}}}finally{Ff(-1)}}function m0(r,t,e,n,o,s,i,a,u,l,c){let p=t.blueprint.slice();return p[sc]=o,p[vt]=n|4|128|8|64,(l!==null||r&&r[vt]&2048)&&(p[vt]|=2048),lz(p),p[No]=p[jm]=r,p[qi]=e,p[rc]=i||r&&r[rc],p[Ho]=a||r&&r[Ho],p[Lm]=u||r&&r[Lm]||null,p[Ki]=s,p[c0]=Mle(),p[UC]=c,p[tz]=l,p[ku]=t.type==2?r[ku]:p,p}function g0(r,t,e,n,o){let s=r.data[t];if(s===null)s=lce(r,t,e,n,o),Jue()&&(s.flags|=32);else if(s.type&64){s.type=e,s.value=n,s.attrs=o;let i=que();s.injectorIndex=i===null?-1:i.injectorIndex}return cv(s,!0),s}function lce(r,t,e,n,o){let s=hz(),i=mz(),a=i?s:s&&s.parent,u=r.data[t]=mce(r,a,e,t,n,o);return r.firstChild===null&&(r.firstChild=u),s!==null&&(i?s.child==null&&u.parent!==null&&(s.child=u):s.next===null&&(s.next=u,u.prev=s)),u}function iB(r,t,e,n){if(e===0)return-1;let o=t.length;for(let s=0;s<e;s++)t.push(n),r.blueprint.push(n),r.data.push(null);return o}function aB(r,t,e,n,o){let s=f0(),i=n&2;try{Ff(-1),i&&t.length>hp&&oB(r,t,hp,!1),Tu(i?2:0,o),e(n,o)}finally{Ff(s),Tu(i?3:1,o)}}function uB(r,t,e){if(nz(t)){let n=br(null);try{let o=t.directiveStart,s=t.directiveEnd;for(let i=o;i<s;i++){let a=r.data[i];if(a.contentQueries){let u=e[i];a.contentQueries(1,u,i)}}}finally{br(n)}}}function lB(r,t,e){fz()&&(Cce(r,t,e,Xi(e,t)),(e.flags&64)===64&&hB(r,t,e))}function cB(r,t,e=Xi){let n=t.localNames;if(n!==null){let o=t.index+1;for(let s=0;s<n.length;s+=2){let i=n[s+1],a=i===-1?e(t,r):r[i];r[o++]=a}}}function pB(r){let t=r.tView;return t===null||t.incompleteFirstPass?r.tView=qA(1,null,r.template,r.decls,r.vars,r.directiveDefs,r.pipeDefs,r.viewQuery,r.schemas,r.consts,r.id):t}function qA(r,t,e,n,o,s,i,a,u,l,c){let p=hp+n,d=p+o,f=cce(p,d),h=typeof l=="function"?l():l;return f[Pt]={type:r,blueprint:f,template:e,queries:null,viewQuery:a,declTNode:t,data:f.slice().fill(null,p),bindingStartIndex:p,expandoStartIndex:d,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:typeof s=="function"?s():s,pipeRegistry:typeof i=="function"?i():i,firstChild:null,schemas:u,consts:h,incompleteFirstPass:!1,ssrId:c}}function cce(r,t){let e=[];for(let n=0;n<t;n++)e.push(n<r?null:Gf);return e}function pce(r,t,e,n){let s=n.get(Ule,Hz)||e===Eu.ShadowDom,i=r.selectRootElement(t,s);return dce(i),i}function dce(r){fce(r)}var fce=()=>null;function hce(r,t,e,n){let o=yB(t);o.push(e),r.firstCreatePass&&xB(r).push(n,o.length-1)}function mce(r,t,e,n,o,s){let i=t?t.injectorIndex:-1,a=0;return Wue()&&(a|=128),{type:e,index:n,insertBeforeIndex:null,injectorIndex:i,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:a,providerIndexes:0,value:o,attrs:s,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tView:null,next:null,prev:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}function x3(r,t,e,n,o){for(let s in t){if(!t.hasOwnProperty(s))continue;let i=t[s];if(i===void 0)continue;n??={};let a,u=fp.None;Array.isArray(i)?(a=i[0],u=i[1]):a=i;let l=s;if(o!==null){if(!o.hasOwnProperty(s))continue;l=o[s]}r===0?v3(n,e,l,a,u):v3(n,e,l,a)}return n}function v3(r,t,e,n,o){let s;r.hasOwnProperty(e)?(s=r[e]).push(t,n):s=r[e]=[t,n],o!==void 0&&s.push(o)}function gce(r,t,e){let n=t.directiveStart,o=t.directiveEnd,s=r.data,i=t.attrs,a=[],u=null,l=null;for(let c=n;c<o;c++){let p=s[c],d=e?e.get(p):null,f=d?d.inputs:null,h=d?d.outputs:null;u=x3(0,p.inputs,c,u,f),l=x3(1,p.outputs,c,l,h);let m=u!==null&&i!==null&&!IA(t)?Ace(u,c,i):null;a.push(m)}u!==null&&(u.hasOwnProperty("class")&&(t.flags|=8),u.hasOwnProperty("style")&&(t.flags|=16)),t.initialInputs=a,t.inputs=u,t.outputs=l}function yce(r){return r==="class"?"className":r==="for"?"htmlFor":r==="formaction"?"formAction":r==="innerHtml"?"innerHTML":r==="readonly"?"readOnly":r==="tabindex"?"tabIndex":r}function xce(r,t,e,n,o,s,i,a){let u=Xi(t,e),l=t.inputs,c;!a&&l!=null&&(c=l[n])?(KA(r,e,c,n,o),p0(t)&&vce(e,t.index)):t.type&3?(n=yce(n),o=i!=null?i(o,t.value||"",n):o,s.setProperty(u,n,o)):t.type&12}function vce(r,t){let e=xp(t,r);e[vt]&16||(e[vt]|=64)}function dB(r,t,e,n){if(fz()){let o=n===null?null:{"":-1},s=Ice(r,e),i,a;s===null?i=a=null:[i,a]=s,i!==null&&fB(r,t,e,i,o,a),o&&Tce(e,n,o)}e.mergedAttrs=SA(e.mergedAttrs,e.attrs)}function fB(r,t,e,n,o,s){for(let l=0;l<n.length;l++)mle(Nz(e,t),r,n[l].type);Ece(e,r.data.length,n.length);for(let l=0;l<n.length;l++){let c=n[l];c.providersResolver&&c.providersResolver(c)}let i=!1,a=!1,u=iB(r,t,n.length,null);for(let l=0;l<n.length;l++){let c=n[l];e.mergedAttrs=SA(e.mergedAttrs,c.hostAttrs),kce(r,e,t,u,c),_ce(u,c,o),c.contentQueries!==null&&(e.flags|=4),(c.hostBindings!==null||c.hostAttrs!==null||c.hostVars!==0)&&(e.flags|=64);let p=c.type.prototype;!i&&(p.ngOnChanges||p.ngOnInit||p.ngDoCheck)&&((r.preOrderHooks??=[]).push(e.index),i=!0),!a&&(p.ngOnChanges||p.ngDoCheck)&&((r.preOrderCheckHooks??=[]).push(e.index),a=!0),u++}gce(r,e,s)}function bce(r,t,e,n,o){let s=o.hostBindings;if(s){let i=r.hostBindingOpCodes;i===null&&(i=r.hostBindingOpCodes=[]);let a=~t.index;wce(i)!=a&&i.push(a),i.push(e,n,s)}}function wce(r){let t=r.length;for(;t>0;){let e=r[--t];if(typeof e=="number"&&e<0)return e}return 0}function Cce(r,t,e,n){let o=e.directiveStart,s=e.directiveEnd;p0(e)&&Nce(t,e,r.data[o+e.componentOffset]),r.firstCreatePass||Nz(e,t),Pf(n,t);let i=e.initialInputs;for(let a=o;a<s;a++){let u=r.data[a],l=Bm(t,r,a,e);if(Pf(l,t),i!==null&&Dce(t,a-o,l,u,e,i),lv(u)){let c=xp(e.index,t);c[qi]=Bm(t,r,a,e)}}}function hB(r,t,e){let n=e.directiveStart,o=e.directiveEnd,s=e.index,i=tle();try{Ff(s);for(let a=n;a<o;a++){let u=r.data[a],l=t[a];VD(a),(u.hostBindings!==null||u.hostVars!==0||u.hostAttrs!==null)&&Sce(u,l)}}finally{Ff(-1),VD(i)}}function Sce(r,t){r.hostBindings!==null&&r.hostBindings(1,t)}function Ice(r,t){let e=r.directiveRegistry,n=null,o=null;if(e)for(let s=0;s<e.length;s++){let i=e[s];if(lue(t,i.selectors,!1))if(n||(n=[]),lv(i))if(i.findHostDirectiveDefs!==null){let a=[];o=o||new Map,i.findHostDirectiveDefs(i,a,o),n.unshift(...a,i);let u=a.length;JD(r,t,u)}else n.unshift(i),JD(r,t,0);else o=o||new Map,i.findHostDirectiveDefs?.(i,n,o),n.push(i)}return n===null?null:[n,o]}function JD(r,t,e){t.componentOffset=e,(r.components??=[]).push(t.index)}function Tce(r,t,e){if(t){let n=r.localNames=[];for(let o=0;o<t.length;o+=2){let s=e[t[o+1]];if(s==null)throw new gt(-301,!1);n.push(t[o],s)}}}function _ce(r,t,e){if(e){if(t.exportAs)for(let n=0;n<t.exportAs.length;n++)e[t.exportAs[n]]=r;lv(t)&&(e[""]=r)}}function Ece(r,t,e){r.flags|=1,r.directiveStart=t,r.directiveEnd=t+e,r.providerIndexes=t}function kce(r,t,e,n,o){r.data[n]=o;let s=o.factory||(o.factory=$m(o.type,!0)),i=new ov(s,lv(o),it);r.blueprint[n]=i,e[n]=i,bce(r,t,n,iB(r,e,o.hostVars,Gf),o)}function Nce(r,t,e){let n=Xi(t,r),o=pB(e),s=r[rc].rendererFactory,i=16;e.signals?i=4096:e.onPush&&(i=64);let a=y0(r,m0(r,o,null,i,n,t,null,s.createRenderer(n,e),null,null,null));r[t.index]=a}function Dce(r,t,e,n,o,s){let i=s[t];if(i!==null)for(let a=0;a<i.length;){let u=i[a++],l=i[a++],c=i[a++],p=i[a++];sB(n,e,u,l,c,p)}}function Ace(r,t,e){let n=null,o=0;for(;o<e.length;){let s=e[o];if(s===0){o+=4;continue}else if(s===5){o+=2;continue}if(typeof s=="number")break;if(r.hasOwnProperty(s)){n===null&&(n=[]);let i=r[s];for(let a=0;a<i.length;a+=3)if(i[a]===t){n.push(s,i[a+1],i[a+2],e[o+1]);break}}o+=2}return n}function mB(r,t,e,n){return[r,!0,0,t,null,n,null,e,null,null]}function gB(r,t){let e=r.contentQueries;if(e!==null){let n=br(null);try{for(let o=0;o<e.length;o+=2){let s=e[o],i=e[o+1];if(i!==-1){let a=r.data[i];NA(s),a.contentQueries(2,t[i],i)}}}finally{br(n)}}}function y0(r,t){return r[rv]?r[o3][Hi]=t:r[rv]=t,r[o3]=t,t}function eA(r,t,e){NA(0);let n=br(null);try{t(r,e)}finally{br(n)}}function yB(r){return r[GC]??=[]}function xB(r){return r.cleanup??=[]}function vB(r,t){let e=r[Lm],n=e?e.get(mp,null):null;n&&n.handleError(t)}function KA(r,t,e,n,o){for(let s=0;s<e.length;){let i=e[s++],a=e[s++],u=e[s++],l=t[i],c=r.data[i];sB(c,l,n,a,u,o)}}function bB(r,t,e){let n=$ue(t,r);jle(r[Ho],n,e)}function Rce(r,t){let e=xp(t,r),n=e[Pt];Oce(n,e);let o=e[sc];o!==null&&e[UC]===null&&(e[UC]=UA(o,e[Lm])),XA(n,e,e[qi])}function Oce(r,t){for(let e=t.length;e<r.blueprint.length;e++)t.push(r.blueprint[e])}function XA(r,t,e){DA(t);try{let n=r.viewQuery;n!==null&&eA(1,n,e);let o=r.template;o!==null&&aB(r,t,o,1,e),r.firstCreatePass&&(r.firstCreatePass=!1),t[nc]?.finishViewCreation(r),r.staticContentQueries&&gB(r,t),r.staticViewQueries&&eA(2,r.viewQuery,e);let s=r.components;s!==null&&Mce(t,s)}catch(n){throw r.firstCreatePass&&(r.incompleteFirstPass=!0,r.firstCreatePass=!1),n}finally{t[vt]&=-5,AA()}}function Mce(r,t){for(let e=0;e<t.length;e++)Rce(r,t[e])}function Fce(r,t,e,n){let o=br(null);try{let s=t.tView,a=r[vt]&4096?4096:16,u=m0(r,s,e,a,null,t,null,null,n?.injector??null,n?.embeddedViewInjector??null,n?.dehydratedView??null),l=r[t.index];u[Rf]=l;let c=r[nc];return c!==null&&(u[nc]=c.createEmbeddedView(s)),XA(s,u,e),u}finally{br(o)}}function b3(r,t){return!t||t.firstChild===null||Bz(r)}function $ce(r,t,e,n=!0){let o=t[Pt];if(Xle(o,t,r,e),n){let i=QD(e,r),a=t[Ho],u=eB(a,r[Of]);u!==null&&qle(o,r[Ki],a,t,u,i)}let s=t[UC];s!==null&&s.firstChild!==null&&(s.firstChild=null)}function QC(r,t,e,n,o=!1){for(;e!==null;){if(e.type===128){e=o?e.projectionNext:e.next;continue}let s=t[e.index];s!==null&&n.push(Nu(s)),ic(s)&&Pce(s,n);let i=e.type;if(i&8)QC(r,t,e.child,n);else if(i&32){let a=GA(e,t),u;for(;u=a();)n.push(u)}else if(i&16){let a=tB(t,e);if(Array.isArray(a))n.push(...a);else{let u=Mf(t[ku]);QC(u[Pt],u,a,n,!0)}}e=o?e.projectionNext:e.next}return n}function Pce(r,t){for(let e=Bs;e<r.length;e++){let n=r[e],o=n[Pt].firstChild;o!==null&&QC(n[Pt],n,o,t)}r[Of]!==r[sc]&&t.push(r[Of])}var wB=[];function Lce(r){return r[ai]??zce(r)}function zce(r){let t=wB.pop()??Object.create(Vce);return t.lView=r,t}function Bce(r){r.lView[ai]!==r&&(r.lView=null,wB.push(r))}var Vce=mn(et({},XN),{consumerIsAlwaysLive:!0,consumerMarkedDirty:r=>{d0(r.lView)},consumerOnSignalRead(){this.lView[ai]=this}});function Uce(r){let t=r[ai]??Object.create(Gce);return t.lView=r,t}var Gce=mn(et({},XN),{consumerIsAlwaysLive:!0,consumerMarkedDirty:r=>{let t=Mf(r.lView);for(;t&&!CB(t[Pt]);)t=Mf(t);t&&cz(t)},consumerOnSignalRead(){this.lView[ai]=this}});function CB(r){return r.type!==2}var Wce=100;function SB(r,t=!0,e=0){let n=r[rc],o=n.rendererFactory,s=!1;s||o.begin?.();try{jce(r,e)}catch(i){throw t&&vB(r,i),i}finally{s||(o.end?.(),n.inlineEffectRunner?.flush())}}function jce(r,t){let e=gz();try{i3(!0),tA(r,t);let n=0;for(;nv(r);){if(n===Wce)throw new gt(103,!1);n++,tA(r,1)}}finally{i3(e)}}function Hce(r,t,e,n){let o=t[vt];if((o&256)===256)return;let s=!1,i=!1;!s&&t[rc].inlineEffectRunner?.flush(),DA(t);let a=!0,u=null,l=null;s||(CB(r)?(l=Lce(t),u=YN(l)):bL()===null?(a=!1,l=Uce(t),u=YN(l)):t[ai]&&(QN(t[ai]),t[ai]=null));try{lz(t),Zue(r.bindingStartIndex),e!==null&&aB(r,t,e,2,n);let c=(o&3)===3;if(!s)if(c){let f=r.preOrderCheckHooks;f!==null&&OC(t,f,null)}else{let f=r.preOrderHooks;f!==null&&MC(t,f,0,null),ID(t,0)}if(i||qce(t),IB(t,0),r.contentQueries!==null&&gB(r,t),!s)if(c){let f=r.contentCheckHooks;f!==null&&OC(t,f)}else{let f=r.contentHooks;f!==null&&MC(t,f,1),ID(t,1)}uce(r,t);let p=r.components;p!==null&&_B(t,p,0);let d=r.viewQuery;if(d!==null&&eA(2,d,n),!s)if(c){let f=r.viewCheckHooks;f!==null&&OC(t,f)}else{let f=r.viewHooks;f!==null&&MC(t,f,2),ID(t,2)}if(r.firstUpdatePass===!0&&(r.firstUpdatePass=!1),t[SD]){for(let f of t[SD])f();t[SD]=null}s||(t[vt]&=-73)}catch(c){throw s||d0(t),c}finally{l!==null&&(wL(l,u),a&&Bce(l)),AA()}}function IB(r,t){for(let e=Uz(r);e!==null;e=Gz(e))for(let n=Bs;n<e.length;n++){let o=e[n];TB(o,t)}}function qce(r){for(let t=Uz(r);t!==null;t=Gz(t)){if(!(t[vt]&jC.HasTransplantedViews))continue;let e=t[zm];for(let n=0;n<e.length;n++){let o=e[n];cz(o)}}}function Kce(r,t,e){let n=xp(t,r);TB(n,e)}function TB(r,t){kA(r)&&tA(r,t)}function tA(r,t){let n=r[Pt],o=r[vt],s=r[ai],i=!!(t===0&&o&16);if(i||=!!(o&64&&t===0),i||=!!(o&1024),i||=!!(s?.dirty&&ZN(s)),i||=!1,s&&(s.dirty=!1),r[vt]&=-9217,i)Hce(n,r,n.template,r[qi]);else if(o&8192){IB(r,1);let a=n.components;a!==null&&_B(r,a,1)}}function _B(r,t,e){for(let n=0;n<t.length;n++)Kce(r,t[n],e)}function YA(r,t){let e=gz()?64:1088;for(r[rc].changeDetectionScheduler?.notify(t);r;){r[vt]|=e;let n=Mf(r);if(LD(r)&&!n)return r;r=n}return null}var Lf=class{get rootNodes(){let t=this._lView,e=t[Pt];return QC(e,t,e.firstChild,[])}constructor(t,e,n=!0){this._lView=t,this._cdRefInjectingView=e,this.notifyErrorHandler=n,this._appRef=null,this._attachedToViewContainer=!1}get context(){return this._lView[qi]}set context(t){this._lView[qi]=t}get destroyed(){return(this._lView[vt]&256)===256}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){let t=this._lView[No];if(ic(t)){let e=t[WC],n=e?e.indexOf(this):-1;n>-1&&(ZD(t,n),BC(e,n))}this._attachedToViewContainer=!1}Qz(this._lView[Pt],this._lView)}onDestroy(t){pz(this._lView,t)}markForCheck(){YA(this._cdRefInjectingView||this._lView,4)}detach(){this._lView[vt]&=-129}reattach(){BD(this._lView),this._lView[vt]|=128}detectChanges(){this._lView[vt]|=1024,SB(this._lView,this.notifyErrorHandler)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new gt(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null;let t=LD(this._lView),e=this._lView[Rf];e!==null&&!t&&WA(e,this._lView),Yz(this._lView[Pt],this._lView)}attachToAppRef(t){if(this._attachedToViewContainer)throw new gt(902,!1);this._appRef=t;let e=LD(this._lView),n=this._lView[Rf];n!==null&&!e&&Zz(n,this._lView),BD(this._lView)}},zf=(()=>{let t=class t{};t.__NG_ELEMENT_ID__=Zce;let r=t;return r})(),Xce=zf,Yce=class extends Xce{constructor(t,e,n){super(),this._declarationLView=t,this._declarationTContainer=e,this.elementRef=n}get ssrId(){return this._declarationTContainer.tView?.ssrId||null}createEmbeddedView(t,e){return this.createEmbeddedViewImpl(t,e)}createEmbeddedViewImpl(t,e,n){let o=Fce(this._declarationLView,this._declarationTContainer,t,{embeddedViewInjector:e,dehydratedView:n});return new Lf(o)}};function Zce(){return ZA(li(),fn())}function ZA(r,t){return r.type&4?new Yce(t,r,qm(r,t)):null}var b4e=new RegExp(`^(\\d+)*(${Ble}|${zle})*(.*)`);var Qce=()=>null;function w3(r,t){return Qce(r,t)}var sv=class{},QA=new Ot("",{providedIn:"root",factory:()=>!1});var EB=new Ot(""),rA=class{},JC=class{};function Jce(r){let t=Error(`No component factory found for ${ms(r)}.`);return t[epe]=r,t}var epe="ngComponent";var nA=class{resolveComponentFactory(t){throw Jce(t)}},aR=class aR{};aR.NULL=new nA;var Vm=aR,Um=class{},x0=(()=>{let t=class t{constructor(){this.destroyNode=null}};t.__NG_ELEMENT_ID__=()=>tpe();let r=t;return r})();function tpe(){let r=fn(),t=li(),e=xp(t.index,r);return(dp(e)?e:r)[Ho]}var rpe=(()=>{let t=class t{};t.\u0275prov=Qe({token:t,providedIn:"root",factory:()=>null});let r=t;return r})();var C3=new Set;function JA(r){C3.has(r)||(C3.add(r),performance?.mark?.("mark_feature_usage",{detail:{feature:r}}))}var kB=(()=>{let t=class t{constructor(){this.handler=null,this.internalCallbacks=[]}execute(){this.executeInternalCallbacks(),this.handler?.execute()}executeInternalCallbacks(){let n=[...this.internalCallbacks];this.internalCallbacks.length=0;for(let o of n)o()}ngOnDestroy(){this.handler?.destroy(),this.handler=null,this.internalCallbacks.length=0}};t.\u0275prov=Qe({token:t,providedIn:"root",factory:()=>new t});let r=t;return r})();function oA(r,t,e){let n=e?r.styles:null,o=e?r.classes:null,s=0;if(t!==null)for(let i=0;i<t.length;i++){let a=t[i];if(typeof a=="number")s=a;else if(s==1)o=KL(o,a);else if(s==2){let u=a,l=t[++i];n=KL(n,u+": "+l+";")}}e?r.styles=n:r.stylesWithoutHost=n,e?r.classes=o:r.classesWithoutHost=o}var e0=class extends Vm{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){let e=Af(t);return new iv(e,this.ngModule)}};function S3(r,t){let e=[];for(let n in r){if(!r.hasOwnProperty(n))continue;let o=r[n];if(o===void 0)continue;let s=Array.isArray(o),i=s?o[0]:o,a=s?o[1]:fp.None;t?e.push({propName:i,templateName:n,isSignal:(a&fp.SignalBased)!==0}):e.push({propName:i,templateName:n})}return e}function npe(r){let t=r.toLowerCase();return t==="svg"?Mue:t==="math"?Fue:null}var iv=class extends JC{get inputs(){let t=this.componentDef,e=t.inputTransforms,n=S3(t.inputs,!0);if(e!==null)for(let o of n)e.hasOwnProperty(o.propName)&&(o.transform=e[o.propName]);return n}get outputs(){return S3(this.componentDef.outputs,!1)}constructor(t,e){super(),this.componentDef=t,this.ngModule=e,this.componentType=t.type,this.selector=fue(t.selectors),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!e}create(t,e,n,o){let s=br(null);try{o=o||this.ngModule;let i=o instanceof ui?o:o?.injector;i&&this.componentDef.getStandaloneInjector!==null&&(i=this.componentDef.getStandaloneInjector(i)||i);let a=i?new UD(t,i):t,u=a.get(Um,null);if(u===null)throw new gt(407,!1);let l=a.get(rpe,null),c=a.get(kB,null),p=a.get(sv,null),d={rendererFactory:u,sanitizer:l,inlineEffectRunner:null,afterRenderEventManager:c,changeDetectionScheduler:p},f=u.createRenderer(null,this.componentDef),h=this.componentDef.selectors[0][0]||"div",m=n?pce(f,n,this.componentDef.encapsulation,a):Xz(f,h,npe(h)),g=512;this.componentDef.signals?g|=4096:this.componentDef.onPush||(g|=16);let y=null;m!==null&&(y=UA(m,a,!0));let x=qA(0,null,null,1,0,null,null,null,null,null,null),w=m0(null,x,null,g,null,null,d,f,a,null,y);DA(w);let C,I;try{let N=this.componentDef,A,O=null;N.findHostDirectiveDefs?(A=[],O=new Map,N.findHostDirectiveDefs(N,A,O),A.push(N)):A=[N];let $=ope(w,m),z=spe($,m,N,A,w,d,f);I=uz(x,hp),m&&upe(f,N,m,n),e!==void 0&&lpe(I,this.ngContentSelectors,e),C=ape(z,N,A,O,w,[cpe]),XA(x,w,null)}finally{AA()}return new sA(this.componentType,C,qm(I,w),w,I)}finally{br(s)}}},sA=class extends rA{constructor(t,e,n,o,s){super(),this.location=n,this._rootLView=o,this._tNode=s,this.previousInputValues=null,this.instance=e,this.hostView=this.changeDetectorRef=new Lf(o,void 0,!1),this.componentType=t}setInput(t,e){let n=this._tNode.inputs,o;if(n!==null&&(o=n[t])){if(this.previousInputValues??=new Map,this.previousInputValues.has(t)&&Object.is(this.previousInputValues.get(t),e))return;let s=this._rootLView;KA(s[Pt],s,o,t,e),this.previousInputValues.set(t,e);let i=xp(this._tNode.index,s);YA(i,1)}}get injector(){return new Df(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(t){this.hostView.onDestroy(t)}};function ope(r,t){let e=r[Pt],n=hp;return r[n]=t,g0(e,n,2,"#host",null)}function spe(r,t,e,n,o,s,i){let a=o[Pt];ipe(n,r,t,i);let u=null;t!==null&&(u=UA(t,o[Lm]));let l=s.rendererFactory.createRenderer(t,e),c=16;e.signals?c=4096:e.onPush&&(c=64);let p=m0(o,pB(e),null,c,o[r.index],r,s,l,null,null,u);return a.firstCreatePass&&JD(a,r,n.length-1),y0(o,p),o[r.index]=p}function ipe(r,t,e,n){for(let o of r)t.mergedAttrs=SA(t.mergedAttrs,o.hostAttrs);t.mergedAttrs!==null&&(oA(t,t.mergedAttrs,!0),e!==null&&nB(n,e,t))}function ape(r,t,e,n,o,s){let i=li(),a=o[Pt],u=Xi(i,o);fB(a,o,i,e,null,n);for(let c=0;c<e.length;c++){let p=i.directiveStart+c,d=Bm(o,a,p,i);Pf(d,o)}hB(a,o,i),u&&Pf(u,o);let l=Bm(o,a,i.directiveStart+i.componentOffset,i);if(r[qi]=o[qi]=l,s!==null)for(let c of s)c(l,t);return uB(a,i,o),l}function upe(r,t,e,n){if(n)OD(r,e,["ng-version","18.2.0"]);else{let{attrs:o,classes:s}=hue(t.selectors[0]);o&&OD(r,e,o),s&&s.length>0&&rB(r,e,s.join(" "))}}function lpe(r,t,e){let n=r.projection=[];for(let o=0;o<t.length;o++){let s=e[o];n.push(s!=null?Array.from(s):null)}}function cpe(){let r=li();MA(fn()[Pt],r)}var bp=(()=>{let t=class t{};t.__NG_ELEMENT_ID__=ppe;let r=t;return r})();function ppe(){let r=li();return DB(r,fn())}var dpe=bp,NB=class extends dpe{constructor(t,e,n){super(),this._lContainer=t,this._hostTNode=e,this._hostLView=n}get element(){return qm(this._hostTNode,this._hostLView)}get injector(){return new Df(this._hostTNode,this._hostLView)}get parentInjector(){let t=FA(this._hostTNode,this._hostLView);if(_z(t)){let e=KC(t,this._hostLView),n=qC(t),o=e[Pt].data[n+8];return new Df(o,e)}else return new Df(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(t){let e=I3(this._lContainer);return e!==null&&e[t]||null}get length(){return this._lContainer.length-Bs}createEmbeddedView(t,e,n){let o,s;typeof n=="number"?o=n:n!=null&&(o=n.index,s=n.injector);let i=w3(this._lContainer,t.ssrId),a=t.createEmbeddedViewImpl(e||{},s,i);return this.insertImpl(a,o,b3(this._hostTNode,i)),a}createComponent(t,e,n,o,s){let i=t&&!Due(t),a;if(i)a=e;else{let h=e||{};a=h.index,n=h.injector,o=h.projectableNodes,s=h.environmentInjector||h.ngModuleRef}let u=i?t:new iv(Af(t)),l=n||this.parentInjector;if(!s&&u.ngModule==null){let m=(i?l:this.parentInjector).get(ui,null);m&&(s=m)}let c=Af(u.componentType??{}),p=w3(this._lContainer,c?.id??null),d=p?.firstChild??null,f=u.create(l,o,d,s);return this.insertImpl(f.hostView,a,b3(this._hostTNode,p)),f}insert(t,e){return this.insertImpl(t,e,!0)}insertImpl(t,e,n){let o=t._lView;if(Lue(o)){let a=this.indexOf(t);if(a!==-1)this.detach(a);else{let u=o[No],l=new NB(u,u[Ki],u[No]);l.detach(l.indexOf(t))}}let s=this._adjustIndex(e),i=this._lContainer;return $ce(i,o,s,n),t.attachToViewContainerRef(),V3(ND(i),s,t),t}move(t,e){return this.insert(t,e)}indexOf(t){let e=I3(this._lContainer);return e!==null?e.indexOf(t):-1}remove(t){let e=this._adjustIndex(t,-1),n=ZD(this._lContainer,e);n&&(BC(ND(this._lContainer),e),Qz(n[Pt],n))}detach(t){let e=this._adjustIndex(t,-1),n=ZD(this._lContainer,e);return n&&BC(ND(this._lContainer),e)!=null?new Lf(n):null}_adjustIndex(t,e=0){return t??this.length+e}};function I3(r){return r[WC]}function ND(r){return r[WC]||(r[WC]=[])}function DB(r,t){let e,n=t[r.index];return ic(n)?e=n:(e=mB(n,t,null,r),t[r.index]=e,y0(t,e)),hpe(e,t,r,n),new NB(e,r,t)}function fpe(r,t){let e=r[Ho],n=e.createComment(""),o=Xi(t,r),s=eB(e,o);return ZC(e,s,n,ece(e,o),!1),n}var hpe=ype,mpe=()=>!1;function gpe(r,t,e){return mpe(r,t,e)}function ype(r,t,e,n){if(r[Of])return;let o;e.type&8?o=Nu(n):o=fpe(t,e),r[Of]=o}var iA=class r{constructor(t){this.queryList=t,this.matches=null}clone(){return new r(this.queryList)}setDirty(){this.queryList.setDirty()}},aA=class r{constructor(t=[]){this.queries=t}createEmbeddedView(t){let e=t.queries;if(e!==null){let n=t.contentQueries!==null?t.contentQueries[0]:e.length,o=[];for(let s=0;s<n;s++){let i=e.getByIndex(s),a=this.queries[i.indexInDeclarationView];o.push(a.clone())}return new r(o)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}finishViewCreation(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let e=0;e<this.queries.length;e++)eR(t,e).matches!==null&&this.queries[e].setDirty()}},uA=class{constructor(t,e,n=null){this.flags=e,this.read=n,typeof t=="string"?this.predicate=Tpe(t):this.predicate=t}},lA=class r{constructor(t=[]){this.queries=t}elementStart(t,e){for(let n=0;n<this.queries.length;n++)this.queries[n].elementStart(t,e)}elementEnd(t){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(t)}embeddedTView(t){let e=null;for(let n=0;n<this.length;n++){let o=e!==null?e.length:0,s=this.getByIndex(n).embeddedTView(t,o);s&&(s.indexInDeclarationView=n,e!==null?e.push(s):e=[s])}return e!==null?new r(e):null}template(t,e){for(let n=0;n<this.queries.length;n++)this.queries[n].template(t,e)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}},cA=class r{constructor(t,e=-1){this.metadata=t,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(t,e){this.isApplyingToNode(e)&&this.matchTNode(t,e)}elementEnd(t){this._declarationNodeIndex===t.index&&(this._appliesToNextNode=!1)}template(t,e){this.elementStart(t,e)}embeddedTView(t,e){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,e),new r(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&&(this.metadata.flags&1)!==1){let e=this._declarationNodeIndex,n=t.parent;for(;n!==null&&n.type&8&&n.index!==e;)n=n.parent;return e===(n!==null?n.index:-1)}return this._appliesToNextNode}matchTNode(t,e){let n=this.metadata.predicate;if(Array.isArray(n))for(let o=0;o<n.length;o++){let s=n[o];this.matchTNodeWithReadOption(t,e,xpe(e,s)),this.matchTNodeWithReadOption(t,e,FC(e,t,s,!1,!1))}else n===zf?e.type&4&&this.matchTNodeWithReadOption(t,e,-1):this.matchTNodeWithReadOption(t,e,FC(e,t,n,!1,!1))}matchTNodeWithReadOption(t,e,n){if(n!==null){let o=this.metadata.read;if(o!==null)if(o===vp||o===bp||o===zf&&e.type&4)this.addMatch(e.index,-2);else{let s=FC(e,t,o,!1,!1);s!==null&&this.addMatch(e.index,s)}else this.addMatch(e.index,n)}}addMatch(t,e){this.matches===null?this.matches=[t,e]:this.matches.push(t,e)}};function xpe(r,t){let e=r.localNames;if(e!==null){for(let n=0;n<e.length;n+=2)if(e[n]===t)return e[n+1]}return null}function vpe(r,t){return r.type&11?qm(r,t):r.type&4?ZA(r,t):null}function bpe(r,t,e,n){return e===-1?vpe(t,r):e===-2?wpe(r,t,n):Bm(r,r[Pt],e,t)}function wpe(r,t,e){if(e===vp)return qm(t,r);if(e===zf)return ZA(t,r);if(e===bp)return DB(t,r)}function AB(r,t,e,n){let o=t[nc].queries[n];if(o.matches===null){let s=r.data,i=e.matches,a=[];for(let u=0;i!==null&&u<i.length;u+=2){let l=i[u];if(l<0)a.push(null);else{let c=s[l];a.push(bpe(t,c,i[u+1],e.metadata.read))}}o.matches=a}return o.matches}function pA(r,t,e,n){let o=r.queries.getByIndex(e),s=o.matches;if(s!==null){let i=AB(r,t,o,e);for(let a=0;a<s.length;a+=2){let u=s[a];if(u>0)n.push(i[a/2]);else{let l=s[a+1],c=t[-u];for(let p=Bs;p<c.length;p++){let d=c[p];d[Rf]===d[No]&&pA(d[Pt],d,l,n)}if(c[zm]!==null){let p=c[zm];for(let d=0;d<p.length;d++){let f=p[d];pA(f[Pt],f,l,n)}}}}}return n}function Cpe(r,t){return r[nc].queries[t].queryList}function Spe(r,t,e){let n=new XD((e&4)===4);return hce(r,t,n,n.destroy),(t[nc]??=new aA).queries.push(new iA(n))-1}function Ipe(r,t,e){let n=ac();return n.firstCreatePass&&(_pe(n,new uA(r,t,e),-1),(t&2)===2&&(n.staticViewQueries=!0)),Spe(n,fn(),t)}function Tpe(r){return r.split(",").map(t=>t.trim())}function _pe(r,t,e){r.queries===null&&(r.queries=new lA),r.queries.track(new cA(t,e))}function eR(r,t){return r.queries.getByIndex(t)}function Epe(r,t){let e=r[Pt],n=eR(e,t);return n.crossesNgTemplate?pA(e,r,t,[]):AB(e,r,n,t)}var gp=class{},av=class{};var dA=class extends gp{constructor(t,e,n,o=!0){super(),this.ngModuleType=t,this._parent=e,this._bootstrapComponents=[],this.destroyCbs=[],this.componentFactoryResolver=new e0(this);let s=X3(t);this._bootstrapComponents=Kz(s.bootstrap),this._r3Injector=$z(t,e,[{provide:gp,useValue:this},{provide:Vm,useValue:this.componentFactoryResolver},...n],ms(t),new Set(["environment"])),o&&this.resolveInjectorInitializers()}resolveInjectorInitializers(){this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(this.ngModuleType)}get injector(){return this._r3Injector}destroy(){let t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}},fA=class extends av{constructor(t){super(),this.moduleType=t}create(t){return new dA(this.moduleType,t,[])}};var t0=class extends gp{constructor(t){super(),this.componentFactoryResolver=new e0(this),this.instance=null;let e=new tv([...t.providers,{provide:gp,useValue:this},{provide:Vm,useValue:this.componentFactoryResolver}],t.parent||_A(),t.debugName,new Set(["environment"]));this.injector=e,t.runEnvironmentInitializers&&e.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(t){this.injector.onDestroy(t)}};function tR(r,t,e=null){return new t0({providers:r,parent:t,debugName:e,runEnvironmentInitializers:!0}).injector}function RB(r){return Npe(r)?Array.isArray(r)||!(r instanceof Map)&&Symbol.iterator in r:!1}function kpe(r,t){if(Array.isArray(r))for(let e=0;e<r.length;e++)t(r[e]);else{let e=r[Symbol.iterator](),n;for(;!(n=e.next()).done;)t(n.value)}}function Npe(r){return r!==null&&(typeof r=="function"||typeof r=="object")}function Dpe(r,t,e){return r[t]=e}function Gm(r,t,e){let n=r[t];return Object.is(n,e)?!1:(r[t]=e,!0)}function Ape(r,t,e,n){let o=Gm(r,t,e);return Gm(r,t+1,n)||o}function Rpe(r,t,e,n,o){let s=Ape(r,t,e,n);return Gm(r,t+2,o)||s}function Ope(r){return(r.flags&32)===32}function Mpe(r,t,e,n,o,s,i,a,u){let l=t.consts,c=g0(t,r,4,i||null,a||null);dB(t,e,c,HC(l,u)),MA(t,c);let p=c.tView=qA(2,c,n,o,s,t.directiveRegistry,t.pipeRegistry,null,t.schemas,l,null);return t.queries!==null&&(t.queries.template(t,c),p.queries=t.queries.embeddedTView(c)),c}function Fpe(r,t,e,n,o,s,i,a,u,l){let c=e+hp,p=t.firstCreatePass?Mpe(c,t,r,n,o,s,i,a,u):t.data[c];cv(p,!1);let d=$pe(t,r,p,e);RA()&&jA(t,r,d,p),Pf(d,r);let f=mB(d,r,d,p);return r[c]=f,y0(r,f),gpe(f,p,r),EA(p)&&lB(t,r,p),u!=null&&cB(r,p,l),p}function qo(r,t,e,n,o,s,i,a){let u=fn(),l=ac(),c=HC(l.consts,s);return Fpe(u,l,r,t,e,n,o,c,i,a),qo}var $pe=Ppe;function Ppe(r,t,e,n){return OA(!0),t[Ho].createComment("")}function Lpe(r,t,e,n){return Gm(r,yz(),e)?t+Qx(e)+n:Gf}function zpe(r,t,e,n,o,s,i,a){let u=Yue(),l=Rpe(r,u,e,o,i);return Que(3),l?t+Qx(e)+n+Qx(o)+s+Qx(i)+a:Gf}function Er(r,t,e){let n=fn(),o=yz();if(Gm(n,o,t)){let s=ac(),i=ole();xce(s,i,n,r,t,n[Ho],e,!1)}return Er}function T3(r,t,e,n,o){let s=t.inputs,i=o?"class":"style";KA(r,e,s[i],i,n)}function Bpe(r,t,e,n,o,s){let i=t.consts,a=HC(i,o),u=g0(t,r,2,n,a);return dB(t,e,u,HC(i,s)),u.attrs!==null&&oA(u,u.attrs,!1),u.mergedAttrs!==null&&oA(u,u.mergedAttrs,!0),t.queries!==null&&t.queries.elementStart(t,u),u}function Me(r,t,e,n){let o=fn(),s=ac(),i=hp+r,a=o[Ho],u=s.firstCreatePass?Bpe(i,s,o,t,e,n):s.data[i],l=Vpe(s,o,u,a,t,r);o[i]=l;let c=EA(u);return cv(u,!0),nB(a,l,u),!Ope(u)&&RA()&&jA(s,o,l,u),Vue()===0&&Pf(l,o),Uue(),c&&(lB(s,o,u),uB(s,u,o)),n!==null&&cB(o,u),Me}function Fe(){let r=li();mz()?Kue():(r=r.parent,cv(r,!1));let t=r;jue(t)&&Hue(),Gue();let e=ac();return e.firstCreatePass&&(MA(e,r),nz(r)&&e.queries.elementEnd(r)),t.classesWithoutHost!=null&&lle(t)&&T3(e,t,fn(),t.classesWithoutHost,!0),t.stylesWithoutHost!=null&&cle(t)&&T3(e,t,fn(),t.stylesWithoutHost,!1),Fe}function Wt(r,t,e,n){return Me(r,t,e,n),Fe(),Wt}var Vpe=(r,t,e,n,o,s)=>(OA(!0),Xz(n,o,sle()));function Xm(){return fn()}var r0="en-US";var Upe=r0;function Gpe(r){typeof r=="string"&&(Upe=r.toLowerCase().replace(/_/g,"-"))}var Wpe=(r,t,e)=>{};function zr(r,t,e,n){let o=fn(),s=ac(),i=li();return Hpe(s,o,o[Ho],i,r,t,n),zr}function jpe(r,t,e,n){let o=r.cleanup;if(o!=null)for(let s=0;s<o.length-1;s+=2){let i=o[s];if(i===e&&o[s+1]===n){let a=t[GC],u=o[s+2];return a.length>u?a[u]:null}typeof i=="string"&&(s+=2)}return null}function Hpe(r,t,e,n,o,s,i){let a=EA(n),l=r.firstCreatePass&&xB(r),c=t[qi],p=yB(t),d=!0;if(n.type&3||i){let m=Xi(n,t),g=i?i(m):m,y=p.length,x=i?C=>i(Nu(C[n.index])):n.index,w=null;if(!i&&a&&(w=jpe(r,t,o,n.index)),w!==null){let C=w.__ngLastListenerFn__||w;C.__ngNextListenerFn__=s,w.__ngLastListenerFn__=s,d=!1}else{s=E3(n,t,c,s),Wpe(m,o,s);let C=e.listen(g,o,s);p.push(s,C),l&&l.push(o,x,y,y+1)}}else s=E3(n,t,c,s);let f=n.outputs,h;if(d&&f!==null&&(h=f[o])){let m=h.length;if(m)for(let g=0;g<m;g+=2){let y=h[g],x=h[g+1],I=t[y][x].subscribe(s),N=p.length;p.push(s,I),l&&l.push(o,n.index,N,-(N+1))}}}function _3(r,t,e,n){let o=br(null);try{return Tu(6,t,e),e(n)!==!1}catch(s){return vB(r,s),!1}finally{Tu(7,t,e),br(o)}}function E3(r,t,e,n){return function o(s){if(s===Function)return n;let i=r.componentOffset>-1?xp(r.index,t):t;YA(i,5);let a=_3(t,e,n,s),u=o.__ngNextListenerFn__;for(;u;)a=_3(t,e,u,s)&&a,u=u.__ngNextListenerFn__;return a}}function vo(r=1){return nle(r)}function v0(r,t,e){Ipe(r,t,e)}function pv(r){let t=fn(),e=ac(),n=xz();NA(n+1);let o=eR(e,n);if(r.dirty&&Pue(t)===((o.metadata.flags&2)===2)){if(o.matches===null)r.reset([]);else{let s=Epe(t,n);r.reset(s,Ale),r.notifyOnChanges()}return!0}return!1}function dv(){return Cpe(fn(),xz())}function ot(r,t=""){let e=fn(),n=ac(),o=r+hp,s=n.firstCreatePass?g0(n,o,1,t,null):n.data[o],i=qpe(n,e,s,t,r);e[o]=i,RA()&&jA(n,e,i,s),cv(s,!1)}var qpe=(r,t,e,n,o)=>(OA(!0),Wle(t[Ho],n));function fv(r){return ci("",r,""),fv}function ci(r,t,e){let n=fn(),o=Lpe(n,r,t,e);return o!==Gf&&bB(n,f0(),o),ci}function rR(r,t,e,n,o,s,i){let a=fn(),u=zpe(a,r,t,e,n,o,s,i);return u!==Gf&&bB(a,f0(),u),rR}var Kpe=(()=>{let t=class t{constructor(n){this._injector=n,this.cachedInjectors=new Map}getOrCreateStandaloneInjector(n){if(!n.standalone)return null;if(!this.cachedInjectors.has(n)){let o=Q3(!1,n.type),s=o.length>0?tR([o],this._injector,`Standalone[${n.type.name}]`):null;this.cachedInjectors.set(n,s)}return this.cachedInjectors.get(n)}ngOnDestroy(){try{for(let n of this.cachedInjectors.values())n!==null&&n.destroy()}finally{this.cachedInjectors.clear()}}};t.\u0275prov=Qe({token:t,providedIn:"environment",factory:()=>new t(St(ui))});let r=t;return r})();function sr(r){JA("NgStandalone"),r.getStandaloneInjector=t=>t.get(Kpe).getOrCreateStandaloneInjector(r)}function b0(r,t,e,n){return Ype(fn(),Xue(),r,t,e,n)}function Xpe(r,t){let e=r[t];return e===Gf?void 0:e}function Ype(r,t,e,n,o,s){let i=t+e;return Gm(r,i,o)?Dpe(r,i+1,s?n.call(s,o):n(o)):Xpe(r,i+1)}var w0=(()=>{let t=class t{log(n){console.log(n)}warn(n){console.warn(n)}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=Qe({token:t,factory:t.\u0275fac,providedIn:"platform"});let r=t;return r})();var OB=new Ot("");function hv(r){return!!r&&typeof r.then=="function"}function MB(r){return!!r&&typeof r.subscribe=="function"}var FB=new Ot(""),$B=(()=>{let t=class t{constructor(){this.initialized=!1,this.done=!1,this.donePromise=new Promise((n,o)=>{this.resolve=n,this.reject=o}),this.appInits=We(FB,{optional:!0})??[]}runInitializers(){if(this.initialized)return;let n=[];for(let s of this.appInits){let i=s();if(hv(i))n.push(i);else if(MB(i)){let a=new Promise((u,l)=>{i.subscribe({complete:u,error:l})});n.push(a)}}let o=()=>{this.done=!0,this.resolve()};Promise.all(n).then(()=>{o()}).catch(s=>{this.reject(s)}),n.length===0&&o(),this.initialized=!0}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=Qe({token:t,factory:t.\u0275fac,providedIn:"root"});let r=t;return r})(),nR=new Ot("");function Zpe(){CL(()=>{throw new gt(600,!1)})}function Qpe(r){return r.isBoundToModule}var Jpe=10;function ede(r,t,e){try{let n=e();return hv(n)?n.catch(o=>{throw t.runOutsideAngular(()=>r.handleError(o)),o}):n}catch(n){throw t.runOutsideAngular(()=>r.handleError(n)),n}}var Wf=(()=>{let t=class t{constructor(){this._bootstrapListeners=[],this._runningTick=!1,this._destroyed=!1,this._destroyListeners=[],this._views=[],this.internalErrorHandler=We(Nle),this.afterRenderEffectManager=We(kB),this.zonelessEnabled=We(QA),this.externalTestViews=new Set,this.beforeRender=new Mr,this.afterTick=new Mr,this.componentTypes=[],this.components=[],this.isStable=We(Hm).hasPendingTasks.pipe(Jt(n=>!n)),this._injector=We(ui)}get allViews(){return[...this.externalTestViews.keys(),...this._views]}get destroyed(){return this._destroyed}whenStable(){let n;return new Promise(o=>{n=this.isStable.subscribe({next:s=>{s&&o()}})}).finally(()=>{n.unsubscribe()})}get injector(){return this._injector}bootstrap(n,o){let s=n instanceof JC;if(!this._injector.get($B).done){let f=!s&&K3(n),h=!1;throw new gt(405,h)}let a;s?a=n:a=this._injector.get(Vm).resolveComponentFactory(n),this.componentTypes.push(a.componentType);let u=Qpe(a)?void 0:this._injector.get(gp),l=o||a.selector,c=a.create($f.NULL,[],l,u),p=c.location.nativeElement,d=c.injector.get(OB,null);return d?.registerApplication(p),c.onDestroy(()=>{this.detachView(c.hostView),$C(this.components,c),d?.unregisterApplication(p)}),this._loadComponent(c),c}tick(){this._tick(!0)}_tick(n){if(this._runningTick)throw new gt(101,!1);let o=br(null);try{this._runningTick=!0,this.detectChangesInAttachedViews(n)}catch(s){this.internalErrorHandler(s)}finally{this._runningTick=!1,br(o),this.afterTick.next()}}detectChangesInAttachedViews(n){let o=null;this._injector.destroyed||(o=this._injector.get(Um,null,{optional:!0}));let s=0,i=this.afterRenderEffectManager;for(;s<Jpe;){let a=s===0;if(n||!a){this.beforeRender.next(a);for(let{_lView:u,notifyErrorHandler:l}of this._views)tde(u,l,a,this.zonelessEnabled)}else o?.begin?.(),o?.end?.();if(s++,i.executeInternalCallbacks(),!this.allViews.some(({_lView:u})=>nv(u))&&(i.execute(),!this.allViews.some(({_lView:u})=>nv(u))))break}}attachView(n){let o=n;this._views.push(o),o.attachToAppRef(this)}detachView(n){let o=n;$C(this._views,o),o.detachFromAppRef()}_loadComponent(n){this.attachView(n.hostView),this.tick(),this.components.push(n);let o=this._injector.get(nR,[]);[...this._bootstrapListeners,...o].forEach(s=>s(n))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(n=>n()),this._views.slice().forEach(n=>n.destroy())}finally{this._destroyed=!0,this._views=[],this._bootstrapListeners=[],this._destroyListeners=[]}}onDestroy(n){return this._destroyListeners.push(n),()=>$C(this._destroyListeners,n)}destroy(){if(this._destroyed)throw new gt(406,!1);let n=this._injector;n.destroy&&!n.destroyed&&n.destroy()}get viewCount(){return this._views.length}warnIfDestroyed(){}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=Qe({token:t,factory:t.\u0275fac,providedIn:"root"});let r=t;return r})();function $C(r,t){let e=r.indexOf(t);e>-1&&r.splice(e,1)}function tde(r,t,e,n){if(!e&&!nv(r))return;SB(r,t,e&&!n?0:1)}var hA=class{constructor(t,e){this.ngModuleFactory=t,this.componentFactories=e}},oR=(()=>{let t=class t{compileModuleSync(n){return new fA(n)}compileModuleAsync(n){return Promise.resolve(this.compileModuleSync(n))}compileModuleAndAllComponentsSync(n){let o=this.compileModuleSync(n),s=X3(n),i=Kz(s.declarations).reduce((a,u)=>{let l=Af(u);return l&&a.push(new iv(l)),a},[]);return new hA(o,i)}compileModuleAndAllComponentsAsync(n){return Promise.resolve(this.compileModuleAndAllComponentsSync(n))}clearCache(){}clearCacheFor(n){}getModuleId(n){}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=Qe({token:t,factory:t.\u0275fac,providedIn:"root"});let r=t;return r})();var rde=(()=>{let t=class t{constructor(){this.zone=We(Zn),this.changeDetectionScheduler=We(sv),this.applicationRef=We(Wf)}initialize(){this._onMicrotaskEmptySubscription||(this._onMicrotaskEmptySubscription=this.zone.onMicrotaskEmpty.subscribe({next:()=>{this.changeDetectionScheduler.runningTick||this.zone.run(()=>{this.applicationRef.tick()})}}))}ngOnDestroy(){this._onMicrotaskEmptySubscription?.unsubscribe()}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=Qe({token:t,factory:t.\u0275fac,providedIn:"root"});let r=t;return r})(),nde=new Ot("",{factory:()=>!1});function PB({ngZoneFactory:r,ignoreChangesOutsideZone:t}){return r??=()=>new Zn(zB()),[{provide:Zn,useFactory:r},{provide:Pm,multi:!0,useFactory:()=>{let e=We(rde,{optional:!0});return()=>e.initialize()}},{provide:Pm,multi:!0,useFactory:()=>{let e=We(ode);return()=>{e.initialize()}}},t===!0?{provide:EB,useValue:!0}:[]]}function LB(r){let t=r?.ignoreChangesOutsideZone,e=PB({ngZoneFactory:()=>{let n=zB(r);return n.shouldCoalesceEventChangeDetection&&JA("NgZone_CoalesceEvent"),new Zn(n)},ignoreChangesOutsideZone:t});return u0([{provide:nde,useValue:!0},{provide:QA,useValue:!1},e])}function zB(r){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:r?.eventCoalescing??!1,shouldCoalesceRunChangeDetection:r?.runCoalescing??!1}}var ode=(()=>{let t=class t{constructor(){this.subscription=new wn,this.initialized=!1,this.zone=We(Zn),this.pendingTasks=We(Hm)}initialize(){if(this.initialized)return;this.initialized=!0;let n=null;!this.zone.isStable&&!this.zone.hasPendingMacrotasks&&!this.zone.hasPendingMicrotasks&&(n=this.pendingTasks.add()),this.zone.runOutsideAngular(()=>{this.subscription.add(this.zone.onStable.subscribe(()=>{Zn.assertNotInAngularZone(),queueMicrotask(()=>{n!==null&&!this.zone.hasPendingMacrotasks&&!this.zone.hasPendingMicrotasks&&(this.pendingTasks.remove(n),n=null)})}))}),this.subscription.add(this.zone.onUnstable.subscribe(()=>{Zn.assertInAngularZone(),n??=this.pendingTasks.add()}))}ngOnDestroy(){this.subscription.unsubscribe()}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=Qe({token:t,factory:t.\u0275fac,providedIn:"root"});let r=t;return r})();var sde=(()=>{let t=class t{constructor(){this.appRef=We(Wf),this.taskService=We(Hm),this.ngZone=We(Zn),this.zonelessEnabled=We(QA),this.disableScheduling=We(EB,{optional:!0})??!1,this.zoneIsDefined=typeof Zone<"u"&&!!Zone.root.run,this.schedulerTickApplyArgs=[{data:{__scheduler_tick__:!0}}],this.subscriptions=new wn,this.angularZoneId=this.zoneIsDefined?this.ngZone._inner?.get(YC):null,this.cancelScheduledCallback=null,this.shouldRefreshViews=!1,this.useMicrotaskScheduler=!1,this.runningTick=!1,this.pendingRenderTaskId=null,this.subscriptions.add(this.appRef.afterTick.subscribe(()=>{this.runningTick||this.cleanup()})),this.subscriptions.add(this.ngZone.onUnstable.subscribe(()=>{this.runningTick||this.cleanup()})),this.disableScheduling||=!this.zonelessEnabled&&(this.ngZone instanceof KD||!this.zoneIsDefined)}notify(n){if(!this.zonelessEnabled&&n===5)return;switch(n){case 3:case 2:case 0:case 4:case 5:case 1:{this.shouldRefreshViews=!0;break}case 8:case 7:case 6:case 9:default:}if(!this.shouldScheduleTick())return;let o=this.useMicrotaskScheduler?d3:Lz;this.pendingRenderTaskId=this.taskService.add(),this.zoneIsDefined?Zone.root.run(()=>{this.cancelScheduledCallback=o(()=>{this.tick(this.shouldRefreshViews)})}):this.cancelScheduledCallback=o(()=>{this.tick(this.shouldRefreshViews)})}shouldScheduleTick(){return!(this.disableScheduling||this.pendingRenderTaskId!==null||this.runningTick||this.appRef._runningTick||!this.zonelessEnabled&&this.zoneIsDefined&&Zone.current.get(YC+this.angularZoneId))}tick(n){if(this.runningTick||this.appRef.destroyed)return;let o=this.taskService.add();try{this.ngZone.run(()=>{this.runningTick=!0,this.appRef._tick(n)},void 0,this.schedulerTickApplyArgs)}catch(s){throw this.taskService.remove(o),s}finally{this.cleanup()}this.useMicrotaskScheduler=!0,d3(()=>{this.useMicrotaskScheduler=!1,this.taskService.remove(o)})}ngOnDestroy(){this.subscriptions.unsubscribe(),this.cleanup()}cleanup(){if(this.shouldRefreshViews=!1,this.runningTick=!1,this.cancelScheduledCallback?.(),this.cancelScheduledCallback=null,this.pendingRenderTaskId!==null){let n=this.pendingRenderTaskId;this.pendingRenderTaskId=null,this.taskService.remove(n)}}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=Qe({token:t,factory:t.\u0275fac,providedIn:"root"});let r=t;return r})();function ide(){return typeof $localize<"u"&&$localize.locale||r0}var sR=new Ot("",{providedIn:"root",factory:()=>We(sR,$t.Optional|$t.SkipSelf)||ide()});var BB=new Ot("");function AC(r){return!!r.platformInjector}function ade(r){let t=AC(r)?r.r3Injector:r.moduleRef.injector,e=t.get(Zn);return e.run(()=>{AC(r)?r.r3Injector.resolveInjectorInitializers():r.moduleRef.resolveInjectorInitializers();let n=t.get(mp,null),o;if(e.runOutsideAngular(()=>{o=e.onError.subscribe({next:s=>{n.handleError(s)}})}),AC(r)){let s=()=>t.destroy(),i=r.platformInjector.get(BB);i.add(s),t.onDestroy(()=>{o.unsubscribe(),i.delete(s)})}else r.moduleRef.onDestroy(()=>{$C(r.allPlatformModules,r.moduleRef),o.unsubscribe()});return ede(n,e,()=>{let s=t.get($B);return s.runInitializers(),s.donePromise.then(()=>{let i=t.get(sR,r0);if(Gpe(i||r0),AC(r)){let a=t.get(Wf);return r.rootComponent!==void 0&&a.bootstrap(r.rootComponent),a}else return ude(r.moduleRef,r.allPlatformModules),r.moduleRef})})})}function ude(r,t){let e=r.injector.get(Wf);if(r._bootstrapComponents.length>0)r._bootstrapComponents.forEach(n=>e.bootstrap(n));else if(r.instance.ngDoBootstrap)r.instance.ngDoBootstrap(e);else throw new gt(-403,!1);t.push(r)}var PC=null;function lde(r=[],t){return $f.create({name:t,providers:[{provide:l0,useValue:"platform"},{provide:BB,useValue:new Set([()=>PC=null])},...r]})}function cde(r=[]){if(PC)return PC;let t=lde(r);return PC=t,Zpe(),pde(t),t}function pde(r){r.get(BA,null)?.forEach(e=>e())}var uc=(()=>{let t=class t{};t.__NG_ELEMENT_ID__=dde;let r=t;return r})();function dde(r){return fde(li(),fn(),(r&16)===16)}function fde(r,t,e){if(p0(r)&&!e){let n=xp(r.index,t);return new Lf(n,n)}else if(r.type&175){let n=t[ku];return new Lf(n,t)}return null}var mA=class{constructor(){}supports(t){return RB(t)}create(t){return new gA(t)}},hde=(r,t)=>t,gA=class{constructor(t){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=t||hde}forEachItem(t){let e;for(e=this._itHead;e!==null;e=e._next)t(e)}forEachOperation(t){let e=this._itHead,n=this._removalsHead,o=0,s=null;for(;e||n;){let i=!n||e&&e.currentIndex<k3(n,o,s)?e:n,a=k3(i,o,s),u=i.currentIndex;if(i===n)o--,n=n._nextRemoved;else if(e=e._next,i.previousIndex==null)o++;else{s||(s=[]);let l=a-o,c=u-o;if(l!=c){for(let d=0;d<l;d++){let f=d<s.length?s[d]:s[d]=0,h=f+d;c<=h&&h<l&&(s[d]=f+1)}let p=i.previousIndex;s[p]=c-l}}a!==u&&t(i,a,u)}}forEachPreviousItem(t){let e;for(e=this._previousItHead;e!==null;e=e._nextPrevious)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;e!==null;e=e._nextAdded)t(e)}forEachMovedItem(t){let e;for(e=this._movesHead;e!==null;e=e._nextMoved)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;e!==null;e=e._nextRemoved)t(e)}forEachIdentityChange(t){let e;for(e=this._identityChangesHead;e!==null;e=e._nextIdentityChange)t(e)}diff(t){if(t==null&&(t=[]),!RB(t))throw new gt(900,!1);return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e=this._itHead,n=!1,o,s,i;if(Array.isArray(t)){this.length=t.length;for(let a=0;a<this.length;a++)s=t[a],i=this._trackByFn(a,s),e===null||!Object.is(e.trackById,i)?(e=this._mismatch(e,s,i,a),n=!0):(n&&(e=this._verifyReinsertion(e,s,i,a)),Object.is(e.item,s)||this._addIdentityChange(e,s)),e=e._next}else o=0,kpe(t,a=>{i=this._trackByFn(o,a),e===null||!Object.is(e.trackById,i)?(e=this._mismatch(e,a,i,o),n=!0):(n&&(e=this._verifyReinsertion(e,a,i,o)),Object.is(e.item,a)||this._addIdentityChange(e,a)),e=e._next,o++}),this.length=o;return this._truncate(e),this.collection=t,this.isDirty}get isDirty(){return this._additionsHead!==null||this._movesHead!==null||this._removalsHead!==null||this._identityChangesHead!==null}_reset(){if(this.isDirty){let t;for(t=this._previousItHead=this._itHead;t!==null;t=t._next)t._nextPrevious=t._next;for(t=this._additionsHead;t!==null;t=t._nextAdded)t.previousIndex=t.currentIndex;for(this._additionsHead=this._additionsTail=null,t=this._movesHead;t!==null;t=t._nextMoved)t.previousIndex=t.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(t,e,n,o){let s;return t===null?s=this._itTail:(s=t._prev,this._remove(t)),t=this._unlinkedRecords===null?null:this._unlinkedRecords.get(n,null),t!==null?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._reinsertAfter(t,s,o)):(t=this._linkedRecords===null?null:this._linkedRecords.get(n,o),t!==null?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._moveAfter(t,s,o)):t=this._addAfter(new yA(e,n),s,o)),t}_verifyReinsertion(t,e,n,o){let s=this._unlinkedRecords===null?null:this._unlinkedRecords.get(n,null);return s!==null?t=this._reinsertAfter(s,t._prev,o):t.currentIndex!=o&&(t.currentIndex=o,this._addToMoves(t,o)),t}_truncate(t){for(;t!==null;){let e=t._next;this._addToRemovals(this._unlink(t)),t=e}this._unlinkedRecords!==null&&this._unlinkedRecords.clear(),this._additionsTail!==null&&(this._additionsTail._nextAdded=null),this._movesTail!==null&&(this._movesTail._nextMoved=null),this._itTail!==null&&(this._itTail._next=null),this._removalsTail!==null&&(this._removalsTail._nextRemoved=null),this._identityChangesTail!==null&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(t,e,n){this._unlinkedRecords!==null&&this._unlinkedRecords.remove(t);let o=t._prevRemoved,s=t._nextRemoved;return o===null?this._removalsHead=s:o._nextRemoved=s,s===null?this._removalsTail=o:s._prevRemoved=o,this._insertAfter(t,e,n),this._addToMoves(t,n),t}_moveAfter(t,e,n){return this._unlink(t),this._insertAfter(t,e,n),this._addToMoves(t,n),t}_addAfter(t,e,n){return this._insertAfter(t,e,n),this._additionsTail===null?this._additionsTail=this._additionsHead=t:this._additionsTail=this._additionsTail._nextAdded=t,t}_insertAfter(t,e,n){let o=e===null?this._itHead:e._next;return t._next=o,t._prev=e,o===null?this._itTail=t:o._prev=t,e===null?this._itHead=t:e._next=t,this._linkedRecords===null&&(this._linkedRecords=new n0),this._linkedRecords.put(t),t.currentIndex=n,t}_remove(t){return this._addToRemovals(this._unlink(t))}_unlink(t){this._linkedRecords!==null&&this._linkedRecords.remove(t);let e=t._prev,n=t._next;return e===null?this._itHead=n:e._next=n,n===null?this._itTail=e:n._prev=e,t}_addToMoves(t,e){return t.previousIndex===e||(this._movesTail===null?this._movesTail=this._movesHead=t:this._movesTail=this._movesTail._nextMoved=t),t}_addToRemovals(t){return this._unlinkedRecords===null&&(this._unlinkedRecords=new n0),this._unlinkedRecords.put(t),t.currentIndex=null,t._nextRemoved=null,this._removalsTail===null?(this._removalsTail=this._removalsHead=t,t._prevRemoved=null):(t._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=t),t}_addIdentityChange(t,e){return t.item=e,this._identityChangesTail===null?this._identityChangesTail=this._identityChangesHead=t:this._identityChangesTail=this._identityChangesTail._nextIdentityChange=t,t}},yA=class{constructor(t,e){this.item=t,this.trackById=e,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}},xA=class{constructor(){this._head=null,this._tail=null}add(t){this._head===null?(this._head=this._tail=t,t._nextDup=null,t._prevDup=null):(this._tail._nextDup=t,t._prevDup=this._tail,t._nextDup=null,this._tail=t)}get(t,e){let n;for(n=this._head;n!==null;n=n._nextDup)if((e===null||e<=n.currentIndex)&&Object.is(n.trackById,t))return n;return null}remove(t){let e=t._prevDup,n=t._nextDup;return e===null?this._head=n:e._nextDup=n,n===null?this._tail=e:n._prevDup=e,this._head===null}},n0=class{constructor(){this.map=new Map}put(t){let e=t.trackById,n=this.map.get(e);n||(n=new xA,this.map.set(e,n)),n.add(t)}get(t,e){let n=t,o=this.map.get(n);return o?o.get(t,e):null}remove(t){let e=t.trackById;return this.map.get(e).remove(t)&&this.map.delete(e),t}get isEmpty(){return this.map.size===0}clear(){this.map.clear()}};function k3(r,t,e){let n=r.previousIndex;if(n===null)return n;let o=0;return e&&n<e.length&&(o=e[n]),n+t+o}function N3(){return new iR([new mA])}var iR=(()=>{let t=class t{constructor(n){this.factories=n}static create(n,o){if(o!=null){let s=o.factories.slice();n=n.concat(s)}return new t(n)}static extend(n){return{provide:t,useFactory:o=>t.create(n,o||N3()),deps:[[t,new B3,new wA]]}}find(n){let o=this.factories.find(s=>s.supports(n));if(o!=null)return o;throw new gt(901,!1)}};t.\u0275prov=Qe({token:t,providedIn:"root",factory:N3});let r=t;return r})();function VB(r){try{let{rootComponent:t,appProviders:e,platformProviders:n}=r,o=cde(n),s=[PB({}),{provide:sv,useExisting:sde},...e||[]],i=new t0({providers:s,parent:o,debugName:"",runEnvironmentInitializers:!1});return ade({r3Injector:i.injector,platformInjector:o,rootComponent:t})}catch(t){return Promise.reject(t)}}var UB=new Ot("");var XB=null;function Ym(){return XB}function YB(r){XB??=r}var C0=class{};var Vs=new Ot(""),ZB=(()=>{let t=class t{historyGo(n){throw new Error("")}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=Qe({token:t,factory:()=>We(vde),providedIn:"platform"});let r=t;return r})();var vde=(()=>{let t=class t extends ZB{constructor(){super(),this._doc=We(Vs),this._location=window.location,this._history=window.history}getBaseHrefFromDOM(){return Ym().getBaseHref(this._doc)}onPopState(n){let o=Ym().getGlobalEventTarget(this._doc,"window");return o.addEventListener("popstate",n,!1),()=>o.removeEventListener("popstate",n)}onHashChange(n){let o=Ym().getGlobalEventTarget(this._doc,"window");return o.addEventListener("hashchange",n,!1),()=>o.removeEventListener("hashchange",n)}get href(){return this._location.href}get protocol(){return this._location.protocol}get hostname(){return this._location.hostname}get port(){return this._location.port}get pathname(){return this._location.pathname}get search(){return this._location.search}get hash(){return this._location.hash}set pathname(n){this._location.pathname=n}pushState(n,o,s){this._history.pushState(n,o,s)}replaceState(n,o,s){this._history.replaceState(n,o,s)}forward(){this._history.forward()}back(){this._history.back()}historyGo(n=0){this._history.go(n)}getState(){return this._history.state}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=Qe({token:t,factory:()=>new t,providedIn:"platform"});let r=t;return r})();function QB(r,t){if(r.length==0)return t;if(t.length==0)return r;let e=0;return r.endsWith("/")&&e++,t.startsWith("/")&&e++,e==2?r+t.substring(1):e==1?r+t:r+"/"+t}function GB(r){let t=r.match(/#|\?|$/),e=t&&t.index||r.length,n=e-(r[e-1]==="/"?1:0);return r.slice(0,n)+r.slice(e)}function jf(r){return r&&r[0]!=="?"?"?"+r:r}var I0=(()=>{let t=class t{historyGo(n){throw new Error("")}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=Qe({token:t,factory:()=>We(JB),providedIn:"root"});let r=t;return r})(),bde=new Ot(""),JB=(()=>{let t=class t extends I0{constructor(n,o){super(),this._platformLocation=n,this._removeListenerFns=[],this._baseHref=o??this._platformLocation.getBaseHrefFromDOM()??We(Vs).location?.origin??""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(n){this._removeListenerFns.push(this._platformLocation.onPopState(n),this._platformLocation.onHashChange(n))}getBaseHref(){return this._baseHref}prepareExternalUrl(n){return QB(this._baseHref,n)}path(n=!1){let o=this._platformLocation.pathname+jf(this._platformLocation.search),s=this._platformLocation.hash;return s&&n?`${o}${s}`:o}pushState(n,o,s,i){let a=this.prepareExternalUrl(s+jf(i));this._platformLocation.pushState(n,o,a)}replaceState(n,o,s,i){let a=this.prepareExternalUrl(s+jf(i));this._platformLocation.replaceState(n,o,a)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(n=0){this._platformLocation.historyGo?.(n)}};t.\u0275fac=function(o){return new(o||t)(St(ZB),St(bde,8))},t.\u0275prov=Qe({token:t,factory:t.\u0275fac,providedIn:"root"});let r=t;return r})();var mv=(()=>{let t=class t{constructor(n){this._subject=new dn,this._urlChangeListeners=[],this._urlChangeSubscription=null,this._locationStrategy=n;let o=this._locationStrategy.getBaseHref();this._basePath=Sde(GB(WB(o))),this._locationStrategy.onPopState(s=>{this._subject.emit({url:this.path(!0),pop:!0,state:s.state,type:s.type})})}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}path(n=!1){return this.normalize(this._locationStrategy.path(n))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(n,o=""){return this.path()==this.normalize(n+jf(o))}normalize(n){return t.stripTrailingSlash(Cde(this._basePath,WB(n)))}prepareExternalUrl(n){return n&&n[0]!=="/"&&(n="/"+n),this._locationStrategy.prepareExternalUrl(n)}go(n,o="",s=null){this._locationStrategy.pushState(s,"",n,o),this._notifyUrlChangeListeners(this.prepareExternalUrl(n+jf(o)),s)}replaceState(n,o="",s=null){this._locationStrategy.replaceState(s,"",n,o),this._notifyUrlChangeListeners(this.prepareExternalUrl(n+jf(o)),s)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(n=0){this._locationStrategy.historyGo?.(n)}onUrlChange(n){return this._urlChangeListeners.push(n),this._urlChangeSubscription??=this.subscribe(o=>{this._notifyUrlChangeListeners(o.url,o.state)}),()=>{let o=this._urlChangeListeners.indexOf(n);this._urlChangeListeners.splice(o,1),this._urlChangeListeners.length===0&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(n="",o){this._urlChangeListeners.forEach(s=>s(n,o))}subscribe(n,o,s){return this._subject.subscribe({next:n,error:o,complete:s})}};t.normalizeQueryParams=jf,t.joinWithSlash=QB,t.stripTrailingSlash=GB,t.\u0275fac=function(o){return new(o||t)(St(I0))},t.\u0275prov=Qe({token:t,factory:()=>wde(),providedIn:"root"});let r=t;return r})();function wde(){return new mv(St(I0))}function Cde(r,t){if(!r||!t.startsWith(r))return t;let e=t.substring(r.length);return e===""||["/",";","?","#"].includes(e[0])?e:t}function WB(r){return r.replace(/\/index.html$/,"")}function Sde(r){if(new RegExp("^(https?:)?//").test(r)){let[,e]=r.split(/\/\/[^\/]+/);return e}return r}function eV(r,t){t=encodeURIComponent(t);for(let e of r.split(";")){let n=e.indexOf("="),[o,s]=n==-1?[e,""]:[e.slice(0,n),e.slice(n+1)];if(o.trim()===t)return decodeURIComponent(s)}return null}var uR=/\s+/,jB=[],T0=(()=>{let t=class t{constructor(n,o){this._ngEl=n,this._renderer=o,this.initialClasses=jB,this.stateMap=new Map}set klass(n){this.initialClasses=n!=null?n.trim().split(uR):jB}set ngClass(n){this.rawClass=typeof n=="string"?n.trim().split(uR):n}ngDoCheck(){for(let o of this.initialClasses)this._updateState(o,!0);let n=this.rawClass;if(Array.isArray(n)||n instanceof Set)for(let o of n)this._updateState(o,!0);else if(n!=null)for(let o of Object.keys(n))this._updateState(o,!!n[o]);this._applyStateDiff()}_updateState(n,o){let s=this.stateMap.get(n);s!==void 0?(s.enabled!==o&&(s.changed=!0,s.enabled=o),s.touched=!0):this.stateMap.set(n,{enabled:o,changed:!0,touched:!0})}_applyStateDiff(){for(let n of this.stateMap){let o=n[0],s=n[1];s.changed?(this._toggleClass(o,s.enabled),s.changed=!1):s.touched||(s.enabled&&this._toggleClass(o,!1),this.stateMap.delete(o)),s.touched=!1}}_toggleClass(n,o){n=n.trim(),n.length>0&&n.split(uR).forEach(s=>{o?this._renderer.addClass(this._ngEl.nativeElement,s):this._renderer.removeClass(this._ngEl.nativeElement,s)})}};t.\u0275fac=function(o){return new(o||t)(it(vp),it(x0))},t.\u0275dir=Wm({type:t,selectors:[["","ngClass",""]],inputs:{klass:[0,"class","klass"],ngClass:"ngClass"},standalone:!0});let r=t;return r})();var lR=class{constructor(t,e,n,o){this.$implicit=t,this.ngForOf=e,this.index=n,this.count=o}get first(){return this.index===0}get last(){return this.index===this.count-1}get even(){return this.index%2===0}get odd(){return!this.even}},tV=(()=>{let t=class t{set ngForOf(n){this._ngForOf=n,this._ngForOfDirty=!0}set ngForTrackBy(n){this._trackByFn=n}get ngForTrackBy(){return this._trackByFn}constructor(n,o,s){this._viewContainer=n,this._template=o,this._differs=s,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForTemplate(n){n&&(this._template=n)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;let n=this._ngForOf;if(!this._differ&&n)if(0)try{}catch{}else this._differ=this._differs.find(n).create(this.ngForTrackBy)}if(this._differ){let n=this._differ.diff(this._ngForOf);n&&this._applyChanges(n)}}_applyChanges(n){let o=this._viewContainer;n.forEachOperation((s,i,a)=>{if(s.previousIndex==null)o.createEmbeddedView(this._template,new lR(s.item,this._ngForOf,-1,-1),a===null?void 0:a);else if(a==null)o.remove(i===null?void 0:i);else if(i!==null){let u=o.get(i);o.move(u,a),HB(u,s)}});for(let s=0,i=o.length;s<i;s++){let u=o.get(s).context;u.index=s,u.count=i,u.ngForOf=this._ngForOf}n.forEachIdentityChange(s=>{let i=o.get(s.currentIndex);HB(i,s)})}static ngTemplateContextGuard(n,o){return!0}};t.\u0275fac=function(o){return new(o||t)(it(bp),it(zf),it(iR))},t.\u0275dir=Wm({type:t,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"},standalone:!0});let r=t;return r})();function HB(r,t){r.context.$implicit=t.item}var wp=(()=>{let t=class t{constructor(n,o){this._viewContainer=n,this._context=new cR,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=o}set ngIf(n){this._context.$implicit=this._context.ngIf=n,this._updateView()}set ngIfThen(n){qB("ngIfThen",n),this._thenTemplateRef=n,this._thenViewRef=null,this._updateView()}set ngIfElse(n){qB("ngIfElse",n),this._elseTemplateRef=n,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(n,o){return!0}};t.\u0275fac=function(o){return new(o||t)(it(bp),it(zf))},t.\u0275dir=Wm({type:t,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"},standalone:!0});let r=t;return r})(),cR=class{constructor(){this.$implicit=null,this.ngIf=null}};function qB(r,t){if(!!!(!t||t.createEmbeddedView))throw new Error(`${r} must be a TemplateRef, but received '${ms(t)}'.`)}var Ko=(()=>{let t=class t{};t.\u0275fac=function(o){return new(o||t)},t.\u0275mod=a0({type:t}),t.\u0275inj=o0({});let r=t;return r})(),rV="browser",Ide="server";function pR(r){return r===Ide}var S0=class{};var hR=class extends C0{constructor(){super(...arguments),this.supportsDOMEvents=!0}},mR=class r extends hR{static makeCurrent(){YB(new r)}onAndCancel(t,e,n){return t.addEventListener(e,n),()=>{t.removeEventListener(e,n)}}dispatchEvent(t,e){t.dispatchEvent(e)}remove(t){t.remove()}createElement(t,e){return e=e||this.getDefaultDocument(),e.createElement(t)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(t){return t.nodeType===Node.ELEMENT_NODE}isShadowRoot(t){return t instanceof DocumentFragment}getGlobalEventTarget(t,e){return e==="window"?window:e==="document"?t:e==="body"?t.body:null}getBaseHref(t){let e=Tde();return e==null?null:_de(e)}resetBaseElement(){yv=null}getUserAgent(){return window.navigator.userAgent}getCookie(t){return eV(document.cookie,t)}},yv=null;function Tde(){return yv=yv||document.querySelector("base"),yv?yv.getAttribute("href"):null}function _de(r){return new URL(r,document.baseURI).pathname}var Ede=(()=>{let t=class t{build(){return new XMLHttpRequest}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=Qe({token:t,factory:t.\u0275fac});let r=t;return r})(),_0=new Ot(""),iV=(()=>{let t=class t{constructor(n,o){this._zone=o,this._eventNameToPlugin=new Map,n.forEach(s=>{s.manager=this}),this._plugins=n.slice().reverse()}addEventListener(n,o,s){return this._findPluginFor(o).addEventListener(n,o,s)}getZone(){return this._zone}_findPluginFor(n){let o=this._eventNameToPlugin.get(n);if(o)return o;if(o=this._plugins.find(i=>i.supports(n)),!o)throw new gt(5101,!1);return this._eventNameToPlugin.set(n,o),o}};t.\u0275fac=function(o){return new(o||t)(St(_0),St(Zn))},t.\u0275prov=Qe({token:t,factory:t.\u0275fac});let r=t;return r})(),xv=class{constructor(t){this._doc=t}},dR="ng-app-id",aV=(()=>{let t=class t{constructor(n,o,s,i={}){this.doc=n,this.appId=o,this.nonce=s,this.platformId=i,this.styleRef=new Map,this.hostNodes=new Set,this.styleNodesInDOM=this.collectServerRenderedStyles(),this.platformIsServer=pR(i),this.resetHostNodes()}addStyles(n){for(let o of n)this.changeUsageCount(o,1)===1&&this.onStyleAdded(o)}removeStyles(n){for(let o of n)this.changeUsageCount(o,-1)<=0&&this.onStyleRemoved(o)}ngOnDestroy(){let n=this.styleNodesInDOM;n&&(n.forEach(o=>o.remove()),n.clear());for(let o of this.getAllStyles())this.onStyleRemoved(o);this.resetHostNodes()}addHost(n){this.hostNodes.add(n);for(let o of this.getAllStyles())this.addStyleToHost(n,o)}removeHost(n){this.hostNodes.delete(n)}getAllStyles(){return this.styleRef.keys()}onStyleAdded(n){for(let o of this.hostNodes)this.addStyleToHost(o,n)}onStyleRemoved(n){let o=this.styleRef;o.get(n)?.elements?.forEach(s=>s.remove()),o.delete(n)}collectServerRenderedStyles(){let n=this.doc.head?.querySelectorAll(`style[${dR}="${this.appId}"]`);if(n?.length){let o=new Map;return n.forEach(s=>{s.textContent!=null&&o.set(s.textContent,s)}),o}return null}changeUsageCount(n,o){let s=this.styleRef;if(s.has(n)){let i=s.get(n);return i.usage+=o,i.usage}return s.set(n,{usage:o,elements:[]}),o}getStyleElement(n,o){let s=this.styleNodesInDOM,i=s?.get(o);if(i?.parentNode===n)return s.delete(o),i.removeAttribute(dR),i;{let a=this.doc.createElement("style");return this.nonce&&a.setAttribute("nonce",this.nonce),a.textContent=o,this.platformIsServer&&a.setAttribute(dR,this.appId),n.appendChild(a),a}}addStyleToHost(n,o){let s=this.getStyleElement(n,o),i=this.styleRef,a=i.get(o)?.elements;a?a.push(s):i.set(o,{elements:[s],usage:1})}resetHostNodes(){let n=this.hostNodes;n.clear(),n.add(this.doc.head)}};t.\u0275fac=function(o){return new(o||t)(St(Vs),St(zA),St(VA,8),St(Km))},t.\u0275prov=Qe({token:t,factory:t.\u0275fac});let r=t;return r})(),fR={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/Math/MathML"},yR=/%COMP%/g,uV="%COMP%",kde=`_nghost-${uV}`,Nde=`_ngcontent-${uV}`,Dde=!0,Ade=new Ot("",{providedIn:"root",factory:()=>Dde});function Rde(r){return Nde.replace(yR,r)}function Ode(r){return kde.replace(yR,r)}function lV(r,t){return t.map(e=>e.replace(yR,r))}var nV=(()=>{let t=class t{constructor(n,o,s,i,a,u,l,c=null){this.eventManager=n,this.sharedStylesHost=o,this.appId=s,this.removeStylesOnCompDestroy=i,this.doc=a,this.platformId=u,this.ngZone=l,this.nonce=c,this.rendererByCompId=new Map,this.platformIsServer=pR(u),this.defaultRenderer=new vv(n,a,l,this.platformIsServer)}createRenderer(n,o){if(!n||!o)return this.defaultRenderer;this.platformIsServer&&o.encapsulation===Eu.ShadowDom&&(o=mn(et({},o),{encapsulation:Eu.Emulated}));let s=this.getOrCreateRenderer(n,o);return s instanceof E0?s.applyToHost(n):s instanceof bv&&s.applyStyles(),s}getOrCreateRenderer(n,o){let s=this.rendererByCompId,i=s.get(o.id);if(!i){let a=this.doc,u=this.ngZone,l=this.eventManager,c=this.sharedStylesHost,p=this.removeStylesOnCompDestroy,d=this.platformIsServer;switch(o.encapsulation){case Eu.Emulated:i=new E0(l,c,o,this.appId,p,a,u,d);break;case Eu.ShadowDom:return new gR(l,c,n,o,a,u,this.nonce,d);default:i=new bv(l,c,o,p,a,u,d);break}s.set(o.id,i)}return i}ngOnDestroy(){this.rendererByCompId.clear()}};t.\u0275fac=function(o){return new(o||t)(St(iV),St(aV),St(zA),St(Ade),St(Vs),St(Km),St(Zn),St(VA))},t.\u0275prov=Qe({token:t,factory:t.\u0275fac});let r=t;return r})(),vv=class{constructor(t,e,n,o){this.eventManager=t,this.doc=e,this.ngZone=n,this.platformIsServer=o,this.data=Object.create(null),this.throwOnSyntheticProps=!0,this.destroyNode=null}destroy(){}createElement(t,e){return e?this.doc.createElementNS(fR[e]||e,t):this.doc.createElement(t)}createComment(t){return this.doc.createComment(t)}createText(t){return this.doc.createTextNode(t)}appendChild(t,e){(oV(t)?t.content:t).appendChild(e)}insertBefore(t,e,n){t&&(oV(t)?t.content:t).insertBefore(e,n)}removeChild(t,e){e.remove()}selectRootElement(t,e){let n=typeof t=="string"?this.doc.querySelector(t):t;if(!n)throw new gt(-5104,!1);return e||(n.textContent=""),n}parentNode(t){return t.parentNode}nextSibling(t){return t.nextSibling}setAttribute(t,e,n,o){if(o){e=o+":"+e;let s=fR[o];s?t.setAttributeNS(s,e,n):t.setAttribute(e,n)}else t.setAttribute(e,n)}removeAttribute(t,e,n){if(n){let o=fR[n];o?t.removeAttributeNS(o,e):t.removeAttribute(`${n}:${e}`)}else t.removeAttribute(e)}addClass(t,e){t.classList.add(e)}removeClass(t,e){t.classList.remove(e)}setStyle(t,e,n,o){o&(Uf.DashCase|Uf.Important)?t.style.setProperty(e,n,o&Uf.Important?"important":""):t.style[e]=n}removeStyle(t,e,n){n&Uf.DashCase?t.style.removeProperty(e):t.style[e]=""}setProperty(t,e,n){t!=null&&(t[e]=n)}setValue(t,e){t.nodeValue=e}listen(t,e,n){if(typeof t=="string"&&(t=Ym().getGlobalEventTarget(this.doc,t),!t))throw new Error(`Unsupported event target ${t} for event ${e}`);return this.eventManager.addEventListener(t,e,this.decoratePreventDefault(n))}decoratePreventDefault(t){return e=>{if(e==="__ngUnwrap__")return t;(this.platformIsServer?this.ngZone.runGuarded(()=>t(e)):t(e))===!1&&e.preventDefault()}}};function oV(r){return r.tagName==="TEMPLATE"&&r.content!==void 0}var gR=class extends vv{constructor(t,e,n,o,s,i,a,u){super(t,s,i,u),this.sharedStylesHost=e,this.hostEl=n,this.shadowRoot=n.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);let l=lV(o.id,o.styles);for(let c of l){let p=document.createElement("style");a&&p.setAttribute("nonce",a),p.textContent=c,this.shadowRoot.appendChild(p)}}nodeOrShadowRoot(t){return t===this.hostEl?this.shadowRoot:t}appendChild(t,e){return super.appendChild(this.nodeOrShadowRoot(t),e)}insertBefore(t,e,n){return super.insertBefore(this.nodeOrShadowRoot(t),e,n)}removeChild(t,e){return super.removeChild(null,e)}parentNode(t){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}},bv=class extends vv{constructor(t,e,n,o,s,i,a,u){super(t,s,i,a),this.sharedStylesHost=e,this.removeStylesOnCompDestroy=o,this.styles=u?lV(u,n.styles):n.styles}applyStyles(){this.sharedStylesHost.addStyles(this.styles)}destroy(){this.removeStylesOnCompDestroy&&this.sharedStylesHost.removeStyles(this.styles)}},E0=class extends bv{constructor(t,e,n,o,s,i,a,u){let l=o+"-"+n.id;super(t,e,n,s,i,a,u,l),this.contentAttr=Rde(l),this.hostAttr=Ode(l)}applyToHost(t){this.applyStyles(),this.setAttribute(t,this.hostAttr,"")}createElement(t,e){let n=super.createElement(t,e);return super.setAttribute(n,this.contentAttr,""),n}},Mde=(()=>{let t=class t extends xv{constructor(n){super(n)}supports(n){return!0}addEventListener(n,o,s){return n.addEventListener(o,s,!1),()=>this.removeEventListener(n,o,s)}removeEventListener(n,o,s){return n.removeEventListener(o,s)}};t.\u0275fac=function(o){return new(o||t)(St(Vs))},t.\u0275prov=Qe({token:t,factory:t.\u0275fac});let r=t;return r})(),Fde=(()=>{let t=class t extends xv{constructor(n){super(n),this.delegate=We(UB,{optional:!0})}supports(n){return this.delegate?this.delegate.supports(n):!1}addEventListener(n,o,s){return this.delegate.addEventListener(n,o,s)}removeEventListener(n,o,s){return this.delegate.removeEventListener(n,o,s)}};t.\u0275fac=function(o){return new(o||t)(St(Vs))},t.\u0275prov=Qe({token:t,factory:t.\u0275fac});let r=t;return r})(),sV=["alt","control","meta","shift"],$de={"\b":"Backspace","	":"Tab","\x7F":"Delete","\x1B":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},Pde={alt:r=>r.altKey,control:r=>r.ctrlKey,meta:r=>r.metaKey,shift:r=>r.shiftKey},Lde=(()=>{let t=class t extends xv{constructor(n){super(n)}supports(n){return t.parseEventName(n)!=null}addEventListener(n,o,s){let i=t.parseEventName(o),a=t.eventCallback(i.fullKey,s,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>Ym().onAndCancel(n,i.domEventName,a))}static parseEventName(n){let o=n.toLowerCase().split("."),s=o.shift();if(o.length===0||!(s==="keydown"||s==="keyup"))return null;let i=t._normalizeKey(o.pop()),a="",u=o.indexOf("code");if(u>-1&&(o.splice(u,1),a="code."),sV.forEach(c=>{let p=o.indexOf(c);p>-1&&(o.splice(p,1),a+=c+".")}),a+=i,o.length!=0||i.length===0)return null;let l={};return l.domEventName=s,l.fullKey=a,l}static matchEventFullKeyCode(n,o){let s=$de[n.key]||n.key,i="";return o.indexOf("code.")>-1&&(s=n.code,i="code."),s==null||!s?!1:(s=s.toLowerCase(),s===" "?s="space":s==="."&&(s="dot"),sV.forEach(a=>{if(a!==s){let u=Pde[a];u(n)&&(i+=a+".")}}),i+=s,i===o)}static eventCallback(n,o,s){return i=>{t.matchEventFullKeyCode(i,n)&&s.runGuarded(()=>o(i))}}static _normalizeKey(n){return n==="esc"?"escape":n}};t.\u0275fac=function(o){return new(o||t)(St(Vs))},t.\u0275prov=Qe({token:t,factory:t.\u0275fac});let r=t;return r})();function cV(r,t){return VB(et({rootComponent:r},zde(t)))}function zde(r){return{appProviders:[...Wde,...r?.providers??[]],platformProviders:Gde}}function Bde(){mR.makeCurrent()}function Vde(){return new mp}function Ude(){return jz(document),document}var Gde=[{provide:Km,useValue:rV},{provide:BA,useValue:Bde,multi:!0},{provide:Vs,useFactory:Ude,deps:[]}];var Wde=[{provide:l0,useValue:"root"},{provide:mp,useFactory:Vde,deps:[]},{provide:_0,useClass:Mde,multi:!0,deps:[Vs,Zn,Km]},{provide:_0,useClass:Lde,multi:!0,deps:[Vs]},{provide:_0,useClass:Fde,multi:!0},nV,aV,iV,{provide:Um,useExisting:nV},{provide:S0,useClass:Ede,deps:[]},[]];var pV=(()=>{let t=class t{constructor(n){this._doc=n}getTitle(){return this._doc.title}setTitle(n){this._doc.title=n||""}};t.\u0275fac=function(o){return new(o||t)(St(Vs))},t.\u0275prov=Qe({token:t,factory:t.\u0275fac,providedIn:"root"});let r=t;return r})();var At="primary",Pv=Symbol("RouteTitle"),CR=class{constructor(t){this.params=t||{}}has(t){return Object.prototype.hasOwnProperty.call(this.params,t)}get(t){if(this.has(t)){let e=this.params[t];return Array.isArray(e)?e[0]:e}return null}getAll(t){if(this.has(t)){let e=this.params[t];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}};function rg(r){return new CR(r)}function Hde(r,t,e){let n=e.path.split("/");if(n.length>r.length||e.pathMatch==="full"&&(t.hasChildren()||n.length<r.length))return null;let o={};for(let s=0;s<n.length;s++){let i=n[s],a=r[s];if(i[0]===":")o[i.substring(1)]=a;else if(i!==a.path)return null}return{consumed:r.slice(0,n.length),posParams:o}}function qde(r,t){if(r.length!==t.length)return!1;for(let e=0;e<r.length;++e)if(!Du(r[e],t[e]))return!1;return!0}function Du(r,t){let e=r?SR(r):void 0,n=t?SR(t):void 0;if(!e||!n||e.length!=n.length)return!1;let o;for(let s=0;s<e.length;s++)if(o=e[s],!vV(r[o],t[o]))return!1;return!0}function SR(r){return[...Object.keys(r),...Object.getOwnPropertySymbols(r)]}function vV(r,t){if(Array.isArray(r)&&Array.isArray(t)){if(r.length!==t.length)return!1;let e=[...r].sort(),n=[...t].sort();return e.every((o,s)=>n[s]===o)}else return r===t}function bV(r){return r.length>0?r[r.length-1]:null}function Cp(r){return dD(r)?r:hv(r)?Xn(Promise.resolve(r)):Nt(r)}var Kde={exact:CV,subset:SV},wV={exact:Xde,subset:Yde,ignored:()=>!0};function dV(r,t,e){return Kde[e.paths](r.root,t.root,e.matrixParams)&&wV[e.queryParams](r.queryParams,t.queryParams)&&!(e.fragment==="exact"&&r.fragment!==t.fragment)}function Xde(r,t){return Du(r,t)}function CV(r,t,e){if(!qf(r.segments,t.segments)||!D0(r.segments,t.segments,e)||r.numberOfChildren!==t.numberOfChildren)return!1;for(let n in t.children)if(!r.children[n]||!CV(r.children[n],t.children[n],e))return!1;return!0}function Yde(r,t){return Object.keys(t).length<=Object.keys(r).length&&Object.keys(t).every(e=>vV(r[e],t[e]))}function SV(r,t,e){return IV(r,t,t.segments,e)}function IV(r,t,e,n){if(r.segments.length>e.length){let o=r.segments.slice(0,e.length);return!(!qf(o,e)||t.hasChildren()||!D0(o,e,n))}else if(r.segments.length===e.length){if(!qf(r.segments,e)||!D0(r.segments,e,n))return!1;for(let o in t.children)if(!r.children[o]||!SV(r.children[o],t.children[o],n))return!1;return!0}else{let o=e.slice(0,r.segments.length),s=e.slice(r.segments.length);return!qf(r.segments,o)||!D0(r.segments,o,n)||!r.children[At]?!1:IV(r.children[At],t,s,n)}}function D0(r,t,e){return t.every((n,o)=>wV[e](r[o].parameters,n.parameters))}var cc=class{constructor(t=new kr([],{}),e={},n=null){this.root=t,this.queryParams=e,this.fragment=n}get queryParamMap(){return this._queryParamMap??=rg(this.queryParams),this._queryParamMap}toString(){return Jde.serialize(this)}},kr=class{constructor(t,e){this.segments=t,this.children=e,this.parent=null,Object.values(e).forEach(n=>n.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return A0(this)}},Hf=class{constructor(t,e){this.path=t,this.parameters=e}get parameterMap(){return this._parameterMap??=rg(this.parameters),this._parameterMap}toString(){return _V(this)}};function Zde(r,t){return qf(r,t)&&r.every((e,n)=>Du(e.parameters,t[n].parameters))}function qf(r,t){return r.length!==t.length?!1:r.every((e,n)=>e.path===t[n].path)}function Qde(r,t){let e=[];return Object.entries(r.children).forEach(([n,o])=>{n===At&&(e=e.concat(t(o,n)))}),Object.entries(r.children).forEach(([n,o])=>{n!==At&&(e=e.concat(t(o,n)))}),e}var XR=(()=>{let t=class t{};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=Qe({token:t,factory:()=>new Ev,providedIn:"root"});let r=t;return r})(),Ev=class{parse(t){let e=new TR(t);return new cc(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(t){let e=`/${wv(t.root,!0)}`,n=rfe(t.queryParams),o=typeof t.fragment=="string"?`#${efe(t.fragment)}`:"";return`${e}${n}${o}`}},Jde=new Ev;function A0(r){return r.segments.map(t=>_V(t)).join("/")}function wv(r,t){if(!r.hasChildren())return A0(r);if(t){let e=r.children[At]?wv(r.children[At],!1):"",n=[];return Object.entries(r.children).forEach(([o,s])=>{o!==At&&n.push(`${o}:${wv(s,!1)}`)}),n.length>0?`${e}(${n.join("//")})`:e}else{let e=Qde(r,(n,o)=>o===At?[wv(r.children[At],!1)]:[`${o}:${wv(n,!1)}`]);return Object.keys(r.children).length===1&&r.children[At]!=null?`${A0(r)}/${e[0]}`:`${A0(r)}/(${e.join("//")})`}}function TV(r){return encodeURIComponent(r).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function k0(r){return TV(r).replace(/%3B/gi,";")}function efe(r){return encodeURI(r)}function IR(r){return TV(r).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function R0(r){return decodeURIComponent(r)}function fV(r){return R0(r.replace(/\+/g,"%20"))}function _V(r){return`${IR(r.path)}${tfe(r.parameters)}`}function tfe(r){return Object.entries(r).map(([t,e])=>`;${IR(t)}=${IR(e)}`).join("")}function rfe(r){let t=Object.entries(r).map(([e,n])=>Array.isArray(n)?n.map(o=>`${k0(e)}=${k0(o)}`).join("&"):`${k0(e)}=${k0(n)}`).filter(e=>e);return t.length?`?${t.join("&")}`:""}var nfe=/^[^\/()?;#]+/;function xR(r){let t=r.match(nfe);return t?t[0]:""}var ofe=/^[^\/()?;=#]+/;function sfe(r){let t=r.match(ofe);return t?t[0]:""}var ife=/^[^=?&#]+/;function afe(r){let t=r.match(ife);return t?t[0]:""}var ufe=/^[^&#]+/;function lfe(r){let t=r.match(ufe);return t?t[0]:""}var TR=class{constructor(t){this.url=t,this.remaining=t}parseRootSegment(){return this.consumeOptional("/"),this.remaining===""||this.peekStartsWith("?")||this.peekStartsWith("#")?new kr([],{}):new kr([],this.parseChildren())}parseQueryParams(){let t={};if(this.consumeOptional("?"))do this.parseQueryParam(t);while(this.consumeOptional("&"));return t}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(this.remaining==="")return{};this.consumeOptional("/");let t=[];for(this.peekStartsWith("(")||t.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),t.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let n={};return this.peekStartsWith("(")&&(n=this.parseParens(!1)),(t.length>0||Object.keys(e).length>0)&&(n[At]=new kr(t,e)),n}parseSegment(){let t=xR(this.remaining);if(t===""&&this.peekStartsWith(";"))throw new gt(4009,!1);return this.capture(t),new Hf(R0(t),this.parseMatrixParams())}parseMatrixParams(){let t={};for(;this.consumeOptional(";");)this.parseParam(t);return t}parseParam(t){let e=sfe(this.remaining);if(!e)return;this.capture(e);let n="";if(this.consumeOptional("=")){let o=xR(this.remaining);o&&(n=o,this.capture(n))}t[R0(e)]=R0(n)}parseQueryParam(t){let e=afe(this.remaining);if(!e)return;this.capture(e);let n="";if(this.consumeOptional("=")){let i=lfe(this.remaining);i&&(n=i,this.capture(n))}let o=fV(e),s=fV(n);if(t.hasOwnProperty(o)){let i=t[o];Array.isArray(i)||(i=[i],t[o]=i),i.push(s)}else t[o]=s}parseParens(t){let e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){let n=xR(this.remaining),o=this.remaining[n.length];if(o!=="/"&&o!==")"&&o!==";")throw new gt(4010,!1);let s;n.indexOf(":")>-1?(s=n.slice(0,n.indexOf(":")),this.capture(s),this.capture(":")):t&&(s=At);let i=this.parseChildren();e[s]=Object.keys(i).length===1?i[At]:new kr([],i),this.consumeOptional("//")}return e}peekStartsWith(t){return this.remaining.startsWith(t)}consumeOptional(t){return this.peekStartsWith(t)?(this.remaining=this.remaining.substring(t.length),!0):!1}capture(t){if(!this.consumeOptional(t))throw new gt(4011,!1)}};function EV(r){return r.segments.length>0?new kr([],{[At]:r}):r}function kV(r){let t={};for(let[n,o]of Object.entries(r.children)){let s=kV(o);if(n===At&&s.segments.length===0&&s.hasChildren())for(let[i,a]of Object.entries(s.children))t[i]=a;else(s.segments.length>0||s.hasChildren())&&(t[n]=s)}let e=new kr(r.segments,t);return cfe(e)}function cfe(r){if(r.numberOfChildren===1&&r.children[At]){let t=r.children[At];return new kr(r.segments.concat(t.segments),t.children)}return r}function kv(r){return r instanceof cc}function pfe(r,t,e=null,n=null){let o=NV(r);return DV(o,t,e,n)}function NV(r){let t;function e(s){let i={};for(let u of s.children){let l=e(u);i[u.outlet]=l}let a=new kr(s.url,i);return s===r&&(t=a),a}let n=e(r.root),o=EV(n);return t??o}function DV(r,t,e,n){let o=r;for(;o.parent;)o=o.parent;if(t.length===0)return vR(o,o,o,e,n);let s=dfe(t);if(s.toRoot())return vR(o,o,new kr([],{}),e,n);let i=ffe(s,o,r),a=i.processChildren?Iv(i.segmentGroup,i.index,s.commands):RV(i.segmentGroup,i.index,s.commands);return vR(o,i.segmentGroup,a,e,n)}function O0(r){return typeof r=="object"&&r!=null&&!r.outlets&&!r.segmentPath}function Nv(r){return typeof r=="object"&&r!=null&&r.outlets}function vR(r,t,e,n,o){let s={};n&&Object.entries(n).forEach(([u,l])=>{s[u]=Array.isArray(l)?l.map(c=>`${c}`):`${l}`});let i;r===t?i=e:i=AV(r,t,e);let a=EV(kV(i));return new cc(a,s,o)}function AV(r,t,e){let n={};return Object.entries(r.children).forEach(([o,s])=>{s===t?n[o]=e:n[o]=AV(s,t,e)}),new kr(r.segments,n)}var M0=class{constructor(t,e,n){if(this.isAbsolute=t,this.numberOfDoubleDots=e,this.commands=n,t&&n.length>0&&O0(n[0]))throw new gt(4003,!1);let o=n.find(Nv);if(o&&o!==bV(n))throw new gt(4004,!1)}toRoot(){return this.isAbsolute&&this.commands.length===1&&this.commands[0]=="/"}};function dfe(r){if(typeof r[0]=="string"&&r.length===1&&r[0]==="/")return new M0(!0,0,r);let t=0,e=!1,n=r.reduce((o,s,i)=>{if(typeof s=="object"&&s!=null){if(s.outlets){let a={};return Object.entries(s.outlets).forEach(([u,l])=>{a[u]=typeof l=="string"?l.split("/"):l}),[...o,{outlets:a}]}if(s.segmentPath)return[...o,s.segmentPath]}return typeof s!="string"?[...o,s]:i===0?(s.split("/").forEach((a,u)=>{u==0&&a==="."||(u==0&&a===""?e=!0:a===".."?t++:a!=""&&o.push(a))}),o):[...o,s]},[]);return new M0(e,t,n)}var Jm=class{constructor(t,e,n){this.segmentGroup=t,this.processChildren=e,this.index=n}};function ffe(r,t,e){if(r.isAbsolute)return new Jm(t,!0,0);if(!e)return new Jm(t,!1,NaN);if(e.parent===null)return new Jm(e,!0,0);let n=O0(r.commands[0])?0:1,o=e.segments.length-1+n;return hfe(e,o,r.numberOfDoubleDots)}function hfe(r,t,e){let n=r,o=t,s=e;for(;s>o;){if(s-=o,n=n.parent,!n)throw new gt(4005,!1);o=n.segments.length}return new Jm(n,!1,o-s)}function mfe(r){return Nv(r[0])?r[0].outlets:{[At]:r}}function RV(r,t,e){if(r??=new kr([],{}),r.segments.length===0&&r.hasChildren())return Iv(r,t,e);let n=gfe(r,t,e),o=e.slice(n.commandIndex);if(n.match&&n.pathIndex<r.segments.length){let s=new kr(r.segments.slice(0,n.pathIndex),{});return s.children[At]=new kr(r.segments.slice(n.pathIndex),r.children),Iv(s,0,o)}else return n.match&&o.length===0?new kr(r.segments,{}):n.match&&!r.hasChildren()?_R(r,t,e):n.match?Iv(r,0,o):_R(r,t,e)}function Iv(r,t,e){if(e.length===0)return new kr(r.segments,{});{let n=mfe(e),o={};if(Object.keys(n).some(s=>s!==At)&&r.children[At]&&r.numberOfChildren===1&&r.children[At].segments.length===0){let s=Iv(r.children[At],t,e);return new kr(r.segments,s.children)}return Object.entries(n).forEach(([s,i])=>{typeof i=="string"&&(i=[i]),i!==null&&(o[s]=RV(r.children[s],t,i))}),Object.entries(r.children).forEach(([s,i])=>{n[s]===void 0&&(o[s]=i)}),new kr(r.segments,o)}}function gfe(r,t,e){let n=0,o=t,s={match:!1,pathIndex:0,commandIndex:0};for(;o<r.segments.length;){if(n>=e.length)return s;let i=r.segments[o],a=e[n];if(Nv(a))break;let u=`${a}`,l=n<e.length-1?e[n+1]:null;if(o>0&&u===void 0)break;if(u&&l&&typeof l=="object"&&l.outlets===void 0){if(!mV(u,l,i))return s;n+=2}else{if(!mV(u,{},i))return s;n++}o++}return{match:!0,pathIndex:o,commandIndex:n}}function _R(r,t,e){let n=r.segments.slice(0,t),o=0;for(;o<e.length;){let s=e[o];if(Nv(s)){let u=yfe(s.outlets);return new kr(n,u)}if(o===0&&O0(e[0])){let u=r.segments[t];n.push(new Hf(u.path,hV(e[0]))),o++;continue}let i=Nv(s)?s.outlets[At]:`${s}`,a=o<e.length-1?e[o+1]:null;i&&a&&O0(a)?(n.push(new Hf(i,hV(a))),o+=2):(n.push(new Hf(i,{})),o++)}return new kr(n,{})}function yfe(r){let t={};return Object.entries(r).forEach(([e,n])=>{typeof n=="string"&&(n=[n]),n!==null&&(t[e]=_R(new kr([],{}),0,n))}),t}function hV(r){let t={};return Object.entries(r).forEach(([e,n])=>t[e]=`${n}`),t}function mV(r,t,e){return r==e.path&&Du(t,e.parameters)}var Tv="imperative",bo=function(r){return r[r.NavigationStart=0]="NavigationStart",r[r.NavigationEnd=1]="NavigationEnd",r[r.NavigationCancel=2]="NavigationCancel",r[r.NavigationError=3]="NavigationError",r[r.RoutesRecognized=4]="RoutesRecognized",r[r.ResolveStart=5]="ResolveStart",r[r.ResolveEnd=6]="ResolveEnd",r[r.GuardsCheckStart=7]="GuardsCheckStart",r[r.GuardsCheckEnd=8]="GuardsCheckEnd",r[r.RouteConfigLoadStart=9]="RouteConfigLoadStart",r[r.RouteConfigLoadEnd=10]="RouteConfigLoadEnd",r[r.ChildActivationStart=11]="ChildActivationStart",r[r.ChildActivationEnd=12]="ChildActivationEnd",r[r.ActivationStart=13]="ActivationStart",r[r.ActivationEnd=14]="ActivationEnd",r[r.Scroll=15]="Scroll",r[r.NavigationSkipped=16]="NavigationSkipped",r}(bo||{}),pi=class{constructor(t,e){this.id=t,this.url=e}},Dv=class extends pi{constructor(t,e,n="imperative",o=null){super(t,e),this.type=bo.NavigationStart,this.navigationTrigger=n,this.restoredState=o}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}},pc=class extends pi{constructor(t,e,n){super(t,e),this.urlAfterRedirects=n,this.type=bo.NavigationEnd}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}},Gs=function(r){return r[r.Redirect=0]="Redirect",r[r.SupersededByNewNavigation=1]="SupersededByNewNavigation",r[r.NoDataFromResolver=2]="NoDataFromResolver",r[r.GuardRejected=3]="GuardRejected",r}(Gs||{}),ER=function(r){return r[r.IgnoredSameUrlNavigation=0]="IgnoredSameUrlNavigation",r[r.IgnoredByUrlHandlingStrategy=1]="IgnoredByUrlHandlingStrategy",r}(ER||{}),lc=class extends pi{constructor(t,e,n,o){super(t,e),this.reason=n,this.code=o,this.type=bo.NavigationCancel}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}},Kf=class extends pi{constructor(t,e,n,o){super(t,e),this.reason=n,this.code=o,this.type=bo.NavigationSkipped}},Av=class extends pi{constructor(t,e,n,o){super(t,e),this.error=n,this.target=o,this.type=bo.NavigationError}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}},F0=class extends pi{constructor(t,e,n,o){super(t,e),this.urlAfterRedirects=n,this.state=o,this.type=bo.RoutesRecognized}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}},kR=class extends pi{constructor(t,e,n,o){super(t,e),this.urlAfterRedirects=n,this.state=o,this.type=bo.GuardsCheckStart}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}},NR=class extends pi{constructor(t,e,n,o,s){super(t,e),this.urlAfterRedirects=n,this.state=o,this.shouldActivate=s,this.type=bo.GuardsCheckEnd}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}},DR=class extends pi{constructor(t,e,n,o){super(t,e),this.urlAfterRedirects=n,this.state=o,this.type=bo.ResolveStart}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}},AR=class extends pi{constructor(t,e,n,o){super(t,e),this.urlAfterRedirects=n,this.state=o,this.type=bo.ResolveEnd}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}},RR=class{constructor(t){this.route=t,this.type=bo.RouteConfigLoadStart}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}},OR=class{constructor(t){this.route=t,this.type=bo.RouteConfigLoadEnd}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}},MR=class{constructor(t){this.snapshot=t,this.type=bo.ChildActivationStart}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}},FR=class{constructor(t){this.snapshot=t,this.type=bo.ChildActivationEnd}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}},$R=class{constructor(t){this.snapshot=t,this.type=bo.ActivationStart}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}},PR=class{constructor(t){this.snapshot=t,this.type=bo.ActivationEnd}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}};var Rv=class{},ng=class{constructor(t,e){this.url=t,this.navigationBehaviorOptions=e}};function xfe(r,t){return r.providers&&!r._injector&&(r._injector=tR(r.providers,t,`Route: ${r.path}`)),r._injector??t}function Yi(r){return r.outlet||At}function vfe(r,t){let e=r.filter(n=>Yi(n)===t);return e.push(...r.filter(n=>Yi(n)!==t)),e}function Lv(r){if(!r)return null;if(r.routeConfig?._injector)return r.routeConfig._injector;for(let t=r.parent;t;t=t.parent){let e=t.routeConfig;if(e?._loadedInjector)return e._loadedInjector;if(e?._injector)return e._injector}return null}var LR=class{get injector(){return Lv(this.route?.snapshot)??this.rootInjector}set injector(t){}constructor(t){this.rootInjector=t,this.outlet=null,this.route=null,this.children=new U0(this.rootInjector),this.attachRef=null}},U0=(()=>{let t=class t{constructor(n){this.rootInjector=n,this.contexts=new Map}onChildOutletCreated(n,o){let s=this.getOrCreateContext(n);s.outlet=o,this.contexts.set(n,s)}onChildOutletDestroyed(n){let o=this.getContext(n);o&&(o.outlet=null,o.attachRef=null)}onOutletDeactivated(){let n=this.contexts;return this.contexts=new Map,n}onOutletReAttached(n){this.contexts=n}getOrCreateContext(n){let o=this.getContext(n);return o||(o=new LR(this.rootInjector),this.contexts.set(n,o)),o}getContext(n){return this.contexts.get(n)||null}};t.\u0275fac=function(o){return new(o||t)(St(ui))},t.\u0275prov=Qe({token:t,factory:t.\u0275fac,providedIn:"root"});let r=t;return r})(),$0=class{constructor(t){this._root=t}get root(){return this._root.value}parent(t){let e=this.pathFromRoot(t);return e.length>1?e[e.length-2]:null}children(t){let e=zR(t,this._root);return e?e.children.map(n=>n.value):[]}firstChild(t){let e=zR(t,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(t){let e=BR(t,this._root);return e.length<2?[]:e[e.length-2].children.map(o=>o.value).filter(o=>o!==t)}pathFromRoot(t){return BR(t,this._root).map(e=>e.value)}};function zR(r,t){if(r===t.value)return t;for(let e of t.children){let n=zR(r,e);if(n)return n}return null}function BR(r,t){if(r===t.value)return[t];for(let e of t.children){let n=BR(r,e);if(n.length)return n.unshift(t),n}return[]}var Us=class{constructor(t,e){this.value=t,this.children=e}toString(){return`TreeNode(${this.value})`}};function Qm(r){let t={};return r&&r.children.forEach(e=>t[e.value.outlet]=e),t}var P0=class extends $0{constructor(t,e){super(t),this.snapshot=e,YR(this,t)}toString(){return this.snapshot.toString()}};function OV(r){let t=bfe(r),e=new yo([new Hf("",{})]),n=new yo({}),o=new yo({}),s=new yo({}),i=new yo(""),a=new gs(e,n,s,i,o,At,r,t.root);return a.snapshot=t.root,new P0(new Us(a,[]),t)}function bfe(r){let t={},e={},n={},o="",s=new eg([],t,n,o,e,At,r,null,{});return new z0("",new Us(s,[]))}var gs=class{constructor(t,e,n,o,s,i,a,u){this.urlSubject=t,this.paramsSubject=e,this.queryParamsSubject=n,this.fragmentSubject=o,this.dataSubject=s,this.outlet=i,this.component=a,this._futureSnapshot=u,this.title=this.dataSubject?.pipe(Jt(l=>l[Pv]))??Nt(void 0),this.url=t,this.params=e,this.queryParams=n,this.fragment=o,this.data=s}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap??=this.params.pipe(Jt(t=>rg(t))),this._paramMap}get queryParamMap(){return this._queryParamMap??=this.queryParams.pipe(Jt(t=>rg(t))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}};function L0(r,t,e="emptyOnly"){let n,{routeConfig:o}=r;return t!==null&&(e==="always"||o?.path===""||!t.component&&!t.routeConfig?.loadComponent)?n={params:et(et({},t.params),r.params),data:et(et({},t.data),r.data),resolve:et(et(et(et({},r.data),t.data),o?.data),r._resolvedData)}:n={params:et({},r.params),data:et({},r.data),resolve:et(et({},r.data),r._resolvedData??{})},o&&FV(o)&&(n.resolve[Pv]=o.title),n}var eg=class{get title(){return this.data?.[Pv]}constructor(t,e,n,o,s,i,a,u,l){this.url=t,this.params=e,this.queryParams=n,this.fragment=o,this.data=s,this.outlet=i,this.component=a,this.routeConfig=u,this._resolve=l}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap??=rg(this.params),this._paramMap}get queryParamMap(){return this._queryParamMap??=rg(this.queryParams),this._queryParamMap}toString(){let t=this.url.map(n=>n.toString()).join("/"),e=this.routeConfig?this.routeConfig.path:"";return`Route(url:'${t}', path:'${e}')`}},z0=class extends $0{constructor(t,e){super(e),this.url=t,YR(this,e)}toString(){return MV(this._root)}};function YR(r,t){t.value._routerState=r,t.children.forEach(e=>YR(r,e))}function MV(r){let t=r.children.length>0?` { ${r.children.map(MV).join(", ")} } `:"";return`${r.value}${t}`}function bR(r){if(r.snapshot){let t=r.snapshot,e=r._futureSnapshot;r.snapshot=e,Du(t.queryParams,e.queryParams)||r.queryParamsSubject.next(e.queryParams),t.fragment!==e.fragment&&r.fragmentSubject.next(e.fragment),Du(t.params,e.params)||r.paramsSubject.next(e.params),qde(t.url,e.url)||r.urlSubject.next(e.url),Du(t.data,e.data)||r.dataSubject.next(e.data)}else r.snapshot=r._futureSnapshot,r.dataSubject.next(r._futureSnapshot.data)}function VR(r,t){let e=Du(r.params,t.params)&&Zde(r.url,t.url),n=!r.parent!=!t.parent;return e&&!n&&(!r.parent||VR(r.parent,t.parent))}function FV(r){return typeof r.title=="string"||r.title===null}var ZR=(()=>{let t=class t{constructor(){this.activated=null,this._activatedRoute=null,this.name=At,this.activateEvents=new dn,this.deactivateEvents=new dn,this.attachEvents=new dn,this.detachEvents=new dn,this.parentContexts=We(U0),this.location=We(bp),this.changeDetector=We(uc),this.inputBinder=We(QR,{optional:!0}),this.supportsBindingToComponentInputs=!0}get activatedComponentRef(){return this.activated}ngOnChanges(n){if(n.name){let{firstChange:o,previousValue:s}=n.name;if(o)return;this.isTrackedInParentContexts(s)&&(this.deactivate(),this.parentContexts.onChildOutletDestroyed(s)),this.initializeOutletWithName()}}ngOnDestroy(){this.isTrackedInParentContexts(this.name)&&this.parentContexts.onChildOutletDestroyed(this.name),this.inputBinder?.unsubscribeFromRouteData(this)}isTrackedInParentContexts(n){return this.parentContexts.getContext(n)?.outlet===this}ngOnInit(){this.initializeOutletWithName()}initializeOutletWithName(){if(this.parentContexts.onChildOutletCreated(this.name,this),this.activated)return;let n=this.parentContexts.getContext(this.name);n?.route&&(n.attachRef?this.attach(n.attachRef,n.route):this.activateWith(n.route,n.injector))}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new gt(4012,!1);return this.activated.instance}get activatedRoute(){if(!this.activated)throw new gt(4012,!1);return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new gt(4012,!1);this.location.detach();let n=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(n.instance),n}attach(n,o){this.activated=n,this._activatedRoute=o,this.location.insert(n.hostView),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.attachEvents.emit(n.instance)}deactivate(){if(this.activated){let n=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(n)}}activateWith(n,o){if(this.isActivated)throw new gt(4013,!1);this._activatedRoute=n;let s=this.location,a=n.snapshot.component,u=this.parentContexts.getOrCreateContext(this.name).children,l=new UR(n,u,s.injector);this.activated=s.createComponent(a,{index:s.length,injector:l,environmentInjector:o}),this.changeDetector.markForCheck(),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.activateEvents.emit(this.activated.instance)}};t.\u0275fac=function(o){return new(o||t)},t.\u0275dir=Wm({type:t,selectors:[["router-outlet"]],inputs:{name:"name"},outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"],standalone:!0,features:[yp]});let r=t;return r})(),UR=class r{__ngOutletInjector(t){return new r(this.route,this.childContexts,t)}constructor(t,e,n){this.route=t,this.childContexts=e,this.parent=n}get(t,e){return t===gs?this.route:t===U0?this.childContexts:this.parent.get(t,e)}},QR=new Ot("");function wfe(r,t,e){let n=Ov(r,t._root,e?e._root:void 0);return new P0(n,t)}function Ov(r,t,e){if(e&&r.shouldReuseRoute(t.value,e.value.snapshot)){let n=e.value;n._futureSnapshot=t.value;let o=Cfe(r,t,e);return new Us(n,o)}else{if(r.shouldAttach(t.value)){let s=r.retrieve(t.value);if(s!==null){let i=s.route;return i.value._futureSnapshot=t.value,i.children=t.children.map(a=>Ov(r,a)),i}}let n=Sfe(t.value),o=t.children.map(s=>Ov(r,s));return new Us(n,o)}}function Cfe(r,t,e){return t.children.map(n=>{for(let o of e.children)if(r.shouldReuseRoute(n.value,o.value.snapshot))return Ov(r,n,o);return Ov(r,n)})}function Sfe(r){return new gs(new yo(r.url),new yo(r.params),new yo(r.queryParams),new yo(r.fragment),new yo(r.data),r.outlet,r.component,r)}var Mv=class{constructor(t,e){this.redirectTo=t,this.navigationBehaviorOptions=e}},$V="ngNavigationCancelingError";function B0(r,t){let{redirectTo:e,navigationBehaviorOptions:n}=kv(t)?{redirectTo:t,navigationBehaviorOptions:void 0}:t,o=PV(!1,Gs.Redirect);return o.url=e,o.navigationBehaviorOptions=n,o}function PV(r,t){let e=new Error(`NavigationCancelingError: ${r||""}`);return e[$V]=!0,e.cancellationCode=t,e}function Ife(r){return LV(r)&&kv(r.url)}function LV(r){return!!r&&r[$V]}var Tfe=(r,t,e,n)=>Jt(o=>(new GR(t,o.targetRouterState,o.currentRouterState,e,n).activate(r),o)),GR=class{constructor(t,e,n,o,s){this.routeReuseStrategy=t,this.futureState=e,this.currState=n,this.forwardEvent=o,this.inputBindingEnabled=s}activate(t){let e=this.futureState._root,n=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,n,t),bR(this.futureState.root),this.activateChildRoutes(e,n,t)}deactivateChildRoutes(t,e,n){let o=Qm(e);t.children.forEach(s=>{let i=s.value.outlet;this.deactivateRoutes(s,o[i],n),delete o[i]}),Object.values(o).forEach(s=>{this.deactivateRouteAndItsChildren(s,n)})}deactivateRoutes(t,e,n){let o=t.value,s=e?e.value:null;if(o===s)if(o.component){let i=n.getContext(o.outlet);i&&this.deactivateChildRoutes(t,e,i.children)}else this.deactivateChildRoutes(t,e,n);else s&&this.deactivateRouteAndItsChildren(e,n)}deactivateRouteAndItsChildren(t,e){t.value.component&&this.routeReuseStrategy.shouldDetach(t.value.snapshot)?this.detachAndStoreRouteSubtree(t,e):this.deactivateRouteAndOutlet(t,e)}detachAndStoreRouteSubtree(t,e){let n=e.getContext(t.value.outlet),o=n&&t.value.component?n.children:e,s=Qm(t);for(let i of Object.values(s))this.deactivateRouteAndItsChildren(i,o);if(n&&n.outlet){let i=n.outlet.detach(),a=n.children.onOutletDeactivated();this.routeReuseStrategy.store(t.value.snapshot,{componentRef:i,route:t,contexts:a})}}deactivateRouteAndOutlet(t,e){let n=e.getContext(t.value.outlet),o=n&&t.value.component?n.children:e,s=Qm(t);for(let i of Object.values(s))this.deactivateRouteAndItsChildren(i,o);n&&(n.outlet&&(n.outlet.deactivate(),n.children.onOutletDeactivated()),n.attachRef=null,n.route=null)}activateChildRoutes(t,e,n){let o=Qm(e);t.children.forEach(s=>{this.activateRoutes(s,o[s.value.outlet],n),this.forwardEvent(new PR(s.value.snapshot))}),t.children.length&&this.forwardEvent(new FR(t.value.snapshot))}activateRoutes(t,e,n){let o=t.value,s=e?e.value:null;if(bR(o),o===s)if(o.component){let i=n.getOrCreateContext(o.outlet);this.activateChildRoutes(t,e,i.children)}else this.activateChildRoutes(t,e,n);else if(o.component){let i=n.getOrCreateContext(o.outlet);if(this.routeReuseStrategy.shouldAttach(o.snapshot)){let a=this.routeReuseStrategy.retrieve(o.snapshot);this.routeReuseStrategy.store(o.snapshot,null),i.children.onOutletReAttached(a.contexts),i.attachRef=a.componentRef,i.route=a.route.value,i.outlet&&i.outlet.attach(a.componentRef,a.route.value),bR(a.route.value),this.activateChildRoutes(t,null,i.children)}else i.attachRef=null,i.route=o,i.outlet&&i.outlet.activateWith(o,i.injector),this.activateChildRoutes(t,null,i.children)}else this.activateChildRoutes(t,null,n)}},V0=class{constructor(t){this.path=t,this.route=this.path[this.path.length-1]}},tg=class{constructor(t,e){this.component=t,this.route=e}};function _fe(r,t,e){let n=r._root,o=t?t._root:null;return Cv(n,o,e,[n.value])}function Efe(r){let t=r.routeConfig?r.routeConfig.canActivateChild:null;return!t||t.length===0?null:{node:r,guards:t}}function sg(r,t){let e=Symbol(),n=t.get(r,e);return n===e?typeof r=="function"&&!O3(r)?r:t.get(r):n}function Cv(r,t,e,n,o={canDeactivateChecks:[],canActivateChecks:[]}){let s=Qm(t);return r.children.forEach(i=>{kfe(i,s[i.value.outlet],e,n.concat([i.value]),o),delete s[i.value.outlet]}),Object.entries(s).forEach(([i,a])=>_v(a,e.getContext(i),o)),o}function kfe(r,t,e,n,o={canDeactivateChecks:[],canActivateChecks:[]}){let s=r.value,i=t?t.value:null,a=e?e.getContext(r.value.outlet):null;if(i&&s.routeConfig===i.routeConfig){let u=Nfe(i,s,s.routeConfig.runGuardsAndResolvers);u?o.canActivateChecks.push(new V0(n)):(s.data=i.data,s._resolvedData=i._resolvedData),s.component?Cv(r,t,a?a.children:null,n,o):Cv(r,t,e,n,o),u&&a&&a.outlet&&a.outlet.isActivated&&o.canDeactivateChecks.push(new tg(a.outlet.component,i))}else i&&_v(t,a,o),o.canActivateChecks.push(new V0(n)),s.component?Cv(r,null,a?a.children:null,n,o):Cv(r,null,e,n,o);return o}function Nfe(r,t,e){if(typeof e=="function")return e(r,t);switch(e){case"pathParamsChange":return!qf(r.url,t.url);case"pathParamsOrQueryParamsChange":return!qf(r.url,t.url)||!Du(r.queryParams,t.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!VR(r,t)||!Du(r.queryParams,t.queryParams);case"paramsChange":default:return!VR(r,t)}}function _v(r,t,e){let n=Qm(r),o=r.value;Object.entries(n).forEach(([s,i])=>{o.component?t?_v(i,t.children.getContext(s),e):_v(i,null,e):_v(i,t,e)}),o.component?t&&t.outlet&&t.outlet.isActivated?e.canDeactivateChecks.push(new tg(t.outlet.component,o)):e.canDeactivateChecks.push(new tg(null,o)):e.canDeactivateChecks.push(new tg(null,o))}function zv(r){return typeof r=="function"}function Dfe(r){return typeof r=="boolean"}function Afe(r){return r&&zv(r.canLoad)}function Rfe(r){return r&&zv(r.canActivate)}function Ofe(r){return r&&zv(r.canActivateChild)}function Mfe(r){return r&&zv(r.canDeactivate)}function Ffe(r){return r&&zv(r.canMatch)}function zV(r){return r instanceof Gi||r?.name==="EmptyError"}var N0=Symbol("INITIAL_VALUE");function og(){return Wi(r=>EC(r.map(t=>t.pipe(oi(1),bD(N0)))).pipe(Jt(t=>{for(let e of t)if(e!==!0){if(e===N0)return N0;if(e===!1||$fe(e))return e}return!0}),hs(t=>t!==N0),oi(1)))}function $fe(r){return kv(r)||r instanceof Mv}function Pfe(r,t){return Yn(e=>{let{targetSnapshot:n,currentSnapshot:o,guards:{canActivateChecks:s,canDeactivateChecks:i}}=e;return i.length===0&&s.length===0?Nt(mn(et({},e),{guardsResult:!0})):Lfe(i,n,o,r).pipe(Yn(a=>a&&Dfe(a)?zfe(n,s,r,t):Nt(a)),Jt(a=>mn(et({},e),{guardsResult:a})))})}function Lfe(r,t,e,n){return Xn(r).pipe(Yn(o=>Wfe(o.component,o.route,e,t,n)),Su(o=>o!==!0,!0))}function zfe(r,t,e,n){return Xn(t).pipe(Nm(o=>km(Vfe(o.route.parent,n),Bfe(o.route,n),Gfe(r,o.path,e),Ufe(r,o.route,e))),Su(o=>o!==!0,!0))}function Bfe(r,t){return r!==null&&t&&t(new $R(r)),Nt(!0)}function Vfe(r,t){return r!==null&&t&&t(new MR(r)),Nt(!0)}function Ufe(r,t,e){let n=t.routeConfig?t.routeConfig.canActivate:null;if(!n||n.length===0)return Nt(!0);let o=n.map(s=>kC(()=>{let i=Lv(t)??e,a=sg(s,i),u=Rfe(a)?a.canActivate(t,r):oc(i,()=>a(t,r));return Cp(u).pipe(Su())}));return Nt(o).pipe(og())}function Gfe(r,t,e){let n=t[t.length-1],s=t.slice(0,t.length-1).reverse().map(i=>Efe(i)).filter(i=>i!==null).map(i=>kC(()=>{let a=i.guards.map(u=>{let l=Lv(i.node)??e,c=sg(u,l),p=Ofe(c)?c.canActivateChild(n,r):oc(l,()=>c(n,r));return Cp(p).pipe(Su())});return Nt(a).pipe(og())}));return Nt(s).pipe(og())}function Wfe(r,t,e,n,o){let s=t&&t.routeConfig?t.routeConfig.canDeactivate:null;if(!s||s.length===0)return Nt(!0);let i=s.map(a=>{let u=Lv(t)??o,l=sg(a,u),c=Mfe(l)?l.canDeactivate(r,t,e,n):oc(u,()=>l(r,t,e,n));return Cp(c).pipe(Su())});return Nt(i).pipe(og())}function jfe(r,t,e,n){let o=t.canLoad;if(o===void 0||o.length===0)return Nt(!0);let s=o.map(i=>{let a=sg(i,r),u=Afe(a)?a.canLoad(t,e):oc(r,()=>a(t,e));return Cp(u)});return Nt(s).pipe(og(),BV(n))}function BV(r){return aD(xo(t=>{if(typeof t!="boolean")throw B0(r,t)}),Jt(t=>t===!0))}function Hfe(r,t,e,n){let o=t.canMatch;if(!o||o.length===0)return Nt(!0);let s=o.map(i=>{let a=sg(i,r),u=Ffe(a)?a.canMatch(t,e):oc(r,()=>a(t,e));return Cp(u)});return Nt(s).pipe(og(),BV(n))}var Fv=class{constructor(t){this.segmentGroup=t||null}},$v=class extends Error{constructor(t){super(),this.urlTree=t}};function Zm(r){return Em(new Fv(r))}function qfe(r){return Em(new gt(4e3,!1))}function Kfe(r){return Em(PV(!1,Gs.GuardRejected))}var WR=class{constructor(t,e){this.urlSerializer=t,this.urlTree=e}lineralizeSegments(t,e){let n=[],o=e.root;for(;;){if(n=n.concat(o.segments),o.numberOfChildren===0)return Nt(n);if(o.numberOfChildren>1||!o.children[At])return qfe(`${t.redirectTo}`);o=o.children[At]}}applyRedirectCommands(t,e,n,o,s){if(typeof e!="string"){let a=e,{queryParams:u,fragment:l,routeConfig:c,url:p,outlet:d,params:f,data:h,title:m}=o,g=oc(s,()=>a({params:f,data:h,queryParams:u,fragment:l,routeConfig:c,url:p,outlet:d,title:m}));if(g instanceof cc)throw new $v(g);e=g}let i=this.applyRedirectCreateUrlTree(e,this.urlSerializer.parse(e),t,n);if(e[0]==="/")throw new $v(i);return i}applyRedirectCreateUrlTree(t,e,n,o){let s=this.createSegmentGroup(t,e.root,n,o);return new cc(s,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(t,e){let n={};return Object.entries(t).forEach(([o,s])=>{if(typeof s=="string"&&s[0]===":"){let a=s.substring(1);n[o]=e[a]}else n[o]=s}),n}createSegmentGroup(t,e,n,o){let s=this.createSegments(t,e.segments,n,o),i={};return Object.entries(e.children).forEach(([a,u])=>{i[a]=this.createSegmentGroup(t,u,n,o)}),new kr(s,i)}createSegments(t,e,n,o){return e.map(s=>s.path[0]===":"?this.findPosParam(t,s,o):this.findOrReturn(s,n))}findPosParam(t,e,n){let o=n[e.path.substring(1)];if(!o)throw new gt(4001,!1);return o}findOrReturn(t,e){let n=0;for(let o of e){if(o.path===t.path)return e.splice(n),o;n++}return t}},jR={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function Xfe(r,t,e,n,o){let s=JR(r,t,e);return s.matched?(n=xfe(t,n),Hfe(n,t,e,o).pipe(Jt(i=>i===!0?s:et({},jR)))):Nt(s)}function JR(r,t,e){if(t.path==="**")return Yfe(e);if(t.path==="")return t.pathMatch==="full"&&(r.hasChildren()||e.length>0)?et({},jR):{matched:!0,consumedSegments:[],remainingSegments:e,parameters:{},positionalParamSegments:{}};let o=(t.matcher||Hde)(e,r,t);if(!o)return et({},jR);let s={};Object.entries(o.posParams??{}).forEach(([a,u])=>{s[a]=u.path});let i=o.consumed.length>0?et(et({},s),o.consumed[o.consumed.length-1].parameters):s;return{matched:!0,consumedSegments:o.consumed,remainingSegments:e.slice(o.consumed.length),parameters:i,positionalParamSegments:o.posParams??{}}}function Yfe(r){return{matched:!0,parameters:r.length>0?bV(r).parameters:{},consumedSegments:r,remainingSegments:[],positionalParamSegments:{}}}function gV(r,t,e,n){return e.length>0&&Jfe(r,e,n)?{segmentGroup:new kr(t,Qfe(n,new kr(e,r.children))),slicedSegments:[]}:e.length===0&&ehe(r,e,n)?{segmentGroup:new kr(r.segments,Zfe(r,e,n,r.children)),slicedSegments:e}:{segmentGroup:new kr(r.segments,r.children),slicedSegments:e}}function Zfe(r,t,e,n){let o={};for(let s of e)if(G0(r,t,s)&&!n[Yi(s)]){let i=new kr([],{});o[Yi(s)]=i}return et(et({},n),o)}function Qfe(r,t){let e={};e[At]=t;for(let n of r)if(n.path===""&&Yi(n)!==At){let o=new kr([],{});e[Yi(n)]=o}return e}function Jfe(r,t,e){return e.some(n=>G0(r,t,n)&&Yi(n)!==At)}function ehe(r,t,e){return e.some(n=>G0(r,t,n))}function G0(r,t,e){return(r.hasChildren()||t.length>0)&&e.pathMatch==="full"?!1:e.path===""}function the(r,t,e,n){return Yi(r)!==n&&(n===At||!G0(t,e,r))?!1:JR(t,r,e).matched}function rhe(r,t,e){return t.length===0&&!r.children[e]}var HR=class{};function nhe(r,t,e,n,o,s,i="emptyOnly"){return new qR(r,t,e,n,o,i,s).recognize()}var ohe=31,qR=class{constructor(t,e,n,o,s,i,a){this.injector=t,this.configLoader=e,this.rootComponentType=n,this.config=o,this.urlTree=s,this.paramsInheritanceStrategy=i,this.urlSerializer=a,this.applyRedirects=new WR(this.urlSerializer,this.urlTree),this.absoluteRedirectCount=0,this.allowRedirects=!0}noMatchError(t){return new gt(4002,`'${t.segmentGroup}'`)}recognize(){let t=gV(this.urlTree.root,[],[],this.config).segmentGroup;return this.match(t).pipe(Jt(({children:e,rootSnapshot:n})=>{let o=new Us(n,e),s=new z0("",o),i=pfe(n,[],this.urlTree.queryParams,this.urlTree.fragment);return i.queryParams=this.urlTree.queryParams,s.url=this.urlSerializer.serialize(i),{state:s,tree:i}}))}match(t){let e=new eg([],Object.freeze({}),Object.freeze(et({},this.urlTree.queryParams)),this.urlTree.fragment,Object.freeze({}),At,this.rootComponentType,null,{});return this.processSegmentGroup(this.injector,this.config,t,At,e).pipe(Jt(n=>({children:n,rootSnapshot:e})),up(n=>{if(n instanceof $v)return this.urlTree=n.urlTree,this.match(n.urlTree.root);throw n instanceof Fv?this.noMatchError(n):n}))}processSegmentGroup(t,e,n,o,s){return n.segments.length===0&&n.hasChildren()?this.processChildren(t,e,n,s):this.processSegment(t,e,n,n.segments,o,!0,s).pipe(Jt(i=>i instanceof Us?[i]:[]))}processChildren(t,e,n,o){let s=[];for(let i of Object.keys(n.children))i==="primary"?s.unshift(i):s.push(i);return Xn(s).pipe(Nm(i=>{let a=n.children[i],u=vfe(e,i);return this.processSegmentGroup(t,u,a,i,o)}),vD((i,a)=>(i.push(...a),i)),lp(null),xD(),Yn(i=>{if(i===null)return Zm(n);let a=VV(i);return she(a),Nt(a)}))}processSegment(t,e,n,o,s,i,a){return Xn(e).pipe(Nm(u=>this.processSegmentAgainstRoute(u._injector??t,e,u,n,o,s,i,a).pipe(up(l=>{if(l instanceof Fv)return Nt(null);throw l}))),Su(u=>!!u),up(u=>{if(zV(u))return rhe(n,o,s)?Nt(new HR):Zm(n);throw u}))}processSegmentAgainstRoute(t,e,n,o,s,i,a,u){return the(n,o,s,i)?n.redirectTo===void 0?this.matchSegmentAgainstRoute(t,o,n,s,i,u):this.allowRedirects&&a?this.expandSegmentAgainstRouteUsingRedirect(t,o,e,n,s,i,u):Zm(o):Zm(o)}expandSegmentAgainstRouteUsingRedirect(t,e,n,o,s,i,a){let{matched:u,parameters:l,consumedSegments:c,positionalParamSegments:p,remainingSegments:d}=JR(e,o,s);if(!u)return Zm(e);typeof o.redirectTo=="string"&&o.redirectTo[0]==="/"&&(this.absoluteRedirectCount++,this.absoluteRedirectCount>ohe&&(this.allowRedirects=!1));let f=new eg(s,l,Object.freeze(et({},this.urlTree.queryParams)),this.urlTree.fragment,yV(o),Yi(o),o.component??o._loadedComponent??null,o,xV(o)),h=L0(f,a,this.paramsInheritanceStrategy);f.params=Object.freeze(h.params),f.data=Object.freeze(h.data);let m=this.applyRedirects.applyRedirectCommands(c,o.redirectTo,p,f,t);return this.applyRedirects.lineralizeSegments(o,m).pipe(Yn(g=>this.processSegment(t,n,e,g.concat(d),i,!1,a)))}matchSegmentAgainstRoute(t,e,n,o,s,i){let a=Xfe(e,n,o,t,this.urlSerializer);return n.path==="**"&&(e.children={}),a.pipe(Wi(u=>u.matched?(t=n._injector??t,this.getChildConfig(t,n,o).pipe(Wi(({routes:l})=>{let c=n._loadedInjector??t,{parameters:p,consumedSegments:d,remainingSegments:f}=u,h=new eg(d,p,Object.freeze(et({},this.urlTree.queryParams)),this.urlTree.fragment,yV(n),Yi(n),n.component??n._loadedComponent??null,n,xV(n)),m=L0(h,i,this.paramsInheritanceStrategy);h.params=Object.freeze(m.params),h.data=Object.freeze(m.data);let{segmentGroup:g,slicedSegments:y}=gV(e,d,f,l);if(y.length===0&&g.hasChildren())return this.processChildren(c,l,g,h).pipe(Jt(w=>new Us(h,w)));if(l.length===0&&y.length===0)return Nt(new Us(h,[]));let x=Yi(n)===s;return this.processSegment(c,l,g,y,x?At:s,!0,h).pipe(Jt(w=>new Us(h,w instanceof Us?[w]:[])))}))):Zm(e)))}getChildConfig(t,e,n){return e.children?Nt({routes:e.children,injector:t}):e.loadChildren?e._loadedRoutes!==void 0?Nt({routes:e._loadedRoutes,injector:e._loadedInjector}):jfe(t,e,n,this.urlSerializer).pipe(Yn(o=>o?this.configLoader.loadChildren(t,e).pipe(xo(s=>{e._loadedRoutes=s.routes,e._loadedInjector=s.injector})):Kfe(e))):Nt({routes:[],injector:t})}};function she(r){r.sort((t,e)=>t.value.outlet===At?-1:e.value.outlet===At?1:t.value.outlet.localeCompare(e.value.outlet))}function ihe(r){let t=r.value.routeConfig;return t&&t.path===""}function VV(r){let t=[],e=new Set;for(let n of r){if(!ihe(n)){t.push(n);continue}let o=t.find(s=>n.value.routeConfig===s.value.routeConfig);o!==void 0?(o.children.push(...n.children),e.add(o)):t.push(n)}for(let n of e){let o=VV(n.children);t.push(new Us(n.value,o))}return t.filter(n=>!e.has(n))}function yV(r){return r.data||{}}function xV(r){return r.resolve||{}}function ahe(r,t,e,n,o,s){return Yn(i=>nhe(r,t,e,n,i.extractedUrl,o,s).pipe(Jt(({state:a,tree:u})=>mn(et({},i),{targetSnapshot:a,urlAfterRedirects:u}))))}function uhe(r,t){return Yn(e=>{let{targetSnapshot:n,guards:{canActivateChecks:o}}=e;if(!o.length)return Nt(e);let s=new Set(o.map(u=>u.route)),i=new Set;for(let u of s)if(!i.has(u))for(let l of UV(u))i.add(l);let a=0;return Xn(i).pipe(Nm(u=>s.has(u)?lhe(u,n,r,t):(u.data=L0(u,u.parent,r).resolve,Nt(void 0))),xo(()=>a++),Dm(1),Yn(u=>a===i.size?Nt(e):zs))})}function UV(r){let t=r.children.map(e=>UV(e)).flat();return[r,...t]}function lhe(r,t,e,n){let o=r.routeConfig,s=r._resolve;return o?.title!==void 0&&!FV(o)&&(s[Pv]=o.title),che(s,r,t,n).pipe(Jt(i=>(r._resolvedData=i,r.data=L0(r,r.parent,e).resolve,null)))}function che(r,t,e,n){let o=SR(r);if(o.length===0)return Nt({});let s={};return Xn(o).pipe(Yn(i=>phe(r[i],t,e,n).pipe(Su(),xo(a=>{if(a instanceof Mv)throw B0(new Ev,a);s[i]=a}))),Dm(1),yD(s),up(i=>zV(i)?zs:Em(i)))}function phe(r,t,e,n){let o=Lv(t)??n,s=sg(r,o),i=s.resolve?s.resolve(t,e):oc(o,()=>s(t,e));return Cp(i)}function wR(r){return Wi(t=>{let e=r(t);return e?Xn(e).pipe(Jt(()=>t)):Nt(t)})}var GV=(()=>{let t=class t{buildTitle(n){let o,s=n.root;for(;s!==void 0;)o=this.getResolvedTitleForRoute(s)??o,s=s.children.find(i=>i.outlet===At);return o}getResolvedTitleForRoute(n){return n.data[Pv]}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=Qe({token:t,factory:()=>We(dhe),providedIn:"root"});let r=t;return r})(),dhe=(()=>{let t=class t extends GV{constructor(n){super(),this.title=n}updateTitle(n){let o=this.buildTitle(n);o!==void 0&&this.title.setTitle(o)}};t.\u0275fac=function(o){return new(o||t)(St(pV))},t.\u0275prov=Qe({token:t,factory:t.\u0275fac,providedIn:"root"});let r=t;return r})(),e2=new Ot("",{providedIn:"root",factory:()=>({})}),fhe=(()=>{let t=class t{};t.\u0275fac=function(o){return new(o||t)},t.\u0275cmp=or({type:t,selectors:[["ng-component"]],standalone:!0,features:[sr],decls:1,vars:0,template:function(o,s){o&1&&Wt(0,"router-outlet")},dependencies:[ZR],encapsulation:2});let r=t;return r})();function t2(r){let t=r.children&&r.children.map(t2),e=t?mn(et({},r),{children:t}):et({},r);return!e.component&&!e.loadComponent&&(t||e.loadChildren)&&e.outlet&&e.outlet!==At&&(e.component=fhe),e}var r2=new Ot(""),hhe=(()=>{let t=class t{constructor(){this.componentLoaders=new WeakMap,this.childrenLoaders=new WeakMap,this.compiler=We(oR)}loadComponent(n){if(this.componentLoaders.get(n))return this.componentLoaders.get(n);if(n._loadedComponent)return Nt(n._loadedComponent);this.onLoadStartListener&&this.onLoadStartListener(n);let o=Cp(n.loadComponent()).pipe(Jt(WV),xo(i=>{this.onLoadEndListener&&this.onLoadEndListener(n),n._loadedComponent=i}),Xx(()=>{this.componentLoaders.delete(n)})),s=new Tm(o,()=>new Mr).pipe(Im());return this.componentLoaders.set(n,s),s}loadChildren(n,o){if(this.childrenLoaders.get(o))return this.childrenLoaders.get(o);if(o._loadedRoutes)return Nt({routes:o._loadedRoutes,injector:o._loadedInjector});this.onLoadStartListener&&this.onLoadStartListener(o);let i=mhe(o,this.compiler,n,this.onLoadEndListener).pipe(Xx(()=>{this.childrenLoaders.delete(o)})),a=new Tm(i,()=>new Mr).pipe(Im());return this.childrenLoaders.set(o,a),a}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=Qe({token:t,factory:t.\u0275fac,providedIn:"root"});let r=t;return r})();function mhe(r,t,e,n){return Cp(r.loadChildren()).pipe(Jt(WV),Yn(o=>o instanceof av||Array.isArray(o)?Nt(o):Xn(t.compileModuleAsync(o))),Jt(o=>{n&&n(r);let s,i,a=!1;return Array.isArray(o)?(i=o,a=!0):(s=o.create(e).injector,i=s.get(r2,[],{optional:!0,self:!0}).flat()),{routes:i.map(t2),injector:s}}))}function ghe(r){return r&&typeof r=="object"&&"default"in r}function WV(r){return ghe(r)?r.default:r}var n2=(()=>{let t=class t{};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=Qe({token:t,factory:()=>We(yhe),providedIn:"root"});let r=t;return r})(),yhe=(()=>{let t=class t{shouldProcessUrl(n){return!0}extract(n){return n}merge(n,o){return n}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=Qe({token:t,factory:t.\u0275fac,providedIn:"root"});let r=t;return r})(),xhe=new Ot("");var vhe=new Ot(""),bhe=(()=>{let t=class t{get hasRequestedNavigation(){return this.navigationId!==0}constructor(){this.currentNavigation=null,this.currentTransition=null,this.lastSuccessfulNavigation=null,this.events=new Mr,this.transitionAbortSubject=new Mr,this.configLoader=We(hhe),this.environmentInjector=We(ui),this.urlSerializer=We(XR),this.rootContexts=We(U0),this.location=We(mv),this.inputBindingEnabled=We(QR,{optional:!0})!==null,this.titleStrategy=We(GV),this.options=We(e2,{optional:!0})||{},this.paramsInheritanceStrategy=this.options.paramsInheritanceStrategy||"emptyOnly",this.urlHandlingStrategy=We(n2),this.createViewTransition=We(xhe,{optional:!0}),this.navigationErrorHandler=We(vhe,{optional:!0}),this.navigationId=0,this.afterPreactivation=()=>Nt(void 0),this.rootComponentType=null;let n=s=>this.events.next(new RR(s)),o=s=>this.events.next(new OR(s));this.configLoader.onLoadEndListener=o,this.configLoader.onLoadStartListener=n}complete(){this.transitions?.complete()}handleNavigationRequest(n){let o=++this.navigationId;this.transitions?.next(mn(et(et({},this.transitions.value),n),{id:o}))}setupNavigations(n,o,s){return this.transitions=new yo({id:0,currentUrlTree:o,currentRawUrl:o,extractedUrl:this.urlHandlingStrategy.extract(o),urlAfterRedirects:this.urlHandlingStrategy.extract(o),rawUrl:o,extras:{},resolve:()=>{},reject:()=>{},promise:Promise.resolve(!0),source:Tv,restoredState:null,currentSnapshot:s.snapshot,targetSnapshot:null,currentRouterState:s,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.transitions.pipe(hs(i=>i.id!==0),Jt(i=>mn(et({},i),{extractedUrl:this.urlHandlingStrategy.extract(i.rawUrl)})),Wi(i=>{let a=!1,u=!1;return Nt(i).pipe(Wi(l=>{if(this.navigationId>i.id)return this.cancelNavigationTransition(i,"",Gs.SupersededByNewNavigation),zs;this.currentTransition=i,this.currentNavigation={id:l.id,initialUrl:l.rawUrl,extractedUrl:l.extractedUrl,targetBrowserUrl:typeof l.extras.browserUrl=="string"?this.urlSerializer.parse(l.extras.browserUrl):l.extras.browserUrl,trigger:l.source,extras:l.extras,previousNavigation:this.lastSuccessfulNavigation?mn(et({},this.lastSuccessfulNavigation),{previousNavigation:null}):null};let c=!n.navigated||this.isUpdatingInternalState()||this.isUpdatedBrowserUrl(),p=l.extras.onSameUrlNavigation??n.onSameUrlNavigation;if(!c&&p!=="reload"){let d="";return this.events.next(new Kf(l.id,this.urlSerializer.serialize(l.rawUrl),d,ER.IgnoredSameUrlNavigation)),l.resolve(!1),zs}if(this.urlHandlingStrategy.shouldProcessUrl(l.rawUrl))return Nt(l).pipe(Wi(d=>{let f=this.transitions?.getValue();return this.events.next(new Dv(d.id,this.urlSerializer.serialize(d.extractedUrl),d.source,d.restoredState)),f!==this.transitions?.getValue()?zs:Promise.resolve(d)}),ahe(this.environmentInjector,this.configLoader,this.rootComponentType,n.config,this.urlSerializer,this.paramsInheritanceStrategy),xo(d=>{i.targetSnapshot=d.targetSnapshot,i.urlAfterRedirects=d.urlAfterRedirects,this.currentNavigation=mn(et({},this.currentNavigation),{finalUrl:d.urlAfterRedirects});let f=new F0(d.id,this.urlSerializer.serialize(d.extractedUrl),this.urlSerializer.serialize(d.urlAfterRedirects),d.targetSnapshot);this.events.next(f)}));if(c&&this.urlHandlingStrategy.shouldProcessUrl(l.currentRawUrl)){let{id:d,extractedUrl:f,source:h,restoredState:m,extras:g}=l,y=new Dv(d,this.urlSerializer.serialize(f),h,m);this.events.next(y);let x=OV(this.rootComponentType).snapshot;return this.currentTransition=i=mn(et({},l),{targetSnapshot:x,urlAfterRedirects:f,extras:mn(et({},g),{skipLocationChange:!1,replaceUrl:!1})}),this.currentNavigation.finalUrl=f,Nt(i)}else{let d="";return this.events.next(new Kf(l.id,this.urlSerializer.serialize(l.extractedUrl),d,ER.IgnoredByUrlHandlingStrategy)),l.resolve(!1),zs}}),xo(l=>{let c=new kR(l.id,this.urlSerializer.serialize(l.extractedUrl),this.urlSerializer.serialize(l.urlAfterRedirects),l.targetSnapshot);this.events.next(c)}),Jt(l=>(this.currentTransition=i=mn(et({},l),{guards:_fe(l.targetSnapshot,l.currentSnapshot,this.rootContexts)}),i)),Pfe(this.environmentInjector,l=>this.events.next(l)),xo(l=>{if(i.guardsResult=l.guardsResult,l.guardsResult&&typeof l.guardsResult!="boolean")throw B0(this.urlSerializer,l.guardsResult);let c=new NR(l.id,this.urlSerializer.serialize(l.extractedUrl),this.urlSerializer.serialize(l.urlAfterRedirects),l.targetSnapshot,!!l.guardsResult);this.events.next(c)}),hs(l=>l.guardsResult?!0:(this.cancelNavigationTransition(l,"",Gs.GuardRejected),!1)),wR(l=>{if(l.guards.canActivateChecks.length)return Nt(l).pipe(xo(c=>{let p=new DR(c.id,this.urlSerializer.serialize(c.extractedUrl),this.urlSerializer.serialize(c.urlAfterRedirects),c.targetSnapshot);this.events.next(p)}),Wi(c=>{let p=!1;return Nt(c).pipe(uhe(this.paramsInheritanceStrategy,this.environmentInjector),xo({next:()=>p=!0,complete:()=>{p||this.cancelNavigationTransition(c,"",Gs.NoDataFromResolver)}}))}),xo(c=>{let p=new AR(c.id,this.urlSerializer.serialize(c.extractedUrl),this.urlSerializer.serialize(c.urlAfterRedirects),c.targetSnapshot);this.events.next(p)}))}),wR(l=>{let c=p=>{let d=[];p.routeConfig?.loadComponent&&!p.routeConfig._loadedComponent&&d.push(this.configLoader.loadComponent(p.routeConfig).pipe(xo(f=>{p.component=f}),Jt(()=>{})));for(let f of p.children)d.push(...c(f));return d};return EC(c(l.targetSnapshot.root)).pipe(lp(null),oi(1))}),wR(()=>this.afterPreactivation()),Wi(()=>{let{currentSnapshot:l,targetSnapshot:c}=i,p=this.createViewTransition?.(this.environmentInjector,l.root,c.root);return p?Xn(p).pipe(Jt(()=>i)):Nt(i)}),Jt(l=>{let c=wfe(n.routeReuseStrategy,l.targetSnapshot,l.currentRouterState);return this.currentTransition=i=mn(et({},l),{targetRouterState:c}),this.currentNavigation.targetRouterState=c,i}),xo(()=>{this.events.next(new Rv)}),Tfe(this.rootContexts,n.routeReuseStrategy,l=>this.events.next(l),this.inputBindingEnabled),oi(1),xo({next:l=>{a=!0,this.lastSuccessfulNavigation=this.currentNavigation,this.events.next(new pc(l.id,this.urlSerializer.serialize(l.extractedUrl),this.urlSerializer.serialize(l.urlAfterRedirects))),this.titleStrategy?.updateTitle(l.targetRouterState.snapshot),l.resolve(!0)},complete:()=>{a=!0}}),wD(this.transitionAbortSubject.pipe(xo(l=>{throw l}))),Xx(()=>{!a&&!u&&this.cancelNavigationTransition(i,"",Gs.SupersededByNewNavigation),this.currentTransition?.id===i.id&&(this.currentNavigation=null,this.currentTransition=null)}),up(l=>{if(u=!0,LV(l))this.events.next(new lc(i.id,this.urlSerializer.serialize(i.extractedUrl),l.message,l.cancellationCode)),Ife(l)?this.events.next(new ng(l.url,l.navigationBehaviorOptions)):i.resolve(!1);else{let c=new Av(i.id,this.urlSerializer.serialize(i.extractedUrl),l,i.targetSnapshot??void 0);try{let p=oc(this.environmentInjector,()=>this.navigationErrorHandler?.(c));if(p instanceof Mv){let{message:d,cancellationCode:f}=B0(this.urlSerializer,p);this.events.next(new lc(i.id,this.urlSerializer.serialize(i.extractedUrl),d,f)),this.events.next(new ng(p.redirectTo,p.navigationBehaviorOptions))}else{this.events.next(c);let d=n.errorHandler(l);i.resolve(!!d)}}catch(p){this.options.resolveNavigationPromiseOnError?i.resolve(!1):i.reject(p)}}return zs}))}))}cancelNavigationTransition(n,o,s){let i=new lc(n.id,this.urlSerializer.serialize(n.extractedUrl),o,s);this.events.next(i),n.resolve(!1)}isUpdatingInternalState(){return this.currentTransition?.extractedUrl.toString()!==this.currentTransition?.currentUrlTree.toString()}isUpdatedBrowserUrl(){let n=this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(!0))),o=this.currentNavigation?.targetBrowserUrl??this.currentNavigation?.extractedUrl;return n.toString()!==o?.toString()&&!this.currentNavigation?.extras.skipLocationChange}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=Qe({token:t,factory:t.\u0275fac,providedIn:"root"});let r=t;return r})();function whe(r){return r!==Tv}var Che=(()=>{let t=class t{};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=Qe({token:t,factory:()=>We(She),providedIn:"root"});let r=t;return r})(),KR=class{shouldDetach(t){return!1}store(t,e){}shouldAttach(t){return!1}retrieve(t){return null}shouldReuseRoute(t,e){return t.routeConfig===e.routeConfig}},She=(()=>{let t=class t extends KR{};t.\u0275fac=(()=>{let n;return function(s){return(n||(n=$A(t)))(s||t)}})(),t.\u0275prov=Qe({token:t,factory:t.\u0275fac,providedIn:"root"});let r=t;return r})(),jV=(()=>{let t=class t{};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=Qe({token:t,factory:()=>We(Ihe),providedIn:"root"});let r=t;return r})(),Ihe=(()=>{let t=class t extends jV{constructor(){super(...arguments),this.location=We(mv),this.urlSerializer=We(XR),this.options=We(e2,{optional:!0})||{},this.canceledNavigationResolution=this.options.canceledNavigationResolution||"replace",this.urlHandlingStrategy=We(n2),this.urlUpdateStrategy=this.options.urlUpdateStrategy||"deferred",this.currentUrlTree=new cc,this.rawUrlTree=this.currentUrlTree,this.currentPageId=0,this.lastSuccessfulId=-1,this.routerState=OV(null),this.stateMemento=this.createStateMemento()}getCurrentUrlTree(){return this.currentUrlTree}getRawUrlTree(){return this.rawUrlTree}restoredState(){return this.location.getState()}get browserPageId(){return this.canceledNavigationResolution!=="computed"?this.currentPageId:this.restoredState()?.\u0275routerPageId??this.currentPageId}getRouterState(){return this.routerState}createStateMemento(){return{rawUrlTree:this.rawUrlTree,currentUrlTree:this.currentUrlTree,routerState:this.routerState}}registerNonRouterCurrentEntryChangeListener(n){return this.location.subscribe(o=>{o.type==="popstate"&&n(o.url,o.state)})}handleRouterEvent(n,o){if(n instanceof Dv)this.stateMemento=this.createStateMemento();else if(n instanceof Kf)this.rawUrlTree=o.initialUrl;else if(n instanceof F0){if(this.urlUpdateStrategy==="eager"&&!o.extras.skipLocationChange){let s=this.urlHandlingStrategy.merge(o.finalUrl,o.initialUrl);this.setBrowserUrl(o.targetBrowserUrl??s,o)}}else n instanceof Rv?(this.currentUrlTree=o.finalUrl,this.rawUrlTree=this.urlHandlingStrategy.merge(o.finalUrl,o.initialUrl),this.routerState=o.targetRouterState,this.urlUpdateStrategy==="deferred"&&!o.extras.skipLocationChange&&this.setBrowserUrl(o.targetBrowserUrl??this.rawUrlTree,o)):n instanceof lc&&(n.code===Gs.GuardRejected||n.code===Gs.NoDataFromResolver)?this.restoreHistory(o):n instanceof Av?this.restoreHistory(o,!0):n instanceof pc&&(this.lastSuccessfulId=n.id,this.currentPageId=this.browserPageId)}setBrowserUrl(n,o){let s=n instanceof cc?this.urlSerializer.serialize(n):n;if(this.location.isCurrentPathEqualTo(s)||o.extras.replaceUrl){let i=this.browserPageId,a=et(et({},o.extras.state),this.generateNgRouterState(o.id,i));this.location.replaceState(s,"",a)}else{let i=et(et({},o.extras.state),this.generateNgRouterState(o.id,this.browserPageId+1));this.location.go(s,"",i)}}restoreHistory(n,o=!1){if(this.canceledNavigationResolution==="computed"){let s=this.browserPageId,i=this.currentPageId-s;i!==0?this.location.historyGo(i):this.currentUrlTree===n.finalUrl&&i===0&&(this.resetState(n),this.resetUrlToCurrentUrlTree())}else this.canceledNavigationResolution==="replace"&&(o&&this.resetState(n),this.resetUrlToCurrentUrlTree())}resetState(n){this.routerState=this.stateMemento.routerState,this.currentUrlTree=this.stateMemento.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,n.finalUrl??this.rawUrlTree)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}generateNgRouterState(n,o){return this.canceledNavigationResolution==="computed"?{navigationId:n,\u0275routerPageId:o}:{navigationId:n}}};t.\u0275fac=(()=>{let n;return function(s){return(n||(n=$A(t)))(s||t)}})(),t.\u0275prov=Qe({token:t,factory:t.\u0275fac,providedIn:"root"});let r=t;return r})(),Sv=function(r){return r[r.COMPLETE=0]="COMPLETE",r[r.FAILED=1]="FAILED",r[r.REDIRECTING=2]="REDIRECTING",r}(Sv||{});function The(r,t){r.events.pipe(hs(e=>e instanceof pc||e instanceof lc||e instanceof Av||e instanceof Kf),Jt(e=>e instanceof pc||e instanceof Kf?Sv.COMPLETE:(e instanceof lc?e.code===Gs.Redirect||e.code===Gs.SupersededByNewNavigation:!1)?Sv.REDIRECTING:Sv.FAILED),hs(e=>e!==Sv.REDIRECTING),oi(1)).subscribe(()=>{t()})}function _he(r){throw r}var Ehe={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},khe={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"},Do=(()=>{let t=class t{get currentUrlTree(){return this.stateManager.getCurrentUrlTree()}get rawUrlTree(){return this.stateManager.getRawUrlTree()}get events(){return this._events}get routerState(){return this.stateManager.getRouterState()}constructor(){this.disposed=!1,this.console=We(w0),this.stateManager=We(jV),this.options=We(e2,{optional:!0})||{},this.pendingTasks=We(Hm),this.urlUpdateStrategy=this.options.urlUpdateStrategy||"deferred",this.navigationTransitions=We(bhe),this.urlSerializer=We(XR),this.location=We(mv),this.urlHandlingStrategy=We(n2),this._events=new Mr,this.errorHandler=this.options.errorHandler||_he,this.navigated=!1,this.routeReuseStrategy=We(Che),this.onSameUrlNavigation=this.options.onSameUrlNavigation||"ignore",this.config=We(r2,{optional:!0})?.flat()??[],this.componentInputBindingEnabled=!!We(QR,{optional:!0}),this.eventsSubscription=new wn,this.resetConfig(this.config),this.navigationTransitions.setupNavigations(this,this.currentUrlTree,this.routerState).subscribe({error:n=>{this.console.warn(n)}}),this.subscribeToNavigationEvents()}subscribeToNavigationEvents(){let n=this.navigationTransitions.events.subscribe(o=>{try{let s=this.navigationTransitions.currentTransition,i=this.navigationTransitions.currentNavigation;if(s!==null&&i!==null){if(this.stateManager.handleRouterEvent(o,i),o instanceof lc&&o.code!==Gs.Redirect&&o.code!==Gs.SupersededByNewNavigation)this.navigated=!0;else if(o instanceof pc)this.navigated=!0;else if(o instanceof ng){let a=o.navigationBehaviorOptions,u=this.urlHandlingStrategy.merge(o.url,s.currentRawUrl),l=et({browserUrl:s.extras.browserUrl,info:s.extras.info,skipLocationChange:s.extras.skipLocationChange,replaceUrl:s.extras.replaceUrl||this.urlUpdateStrategy==="eager"||whe(s.source)},a);this.scheduleNavigation(u,Tv,null,l,{resolve:s.resolve,reject:s.reject,promise:s.promise})}}Dhe(o)&&this._events.next(o)}catch(s){this.navigationTransitions.transitionAbortSubject.next(s)}});this.eventsSubscription.add(n)}resetRootComponentType(n){this.routerState.root.component=n,this.navigationTransitions.rootComponentType=n}initialNavigation(){this.setUpLocationChangeListener(),this.navigationTransitions.hasRequestedNavigation||this.navigateToSyncWithBrowser(this.location.path(!0),Tv,this.stateManager.restoredState())}setUpLocationChangeListener(){this.nonRouterCurrentEntryChangeSubscription??=this.stateManager.registerNonRouterCurrentEntryChangeListener((n,o)=>{setTimeout(()=>{this.navigateToSyncWithBrowser(n,"popstate",o)},0)})}navigateToSyncWithBrowser(n,o,s){let i={replaceUrl:!0},a=s?.navigationId?s:null;if(s){let l=et({},s);delete l.navigationId,delete l.\u0275routerPageId,Object.keys(l).length!==0&&(i.state=l)}let u=this.parseUrl(n);this.scheduleNavigation(u,o,a,i)}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.navigationTransitions.currentNavigation}get lastSuccessfulNavigation(){return this.navigationTransitions.lastSuccessfulNavigation}resetConfig(n){this.config=n.map(t2),this.navigated=!1}ngOnDestroy(){this.dispose()}dispose(){this.navigationTransitions.complete(),this.nonRouterCurrentEntryChangeSubscription&&(this.nonRouterCurrentEntryChangeSubscription.unsubscribe(),this.nonRouterCurrentEntryChangeSubscription=void 0),this.disposed=!0,this.eventsSubscription.unsubscribe()}createUrlTree(n,o={}){let{relativeTo:s,queryParams:i,fragment:a,queryParamsHandling:u,preserveFragment:l}=o,c=l?this.currentUrlTree.fragment:a,p=null;switch(u??this.options.defaultQueryParamsHandling){case"merge":p=et(et({},this.currentUrlTree.queryParams),i);break;case"preserve":p=this.currentUrlTree.queryParams;break;default:p=i||null}p!==null&&(p=this.removeEmptyProps(p));let d;try{let f=s?s.snapshot:this.routerState.snapshot.root;d=NV(f)}catch{(typeof n[0]!="string"||n[0][0]!=="/")&&(n=[]),d=this.currentUrlTree.root}return DV(d,n,p,c??null)}navigateByUrl(n,o={skipLocationChange:!1}){let s=kv(n)?n:this.parseUrl(n),i=this.urlHandlingStrategy.merge(s,this.rawUrlTree);return this.scheduleNavigation(i,Tv,null,o)}navigate(n,o={skipLocationChange:!1}){return Nhe(n),this.navigateByUrl(this.createUrlTree(n,o),o)}serializeUrl(n){return this.urlSerializer.serialize(n)}parseUrl(n){try{return this.urlSerializer.parse(n)}catch{return this.urlSerializer.parse("/")}}isActive(n,o){let s;if(o===!0?s=et({},Ehe):o===!1?s=et({},khe):s=o,kv(n))return dV(this.currentUrlTree,n,s);let i=this.parseUrl(n);return dV(this.currentUrlTree,i,s)}removeEmptyProps(n){return Object.entries(n).reduce((o,[s,i])=>(i!=null&&(o[s]=i),o),{})}scheduleNavigation(n,o,s,i,a){if(this.disposed)return Promise.resolve(!1);let u,l,c;a?(u=a.resolve,l=a.reject,c=a.promise):c=new Promise((d,f)=>{u=d,l=f});let p=this.pendingTasks.add();return The(this,()=>{queueMicrotask(()=>this.pendingTasks.remove(p))}),this.navigationTransitions.handleNavigationRequest({source:o,restoredState:s,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,rawUrl:n,extras:i,resolve:u,reject:l,promise:c,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),c.catch(d=>Promise.reject(d))}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=Qe({token:t,factory:t.\u0275fac,providedIn:"root"});let r=t;return r})();function Nhe(r){for(let t=0;t<r.length;t++)if(r[t]==null)throw new gt(4008,!1)}function Dhe(r){return!(r instanceof Rv)&&!(r instanceof ng)}var Ahe=new Ot("");function HV(r,...t){return u0([{provide:r2,multi:!0,useValue:r},[],{provide:gs,useFactory:Rhe,deps:[Do]},{provide:nR,multi:!0,useFactory:Ohe},t.map(e=>e.\u0275providers)])}function Rhe(r){return r.routerState.root}function Ohe(){let r=We($f);return t=>{let e=r.get(Wf);if(t!==e.components[0])return;let n=r.get(Do),o=r.get(Mhe);r.get(Fhe)===1&&n.initialNavigation(),r.get($he,null,$t.Optional)?.setUpPreloading(),r.get(Ahe,null,$t.Optional)?.init(),n.resetRootComponentType(e.componentTypes[0]),o.closed||(o.next(),o.complete(),o.unsubscribe())}}var Mhe=new Ot("",{factory:()=>new Mr}),Fhe=new Ot("",{providedIn:"root",factory:()=>1});var $he=new Ot("");var W0="0.0.12";var Ao=class r{version=W0;static \u0275fac=function(e){return new(e||r)};static \u0275cmp=or({type:r,selectors:[["app-footer"]],standalone:!0,features:[sr],decls:4,vars:1,consts:[[1,"footer"],[1,"content","has-text-centered"]],template:function(e,n){e&1&&(Me(0,"footer",0)(1,"div",1)(2,"p"),ot(3),Fe()()()),e&2&&(qt(3),ci("version ",n.version,""))},styles:[".footer[_ngcontent-%COMP%]{position:fixed;bottom:0;width:100%;padding:1rem}"]})};function qV(r){let t="An error occurred.";return r instanceof Error?t=`Error: ${r.message}

Stack Trace:
${r.stack}`:typeof r=="string"?t=`Error: ${r}`:typeof r=="object"&&r.message&&(t=`Error: ${r.message}

Stack Trace:
${r.stack}`),t}var Phe=r=>({"is-loading":r});function Lhe(r,t){if(r&1){let e=Xm();Me(0,"button",5),zr("click",function(){Bf(e);let o=vo();return Vf(o.askCameraAccess())}),ot(1," START "),Fe()}if(r&2){let e=vo();Er("ngClass",b0(1,Phe,e.started))}}function zhe(r,t){r&1&&(Me(0,"div",9),ot(1," Please make sure to open this page in Internet browser that has access to a camera. "),Fe())}function Bhe(r,t){if(r&1&&(Me(0,"div",10)(1,"p"),ot(2,"An error happened when trying to access the camera"),Fe(),Me(3,"p"),ot(4),Fe()()),r&2){let e=vo(2);qt(4),fv(e.error)}}function Vhe(r,t){if(r&1){let e=Xm();Me(0,"div",11)(1,"p"),ot(2,"We found a camera in your browser, we are ready, what game you want to play?"),Fe(),Me(3,"p")(4,"button",12),zr("click",function(){Bf(e);let o=vo(2);return Vf(o.balloonsGame())}),ot(5," PICK THE GREEN BALLS "),Fe(),Me(6,"button",12),zr("click",function(){Bf(e);let o=vo(2);return Vf(o.ticTacToeGame())}),ot(7," TIC-TAC-TOE "),Fe()()()}}function Uhe(r,t){if(r&1){let e=Xm();Me(0,"div",11)(1,"p"),ot(2,"TIC TAC TOE IS UNDER DEVELOPMENT, our current challenge is to define how to move your body to choose your move in the game. Ideas are welcome \u{1F60A}"),Fe(),Me(3,"p")(4,"button",12),zr("click",function(){Bf(e);let o=vo(2);return Vf(o.ticTacToeGame())}),ot(5," TIC-TAC-TOE "),Fe()()()}}function Ghe(r,t){if(r&1&&(Me(0,"div"),qo(1,zhe,2,0,"div",6)(2,Bhe,5,1,"div",7)(3,Vhe,8,0,"div",8)(4,Uhe,6,0,"div",8),Fe()),r&2){let e=vo();qt(),Er("ngIf",!e.mediaAPIAvailable),qt(),Er("ngIf",e.error),qt(),Er("ngIf",e.ready),qt(),Er("ngIf",e.ready)}}var j0=class r{constructor(t){this.router=t}started=!1;mediaAPIAvailable=!1;ready=!1;error;balloonsGame(){this.router.navigate(["/balloons"])}ticTacToeGame(){this.router.navigate(["/lobby/tic-tac-toe"])}askCameraAccess(){return L(this,null,function*(){this.checkIfMediaIsAvailable(),this.started=!0,console.log("ask camera access");try{yield fD(mD({videoAccess:this.getVideoAccess(),delay:gD(3e3)})),this.ready=!0,this.error=void 0}catch(t){console.error("Camera is not available",t),this.ready=!1,this.error=qV(t)}})}checkIfMediaIsAvailable(){navigator.mediaDevices?this.mediaAPIAvailable=!0:this.mediaAPIAvailable=!1}getVideoAccess(){return L(this,null,function*(){console.log("start to get media device");let t=yield navigator.mediaDevices.getUserMedia({video:!0});console.log("media device found",t)})}static \u0275fac=function(e){return new(e||r)(it(Do))};static \u0275cmp=or({type:r,selectors:[["app-welcome-page"]],standalone:!0,features:[sr],decls:14,vars:2,consts:[[1,"section"],[1,"container"],[1,"content","is-large"],["class","button is-large is-info",3,"ngClass","click",4,"ngIf"],[4,"ngIf"],[1,"button","is-large","is-info",3,"click","ngClass"],["class","notification is-warning",4,"ngIf"],["class","notification is-danger",4,"ngIf"],["class","box content is-large",4,"ngIf"],[1,"notification","is-warning"],[1,"notification","is-danger"],[1,"box","content","is-large"],[1,"button","is-large","is-primary","big-buttons",3,"click"]],template:function(e,n){e&1&&(Me(0,"section",0)(1,"div",1)(2,"div",2)(3,"h1"),ot(4,"Move, Play, Control"),Fe(),Wt(5,"p"),Me(6,"p"),ot(7," In Move Playground, your body is the controller. Your movements shape the game in real-time. Ready to jump in? "),Fe(),Me(8,"p"),ot(9,` To start, you'll need to allow camera access. Click on START and follow the prompt, click "Allow," and you're good to go! `),Fe(),qo(10,Lhe,2,3,"button",3),Fe(),qo(11,Ghe,5,4,"div",4),Fe()(),Wt(12,"section",0)(13,"app-footer")),e&2&&(qt(10),Er("ngIf",!n.ready),qt(),Er("ngIf",n.started))},dependencies:[Ao,Ko,T0,wp],styles:[".big-buttons[_ngcontent-%COMP%]{margin:10px}"]})};var Ip=class r{fps=10;lastFrameTime=0;running=!1;render;static getInstance(){return new r}constructor(){this.render=new Mr}setup(t){this.fps=t,this.lastFrameTime=0}start(){this.running=!0,this.lastFrameTime=performance.now(),this.animate()}stop(){this.running=!1,this.lastFrameTime=performance.now()}animate(){requestAnimationFrame(t=>{let e=t-this.lastFrameTime,n=1e3/this.fps;e>=n&&(this.lastFrameTime=t-e%n),this.running&&(this.render.next(e),this.animate())})}};var Tp=class r{poses=new Mr;handDetected=new Mr;constructor(){}moveHand(t){this.handDetected.next(t)}static \u0275fac=function(e){return new(e||r)};static \u0275prov=Qe({token:r,factory:r.\u0275fac,providedIn:"root"})};var H0=class r{constructor(t){this.poseState=t;this.refresh=Ip.getInstance()}canvas;ctx;balloons=[];MAX_LINES=4;BALLOON_RADIUS=30;MIN_BALLOONS=5;lines=[];currentLine=this.MAX_LINES-1;green=new dn;red=new dn;time=new dn;totalGameTime=3e5;currentTime=0;refresh;possiblePositions=[];ngOnInit(){this.setup(),this.calculateLines(),this.possiblePositions=this.calculatePossiblePositions(5),this.start(),this.poseState.handDetected.subscribe(t=>{this.didHandPopBalloon(t)})}didHandPopBalloon(t){this.balloons.forEach(e=>{Math.sqrt((t.x-e.x)**2+(t.y-e.y)**2)<e.radius&&this.popBalloon(e,`hand-${t.name}`)})}calculateLines(){let t=Math.floor(this.canvas.height/this.MAX_LINES),e=t/2;for(let n=1;n<=this.MAX_LINES;n++){let o=t*n-e;this.lines.push(o)}console.log("lines",this.lines,this.currentLine)}setup(){this.canvas=document.getElementById("gameCanvas");let t=this.canvas.getContext("2d");if(!t)throw new Error("Not able to get canvas context");this.ctx=t}start(){this.refresh.setup(20),this.refresh.render.subscribe(t=>{this.updateTimer(t),this.udpate()}),this.refresh.start()}udpate(){this.clearScreen(),this.removeOldRedBalloons(),this.keepMinimumAmountOfBalloons(),this.drawPossiblePositions(this.possiblePositions),this.drawAllBalloons(),this.time.emit(this.currentTime)}removeOldRedBalloons(){let t=performance.now();this.balloons=this.balloons.filter(e=>!(e.color==="red"&&t-e.creationTime>5e3))}keepMinimumAmountOfBalloons(){let t=this.MIN_BALLOONS-this.balloons.length;this.addBalloons(t)}updateTimer(t){this.currentTime+=t}clearScreen(){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height)}drawAllBalloons(){this.balloons.forEach(t=>{this.drawBalloon(t)})}drawBalloon(t){this.ctx.beginPath(),this.ctx.arc(t.x,t.y,t.radius,0,2*Math.PI),this.ctx.fillStyle=t.color,this.ctx.fill()}addBalloons(t){let e=[...this.possiblePositions];this.balloons.forEach(n=>{e=e.filter(o=>Math.sqrt((o.x-n.x)**2+(o.y-n.y)**2)>=this.BALLOON_RADIUS*2)});for(let n=0;n<t&&e.length>0;n++){let o=Math.floor(Math.random()*e.length),{x:s,y:i}=e.splice(o,1)[0],a={id:crypto.randomUUID(),x:s,y:i,color:Math.random()>.5?"green":"red",radius:this.BALLOON_RADIUS,popped:!1,creationTime:performance.now()};this.balloons.push(a)}}calculatePossiblePositions(t){let e=[],n=this.BALLOON_RADIUS*2,o=this.BALLOON_RADIUS*2+n,s=this.canvas.width;return this.lines.forEach(i=>{let a=n;for(;a+this.BALLOON_RADIUS*2<=s;)e.push({x:a+this.BALLOON_RADIUS,y:i}),a+=o}),console.log("positions",e),e}drawPossiblePositions(t){this.ctx.strokeStyle="#cccccc",this.ctx.lineWidth=2,t.forEach(({x:e,y:n})=>{this.ctx.beginPath(),this.ctx.arc(e,n,this.BALLOON_RADIUS,0,2*Math.PI),this.ctx.stroke()})}popBalloon(t,e){console.log("balloon popped by",e),t.popped||(t.popped=!0,t.color==="green"?this.green.emit():this.red.emit(),this.balloons=this.balloons.filter(n=>n.id!=t.id))}handleClick(t){if(!this.canvas){console.warn("No canvas defined yet...");return}let e=this.canvas.getBoundingClientRect(),n=t.clientX-e.left,o=t.clientY-e.top;console.log("click",n,o),this.balloons.forEach(s=>{Math.sqrt((n-s.x)**2+(o-s.y)**2)<s.radius&&this.popBalloon(s,"mouse-click")})}static \u0275fac=function(e){return new(e||r)(it(Tp))};static \u0275cmp=or({type:r,selectors:[["app-green-balloon-game"]],hostBindings:function(e,n){e&1&&zr("click",function(s){return n.handleClick(s)},!1,qz)},outputs:{green:"green",red:"red",time:"time"},standalone:!0,features:[sr],decls:2,vars:0,consts:[[1,"canvas-container"],["id","gameCanvas","width","640","height","480"]],template:function(e,n){e&1&&(Me(0,"div",0),Wt(1,"canvas",1),Fe())},styles:[".canvas-container[_ngcontent-%COMP%]{width:100%;height:100%;position:relative}canvas[_ngcontent-%COMP%]{width:100%;height:100%;display:block}"]})};var Au=class r{message=new Mr;warning(t){this.message.next(t)}clear(){this.message.next("")}static \u0275fac=function(e){return new(e||r)};static \u0275prov=Qe({token:r,factory:r.\u0275fac,providedIn:"root"})};function Whe(r,t){if(r&1&&(Me(0,"div",1),ot(1),Fe()),r&2){let e=vo();qt(),ci(" ",e.message,`
`)}}var ig=class r{constructor(t){this.notification=t}message="";ngOnInit(){this.notification.message.subscribe(t=>{this.message=t})}static \u0275fac=function(e){return new(e||r)(it(Au))};static \u0275cmp=or({type:r,selectors:[["app-notification"]],standalone:!0,features:[sr],decls:1,vars:1,consts:[["class","notification is-warning fixed-notification",4,"ngIf"],[1,"notification","is-warning","fixed-notification"]],template:function(e,n){e&1&&qo(0,Whe,2,1,"div",0),e&2&&Er("ngIf",n.message)},dependencies:[Ko,wp],styles:[".fixed-notification[_ngcontent-%COMP%]{position:fixed;bottom:20px;left:50%;transform:translate(-50%);z-index:1000;width:90%;max-width:500px}"]})};function jhe(r,t,e,n){return Math.sqrt((e-r)**2+(n-t)**2)}function Hhe(r,t){let e=Math.sqrt(r**2+t**2);return{x:r/e,y:t/e}}function qhe(r,t,e){let n=jhe(r.x,r.y,t.x,t.y),o={x:t.x-r.x,y:t.y-r.y},s=Hhe(o.x,o.y),i=n*e;return{x:t.x+i*s.x,y:t.y+i*s.y}}function KV(r,t){return qhe(r,t,.25)}var Khe=["poseCanvas"],XV=["nose","left_eye","right_eye","left_ear","right_ear"],Xhe=[["mouth_left","mouth_right"],["left_shoulder","right_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["left_shoulder","left_hip"],["right_shoulder","right_hip"],["left_hip","right_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["right_hip","right_knee"],["right_knee","right_ankle"],["left_ankle","left_foot_index"],["left_ankle","left_heel"],["right_ankle","right_foot_index"],["right_ankle","right_heel"]],K0=class r{constructor(t){this.poseState=t}canvasRef;poses=[];canvas;ctx;ngAfterViewInit(){this.canvas=this.canvasRef.nativeElement,this.ctx=this.canvas.getContext("2d"),this.drawPose()}ngOnChanges(){this.ctx&&(this.clearCanvas(),this.drawPose())}clearCanvas(){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height)}drawPose(){!this.poses||this.poses.length===0||this.poses.forEach(t=>{t.keypoints.forEach(n=>{["left_wrist","right_wrist"].includes(n.name)||XV.includes(n.name)||this.drawPoint(n.x,n.y,n.score)}),this.drawSkeletonWithStrings(t.keypoints),this.drawHeadCircleAroundCenter(t.keypoints),this.drawHandCirclesAroundCenter(t.keypoints)})}drawPoint(t,e,n){if(n>.5){let o=this.getColorForConfidence(n);this.ctx.beginPath(),this.ctx.arc(t,e,5,0,2*Math.PI),this.ctx.fillStyle=o,this.ctx.fill()}}getColorForConfidence(t){let e=(t-.5)*2;return`hsl(${Math.floor(e*120)}, 100%, 50%)`}drawSkeletonWithStrings(t){let e=t.reduce((n,o)=>(o.name&&(n[o.name]=o),n),{});Xhe.forEach(([n,o])=>{let s=e[n],i=e[o];s&&i&&s.score>.5&&i.score>.5&&(this.ctx.beginPath(),this.ctx.moveTo(s.x,s.y),this.ctx.lineTo(i.x,i.y),this.ctx.strokeStyle="white",this.ctx.lineWidth=3,this.ctx.stroke())})}drawHeadCircleAroundCenter(t){let e=this.createKeypointMap(t);this.drawCircleForHead(XV,e)}drawCircleForHead(t,e){let n=t.map(o=>e[o]).filter(o=>o&&o.score>.5);if(n.length>0){let o=this.calculateCenter(n);this.ctx.beginPath(),this.ctx.arc(o.x,o.y,60,0,2*Math.PI),this.ctx.strokeStyle="white",this.ctx.lineWidth=3,this.ctx.stroke()}}drawHandCirclesAroundCenter(t){let e=this.createKeypointMap(t),n=this.drawCircleForHand("left","left_elbow","left_wrist",e),o=this.drawCircleForHand("right","right_elbow","right_wrist",e);n&&this.poseState.moveHand(n),o&&this.poseState.moveHand(o)}drawCircleForHand(t,e,n,o){let s=o[e],i=o[n];if(s&&i&&s.score>.5&&i.score>.5){let a=KV(s,i);return this.ctx.beginPath(),this.ctx.arc(a.x,a.y,20,0,2*Math.PI),this.ctx.strokeStyle="blue",this.ctx.lineWidth=3,this.ctx.stroke(),{name:t,x:a.x,y:a.y,radius:20}}}calculateCenter(t){let e=t.length,n=t.reduce((o,s)=>(o.x+=s.x,o.y+=s.y,o),{x:0,y:0});return{x:n.x/e,y:n.y/e}}createKeypointMap(t){return t.reduce((e,n)=>(n.name&&(e[n.name]=n),e),{})}static \u0275fac=function(e){return new(e||r)(it(Tp))};static \u0275cmp=or({type:r,selectors:[["app-pose-drawer"]],viewQuery:function(e,n){if(e&1&&v0(Khe,5),e&2){let o;pv(o=dv())&&(n.canvasRef=o.first)}},inputs:{poses:"poses"},standalone:!0,features:[yp,sr],decls:3,vars:0,consts:[["poseCanvas",""],["width","640","height","480"]],template:function(e,n){e&1&&(Me(0,"div"),Wt(1,"canvas",1,0),Fe())},styles:["canvas[_ngcontent-%COMP%]{border:1px solid black}"]})};var v8=If(ZV());var dc=class{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}},Zi=class{refCount(t){return ys("refCount")}incRef(t){return ys("incRef")}timerAvailable(){return!0}time(t){return ys("time")}read(t){return ys("read")}readSync(t){return ys("readSync")}readToGPU(t,e){return ys("readToGPU")}numDataIds(){return ys("numDataIds")}disposeData(t,e){return ys("disposeData")}write(t,e,n){return ys("write")}move(t,e,n,o,s){return ys("move")}createTensorFromGPUData(t,e,n){return ys("createTensorFromGPUData")}memory(){return ys("memory")}floatPrecision(){return ys("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return ys("dispose")}};function ys(r){throw new Error(`'${r}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function QV(r){let t=r.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,X0(r,t,e)}function Yhe(r,t){if(r.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${r.length}Second array length was ${t.length}`);let e=r.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,X0(r,e,n),X0(t,e,n)}function ag(r,t,e){return Math.max(r,Math.min(t,e))}function Zhe(r){return r%2===0?r:r+1}function X0(r,t,e){let n=r[t];r[t]=r[e],r[e]=n}function Qhe(r){let t=0;for(let e=0;e<r.length;e++)t+=r[e];return t}function Jhe(r,t){let e=Math.random();return t*e+(1-e)*r}function eme(r,t){let e=0;for(let n=0;n<r.length;n++){let o=Number(r[n])-Number(t[n]);e+=o*o}return e}function F(r,t){if(!r)throw new Error(typeof t=="string"?t:t())}function on(r,t,e=""){F(xs(r,t),()=>e+` Shapes ${r} and ${t} must match`)}function Ws(r){F(r!=null,()=>"The input to the tensor constructor must be a non-null value.")}function bt(r){if(r.length===0)return 1;let t=r[0];for(let e=1;e<r.length;e++)t*=r[e];return t}function tme(r){return r.length===0}function s2(r,t){if(r===t)return!0;if(r==null||t==null||r.length!==t.length)return!1;for(let e=0;e<r.length;e++)if(r[e]!==null&&t[e]!==null&&r[e]!==t[e])return!1;return!0}function xs(r,t){if(r===t)return!0;if(r==null||t==null||r.length!==t.length)return!1;for(let e=0;e<r.length;e++)if(r[e]!==t[e])return!1;return!0}function fc(r){return r%1===0}function rme(r){if(Math.tanh!=null)return Math.tanh(r);if(r===1/0)return 1;if(r===-1/0)return-1;{let t=Math.exp(2*r);return(t-1)/(t+1)}}function nme(r){let t=Math.ceil(Math.sqrt(r));return[t,Math.ceil(r/t)]}function ome(r){let t=new Uint32Array(r);for(let e=0;e<r;++e)t[e]=e;return QV(t),t}function Yf(r,t){return t<=r.length?r:r+" ".repeat(t-r.length)}function sme(r,t=o=>0,e,n){return new Promise((o,s)=>{let i=0,a=()=>{if(r()){o();return}i++;let u=t(i);if(e!=null&&i>=e){s();return}n!=null?n(a,u):setTimeout(a,u)};a()})}function ime(r,t){let e=1,n=-1;for(let s=0;s<r.length;++s)if(r[s]>=0)e*=r[s];else if(r[s]===-1){if(n!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${n} and dim ${s}`);n=s}else if(r[s]<0)throw Error(`Shapes can not be < 0. Found ${r[s]} at dim ${s}`);if(n===-1){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${r}`);return r}if(e===0)throw Error(`Cannot infer the missing size in [${r}] when there are 0 elements`);if(t%e!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);let o=r.slice();return o[n]=t/e,o}function Cn(r,t){let e=t.length;return r=r==null?t.map((n,o)=>o):[].concat(r),F(r.every(n=>n>=-e&&n<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${r}`),F(r.every(n=>fc(n)),()=>`All values in axis param must be integers but got axis ${r}`),r.map(n=>n<0?e+n:n)}function i2(r,t){let e=[],n=[],o=t!=null&&Array.isArray(t)&&t.length===0,s=t==null||o?null:Cn(t,r).sort(),i=0;for(let a=0;a<r.length;++a){if(s!=null){if(s[i]===a&&r[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${r[a]}' is not 1`);(s[i]==null||s[i]>a)&&r[a]===1&&(e.push(r[a]),n.push(a)),s[i]<=a&&i++}r[a]!==1&&(e.push(r[a]),n.push(a))}return{newShape:e,keptDims:n}}function a2(r,t){return Y0(r,t)}function Y0(r,t){let e=null;if(r==null||r==="float32")e=new Float32Array(t);else if(r==="int32")e=new Int32Array(t);else if(r==="bool")e=new Uint8Array(t);else if(r==="string")e=new Array(t);else throw new Error(`Unknown data type ${r}`);return e}function u2(r,t){for(let e=0;e<r.length;e++){let n=r[e];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${t} being uploaded contains ${n}.`)}}function l2(r){return r==="bool"||r==="complex64"||r==="float32"||r==="int32"||r==="string"}function ame(r,t){return!(t==="complex64"||t==="float32"&&r!=="complex64"||t==="int32"&&r!=="float32"&&r!=="complex64"||t==="bool"&&r==="bool")}function ug(r){if(r==="float32"||r==="int32")return 4;if(r==="complex64")return 8;if(r==="bool")return 1;throw new Error(`Unknown dtype ${r}`)}function c2(r){if(r==null)return 0;let t=0;return r.forEach(e=>t+=e.length),t}function lg(r){return typeof r=="string"||r instanceof String}function JV(r){return typeof r=="boolean"}function eU(r){return typeof r=="number"}function _p(r){return Array.isArray(r)?_p(r[0]):r instanceof Float32Array?"float32":r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray?"int32":eU(r)?"float32":lg(r)?"string":JV(r)?"bool":"float32"}function cg(r){return!!(r&&r.constructor&&r.call&&r.apply)}function pg(r,t){for(let e=t;e<r;++e)if(r%e===0)return e;return r}function Ru(r){let t=r.length;if(t<2)return[];let e=new Array(t-1);e[t-2]=r[t-1];for(let n=t-3;n>=0;--n)e[n]=e[n+1]*r[n+1];return e}function tU(r,t,e,n=!1){let o=new Array;if(t.length===1){let s=t[0]*(n?2:1);for(let i=0;i<s;i++)o[i]=e[r+i]}else{let s=t[0],i=t.slice(1),a=i.reduce((u,l)=>u*l)*(n?2:1);for(let u=0;u<s;u++)o[u]=tU(r+u*a,i,e,n)}return o}function Xf(r,t,e=!1){if(r.length===0)return t[0];let n=r.reduce((o,s)=>o*s)*(e?2:1);if(n===0)return[];if(n!==t.length)throw new Error(`[${r}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return tU(0,r,t,e)}function ume(r,t){if(Array.isArray(r))return r;if(t==="float32")return r instanceof Float32Array?r:new Float32Array(r);if(t==="int32")return r instanceof Int32Array?r:new Int32Array(r);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(r));throw new Error(`Unknown dtype ${t}`)}function Bv(r,t){let e=dg(r,t);for(let n=0;n<e.length;n++)e[n]=1;return e}function dg(r,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(r);if(t==="int32")return new Int32Array(r);if(t==="bool")return new Uint8Array(r);throw new Error(`Unknown data type ${t}`)}function lme(r,t){let e=r.reduce((n,o)=>n*o,1);if(t==null||t==="float32")return Xf(r,new Float32Array(e));if(t==="int32")return Xf(r,new Int32Array(e));if(t==="bool")return Xf(r,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function Vr(r){r.forEach(t=>{F(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${r}].`)})}function cme(r,t,e){if(t===0)return 0;if(t===1)return r[0];let n=r[r.length-1];for(let o=0;o<r.length-1;++o)n+=e[o]*r[o];return n}function pme(r,t,e){if(t===0)return[];if(t===1)return[r];let n=new Array(t);for(let o=0;o<n.length-1;++o)n[o]=Math.floor(r/e[o]),r-=n[o]*e[o];return n[n.length-1]=r,n}function Zf(r){return r&&r.then&&typeof r.then=="function"}var rU="tfjsflags",Vv=class{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=fme,this.populateURLFlags()}setPlatform(t,e){this.platform!=null&&(j().getBool("IS_TEST")||j().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},this.urlFlags[t]!=null){let o=this.urlFlags[t];j().getBool("IS_TEST")||j().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${o}.`),this.set(t,o)}}getAsync(t){return L(this,null,function*(){return t in this.flags?this.flags[t]:(this.flags[t]=yield this.evaluateFlag(t),this.flags[t])})}get(t){if(t in this.flags)return this.flags[t];let e=this.evaluateFlag(t);if(Zf(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let t=this.getQueryParams(this.global.location.search);rU in t&&t[rU].split(",").forEach(n=>{let[o,s]=n.split(":");this.urlFlags[o]=mme(o,s)})}};function fme(r){let t={};return r.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...n)=>(hme(t,n[0],n[1]),n.join("="))),t}function hme(r,t,e){r[decodeURIComponent(t)]=decodeURIComponent(e||"")}function mme(r,t){let e=t.toLowerCase();return e==="true"||e==="false"?e==="true":`${+e}`===e?+e:t}function j(){return p2}var p2=null;function nU(r){p2=r}var d2;function f2(){if(d2==null){let r;if(typeof window<"u")r=window;else if(typeof global<"u")r=global;else if(typeof process<"u")r=process;else if(typeof self<"u")r=self;else throw new Error("Could not find a global object");d2=r}return d2}function gme(){let r=f2();return r._tfGlobals==null&&(r._tfGlobals=new Map),r._tfGlobals}function Uv(r,t){let e=gme();if(e.has(r))return e.get(r);{let n=t();return e.set(r,n),e.get(r)}}var Ou="Abs",Qi="Acos",Ji="Acosh",js="Add",Mu="AddN",Ep="All",kp="Any",Fu="ArgMax",$u="ArgMin",ea="Asin",ta="Asinh",ra="Atan",na="Atanh",oa="Atan2",Pu="AvgPool",Np="AvgPoolGrad",Lu="AvgPool3D",Dp="AvgPool3DGrad",zu="BatchMatMul",Bu="BatchToSpaceND",Ap="Bincount",Qf="BitwiseAnd",oU="BroadcastTo",Rp="BroadcastArgs",di="Cast",sa="Ceil",ia="ClipByValue",Op="Complex",Vu="ComplexAbs",Uu="Concat",Gu="Conv2D",Mp="Conv2DBackpropFilter",Wu="Conv2DBackpropInput",ju="Conv3D",Fp="Conv3DBackpropFilterV2",$p="Conv3DBackpropInputV2",aa="Cos",ua="Cosh",Pp="Cumprod",Hu="Cumsum",Lp="CropAndResize",zp="DenseBincount",Bp="DepthToSpace",qu="DepthwiseConv2dNative",Vp="DepthwiseConv2dNativeBackpropFilter",Up="DepthwiseConv2dNativeBackpropInput",Gp="Diag",Ku="Dilation2D",Jf="Dilation2DBackpropInput",eh="Dilation2DBackpropFilter",th="Draw",la="RealDiv",Wp="Einsum",ca="Elu",jp="EluGrad",pa="Erf",hc="Equal",da="Exp",Xu="ExpandDims",fa="Expm1",Hp="FFT",qp="Fill",Kp="FlipLeftRight",ha="Floor",ma="FloorDiv",Yu="FusedBatchNorm",Zu="GatherV2",Xp="GatherNd",mc="Greater",ga="GreaterEqual",fi="Identity",Yp="IFFT",Zp="Imag",ya="IsFinite",xa="IsInf",va="IsNan",Qu="LeakyRelu",gc="Less",yc="LessEqual",Qp="LinSpace",ba="Log",wa="Log1p",xc="LogicalAnd",vc="LogicalNot",bc="LogicalOr";var sU="LogSoftmax";var Ju="LRN",Jp="LRNGrad";var el="Max",Ca="Maximum",tl="MaxPool",ed="MaxPoolGrad",rl="MaxPool3D",td="MaxPool3DGrad",rd="MaxPoolWithArgmax",nl="Mean",ol="Min",Sa="Minimum",sl="MirrorPad",Ia="Mod",nd="Multinomial",Ta="Multiply",il="Neg",wc="NotEqual",od="NonMaxSuppressionV3",fg="NonMaxSuppressionV4",sd="NonMaxSuppressionV5",al="OnesLike",ul="OneHot",ll="Pack",cl="PadV2";var _a="Pow",pl="Prelu",dl="Prod",hg="RaggedGather",mg="RaggedRange",gg="RaggedTensorToTensor",id="Range",ad="Real",Ea="Reciprocal",ka="Relu",fl="Reshape",hl="ResizeNearestNeighbor",ud="ResizeNearestNeighborGrad",ml="ResizeBilinear",ld="ResizeBilinearGrad",Na="Relu6",gl="Reverse",Da="Round",Aa="Rsqrt",cd="ScatterNd",pd="TensorScatterUpdate",dd="SearchSorted",yl="Select",Ra="Selu",xl="Slice",Oa="Sin",Ma="Sinh",Fa="Sign",$a="Sigmoid",Pa="Softplus",La="Sqrt",vl="Sum",bl="SpaceToBatchND",wl="SplitV",Cl="Softmax",yg="SparseFillEmptyRows",xg="SparseReshape",fd="SparseSegmentMean",hd="SparseSegmentSum",md="SparseToDense",za="SquaredDifference",gd="Square",rh="StaticRegexReplace",yd="StridedSlice",xd="StringNGrams",vg="StringSplit",bg="StringToHashBucketFast",Ba="Sub",Va="Tan",Ua="Tanh",hi="Tile",vd="TopK",bd="Transform",mi="Transpose",wg="Unique",Sl="Unpack",Il="UnsortedSegmentSum";var Tl="ZerosLike",Ga="Step",nh="FromPixels",wd="RotateWithOffset",Cc="_FusedMatMul",Sc="FusedConv2D",Ic="FusedDepthwiseConv2D";function _l(...r){j().getBool("IS_TEST")||j().getBool("PROD")||console.warn(...r)}function yme(...r){j().getBool("IS_TEST")||j().getBool("PROD")||console.log(...r)}var Z0=Uv("kernelRegistry",()=>new Map),h2=Uv("gradRegistry",()=>new Map);function Cg(r,t){let e=uU(r,t);return Z0.get(e)}function m2(r){return h2.get(r)}function g2(r){let t=Z0.entries(),e=[];for(;;){let{done:n,value:o}=t.next();if(n)break;let[s,i]=o,[a]=s.split("_");a===r&&e.push(i)}return e}function Sg(r){let{kernelName:t,backendName:e}=r,n=uU(t,e);Z0.has(n)&&_l(`The kernel '${t}' for backend '${e}' is already registered`),Z0.set(n,r)}function aU(r){let{kernelName:t}=r;h2.has(t)&&j().getBool("DEBUG")&&_l(`Overriding the gradient for '${t}'`),h2.set(t,r)}function uU(r,t){return`${t}_${r}`}var b={};ur(b,{arraysEqual:()=>xs,arraysEqualWithNull:()=>s2,assert:()=>F,assertNonNegativeIntegerDimensions:()=>Vr,assertNonNull:()=>Ws,assertShapesMatch:()=>on,bytesFromStringArray:()=>c2,bytesPerElement:()=>ug,checkConversionForErrors:()=>u2,clamp:()=>ag,computeStrides:()=>Ru,convertBackendValuesAndArrayBuffer:()=>ume,createScalarValue:()=>Ime,createShuffledIndices:()=>ome,decodeString:()=>kg,distSquared:()=>eme,encodeString:()=>Eg,fetch:()=>_me,fingerPrint64:()=>Sme,flatten:()=>Sd,getArrayFromDType:()=>Y0,getTypedArrayFromDType:()=>a2,hasEncodingLoss:()=>ame,hexToLong:()=>Gv,indexToLoc:()=>pme,inferDtype:()=>_p,inferFromImplicitShape:()=>ime,isBoolean:()=>JV,isFunction:()=>cg,isInt:()=>fc,isNumber:()=>eU,isPromise:()=>Zf,isScalarShape:()=>tme,isString:()=>lg,isTypedArray:()=>wo,isValidDtype:()=>l2,locToIndex:()=>cme,makeOnesTypedArray:()=>Bv,makeZerosNestedTypedArray:()=>lme,makeZerosTypedArray:()=>dg,nearestDivisor:()=>pg,nearestLargerEven:()=>Zhe,now:()=>uh,parseAxisParam:()=>Cn,randUniform:()=>Jhe,repeatedTry:()=>sme,rightPad:()=>Yf,shuffle:()=>QV,shuffleCombo:()=>Yhe,sizeFromShape:()=>bt,sizeToSquarishShape:()=>nme,squeezeShape:()=>i2,sum:()=>Qhe,swap:()=>X0,tanh:()=>rme,toNestedArray:()=>Xf,toTypedArray:()=>_g});function Q0(r){return r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray}var b2=If(vU());var ah=b2.default||b2;function Gv(r){return ah.fromString(r,!0,16)}var wU=Gv("c3a5c85c97cb3127"),ih=Gv("b492b66fbe98f273"),Ro=Gv("9ae16a3b2f90404f");function v2(r){return r.xor(r.shru(47))}function CU(r,t,e){let n=r.slice(t,t+e);return ah.fromBytes(Array.from(n),!0,!0)}function Ur(r,t){return CU(r,t,8)}function bU(r,t){return CU(r,t,4)}function Qn(r,t){return t===0?r:r.shru(t).or(r.shl(64-t))}function Cd(r,t,e=Gv("9ddfea08eb382d69")){let n=r.xor(t).mul(e);n=n.xor(n.shru(47));let o=t.xor(n).mul(e);return o=o.xor(o.shru(47)),o=o.mul(e),o}function vme(r,t,e,n,o,s){o=o.add(r),s=Qn(s.add(o).add(n),21);let i=o;return o=o.add(t),o=o.add(e),s=s.add(Qn(o,44)),[o.add(n),s.add(i)]}function eS(r,t,e,n){return vme(Ur(r,t),Ur(r,t+8),Ur(r,t+16),Ur(r,t+24),e,n)}function bme(r,t=r.length){if(t>=8){let e=Ro.add(t*2),n=Ur(r,0).add(Ro),o=Ur(r,t-8),s=Qn(o,37).mul(e).add(n),i=Qn(n,25).add(o).mul(e);return Cd(s,i,e)}if(t>=4){let e=Ro.add(t*2),n=bU(r,0);return Cd(n.shl(3).add(t),bU(r,t-4),e)}if(t>0){let e=r[0],n=r[t>>1],o=r[t-1],s=e+(n<<8),i=t+(o<<2);return v2(Ro.mul(s).xor(wU.mul(i))).mul(Ro)}return Ro}function wme(r,t=r.length){let e=Ro.add(t*2),n=Ur(r,0).mul(ih),o=Ur(r,8),s=Ur(r,t-8).mul(e),i=Ur(r,t-16).mul(Ro);return Cd(Qn(n.add(o),43).add(Qn(s,30)).add(i),n.add(Qn(o.add(Ro),18)).add(s),e)}function Cme(r,t=r.length){let e=Ro.add(t*2),n=Ur(r,0).mul(Ro),o=Ur(r,8),s=Ur(r,t-8).mul(e),i=Ur(r,t-16).mul(Ro),a=Qn(n.add(o),43).add(Qn(s,30)).add(i),u=Cd(a,n.add(Qn(o.add(Ro),18)).add(s),e),l=Ur(r,16).mul(e),c=Ur(r,24),p=a.add(Ur(r,t-32)).mul(e),d=u.add(Ur(r,t-24)).mul(e);return Cd(Qn(l.add(c),43).add(Qn(p,30)).add(d),l.add(Qn(c.add(n),18)).add(p),e)}function Sme(r,t=r.length){let e=ah.fromNumber(81,!0);if(t<=32)return t<=16?bme(r,t):wme(r,t);if(t<=64)return Cme(r,t);let n=e,o=e.mul(ih).add(113),s=v2(o.mul(Ro).add(113)).mul(Ro),i=[ah.UZERO,ah.UZERO],a=[ah.UZERO,ah.UZERO];n=n.mul(Ro).add(Ur(r,0));let u=0,l=(t-1>>6)*64,c=l+(t-1&63)-63;do n=Qn(n.add(o).add(i[0]).add(Ur(r,u+8)),37).mul(ih),o=Qn(o.add(i[1]).add(Ur(r,u+48)),42).mul(ih),n=n.xor(a[1]),o=o.add(i[0]).add(Ur(r,u+40)),s=Qn(s.add(a[0]),33).mul(ih),i=eS(r,u,i[1].mul(ih),n.add(a[0])),a=eS(r,u+32,s.add(a[1]),o.add(Ur(r,u+16))),[s,n]=[n,s],u+=64;while(u!==l);let p=ih.add(s.and(255).shl(1));return u=c,a[0]=a[0].add(t-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),n=Qn(n.add(o).add(i[0]).add(Ur(r,u+8)),37).mul(p),o=Qn(o.add(i[1]).add(Ur(r,u+48)),42).mul(p),n=n.xor(a[1].mul(9)),o=o.add(i[0].mul(9).add(Ur(r,u+40))),s=Qn(s.add(a[0]),33).mul(p),i=eS(r,u,i[1].mul(p),n.add(a[0])),a=eS(r,u+32,s.add(a[1]),o.add(Ur(r,u+16))),[s,n]=[n,s],Cd(Cd(i[0],a[0],p).add(v2(o).mul(wU)).add(s),Cd(i[1],a[1],p).add(n),p)}function Ime(r,t){return t==="string"?Eg(r):_g([r],t)}function Tme(r,t){return r instanceof Float32Array&&t==="float32"||r instanceof Int32Array&&t==="int32"||r instanceof Uint8Array&&t==="bool"}function _g(r,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(r)&&(r=Sd(r)),j().getBool("DEBUG")&&u2(r,t),Tme(r,t))return r;if(t==null||t==="float32"||t==="complex64")return new Float32Array(r);if(t==="int32")return new Int32Array(r);if(t==="bool"){let e=new Uint8Array(r.length);for(let n=0;n<e.length;++n)Math.round(r[n])!==0&&(e[n]=1);return e}else throw new Error(`Unknown data type ${t}`)}function uh(){return j().platform.now()}function _me(r,t){return j().platform.fetch(r,t)}function Eg(r,t="utf-8"){return t=t||"utf-8",j().platform.encode(r,t)}function kg(r,t="utf-8"){return t=t||"utf-8",j().platform.decode(r,t)}function wo(r){return j().platform.isTypedArray!=null?j().platform.isTypedArray(r):Q0(r)}function Sd(r,t=[],e=!1){if(t==null&&(t=[]),typeof r=="boolean"||typeof r=="number"||typeof r=="string"||Zf(r)||r==null||wo(r)&&e)t.push(r);else if(Array.isArray(r)||wo(r))for(let n=0;n<r.length;++n)Sd(r[n],t,e);else{let n=-1;for(let o of Object.keys(r))/^([1-9]+[0-9]*|0)$/.test(o)&&(n=Math.max(n,Number(o)));for(let o=0;o<=n;o++)Sd(r[o],t,e)}return t}var tS=class{constructor(t,e){this.backendTimer=t,this.logger=e,e==null&&(this.logger=new w2)}profileKernel(t,e,n){let o,s=()=>{o=n()},i,a=uh();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(s);else{s();for(let l of o)l.dataSync();i=Promise.resolve({kernelMs:uh()-a})}if(j().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<o.length;l++){let c=o[l];c.data().then(p=>{Eme(p,c.dtype,t)})}return{kernelName:t,outputs:o,inputs:e,timeMs:i.then(l=>l.kernelMs),extraInfo:i.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(t){let{kernelName:e,outputs:n,timeMs:o,inputs:s,extraInfo:i}=t;n.forEach(a=>{Promise.all([a.data(),o,i]).then(u=>{this.logger.logKernelProfile(e,a,u[0],u[1],s,u[2])})})}};function Eme(r,t,e){if(t!=="float32")return!1;for(let n=0;n<r.length;n++){let o=r[n];if(isNaN(o)||!isFinite(o))return console.warn(`Found ${o} in the result of '${e}'`),!0}return!1}var w2=class{logKernelProfile(t,e,n,o,s,i){let a=typeof o=="number"?Yf(`${o}ms`,9):o.error,u=Yf(t,25),l=e.rank,c=e.size,p=Yf(e.shape.toString(),14),d="";for(let f in s){let h=s[f];if(h!=null){let m=h.shape||e.shape,g=m.length;d+=`${f}: ${g}D ${g>0?m:""} `}}console.log(`%c${u}	%c${a}	%c${l}D ${p}	%c${c}	%c${d}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function SU(r,t,e){let n={},o={};for(let u=0;u<t.length;u++)n[t[u].id]=!0;for(let u=0;u<r.length;u++){let l=r[u],c=l.inputs;for(let p in c){let d=c[p],f=!1;for(let h=0;h<t.length;h++)if(n[d.id]){l.outputs.forEach(m=>n[m.id]=!0),f=!0,o[l.id]=!0;break}if(f)break}}let s={};s[e.id]=!0;let i={};for(let u=r.length-1;u>=0;u--){let l=r[u],c=l.inputs;for(let p=0;p<l.outputs.length;p++)if(s[l.outputs[p].id]){for(let d in c)s[c[d].id]=!0,i[l.id]=!0;break}}let a=[];for(let u=0;u<r.length;u++){let l=r[u];if(o[l.id]&&i[l.id]){let c={};for(let d in l.inputs){let f=l.inputs[d];n[f.id]&&(c[d]=f)}let p=Object.assign({},l);p.inputs=c,p.outputs=l.outputs,a.push(p)}}return a}function IU(r,t,e,n){for(let o=t.length-1;o>=0;o--){let s=t[o],i=[];if(s.outputs.forEach(u=>{let l=r[u.id];l!=null?i.push(l):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let a=s.gradient(i);for(let u in s.inputs){if(!(u in a))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(a)}.`);let l=e(()=>a[u]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${l.dtype}'`);let c=s.inputs[u];if(!xs(l.shape,c.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${u}' has shape '${l.shape}', which does not match the shape of the input '${c.shape}'`);if(r[c.id]==null)r[c.id]=l;else{let p=r[c.id];r[c.id]=n(p,l),p.dispose()}}}}var TU=20,Wv=3,C2=7;function _U(r,t,e,n){let o=Ru(t),s=kme(r,t,e,o),i=t.length,a=rS(r,t,e,o,s),u=["Tensor"];return n&&(u.push(`  dtype: ${e}`),u.push(`  rank: ${i}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(a.map(l=>"    "+l).join(`
`)),u.join(`
`)}function kme(r,t,e,n){let o=bt(t),s=n[n.length-1],i=new Array(s).fill(0),a=t.length,u=e==="complex64"?Hv(r):r;if(a>1)for(let l=0;l<o/s;l++){let c=l*s;for(let p=0;p<s;p++)i[p]=Math.max(i[p],jv(u[c+p],0,e).length)}return i}function jv(r,t,e){let n;return Array.isArray(r)?n=`${parseFloat(r[0].toFixed(C2))} + ${parseFloat(r[1].toFixed(C2))}j`:lg(r)?n=`'${r}'`:e==="bool"?n=EU(r):n=parseFloat(r.toFixed(C2)).toString(),Yf(n,t)}function EU(r){return r===0?"false":"true"}function rS(r,t,e,n,o,s=!0){let i=e==="complex64"?2:1,a=t[0],u=t.length;if(u===0){if(e==="complex64"){let m=Hv(r);return[jv(m[0],0,e)]}return e==="bool"?[EU(r[0])]:[r[0].toString()]}if(u===1){if(a>TU){let g=Wv*i,y=Array.from(r.slice(0,g)),x=Array.from(r.slice((a-Wv)*i,a*i));return e==="complex64"&&(y=Hv(y),x=Hv(x)),["["+y.map((w,C)=>jv(w,o[C],e)).join(", ")+", ..., "+x.map((w,C)=>jv(w,o[a-Wv+C],e)).join(", ")+"]"]}return["["+(e==="complex64"?Hv(r):Array.from(r)).map((g,y)=>jv(g,o[y],e)).join(", ")+"]"]}let l=t.slice(1),c=n.slice(1),p=n[0]*i,d=[];if(a>TU){for(let m=0;m<Wv;m++){let g=m*p,y=g+p;d.push(...rS(r.slice(g,y),l,e,c,o,!1))}d.push("...");for(let m=a-Wv;m<a;m++){let g=m*p,y=g+p;d.push(...rS(r.slice(g,y),l,e,c,o,m===a-1))}}else for(let m=0;m<a;m++){let g=m*p,y=g+p;d.push(...rS(r.slice(g,y),l,e,c,o,m===a-1))}let f=u===2?",":"";d[0]="["+(a>0?d[0]+f:"");for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+f;let h=`,
`;for(let m=2;m<u;m++)h+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":h),d}function Hv(r){let t=[];for(let e=0;e<r.length;e+=2)t.push([r[e],r[e+1]]);return t}var jt=class{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=bt(t),n!=null){let o=n.length;F(o===this.size,()=>`Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Y0(e,this.size),this.strides=Ru(t)}set(t,...e){e.length===0&&(e=[0]),F(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);let n=this.locToIndex(e);this.values[n]=t}get(...t){t.length===0&&(t=[0]);let e=0;for(let o of t){if(o<0||o>=this.shape[e]){let s=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(s)}e++}let n=t[t.length-1];for(let o=0;o<t.length-1;++o)n+=this.strides[o]*t[o];return this.values[n]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];let e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return ja().makeTensor(this.values,this.shape,this.dtype)}},ja=null,Ng=null,Nme=null;function kU(r){ja=r}function NU(r){Ng=r}function DU(r){Nme=r}var ct=class{constructor(t,e,n,o){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=bt(t),this.strides=Ru(t),this.dataId=n,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){return L(this,null,function*(){let t=yield this.data();return Ng.buffer(this.shape,this.dtype,t)})}bufferSync(){return Ng.buffer(this.shape,this.dtype,this.dataSync())}array(){return L(this,null,function*(){let t=yield this.data();return Xf(this.shape,t,this.dtype==="complex64")})}arraySync(){return Xf(this.shape,this.dataSync(),this.dtype==="complex64")}data(){return L(this,null,function*(){this.throwIfDisposed();let t=ja().read(this.dataId);if(this.dtype==="string"){let e=yield t;try{return e.map(n=>kg(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t})}dataToGPU(t){return this.throwIfDisposed(),ja().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();let t=ja().readSync(this.dataId);if(this.dtype==="string")try{return t.map(e=>kg(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}bytes(){return L(this,null,function*(){this.throwIfDisposed();let t=yield ja().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)})}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),ja().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Ng.print(this,t)}clone(){return this.throwIfDisposed(),Ng.clone(this)}toString(t=!1){let e=this.dataSync();return _U(e,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Ng.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),ja().makeVariable(this,t,e,n)}};Object.defineProperty(ct,Symbol.hasInstance,{value:r=>!!r&&r.data!=null&&r.dataSync!=null&&r.throwIfDisposed!=null});function U(){return Uv("Tensor",()=>ct)}U();var Tc=class extends ct{constructor(t,e,n,o){super(t.shape,t.dtype,t.dataId,o),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!xs(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);ja().disposeTensor(this),this.dataId=t.dataId,ja().incRef(this,null)}dispose(){ja().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Tc,Symbol.hasInstance,{value:r=>r instanceof ct&&r.assign!=null&&r.assign instanceof Function});var AU=function(r){return r.float32="float32",r.int32="int32",r.bool="int32",r.complex64="complex64",r}(AU||{}),RU=function(r){return r.float32="float32",r.int32="int32",r.bool="bool",r.complex64="complex64",r}(RU||{}),OU=function(r){return r.float32="float32",r.int32="float32",r.bool="float32",r.complex64="complex64",r}(OU||{}),MU=function(r){return r.float32="complex64",r.int32="complex64",r.bool="complex64",r.complex64="complex64",r}(MU||{}),Dme={float32:OU,int32:AU,bool:RU,complex64:MU};function mr(r,t){if(r==="string"||t==="string"){if(r==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${r} with ${t}`)}return Dme[r][t]}function _c(r){return mr(r,"int32")}function nS(r){return r!=null&&typeof r=="object"&&"texture"in r&&r.texture instanceof WebGLTexture}function oS(r){return typeof GPUBuffer<"u"&&r!=null&&typeof r=="object"&&"buffer"in r&&r.buffer instanceof GPUBuffer}function wt(r,t){if(r.dtype===t.dtype)return[r,t];let e=mr(r.dtype,t.dtype);return[r.cast(e),t.cast(e)]}function FU(r,t){F(r.dtype===t.dtype,()=>`The dtypes of the first(${r.dtype}) and second(${t.dtype}) input must match`)}function sS(r){let t=[];return $U(r,t,new Set),t}function $U(r,t,e){if(r==null)return;if(r instanceof ct){t.push(r);return}if(!Ame(r))return;let n=r;for(let o in n){let s=n[o];e.has(s)||(e.add(s),$U(s,t,e))}}function Ame(r){return Array.isArray(r)||typeof r=="object"}function S2(r){return r.kernelName!=null}var iS=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(let t in this.registeredVariables)this.registeredVariables[t].dispose()}},Ome=(()=>{class r{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new iS}ready(){return L(this,null,function*(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let e=this.getSortedBackends();for(let n=0;n<e.length;n++){let o=e[n];if(yield this.initializeBackend(o).success){yield this.setBackend(o);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")})}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:e,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){let{asyncInit:n}=this.initializeBackend(e);if(n)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,n,o=1){return e in this.registryFactory?(_l(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:n,priority:o},!0)}setBackend(e){return L(this,null,function*(){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;let{success:n,asyncInit:o}=this.initializeBackend(e);if(!(o?yield n:n))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new tS(this.backendInstance),!0})}setupRegisteredKernels(){g2(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){g2(e).forEach(o=>{o.disposeFunc!=null&&o.disposeFunc(this.registry[e])})}initializeBackend(e){let n=this.registryFactory[e];if(n==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let o=n.factory();if(o&&!(o instanceof Zi)&&typeof o.then=="function"){let s=++this.pendingBackendInitId,i=o.then(a=>s<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,_l(`Initialization of backend ${e} failed`),_l(a.stack||a.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=o,{success:!0,asyncInit:!1}}catch(o){return _l(`Initialization of backend ${e} failed`),_l(o.stack||o.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,n)=>this.registryFactory[n].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let n=0;n<e.length;n++){let o=e[n],{success:s,asyncInit:i}=this.initializeBackend(o);if(i||s)return{name:o,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,n){let o=this.state.tensorInfo.get(n),s=o.backend,i=this.readSync(n),a=s.refCount(n);s.disposeData(n,!0),o.backend=e,e.move(n,i,o.shape,o.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,n){let o=null;if(n==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");n=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");o=e}let s;return this.scopedRun(()=>this.startScope(o),()=>this.endScope(s),()=>(s=n(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,n,o){e();try{let s=o();return n(),s}catch(s){throw n(),s}}nextTensorId(){return r.nextTensorId++}nextVariableId(){return r.nextVariableId++}clone(e){let n=R.runKernel(fi,{x:e}),o={x:e},s=a=>({x:()=>{let u="float32",l={x:a},c={dtype:u};return R.runKernel(di,l,c)}}),i=[];return this.addTapeNode(this.state.activeScope.name,o,[n],s,i,{}),n}runKernel(e,n,o){if(this.backendName==null&&this.backend,!(Cg(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:n,attrs:o})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,n,o){let s=this.backend.numDataIds(),i=0;o.forEach(l=>{i+=l.dtype==="complex64"?3:1});let a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],u=s-n-i-a;if(u>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${u} data ids) after running '${e}'`)}runKernelFunc(e){let n,o=[],s=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let u;this.backendName==null&&this.backend;let l,c=S2(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(S2(e)){let{kernelName:m,inputs:g,attrs:y}=e;this.backendName==null&&this.backend;let x=Cg(m,this.backendName);F(x!=null,()=>`Cannot find registered kernel '${m}' for backend '${this.backendName}'`),u=()=>{let w=this.backend.numDataIds();l=x.kernelFunc({inputs:g,attrs:y,backend:this.backend});let C=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(m,w,C);let I=C.map(N=>N.rank!=null?N:this.makeTensorFromTensorInfo(N));if(s){let N=this.getTensorsForGradient(m,g,I);o=this.saveTensorsForBackwardMode(N)}return I}}else{let{forwardFunc:m}=e,g=y=>{s&&(o=y.map(x=>this.keep(this.clone(x))))};u=()=>{let y=this.backend.numDataIds();l=this.tidy(()=>m(this.backend,g));let x=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,y,x),x}}let{inputs:p,attrs:d}=e,f=S2(e)?null:e.backwardsFunc,h;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=u():(h=this.profiler.profileKernel(c,p,()=>u()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),n=h.outputs)}),s&&this.addTapeNode(c,p,n,f,o,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(p).map(m=>p[m]!=null?p[m].shape:null),outputShapes:n.map(m=>m.shape),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(e){return e.map(o=>this.keep(this.clone(o)))}getTensorsForGradient(e,n,o){let s=m2(e);if(s!=null){let i=s.inputsToSave||[],a=s.outputsToSave||[],u;s.saveAllInputs?(F(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),u=Object.keys(n).map(c=>n[c])):u=i.map(c=>n[c]);let l=o.filter((c,p)=>a[p]);return u.concat(l)}return[]}makeTensor(e,n,o,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");o=o||"float32",s=s||this.backend;let i=e;o==="string"&&lg(e[0])&&(i=e.map(l=>Eg(l)));let a=s.write(i,n,o),u=new ct(n,o,a,this.nextTensorId());if(this.trackTensor(u,s),o==="string"){let l=this.state.tensorInfo.get(a),c=c2(i);this.state.numBytes+=c-l.bytes,l.bytes=c}return u}makeTensorFromDataId(e,n,o,s){o=o||"float32";let i={dataId:e,shape:n,dtype:o};return this.makeTensorFromTensorInfo(i,s)}makeTensorFromTensorInfo(e,n){let{dataId:o,shape:s,dtype:i}=e,a=new ct(s,i,o,this.nextTensorId());return this.trackTensor(a,n),a}makeVariable(e,n=!0,o,s){o=o||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));let i=new Tc(e,n,o,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,n){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let o=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(o=e.size*ug(e.dtype)),this.state.numBytes+=o,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:n||this.backend,dtype:e.dtype,shape:e.shape,bytes:o})),e instanceof Tc||this.track(e)}incRef(e,n){this.trackTensor(e,n),this.backend.incRef(e.dataId)}removeDataId(e,n){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===n&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let n=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){let o=e.size*ug(e.dtype);this.state.numBytes-=o}n.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,n.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let n=this.state.registeredVariables[e];this.disposeVariable(n)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){return L(this,null,function*(){this.state.profiling=!0;let n=this.state.numBytes,o=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=yield e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-o;for(let s of this.state.activeProfile.kernels)s.kernelTimeMs=yield s.kernelTimeMs,s.extraInfo=yield s.extraInfo;return this.state.activeProfile})}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,n,o,s,i,a){let u={id:this.state.nextTapeNodeId++,kernelName:e,inputs:n,outputs:o,saved:i},l=m2(e);l!=null&&(s=l.gradFunc),s!=null&&(u.gradient=c=>(c=c.map((p,d)=>{if(p==null){let f=o[d],h=dg(f.size,f.dtype);return this.makeTensor(h,f.shape,f.dtype)}return p}),s(c.length>1?c:c[0],i,a))),this.state.activeTape.push(u)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(n.name=e),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(e){let n=sS(e),o=new Set(n.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){let a=this.state.activeScope.track[i];!a.kept&&!o.has(a.id)&&a.dispose()}let s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(i=>{!i.kept&&i.scopeId===s.id&&this.track(i)})}gradients(e,n,o,s=!1){if(F(n.length>0,()=>"gradients() received an empty list of xs."),o!=null&&o.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${o.dtype}'`);let i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));F(i instanceof ct,()=>"The result y returned by f() must be a tensor.");let a=SU(this.state.activeTape,n,i);if(!s&&a.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let u={};u[i.id]=o??Mme(i.shape),IU(u,a,c=>this.tidy(c),Fme);let l=n.map(c=>u[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(let p of c.saved)p.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(e){return F(cg(e),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{F(n.every(u=>u instanceof ct),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let o,s={};n.forEach((u,l)=>{s[l]=u});let i=(u,l)=>(o=e(...n,l),F(o.value instanceof ct,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),F(cg(o.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),o.value),a=(u,l)=>{let c=o.gradFunc(u,l),p=Array.isArray(c)?c:[c];F(p.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),F(p.every(f=>f instanceof ct),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let d={};return p.forEach((f,h)=>{d[h]=()=>f}),d};return this.runKernelFunc({forwardFunc:i,backwardsFunc:a,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,n){return this.state.tensorInfo.get(e).backend.readToGPU(e,n)}time(e){return L(this,null,function*(){let n=uh(),o=yield this.backend.time(e);return o.wallMs=uh()-n,o})}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new iS;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return r.nextTensorId=0,r.nextVariableId=0,r})();function Mme(r){let t=Bv(bt(r),"float32");return R.makeTensor(t,r,"float32")}function I2(){let r=f2();if(r._tfengine==null){let t=new Vv(r);r._tfengine=new Ome(t)}return nU(r._tfengine.ENV),kU(()=>r._tfengine),r._tfengine}var R=I2();function Fme(r,t){let e={a:r,b:t};return R.runKernel(js,e)}var Id={};ur(Id,{isBrowser:()=>_2,isMobile:()=>Lme,mockIsMobile:()=>Pme});function $me(){return typeof navigator<"u"&&navigator!=null}var T2;function Pme(r){T2=r}function Lme(r){if(T2!==void 0)return T2;if(r||$me()){if(r||(r=navigator),r.product==="ReactNative")return!0;let t=r.userAgent||r.vendor||(typeof window<"u"?window.opera:"");if(!t){let e=r;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function _2(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var Yo=j();Yo.registerFlag("DEBUG",()=>!1,r=>{r&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Yo.registerFlag("IS_BROWSER",()=>_2());Yo.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Yo.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Yo.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Yo.registerFlag("PROD",()=>!1);Yo.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Yo.getBool("DEBUG"));Yo.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Yo.registerFlag("IS_TEST",()=>!1);Yo.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Yo.getBool("DEBUG"));Yo.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Yo.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Yo.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Zo(r,t){let e=r;if(wo(r))return t==="string"?[]:[r.length];if(nS(r)){let o=r.channels||"RGBA";return[r.height,r.width*o.length]}else if(oS(r))return[r.buffer.size/(t==null?4:ug(t))];if(!Array.isArray(r))return[];let n=[];for(;Array.isArray(e)||wo(e)&&t!=="string";)n.push(e.length),e=e[0];return Array.isArray(r)&&j().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&LU(r,n,[]),n}function LU(r,t,e){if(e=e||[],!Array.isArray(r)&&!wo(r)){F(t.length===0,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}F(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${r.length} elements`),F(r.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${r.length} elements`);let n=t.slice(1);for(let o=0;o<r.length;++o)LU(r[o],n,e.concat(o))}function PU(r,t,e,n){if(r!=="string_or_numeric"){if(r==null)throw new Error("Expected dtype cannot be null.");if(r!=="numeric"&&r!==t||r==="numeric"&&t==="string")throw new Error(`Argument '${e}' passed to '${n}' must be ${r} tensor, but got ${t} tensor`)}}function E(r,t,e,n="numeric"){if(r instanceof U())return PU(n,r.dtype,t,e),r;let o=_p(r);if(o!=="string"&&["bool","int32","float32"].indexOf(n)>=0&&(o=n),PU(n,o,t,e),r==null||!wo(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string"){let u=r==null?"null":r.constructor.name;throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${u}'`)}let s=Zo(r,o);!wo(r)&&!Array.isArray(r)&&(r=[r]);let a=o!=="string"?_g(r,o):Sd(r,[],!0);return R.makeTensor(a,s,o)}function lh(r,t,e,n="numeric"){if(!Array.isArray(r))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return r.map((s,i)=>E(s,`${t}[${i}]`,e,n))}var E2="__op";function D(r){let t=Object.keys(r);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0],n=r[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e=e+E2;let o=(...s)=>{R.startScope(e);try{let i=n(...s);return Zf(i)&&console.error("Cannot return a Promise inside of tidy."),R.endScope(i),i}catch(i){throw R.endScope(null),i}};return Object.defineProperty(o,"name",{value:e,configurable:!0}),o}function zme(r,t){let e=E(r,"real","complex"),n=E(t,"imag","complex");on(e.shape,n.shape,`real and imag shapes, ${e.shape} and ${n.shape}, must match in call to tf.complex().`);let o={real:e,imag:n};return R.runKernel(Op,o)}var Qo=D({complex_:zme});function Oo(r,t,e,n){if(n==null)n=_p(r);else if(n==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(oS(r)||nS(r)){if(n!=="float32"&&n!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${n}.`);return R.backend.createTensorFromGPUData(r,t||e,n)}if(!wo(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Vr(t);let o=bt(t),s=bt(e);F(o===s,()=>`Based on the provided shape, [${t}], the tensor should have ${o} values but has ${s}`);for(let i=0;i<e.length;++i){let a=e[i],u=i===e.length-1?a!==bt(t.slice(i)):!0;F(e[i]===t[i]||!u,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!wo(r)&&!Array.isArray(r)&&(r=[r]),t=t||e,r=n!=="string"?_g(r,n):Sd(r,[],!0),R.makeTensor(r,t,n)}function $n(r,t,e){let n=Zo(r,e);return Oo(r,t,n,e)}var Ec={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};var so=class r{static join(t){return new r(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(n=>wo(n)?n.buffer:n),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let e=0;for(let n=0;n<t.length;n++){let o=t[n];n!==t.length-1&&o.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let s=e+o.byteLength;this.shards.push({buffer:o,start:e,end:s}),e=s}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,e=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,e=isNaN(Number(e))?0:e,t=Math.max(0,t),e=Math.min(this.byteLength,e),e<=t)return new ArrayBuffer(0);let n=this.findShardForByte(t);if(n===-1)throw new Error(`Could not find start shard for byte ${t}`);let o=e-t,s=new ArrayBuffer(o),i=new Uint8Array(s),a=0;for(let u=n;u<this.shards.length;u++){let l=this.shards[u],p=t+a-l.start,d=a,h=Math.min(e,l.end)-l.start,m=new Uint8Array(l.buffer,p,h-p);if(i.set(m,d),a+=m.length,e<l.end)break}return s}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function e(o){return t<o.start?-1:t>=o.end?1:0}if(e(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let n=Bme(this.shards,e);return n===-1?-1:(this.previousShardIndex=n,this.previousShardIndex)}};function Bme(r,t){let e=0,n=r.length;for(;e<=n;){let o=Math.floor((n-e)/2)+e,s=t(r[o]);if(s===0)return o;s<0?n=o:e=o+1}return-1}function Vme(r){j().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(r+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}DU(Vme);function Pn(){return R}function qv(){return R.memory()}function X(r,t){return R.tidy(r,t)}function $e(r){sS(r).forEach(e=>e.dispose())}function Ar(r){return R.keep(r)}function zU(){return R.ready()}function El(){return R.backendName}function Dg(r,t,e=1){return R.registerBackend(r,t,e)}function kl(){return R.backend}var Td=4;function UU(r,t){return L(this,null,function*(){let e=[],n=[],o=Array.isArray(r)?r.map(i=>i.name):Object.keys(r);for(let i=0;i<o.length;++i){let a=o[i],u=Array.isArray(r)?r[i].tensor:r[a];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${u.dtype}`);let l={name:a,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){let c=new Promise(p=>L(this,null,function*(){let d=yield u.bytes(),f=d.reduce((g,y)=>g+y.length,0)+Td*d.length,h=new Uint8Array(f),m=0;for(let g=0;g<d.length;g++){let y=d[g],x=new Uint8Array(new Uint32Array([y.length]).buffer);h.set(x,m),m+=Td,h.set(y,m),m+=y.length}p(h)}));n.push(c)}else n.push(u.data());t!=null&&(l.group=t),e.push(l)}let s=yield Promise.all(n);return{data:Wme(s),specs:e}})}function aS(r,t){let e=new so(r),n={},o=0;for(let s of t){let i=Ume(s,(a,u)=>e.slice(o+a,o+u));n[s.name]=GU(s,e.slice(o,o+i)),o+=i}return n}function Ume(r,t){let e=bt(r.shape),n;if("quantization"in r){let o=r.quantization;n=Ec[o.dtype]}else if(r.dtype==="string"){let o=0;for(let s=0;s<e;s++)o+=Td+new Uint32Array(t(o,o+Td))[0];return o}else n=Ec[r.dtype];return e*n}function Gme(r,t){return L(this,null,function*(){let e=bt(r.shape),n;if("quantization"in r){let o=r.quantization;n=Ec[o.dtype]}else if(r.dtype==="string"){let o=0;for(let s=0;s<e;s++)o+=Td+new Uint32Array(yield t(o,o+Td))[0];return o}else n=Ec[r.dtype];return e*n})}function GU(r,t){let e=r.name,n=r.dtype,o=r.shape,s=bt(o),i,a=0;if("quantization"in r){let u=r.quantization;if(u.dtype==="uint8"||u.dtype==="uint16"){if(!("min"in u&&"scale"in u))throw new Error(`Weight ${r.name} with quantization ${u.dtype} doesn't have corresponding metadata min and scale.`)}else if(u.dtype==="float16"){if(n!=="float32")throw new Error(`Weight ${r.name} is quantized with ${u.dtype} which only supports weights of type float32 not ${n}.`)}else throw new Error(`Weight ${r.name} has unknown quantization dtype ${u.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let l=Ec[u.dtype],c=u.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(n==="float32")if(u.dtype==="uint8"||u.dtype==="uint16"){i=new Float32Array(c.length);for(let p=0;p<c.length;p++){let d=c[p];i[p]=d*u.scale+u.min}}else if(u.dtype==="float16")i=Kme()(c);else throw new Error(`Unsupported quantization type ${u.dtype} for weight type float32.`);else if(n==="int32"){if(u.dtype!=="uint8"&&u.dtype!=="uint16")throw new Error(`Unsupported quantization type ${u.dtype} for weight type int32.`);i=new Int32Array(c.length);for(let p=0;p<c.length;p++){let d=c[p];i[p]=Math.round(d*u.scale+u.min)}}else throw new Error(`Unsupported dtype in weight '${e}': ${n}`);a+=s*l}else if(n==="string"){let u=bt(r.shape);i=[];for(let l=0;l<u;l++){let c=new Uint32Array(t.slice(a,a+Td))[0];a+=Td;let p=new Uint8Array(t.slice(a,a+c));i.push(p),a+=c}}else{let u=Ec[n];if(n==="float32")i=new Float32Array(t);else if(n==="int32")i=new Int32Array(t);else if(n==="bool")i=new Uint8Array(t);else if(n==="complex64"){i=new Float32Array(t);let l=new Float32Array(i.length/2),c=new Float32Array(i.length/2);for(let h=0;h<l.length;h++)l[h]=i[h*2],c[h]=i[h*2+1];let p=$n(l,o,"float32"),d=$n(c,o,"float32"),f=Qo(p,d);return p.dispose(),d.dispose(),f}else throw new Error(`Unsupported dtype in weight '${e}': ${n}`);a+=s*u}return $n(i,o,n)}function BU(r,t,e){return L(this,null,function*(){let n=new Uint8Array(t);for(;n.byteLength<e;){let{done:o,value:s}=yield r.read();if(o&&s==null){let a=e-n.byteLength;throw new Error(`Reader is done but ${a} bytes are still expected`)}let i=new Uint8Array(n.length+s.byteLength);i.set(n,0),i.set(new Uint8Array(s),n.length),n=i}return n.buffer})}function uS(r,t){return L(this,null,function*(){let e={},n=r.getReader(),o=new ArrayBuffer(0);for(let s of t){let i=yield Gme(s,(l,c)=>L(this,null,function*(){return o=yield BU(n,o,c),o.slice(l,c)}));o=yield BU(n,o,i);let a=o.slice(0,i);o=o.slice(i);let u=GU(s,a);if(e[s.name]=u,El()==="webgpu"){let l=kl();"uploadToGPU"in l&&bt(u.shape)>=j().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&l.uploadToGPU(u.dataId)}}return e})}function Wme(r){if(r===null)throw new Error(`Invalid input value: ${JSON.stringify(r)}`);let t=0,e=[];r.forEach(s=>{if(t+=s.byteLength,e.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let n=new Uint8Array(t),o=0;return e.forEach(s=>{n.set(new Uint8Array(s.buffer),o),o+=s.byteLength}),n.buffer}var k2=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function VU(r){return k2?Buffer.byteLength(r,"utf8"):new Blob([r]).size}function WU(r){if(k2)return Buffer.from(r).toString("base64");let t=new Uint8Array(r),e="";for(let n=0,o=t.length;n<o;n++)e+=String.fromCharCode(t[n]);return btoa(e)}function jU(r){if(k2){let n=Buffer.from(r,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}let t=atob(r),e=new Uint8Array(t.length);for(let n=0;n<t.length;++n)e.set([t.charCodeAt(n)],n);return e.buffer}function HU(r){return so.join(r)}function N2(r){let t="/";for(r=r.trim();r.endsWith(t);)r=r.slice(0,r.length-1);let e=r.split(t);return e[e.length-1]}function lS(r,t){let e={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy,weightsManifest:t};return r.signature!=null&&(e.signature=r.signature),r.userDefinedMetadata!=null&&(e.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(e.modelInitializer=r.modelInitializer),r.initializerSignature!=null&&(e.initializerSignature=r.initializerSignature),r.trainingConfig!=null&&(e.trainingConfig=r.trainingConfig),e}function D2(r,t,e){let n={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy};if(r.trainingConfig!=null&&(n.trainingConfig=r.trainingConfig),r.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");n.weightSpecs=t,n.weightData=e}return r.signature!=null&&(n.signature=r.signature),r.userDefinedMetadata!=null&&(n.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(n.modelInitializer=r.modelInitializer),r.initializerSignature!=null&&(n.initializerSignature=r.initializerSignature),n}function Ag(r,t){return L(this,null,function*(){let e,n;return r.weightsManifest!=null&&([e,n]=yield t(r.weightsManifest)),D2(r,e,n)})}function Nl(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:r.modelTopology==null?0:VU(JSON.stringify(r.modelTopology)),weightSpecsBytes:r.weightSpecs==null?0:VU(JSON.stringify(r.weightSpecs)),weightDataBytes:r.weightData==null?0:new so(r.weightData).byteLength}}function Kv(r){let t=[];for(let e of r)t.push(...e.weights);return t}function jme(){let r=e=>{let n=e<<13,o=0;for(;!(n&8388608);)o-=8388608,n<<=1;return n&=-8388609,o+=947912704,n|o},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=r(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}function Hme(){let r=new Uint32Array(64);r[0]=0,r[31]=1199570944,r[32]=2147483648,r[63]=3347054592;for(let t=1;t<31;t++)r[t]=t<<23;for(let t=33;t<63;t++)r[t]=2147483648+(t-32<<23);return r}function qme(){let r=new Uint32Array(64);for(let t=0;t<64;t++)r[t]=1024;return r[0]=r[32]=0,r}function Kme(){let r=jme(),t=Hme(),e=qme();return n=>{let o=new ArrayBuffer(4*n.length),s=new Uint32Array(o);for(let i=0;i<n.length;i++){let a=n[i],u=r[e[a>>10]+(a&1023)]+t[a>>10];s[i]=u}return new Float32Array(o)}}var Ln=class r{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return r.instance==null&&(r.instance=new r),r.instance}static registerSaveRouter(t){r.getInstance().saveRouters.push(t)}static registerLoadRouter(t){r.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return r.getHandlers(t,"save")}static getLoadHandlers(t,e){return r.getHandlers(t,"load",e)}static getHandlers(t,e,n){let o=[];return(e==="load"?r.getInstance().loadRouters:r.getInstance().saveRouters).forEach(i=>{let a=i(t,n);a!==null&&o.push(a)}),o}},qU=r=>Ln.registerSaveRouter(r),KU=r=>Ln.registerLoadRouter(r),XU=r=>Ln.getSaveHandlers(r),YU=(r,t)=>Ln.getLoadHandlers(r,t);var A2="tensorflowjs",R2=1,ch="models_store",_d="model_info_store";function ZU(){if(!j().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let r=typeof window>"u"?self:window,t=r.indexedDB||r.mozIndexedDB||r.webkitIndexedDB||r.msIndexedDB||r.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function O2(r){let t=r.result;t.createObjectStore(ch,{keyPath:"modelPath"}),t.createObjectStore(_d,{keyPath:"modelPath"})}var ph=(()=>{class r{constructor(e){if(this.indexedDB=ZU(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){return L(this,null,function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)})}load(){return L(this,null,function*(){return this.databaseAction(this.modelPath)})}databaseAction(e,n){return new Promise((o,s)=>{let i=this.indexedDB.open(A2,R2);i.onupgradeneeded=()=>O2(i),i.onsuccess=()=>{let a=i.result;if(n==null){let u=a.transaction(ch,"readonly"),c=u.objectStore(ch).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return a.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));o(c.result.modelArtifacts)},c.onerror=p=>(a.close(),s(c.error)),u.oncomplete=()=>a.close()}else{n.weightData=so.join(n.weightData);let u=Nl(n),l=a.transaction(_d,"readwrite"),c=l.objectStore(_d),p;try{p=c.put({modelPath:this.modelPath,modelArtifactsInfo:u})}catch(f){return s(f)}let d;p.onsuccess=()=>{d=a.transaction(ch,"readwrite");let f=d.objectStore(ch),h;try{h=f.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:u})}catch(m){return s(m)}h.onsuccess=()=>o({modelArtifactsInfo:u}),h.onerror=m=>{c=l.objectStore(_d);let g=c.delete(this.modelPath);g.onsuccess=()=>(a.close(),s(h.error)),g.onerror=y=>(a.close(),s(h.error))}},p.onerror=f=>(a.close(),s(p.error)),l.oncomplete=()=>{d==null?a.close():d.oncomplete=()=>a.close()}}},i.onerror=a=>s(i.error)})}}return r.URL_SCHEME="indexeddb://",r})();var QU=r=>j().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(ph.URL_SCHEME)?Xme(r.slice(ph.URL_SCHEME.length)):null;Ln.registerSaveRouter(QU);Ln.registerLoadRouter(QU);function Xme(r){return new ph(r)}function Yme(r){return r.startsWith(ph.URL_SCHEME)?r.slice(ph.URL_SCHEME.length):r}var cS=class{constructor(){this.indexedDB=ZU()}listModels(){return L(this,null,function*(){return new Promise((t,e)=>{let n=this.indexedDB.open(A2,R2);n.onupgradeneeded=()=>O2(n),n.onsuccess=()=>{let o=n.result,s=o.transaction(_d,"readonly"),a=s.objectStore(_d).getAll();a.onsuccess=()=>{let u={};for(let l of a.result)u[l.modelPath]=l.modelArtifactsInfo;t(u)},a.onerror=u=>(o.close(),e(a.error)),s.oncomplete=()=>o.close()},n.onerror=o=>e(n.error)})})}removeModel(t){return L(this,null,function*(){return t=Yme(t),new Promise((e,n)=>{let o=this.indexedDB.open(A2,R2);o.onupgradeneeded=()=>O2(o),o.onsuccess=()=>{let s=o.result,i=s.transaction(_d,"readwrite"),a=i.objectStore(_d),u=a.get(t),l;u.onsuccess=()=>{if(u.result==null)return s.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{let c=a.delete(t),p=()=>{l=s.transaction(ch,"readwrite");let f=l.objectStore(ch).delete(t);f.onsuccess=()=>e(u.result.modelArtifactsInfo),f.onerror=h=>n(u.error)};c.onsuccess=p,c.onerror=d=>(p(),s.close(),n(u.error))}},u.onerror=c=>(s.close(),n(u.error)),i.oncomplete=()=>{l==null?s.close():l.oncomplete=()=>s.close()}},o.onerror=s=>n(o.error)})})}};var kc="/",Rg="tensorflowjs_models",JU="info",Zme="model_topology",Qme="weight_specs",Jme="weight_data",ege="model_metadata";function eG(r){return{info:[Rg,r,JU].join(kc),topology:[Rg,r,Zme].join(kc),weightSpecs:[Rg,r,Qme].join(kc),weightData:[Rg,r,Jme].join(kc),modelMetadata:[Rg,r,ege].join(kc)}}function tG(r){for(let t of Object.values(r))window.localStorage.removeItem(t)}function tge(r){let t=r.split(kc);if(t.length<3)throw new Error(`Invalid key format: ${r}`);return t.slice(1,t.length-1).join(kc)}function rge(r){return r.startsWith(dh.URL_SCHEME)?r.slice(dh.URL_SCHEME.length):r}var dh=(()=>{class r{constructor(e){if(!j().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=eG(this.modelPath)}save(e){return L(this,null,function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let n=JSON.stringify(e.modelTopology),o=JSON.stringify(e.weightSpecs),s=Nl(e),i=so.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,o),this.LS.setItem(this.keys.weightData,WU(i));let a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:s}}catch{throw tG(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}})}load(){return L(this,null,function*(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let n={},o=JSON.parse(this.LS.getItem(this.keys.topology));if(o==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=o;let s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=s;let i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){let u=JSON.parse(i);n.format=u.format,n.generatedBy=u.generatedBy,n.convertedBy=u.convertedBy,u.signature!=null&&(n.signature=u.signature),u.userDefinedMetadata!=null&&(n.userDefinedMetadata=u.userDefinedMetadata),u.modelInitializer!=null&&(n.modelInitializer=u.modelInitializer),u.initializerSignature!=null&&(n.initializerSignature=u.initializerSignature),u.trainingConfig!=null&&(n.trainingConfig=u.trainingConfig)}let a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=jU(a),n})}}return r.URL_SCHEME="localstorage://",r})();var rG=r=>j().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(dh.URL_SCHEME)?nge(r.slice(dh.URL_SCHEME.length)):null;Ln.registerSaveRouter(rG);Ln.registerLoadRouter(rG);function nge(r){return new dh(r)}var pS=class{constructor(){F(j().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),F(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){return L(this,null,function*(){let t={},e=Rg+kc,n=kc+JU;for(let o=0;o<this.LS.length;++o){let s=this.LS.key(o);if(s.startsWith(e)&&s.endsWith(n)){let i=tge(s);t[i]=JSON.parse(this.LS.getItem(s))}}return t})}removeModel(t){return L(this,null,function*(){t=rge(t);let e=eG(t);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${t}'`);let n=JSON.parse(this.LS.getItem(e.info));return tG(e),n})}};var Og="://",Ha=class r{constructor(){this.managers={}}static getInstance(){return r.instance==null&&(r.instance=new r),r.instance}static registerManager(t,e){F(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(Og)&&(t=t.slice(0,t.indexOf(Og))),F(t.length>0,()=>"scheme must not be an empty string.");let n=r.getInstance();F(n.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),n.managers[t]=e}static getManager(t){let e=r.getInstance().managers[t];if(e==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(r.getInstance().managers)}};function dS(r){if(r.indexOf(Og)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Ha.getSchemes().join(",")}`);return{scheme:r.split(Og)[0],path:r.split(Og)[1]}}function nG(r,t,e=!1){return L(this,null,function*(){F(r!==t,()=>`Old path and new path are the same: '${r}'`);let n=Ln.getLoadHandlers(r);F(n.length>0,()=>`Copying failed because no load handler is found for source URL ${r}.`),F(n.length<2,()=>`Copying failed because more than one (${n.length}) load handlers for source URL ${r}.`);let o=n[0],s=Ln.getSaveHandlers(t);F(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),F(s.length<2,()=>`Copying failed because more than one (${n.length}) save handlers for destination URL ${t}.`);let i=s[0],a=dS(r).scheme,u=dS(r).path,l=a===dS(r).scheme,c=yield o.load();e&&l&&(yield Ha.getManager(a).removeModel(u));let p=yield i.save(c);return e&&!l&&(yield Ha.getManager(a).removeModel(u)),p.modelArtifactsInfo})}function oG(){return L(this,null,function*(){let r=Ha.getSchemes(),t={};for(let e of r){let n=yield Ha.getManager(e).listModels();for(let o in n){let s=e+Og+o;t[s]=n[o]}}return t})}function sG(r){return L(this,null,function*(){let t=dS(r);return Ha.getManager(t.scheme).removeModel(t.path)})}function iG(r,t){return L(this,null,function*(){return nG(r,t,!1)})}function aG(r,t){return L(this,null,function*(){return nG(r,t,!0)})}var M2=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){if(typeof window>"u"||!j().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,e);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();let o=this.functionRefs[n.data.index];o(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(t){return Q0(t)}};if(j().get("IS_BROWSER")){j().setPlatform("browser",new M2);try{Ha.registerManager(dh.URL_SCHEME,new pS)}catch{}try{Ha.registerManager(ph.URL_SCHEME,new cS)}catch{}}var sge={importFetch:()=>lG()},F2;var $2=class{constructor(){this.util=cG(),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return j().global.fetch!=null?j().global.fetch(t,e):(F2==null&&(F2=sge.importFetch()),F2(t,e))}now(){let t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return t.length===0?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}};j().get("IS_NODE")&&!j().get("IS_BROWSER")&&j().setPlatform("node",new $2);function Ne(r,t="float32",e){return t=t||"float32",Vr(r),new jt(r,t,e)}function ige(r,t){let e=E(r,"x","cast");if(!l2(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&e.dtype!=="string"||t!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");let n={x:e},o={dtype:t};return R.runKernel(di,n,o)}var le=D({cast_:ige});function age(r){let e={x:E(r,"x","clone","string_or_numeric")};return R.runKernel(fi,e)}var Mo=D({clone_:age});function fS(r,t=!1){console.log(r.toString(t))}I2();var uge={buffer:Ne,cast:le,clone:Mo,print:fS};NU(uge);function lge(r,t){let e=E(r,"a","add"),n=E(t,"b","add");[e,n]=wt(e,n);let o={a:e,b:n};return R.runKernel(js,o)}var re=D({add_:lge});function cge(r,t){let e=E(r,"a","floorDiv"),n=E(t,"b","floorDiv");[e,n]=wt(e,n);let o={a:e,b:n};return R.runKernel(ma,o)}var Fg=D({floorDiv_:cge});function pge(r,t){let e=E(r,"a","div"),n=E(t,"b","div");if([e,n]=wt(e,n),e.dtype==="int32"&&n.dtype==="int32")return Fg(e,n);let o={a:e,b:n},s={};return R.runKernel(la,o,s)}var me=D({div_:pge});function dge(r,t){let e=E(r,"a","mul"),n=E(t,"b","mul");[e,n]=wt(e,n);let o={a:e,b:n};return R.runKernel(Ta,o)}var B=D({mul_:dge});function fge(r){let t=E(r,"x","abs");if(t.dtype==="complex64"){let e={x:t};return R.runKernel(Vu,e)}else{let e={x:t};return R.runKernel(Ou,e)}}var Nr=D({abs_:fge});function hge(r){let e={x:E(r,"x","acos")};return R.runKernel(Qi,e)}var hS=D({acos_:hge});function mge(r){let e={x:E(r,"x","acosh")};return R.runKernel(Ji,e)}var mS=D({acosh_:mge});function gge(r){F(Array.isArray(r),()=>"The argument passed to tf.addN() must be a list of tensors"),F(r.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${r.length}`);let t=r.map((o,s)=>E(o,`tensors${s}`,"addN")),e=t[0];t.forEach(o=>{if(o.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(o=>{if(!xs(o.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let n=t;return R.runKernel(Mu,n)}var pG=D({addN_:gge});function yge(r,t=null,e=!1){let o={x:E(r,"x","all","bool")},s={axis:t,keepDims:e};return R.runKernel(Ep,o,s)}var $g=D({all_:yge});function xge(r,t=null,e=!1){let o={x:E(r,"x","any","bool")},s={axis:t,keepDims:e};return R.runKernel(kp,o,s)}var hh=D({any_:xge});function vge(r,t=0){let n={x:E(r,"x","argMax")},o={axis:t};return R.runKernel(Fu,n,o)}var vi=D({argMax_:vge});function bge(r,t=0){let n={x:E(r,"x","argMin")},o={axis:t};return R.runKernel($u,n,o)}var gS=D({argMin_:bge});function wge(r){let e={x:E(r,"x","asin")};return R.runKernel(ea,e)}var yS=D({asin_:wge});function Cge(r){let e={x:E(r,"x","asinh")};return R.runKernel(ta,e)}var xS=D({asinh_:Cge});function Sge(r){let e={x:E(r,"x","atan")};return R.runKernel(ra,e)}var vS=D({atan_:Sge});function Ige(r,t){let e=E(r,"a","atan2"),n=E(t,"b","atan2");[e,n]=wt(e,n);let o={a:e,b:n};return R.runKernel(oa,o)}var bS=D({atan2_:Ige});function Tge(r){let e={x:E(r,"x","atanh")};return R.runKernel(na,e)}var wS=D({atanh_:Tge});function _ge(r,t,e,n,o="NHWC",s){let i=r[3],a=[...t,i],u=fG(o);return mh(r,a,e,s,n,null,null,u)}function L2(r,t,e,n,o,s,i="channelsLast"){let[a,u]=Xv(t),l;if(i==="channelsLast")l=[a,u,r[3],r[3]];else if(i==="channelsFirst")l=[a,u,r[1],r[1]];else throw new Error(`Unknown dataFormat ${i}`);return mh(r,l,e,n,o,s,!1,i)}function Ege(r,t,e,n,o,s,i="NDHWC"){let[a,u,l]=P2(t),c,p;if(i==="NDHWC")p="channelsLast",c=[a,u,l,r[4],r[4]];else if(i==="NCDHW")p="channelsFirst",c=[a,u,l,r[1],r[1]];else throw new Error(`Unknown dataFormat ${i}`);return dG(r,c,e,n,o,!1,p,s)}function mh(r,t,e,n,o,s,i=!1,a="channelsLast"){let[u,l,c,p]=[-1,-1,-1,-1];if(a==="channelsLast")[u,l,c,p]=r;else if(a==="channelsFirst")[u,p,l,c]=r;else throw new Error(`Unknown dataFormat ${a}`);let[d,f,,h]=t,[m,g]=Xv(e),[y,x]=Xv(n),w=Pg(d,y),C=Pg(f,x),{padInfo:I,outHeight:N,outWidth:A}=Dge(o,l,c,m,g,w,C,s,a),O=i?h*p:h,$;return a==="channelsFirst"?$=[u,O,N,A]:a==="channelsLast"&&($=[u,N,A,O]),{batchSize:u,dataFormat:a,inHeight:l,inWidth:c,inChannels:p,outHeight:N,outWidth:A,outChannels:O,padInfo:I,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:f,effectiveFilterHeight:w,effectiveFilterWidth:C,dilationHeight:y,dilationWidth:x,inShape:r,outShape:$,filterShape:t}}function dG(r,t,e,n,o,s=!1,i="channelsLast",a){let[u,l,c,p,d]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[u,l,c,p,d]=r;else if(i==="channelsFirst")[u,d,l,c,p]=r;else throw new Error(`Unknown dataFormat ${i}`);let[f,h,m,,g]=t,[y,x,w]=P2(e),[C,I,N]=P2(n),A=Pg(f,C),O=Pg(h,I),$=Pg(m,N),{padInfo:z,outDepth:G,outHeight:K,outWidth:Z}=Age(o,l,c,p,y,x,w,A,O,$,a),Q=s?g*d:g,J;return i==="channelsFirst"?J=[u,Q,G,K,Z]:i==="channelsLast"&&(J=[u,G,K,Z,Q]),{batchSize:u,dataFormat:i,inDepth:l,inHeight:c,inWidth:p,inChannels:d,outDepth:G,outHeight:K,outWidth:Z,outChannels:Q,padInfo:z,strideDepth:y,strideHeight:x,strideWidth:w,filterDepth:f,filterHeight:h,filterWidth:m,effectiveFilterDepth:A,effectiveFilterHeight:O,effectiveFilterWidth:$,dilationDepth:C,dilationHeight:I,dilationWidth:N,inShape:r,outShape:J,filterShape:t}}function kge(r,t,e,n,o){n==null&&(n=z2(r,t,e));let s=r[0],i=r[1],a=Yv((s-t+2*n)/e+1,o),u=Yv((i-t+2*n)/e+1,o);return[a,u]}function Nge(r,t,e,n,o,s){o==null&&(o=z2(r,t[0],n[0]));let i=[0,0,0,e];for(let a=0;a<3;a++)r[a]+2*o>=t[a]&&(i[a]=Yv((r[a]-t[a]+2*o)/n[a]+1,s));return i}function z2(r,t,e,n=1){let o=Pg(t,n);return Math.floor((r[0]*(e-1)-e+o)/2)}function Xv(r){return typeof r=="number"?[r,r,r]:r.length===2?[r[0],r[1],1]:r}function P2(r){return typeof r=="number"?[r,r,r]:r}function Pg(r,t){return t<=1?r:r+(r-1)*(t-1)}function Dge(r,t,e,n,o,s,i,a,u){let l,c,p;if(typeof r=="number"){l={top:r,bottom:r,left:r,right:r,type:r===0?"VALID":"NUMBER"};let f=kge([t,e],s,n,r,a);c=f[0],p=f[1]}else if(r==="same"){c=Math.ceil(t/n),p=Math.ceil(e/o);let d=Math.max(0,(c-1)*n+s-t),f=Math.max(0,(p-1)*o+i-e),h=Math.floor(d/2),m=d-h,g=Math.floor(f/2),y=f-g;l={top:h,bottom:m,left:g,right:y,type:"SAME"}}else if(r==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-s+1)/n),p=Math.ceil((e-i+1)/o);else if(typeof r=="object"){let d=u==="channelsLast"?r[1][0]:r[2][0],f=u==="channelsLast"?r[1][1]:r[2][1],h=u==="channelsLast"?r[2][0]:r[3][0],m=u==="channelsLast"?r[2][1]:r[3][1];l={top:d,bottom:f,left:h,right:m,type:d===0&&f===0&&h===0&&m===0?"VALID":"EXPLICIT"},c=Yv((t-s+d+f)/n+1,a),p=Yv((e-i+h+m)/o+1,a)}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:l,outHeight:c,outWidth:p}}function Age(r,t,e,n,o,s,i,a,u,l,c){let p,d,f,h;if(r==="valid"&&(r=0),typeof r=="number"){p={top:r,bottom:r,left:r,right:r,front:r,back:r,type:r===0?"VALID":"NUMBER"};let g=Nge([t,e,n,1],[a,u,l],1,[o,s,i],r,c);d=g[0],f=g[1],h=g[2]}else if(r==="same"){d=Math.ceil(t/o),f=Math.ceil(e/s),h=Math.ceil(n/i);let m=(d-1)*o+a-t,g=(f-1)*s+u-e,y=(h-1)*i+l-n,x=Math.floor(m/2),w=m-x,C=Math.floor(g/2),I=g-C,N=Math.floor(y/2),A=y-N;p={top:C,bottom:I,left:N,right:A,front:x,back:w,type:"SAME"}}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:p,outDepth:d,outHeight:f,outWidth:h}}function Yv(r,t){if(!t)return Math.trunc(r);switch(t){case"round":return Math.round(r);case"ceil":return Math.ceil(r);case"floor":return Math.floor(r);default:throw new Error(`Unknown roundingMode ${t}`)}}function Hs(r){let[t,e,n]=Xv(r);return t===1&&e===1&&n===1}function Jn(r,t){return Hs(r)||Hs(t)}function Dl(r){return Xv(r).every(t=>t>0)}function fG(r){if(r==="NHWC")return"channelsLast";if(r==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${r}`)}function wr(r,t,e){if(e!=null){if(typeof t=="string")throw Error(`Error in ${r}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if(typeof t=="number")F(fc(t),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else if(typeof t=="object")t.forEach(n=>{n.forEach(o=>{F(fc(o),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${e} but got pad ${o}.`)})});else throw Error(`Error in ${r}: Unknown padding parameter: ${t}`)}}function Rge(r,t){let n={x:E(r,"x","reshape","string_or_numeric")},o={shape:t};return R.runKernel(fl,n,o)}var V=D({reshape_:Rge});function Oge(r,t,e,n,o){let s=E(r,"x","avgPool","float32"),i=1;F(Jn(e,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);let a=s,u=!1;s.rank===3&&(u=!0,a=V(s,[1,s.shape[0],s.shape[1],s.shape[2]])),F(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),wr("avgPool",n,o);let l={x:a},c={filterSize:t,strides:e,pad:n,dimRoundingMode:o},p=R.runKernel(Pu,l,c);return p=le(p,s.dtype),u?V(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Ed=D({avgPool_:Oge});function Mge(r,t,e,n,o,s="NDHWC"){let i=E(r,"x","avgPool3d","float32"),a=i,u=!1;i.rank===4&&(u=!0,a=V(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),F(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),F(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),F(typeof e=="number"&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),wr("avgPool3d",n,o);let l={x:a},c={filterSize:t,strides:e,pad:n,dimRoundingMode:o,dataFormat:s},p=R.runKernel(Lu,l,c);return p=le(p,a.dtype),u?V(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var CS=D({avgPool3d_:Mge});function Fge(r,t=0){F(r.length>=1,()=>"Pass at least one tensor to concat");let e=lh(r,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"&&e.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),e.length===1)return Mo(e[0]);let n=e,o={axis:t};return R.runKernel(Uu,n,o)}var Dt=D({concat_:Fge});function $ge(r,t,e=!1,n=!1){let o=E(r,"a","matMul"),s=E(t,"b","matMul");[o,s]=wt(o,s);let i={a:o,b:s},a={transposeA:e,transposeB:n};return R.runKernel(zu,i,a)}var dt=D({matMul_:$ge});function Pge(r){let e={x:E(r,"x","sigmoid","float32")};return R.runKernel($a,e)}var Rn=D({sigmoid_:Pge});function Lge(r,t,e){let n=E(r,"x","slice","string_or_numeric");if(n.rank===0)throw new Error("Slicing scalar is not possible");let o={x:n},s={begin:t,size:e};return R.runKernel(xl,o,s)}var Ue=D({slice_:Lge});function zge(r){let e={x:E(r,"x","tanh","float32")};return R.runKernel(Ua,e)}var qa=D({tanh_:zge});function Bge(r,t,e,n,o,s){let i=E(r,"forgetBias","basicLSTMCell"),a=E(t,"lstmKernel","basicLSTMCell"),u=E(e,"lstmBias","basicLSTMCell"),l=E(n,"data","basicLSTMCell"),c=E(o,"c","basicLSTMCell"),p=E(s,"h","basicLSTMCell"),d=Dt([l,p],1),f=dt(d,a),h=re(f,u),m=h.shape[0],g=h.shape[1]/4,y=[m,g],x=Ue(h,[0,0],y),w=Ue(h,[0,g],y),C=Ue(h,[0,g*2],y),I=Ue(h,[0,g*3],y),N=re(B(Rn(x),qa(w)),B(c,Rn(re(i,C)))),A=B(qa(N),Rn(I));return[N,A]}var hG=D({basicLSTMCell_:Bge});function Vge(r,t,e){let n=E(r,"x","batchToSpaceND"),o=t.reduce((a,u)=>a*u);F(n.rank>=1+t.length,()=>`input rank is ${n.rank} but should be > than blockShape.length ${t.length}`),F(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),F(n.shape[0]%o===0,()=>`input tensor batch is ${n.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${o}`);let s={x:n},i={blockShape:t,crops:e};return R.runKernel(Bu,s,i)}var kd=D({batchToSpaceND_:Vge});function mG(r){let t;return r.rank===0||r.rank===1?t=V(r,[1,1,1,r.size]):r.rank===2?t=V(r,[1,1,r.shape[0],r.shape[1]]):r.rank===3?t=V(r,[1,r.shape[0],r.shape[1],r.shape[2]]):t=r,t}function Uge(r,t,e,n,o,s){s==null&&(s=.001);let i=E(r,"x","batchNorm"),a=E(t,"mean","batchNorm"),u=E(e,"variance","batchNorm"),l;o!=null&&(l=E(o,"scale","batchNorm"));let c;n!=null&&(c=E(n,"offset","batchNorm")),F(a.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),F(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),F(l==null||a.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let d={x:mG(i),scale:l,offset:c,mean:a,variance:u},f={varianceEpsilon:s},h=R.runKernel(Yu,d,f);return V(h,i.shape)}var Al=D({batchNorm_:Uge});function Gge(r,t,e,n,o,s){let i=E(r,"x","batchNorm"),a=E(t,"mean","batchNorm"),u=E(e,"variance","batchNorm"),l;o!=null&&(l=E(o,"scale","batchNorm"));let c;return n!=null&&(c=E(n,"offset","batchNorm")),F(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),F(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),F(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),l!=null&&F(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&F(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Al(i,a,u,c,l,s)}var SS=D({batchNorm2d_:Gge});function Wge(r,t,e,n,o,s){let i=E(r,"x","batchNorm"),a=E(t,"mean","batchNorm"),u=E(e,"variance","batchNorm"),l;o!=null&&(l=E(o,"scale","batchNorm"));let c;return n!=null&&(c=E(n,"offset","batchNorm")),F(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),F(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),F(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),l!=null&&F(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&F(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Al(i,a,u,c,l,s)}var IS=D({batchNorm3d_:Wge});function jge(r,t,e,n,o,s){let i=E(r,"x","batchNorm"),a=E(t,"mean","batchNorm"),u=E(e,"variance","batchNorm"),l;o!=null&&(l=E(o,"scale","batchNorm"));let c;return n!=null&&(c=E(n,"offset","batchNorm")),F(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),F(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),F(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),l!=null&&F(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&F(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Al(i,a,u,c,l,s)}var TS=D({batchNorm4d_:jge});function Hge(r,t,e){let n=E(r,"x","bincount"),o=E(t,"weights","bincount");F(n.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${n.dtype}`),F(e>=0,()=>`size must be non-negative, but got ${e}.`),F(o.size===n.size||o.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${n.shape}, weights shape: ${o.shape}.`);let s={x:n,weights:o},i={size:e};return R.runKernel(Ap,s,i)}var _S=D({bincount_:Hge});function qge(r,t){let e=E(r,"x","bitwiseAnd"),n=E(t,"y","bitwiseAnd");if(!xs(e.shape,n.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${e.shape}, y: ${n.shape}`);if(e.dtype!=="int32"||n.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${e.dtype} and type of y: ${n.dtype}`);let o={a:e,b:n};return R.runKernel(Qf,o)}var gG=D({bitwiseAnd_:qge});function Kge(r,t){let e=E(r,"s0","broadcastArgs","int32"),n=E(t,"s1","broadcastArgs","int32");if(e.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${e.rank}`);if(n.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${n.rank}`);let o={s0:e,s1:n};return R.runKernel(Rp,o)}var yG=D({broadcastArgs_:Kge});function Xge(r,t){let e=E(r,"broadcastTo","x"),n=e.shape;if(Vr(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){let l=e.shape.slice();for(;l.length<t.length;)l.unshift(1);e=V(e,l)}let o=e.shape,s=Array.from(t);for(let l=t.length-1;l>=0;l--)if(o[l]===t[l])s[l]=1;else if(e.shape[l]!==1)throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${t}].`);if(s.map((l,c)=>l>1?c:-1).filter(l=>l>=0).length===0)return Mo(e);let a={x:e},u={reps:s};return R.runKernel(hi,a,u)}var Rl=D({broadcastTo_:Xge});function Yge(r){let e={x:E(r,"x","ceil","float32")};return R.runKernel(sa,e)}var ES=D({ceil_:Yge});function bi(r,t,e){Vr(r),e=e||_p(t);let n={shape:r,value:t,dtype:e};return R.runKernel(qp,{},n)}function Zge(r,t,e){let n=E(r,"x","clipByValue");if(F(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e)return bi(n.shape,t,n.dtype);let o={x:n},s={clipValueMin:t,clipValueMax:e};return R.runKernel(ia,o,s)}var Sn=D({clipByValue_:Zge});function Qge(r){return Dt(r,0)}var kS=D({concat1d_:Qge});function Jge(r,t){return Dt(r,t)}var NS=D({concat2d_:Jge});function eye(r,t){return Dt(r,t)}var DS=D({concat3d_:eye});function tye(r,t){return Dt(r,t)}var AS=D({concat4d_:tye});function rye(r,t,e,n,o="NHWC",s=[1,1],i){let a=E(r,"x","conv2d","float32"),u=E(t,"filter","conv2d","float32"),l=a,c=!1;a.rank===3&&(c=!0,l=V(a,[1,a.shape[0],a.shape[1],a.shape[2]])),F(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),F(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),wr("conv2d",n,i);let p=o==="NHWC"?l.shape[3]:l.shape[1];F(p===u.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${u.shape[2]}.`),F(Jn(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),F(Dl(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),F(Dl(e),()=>"Error in conv2D: Strides should be larger than 0.");let d={x:l,filter:u},f={strides:e,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i},h=R.runKernel(Gu,d,f);return c?V(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var Jo=D({conv2d_:rye});function nye(r,t,e,n,o="NWC",s=1,i){let a=E(r,"x","conv1d"),u=E(t,"filter","conv1d"),l=a,c=!1;a.rank===2&&(c=!0,l=V(a,[1,a.shape[0],a.shape[1]])),F(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),F(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),wr("conv1d",n,i),F(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),F(Jn(e,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${s}'`),F(Dl(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),F(Dl(e),()=>"Error in conv1D: Stride should be larger than 0."),F(o==="NWC",()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`);let p=V(u,[1,u.shape[0],u.shape[1],u.shape[2]]),d=V(l,[l.shape[0],1,l.shape[1],l.shape[2]]),g=Jo(d,p,[1,e],n,"NHWC",[1,s],i);return c?V(g,[g.shape[2],g.shape[3]]):V(g,[g.shape[0],g.shape[2],g.shape[3]])}var Lg=D({conv1d_:nye});function oye(r,t,e,n,o,s="NHWC",i){F(r.length===t.rank,()=>`Length of inShape (${r.length}) and rank of dy (${t.rank}) must match`);let a=r,u=t,l=!1;t.rank===3&&(l=!0,u=V(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,r[0],r[1],r[2]]),F(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),F(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),F(e.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);let c=s==="NHWC"?a[3]:a[1],p=s==="NHWC"?u.shape[3]:u.shape[1];F(c===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${e.shape[2]}.`),F(p===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${e.shape[3]}.`),wr("conv2dDerInput",o,i);let d={dy:u,filter:e},f={strides:n,pad:o,dataFormat:s,dimRoundingMode:i,inputShape:a},h=R.runKernel(Wu,d,f);return l?V(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var zg=D({conv2DBackpropInput_:oye});function sye(r,t,e,n,o,s){let i=E(r,"x","conv2dTranspose"),a=E(t,"filter","conv2dTranspose");return zg(e,i,a,n,o,"NHWC",s)}var Bg=D({conv2dTranspose_:sye});function iye(r,t,e,n,o="NDHWC",s=[1,1,1]){let i=E(r,"x","conv3d"),a=E(t,"filter","conv3d"),u=i,l=!1;i.rank===4&&(l=!0,u=V(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),F(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),F(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),F(u.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${a.shape[3]}.`),F(Jn(e,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),F(o==="NDHWC",()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`),F(Dl(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),F(Dl(e),()=>"Error in conv3D: Strides should be larger than 0.");let c={x:u,filter:a},p={strides:e,pad:n,dataFormat:o,dilations:s},d=R.runKernel(ju,c,p);return l?V(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var RS=D({conv3d_:iye});function aye(r,t,e,n,o){F(r.length===t.rank,()=>`Length of inShape (${r.length}) and rank of dy (${t.rank}) must match`);let s=r,i=t,a=!1;t.rank===4&&(a=!0,i=V(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,r[0],r[1],r[2],r[3]]);let u=s[4],l=i.shape[4];F(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),F(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),F(e.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),F(u===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${e.shape[3]}.`),F(l===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${e.shape[4]}.`);let c={dy:i,filter:e},p={pad:o,strides:n,inputShape:s},d=R.runKernel($p,c,p);return a?V(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var OS=D({conv3DBackpropInput_:aye});function uye(r,t,e,n,o){let s=E(r,"x","conv3dTranspose"),i=E(t,"filter","conv3dTranspose");return OS(e,s,i,n,o)}var MS=D({conv3dTranspose_:uye});function lye(r){let e={x:E(r,"x","cos","float32")};return R.runKernel(aa,e)}var Nd=D({cos_:lye});function cye(r){let e={x:E(r,"x","cosh","float32")};return R.runKernel(ua,e)}var Vg=D({cosh_:cye});function pye(r,t=0,e=!1,n=!1){let s={x:E(r,"x","cumprod")},i={axis:t,exclusive:e,reverse:n};return R.runKernel(Pp,s,i)}var gh=D({cumprod_:pye});function dye(r,t=0,e=!1,n=!1){let s={x:E(r,"x","cumsum")},i={axis:t,exclusive:e,reverse:n};return R.runKernel(Hu,s,i)}var Ug=D({cumsum_:dye});function fye(r,t,e,n=!1){let o=E(r,"x","denseBincount"),s=E(t,"weights","denseBincount");F(o.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`),F(o.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`),F(e>=0,()=>`size must be non-negative, but got ${e}.`),F(s.size===o.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${s.shape}.`);let i={x:o,weights:s},a={size:e,binaryOutput:n};return R.runKernel(zp,i,a)}var Zv=D({denseBincount_:fye});function hye(r,t,e="NHWC"){let n=E(r,"x","depthToSpace","float32"),o=e==="NHWC"?n.shape[1]:n.shape[2],s=e==="NHWC"?n.shape[2]:n.shape[3],i=e==="NHWC"?n.shape[3]:n.shape[1];F(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),F(o*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${t}  for depthToSpace with input shape
    ${n.shape}`),F(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t} for depthToSpace with input shape
        ${n.shape}`),F(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${n.shape}`);let a={x:n},u={blockSize:t,dataFormat:e};return R.runKernel(Bp,a,u)}var FS=D({depthToSpace_:hye});function mye(r,t,e,n,o="NHWC",s=[1,1],i){let a=E(r,"x","depthwiseConv2d","float32"),u=E(t,"filter","depthwiseConv2d","float32"),l=a,c=!1;a.rank===3&&(c=!0,l=V(a,[1,a.shape[0],a.shape[1],a.shape[2]])),F(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),F(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);let p=o==="NHWC"?l.shape[3]:l.shape[1];F(p===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${u.shape[2]}.`),wr("depthwiseConv2d",n,i);let d={x:l,filter:u},f={strides:e,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i},h=R.runKernel(qu,d,f);return c?V(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var Ol=D({depthwiseConv2d_:mye});function gye(r){let e={x:E(r,"x","diag")};return R.runKernel(Gp,e)}var xG=D({diag_:gye});function yye(r,t,e,n,o=[1,1],s="NHWC"){let i=E(r,"x","dilation2d"),a=E(t,"filter","dilation2d");F(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),F(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),F(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let u=i,l=!1;i.rank===3&&(u=V(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0),F(u.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${a.shape[2]}`);let c={x:u,filter:a},p={strides:e,pad:n,dilations:o},d=R.runKernel(Ku,c,p);return l?V(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var $S=D({dilation2d_:yye});var Fo={};ur(Fo,{assertAndGetBroadcastShape:()=>st,getBroadcastDims:()=>vG,getReductionAxes:()=>gr});function vG(r,t){let e=r.length,n=[];for(let o=0;o<e;o++){let s=e-1-o,i=r[s]||1;(t[t.length-1-o]||1)>1&&i===1&&n.unshift(s)}return n}function gr(r,t){let e=[];for(let n=0;n<t.length;n++){let o=r[r.length-n-1],s=t.length-n-1,i=t[s];(o==null||o===1&&i>1)&&e.unshift(s)}return e}function st(r,t){let e=Math.max(r.length,t.length),n=new Array(e);for(let o=0;o<e;o++){let s=r[r.length-o-1];s==null&&(s=1);let i=t[t.length-o-1];if(i==null&&(i=1),s===1)n[e-o-1]=i;else if(i===1)n[e-o-1]=s;else if(s!==i){let a=`Operands could not be broadcast together with shapes ${r} and ${t}.`;throw Error(a)}else n[e-o-1]=s}return n}function xye(r,t){let e=E(r,"a","equal","string_or_numeric"),n=E(t,"b","equal","string_or_numeric");[e,n]=wt(e,n),st(e.shape,n.shape);let o={a:e,b:n};return R.runKernel(hc,o)}var Co=D({equal_:xye});function vye(r,t,e){let n=E(t,"a","where"),o=E(e,"b","where"),s=E(r,"condition","where","bool"),i=st(st(s.shape,n.shape),o.shape),a=Rl(s,i),u=Rl(n,i),l=Rl(o,i),c={condition:a,t:u,e:l};return R.runKernel(yl,c)}var Cr=D({where_:vye});function bye(r){let e={x:E(r,"x","zerosLike")};return R.runKernel(Tl,e)}var je=D({zerosLike_:bye});function wye(r,t){let e=E(r,"a","div"),n=E(t,"b","div");[e,n]=wt(e,n);let o=me(e,n),s=je(o),i=Co(n,s);return Cr(i,s,o)}var PS=D({divNoNan_:wye});function Cye(r,t){let e=E(r,"t1","dot"),n=E(t,"t2","dot");F((e.rank===1||e.rank===2)&&(n.rank===1||n.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${n.rank}.`);let o=e.rank===1?e.size:e.shape[1],s=n.rank===1?n.size:n.shape[0];if(F(o===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${s}.`),e.rank===1&&n.rank===1){let i=V(e,[1,-1]),a=V(n,[-1,1]),u=dt(i,a);return V(u,[])}else if(e.rank===1&&n.rank===2){let i=V(e,[1,-1]),a=V(n,[n.shape[0],n.shape[1]]),u=dt(i,a);return V(u,[u.size])}else if(e.rank===2&&n.rank===1){let i=V(n,[-1,1]),a=dt(e,i);return V(a,[a.size])}else{let i=V(n,[n.shape[0],n.shape[1]]);return dt(e,i)}}var LS=D({dot_:Cye});function Sye(r,...t){let e=t.map((o,s)=>E(o,`tensors${s}`,"einsum")),n={equation:r};return R.runKernel(Wp,e,n)}var Dd=D({einsum_:Sye});function Iye(r){let e={x:E(r,"x","elu","float32")};return R.runKernel(ca,e)}var Ml=D({elu_:Iye});function Tye(r,t){let e=E(r,"x","ensureShape","string_or_numeric");if(!s2(e.shape,t))throw new Error(`EnsureShape: Shape of tensor ${e.shape} is not compatible with expected shape ${t}`);return r}var bG=D({ensureShape_:Tye});function _ye(r){let t=E(r,"x","erf");F(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=le(t,"float32"));let e={x:t};return R.runKernel(pa,e)}var Gg=D({erf_:_ye});function B2(r,t){for(let e=0;e<r.length;++e)if(r[r.length-e-1]!==t-1-e)return!1;return!0}function wG(r,t,e){let n=r.length+t.length,o=[],s=0,i=0;for(let a=0;a<n;a++)e.indexOf(a)===-1?o.push(r[s++]):o.push(t[i++]);return o}function V2(r,t){let e=[],n=r.length;for(let s=0;s<n;s++)t.indexOf(s)===-1&&e.push(r[s]);let o=t.map(s=>r[s]);return[e,o]}function wi(r,t){let e=t.map(n=>1);return wG(r,e,t)}function Eye(r,t,e){F(B2(t,e),()=>`${r} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function U2(r,t){if(B2(r,t))return null;let e=[];for(let n=0;n<t;++n)r.indexOf(n)===-1&&e.push(n);return r.forEach(n=>e.push(n)),e}function Qv(r){return r.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function kye(r,t){let e=[];for(let n=t-r;n<t;++n)e.push(n);return e}function Nye(r,t=null,e=!1){let o={x:E(r,"x","max")},s={reductionIndices:t,keepDims:e};return R.runKernel(el,o,s)}var zn=D({max_:Nye});function Dye(r,t=null,e=!1){let o={x:E(r,"x","min")},s={axis:t,keepDims:e};return R.runKernel(ol,o,s)}var Nc=D({min_:Dye});function Aye(r,t){let e=E(r,"base","pow"),n=E(t,"exp","pow");[e,n]=wt(e,n);let o={a:e,b:n};return R.runKernel(_a,o)}var io=D({pow_:Aye});function we(r,t){if((wo(r)&&t!=="string"||Array.isArray(r))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&wo(r)&&!(r instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Oo(r,[],[],t)}function Rye(r){let e={x:E(r,"x","sqrt","float32")};return R.runKernel(La,e)}var lr=D({sqrt_:Rye});function Oye(r){let t=E(r,"x","square"),e={};return R.runKernel("Square",{x:t},e)}var at=D({square_:Oye});function Mye(r,t=null,e=!1){let n=E(r,"x","sum");n.dtype==="bool"&&(n=le(n,"int32"));let o={x:n},s={axis:t,keepDims:e};return R.runKernel(vl,o,s)}var Ie=D({sum_:Mye});function Fye(r,t="euclidean",e=null,n=!1){r=E(r,"x","norm");let o=CG(r,t,e),s=o.shape;if(n){let i=Cn(e,r.shape);s=wi(o.shape,i)}return V(o,s)}function CG(r,t,e=null){if(r.rank===0)return Nr(r);if(r.rank!==1&&e===null)return CG(V(r,[-1]),t,e);if(r.rank===1||typeof e=="number"||Array.isArray(e)&&e.length===1){if(t===1)return Ie(Nr(r),e);if(t===1/0)return zn(Nr(r),e);if(t===-1/0)return Nc(Nr(r),e);if(t==="euclidean"||t===2)return lr(Ie(io(Nr(r),we(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&e.length===2){if(t===1)return zn(Ie(Nr(r),e[0]),e[1]-1);if(t===1/0)return zn(Ie(Nr(r),e[1]),e[0]);if(t===-1/0)return Nc(Ie(Nr(r),e[1]),e[0]);if(t==="fro"||t==="euclidean")return lr(Ie(at(r),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}var Dc=D({norm_:Fye});function $ye(r,t=null,e=!1){return Dc(r,"euclidean",t,e)}var zS=D({euclideanNorm_:$ye});function Pye(r){let e={x:E(r,"x","exp")};return R.runKernel(da,e)}var Rr=D({exp_:Pye});function Lye(r,t=0){let e=E(r,"x","expandDims","string_or_numeric");F(t<=e.rank,()=>"Axis must be <= rank of the tensor");let n={input:e},o={dim:t};return R.runKernel(Xu,n,o)}var Sr=D({expandDims_:Lye});function zye(r){let e={x:E(r,"x","expm1")};return R.runKernel(fa,e)}var BS=D({expm1_:zye});function Bye(r,t){let e=E(r,"x","tile","string_or_numeric");F(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`);let n={x:e},o={reps:t};return R.runKernel(hi,n,o)}var eo=D({tile_:Bye});function Vye(r,t,e,n="float32"){t==null&&(t=r);let o=Ne([r,t],n),s=r<=t?r:t;for(let a=0;a<s;++a)o.set(1,a,a);let i=V(o.toTensor(),[r,t]);if(e==null)return i;if(e.length===1)return eo(Sr(i,0),[e[0],1,1]);if(e.length===2)return eo(Sr(Sr(i,0),0),[e[0],e[1],1,1]);if(e.length===3)return eo(Sr(Sr(Sr(i,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}var yh=D({eye_:Vye});function Uye(r){let e={x:E(r,"x","floor","float32")};return R.runKernel(ha,e)}var Fl=D({floor_:Uye});function Gye(r,t,e=0,n=0){let o=E(r,"x","gather"),s=E(t,"indices","gather","int32"),i={x:o,indices:s},a={axis:e,batchDims:n};return R.runKernel(Zu,i,a)}var $l=D({gather_:Gye});function Wye(r,t){let e=E(r,"a","greater","string_or_numeric"),n=E(t,"b","greater","string_or_numeric");[e,n]=wt(e,n),st(e.shape,n.shape);let o={a:e,b:n};return R.runKernel(mc,o)}var Gr=D({greater_:Wye});function jye(r,t){let e=E(r,"a","greaterEqual","string_or_numeric"),n=E(t,"b","greaterEqual","string_or_numeric");[e,n]=wt(e,n),st(e.shape,n.shape);let o={a:e,b:n};return R.runKernel(ga,o)}var $o=D({greaterEqual_:jye});function Hye(r){let e={input:E(r,"input","imag")};return R.runKernel(Zp,e)}var Ad=D({imag_:Hye});function qye(r){let e={x:E(r,"x","isFinite")};return R.runKernel(ya,e)}var VS=D({isFinite_:qye});function Kye(r){let e={x:E(r,"x","isInf")};return R.runKernel(xa,e)}var US=D({isInf_:Kye});function Xye(r){let e={x:E(r,"x","isNaN")};return R.runKernel(va,e)}var GS=D({isNaN_:Xye});function Yye(r,t=.2){let n={x:E(r,"x","leakyRelu")},o={alpha:t};return R.runKernel(Qu,n,o)}var Rd=D({leakyRelu_:Yye});function Zye(r,t){let e=E(r,"a","less","string_or_numeric"),n=E(t,"b","less","string_or_numeric");[e,n]=wt(e,n),st(e.shape,n.shape);let o={a:e,b:n};return R.runKernel(gc,o)}var Ac=D({less_:Zye});function Qye(r,t){let e=E(r,"a","lessEqual","string_or_numeric"),n=E(t,"b","lessEqual","string_or_numeric");[e,n]=wt(e,n),st(e.shape,n.shape);let o={a:e,b:n};return R.runKernel(yc,o)}var ws=D({lessEqual_:Qye});function SG(r,t,e){if(e<=0)throw new Error("The number of values should be positive.");let n={start:r,stop:t,num:e};return R.runKernel(Qp,{},n)}function Jye(r,t=5,e=1,n=1,o=.5){let s=E(r,"x","localResponseNormalization");F(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),F(fc(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=s,a=!1;s.rank===3&&(a=!0,i=V(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let u={x:i},l={depthRadius:t,bias:e,alpha:n,beta:o},c=R.runKernel(Ju,u,l);return a?V(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var WS=D({localResponseNormalization_:Jye});function exe(r){let e={x:E(r,"x","log","float32")};return R.runKernel(ba,e)}var Bn=D({log_:exe});function txe(r){let e={x:E(r,"x","log1p")};return R.runKernel(wa,e)}var Od=D({log1p_:txe});function W2(r,t){F(cg(r),()=>"The f passed in variableGrads(f) must be a function"),F(t==null||Array.isArray(t)&&t.every(l=>l instanceof Tc),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let e=t!=null;if(!e){t=[];for(let l in R.registeredVariables)t.push(R.registeredVariables[l])}let n=e?t.filter(l=>!l.trainable):null,o=t.length;t=t.filter(l=>l.trainable),F(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`);let s=!0,{value:i,grads:a}=R.gradients(r,t,null,s);F(a.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),F(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let u={};return t.forEach((l,c)=>{a[c]!=null&&(u[l.name]=a[c])}),n?.forEach(l=>u[l.name]=null),{value:i,grads:u}}function es(r){return R.customGrad(r)}function rxe(r){let e={x:E(r,"x","neg")};return R.runKernel(il,e)}var yt=D({neg_:rxe});function nxe(r){let e={x:E(r,"x","softplus")};return R.runKernel(Pa,e)}var Ka=D({softplus_:nxe});function oxe(r){let t=E(r,"x","logSigmoid");return es(n=>({value:yt(Ka(yt(n))),gradFunc:i=>B(i,Rn(yt(n)))}))(t)}var jS=D({logSigmoid_:oxe});function sxe(r,t){let e=E(r,"a","sub"),n=E(t,"b","sub");[e,n]=wt(e,n);let o={a:e,b:n};return R.runKernel(Ba,o)}var xe=D({sub_:sxe});function ixe(r,t=-1){let e=E(r,"logits","logSoftmax");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return es((o,s)=>{let a=zn(o,t,!0),u=xe(o,a),l=xe(le(u,"float32"),Bn(Ie(Rr(u),t,!0)));return s([l]),{value:l,gradFunc:(p,d)=>{let[f]=d,h=!0,m=Rr(f);return xe(p,B(Ie(p,t,h),m))}}})(e)}var Wg=D({logSoftmax_:ixe});function axe(r,t=null,e=!1){let n=E(r,"x","logSumExp"),o=Cn(t,n.shape),s=zn(n,o,!0),i=xe(n,s),a=Rr(i),u=Ie(a,o),l=Bn(u),c=re(V(s,l.shape),l);if(e){let p=wi(c.shape,o);return V(c,p)}return c}var Md=D({logSumExp_:axe});function uxe(r,t){let e=E(r,"a","logicalAnd","bool"),n=E(t,"b","logicalAnd","bool");st(e.shape,n.shape);let o={a:e,b:n};return R.runKernel(xc,o)}var ao=D({logicalAnd_:uxe});function lxe(r){let e={x:E(r,"x","logicalNot","bool")};return R.runKernel(vc,e)}var Fd=D({logicalNot_:lxe});function cxe(r,t){let e=E(r,"a","logicalOr","bool"),n=E(t,"b","logicalOr","bool");st(e.shape,n.shape);let o={a:e,b:n};return R.runKernel(bc,o)}var jg=D({logicalOr_:cxe});function pxe(r,t){let e=E(r,"a","logicalXor","bool"),n=E(t,"b","logicalXor","bool");return st(e.shape,n.shape),ao(jg(r,t),Fd(ao(r,t)))}var HS=D({logicalXor_:pxe});var qS=2147483648;function dxe(r,t,e="left"){let n=E(r,"sortedSequence","searchSorted"),o=E(t,"values","searchSorted"),s=n.shape[n.shape.length-1],i=o.shape[o.shape.length-1],a=V(n,[-1,s]),u=V(o,[-1,i]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(bt(u.shape)>=qS)throw new Error(`values tensor size must less than ${qS}`);if(a.shape[1]>=qS)throw new Error(`trailing dim_size must less than ${qS} for int32 output type, was ${a.shape[1]}`);let l={sortedSequence:a,values:u},c={side:e};return R.runKernel(dd,l,c)}var Jv=D({searchSorted_:dxe});function IG(r,t){return Jv(r,t,"left")}function fxe(r,t,e,n,o){let s=E(r,"x","maxPool"),i=1,a=s,u=!1;s.rank===3&&(u=!0,a=V(s,[1,s.shape[0],s.shape[1],s.shape[2]])),F(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),F(Jn(e,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),wr("maxPool",n,o);let l={x:a},c={filterSize:t,strides:e,pad:n,dimRoundingMode:o},p=R.runKernel(tl,l,c);return u?V(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var $d=D({maxPool_:fxe});function hxe(r,t=[1,1,1],e,n,o,s="NDHWC"){let i=E(r,"x","maxPool3d"),a=i,u=!1;i.rank===4&&(u=!0,a=V(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),F(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),F(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),wr("maxPool3d",n,o);let l={x:a},c={filterSize:t,strides:e,pad:n,dimRoundingMode:o,dataFormat:s},p=R.runKernel(rl,l,c);return u?V(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var KS=D({maxPool3d_:hxe});function mxe(r,t,e,n,o=!1){let i={x:E(r,"x","maxPoolWithArgmax")},a={filterSize:t,strides:e,pad:n,includeBatchInIndex:o},u=R.runKernel(rd,i,a);return{result:u[0],indexes:u[1]}}var TG=D({maxPoolWithArgmax_:mxe});function gxe(r,t){let e=E(r,"a","maximum"),n=E(t,"b","maximum");[e,n]=wt(e,n),e.dtype==="bool"&&(e=le(e,"int32"),n=le(n,"int32")),st(e.shape,n.shape);let o={a:e,b:n};return R.runKernel(Ca,o)}var ts=D({maximum_:gxe});function yxe(r,t=null,e=!1){let o={x:E(r,"x","mean")},s={axis:t,keepDims:e};return R.runKernel(nl,o,s)}var Ir=D({mean_:yxe});function er(r,t="float32"){if(Vr(r),t==="complex64"){let n=er(r,"float32"),o=er(r,"float32");return Qo(n,o)}let e=dg(bt(r),t);return R.makeTensor(e,r,t)}function hn(r,t="float32"){if(Vr(r),t==="complex64"){let n=hn(r,"float32"),o=er(r,"float32");return Qo(n,o)}let e=Bv(bt(r),t);return R.makeTensor(e,r,t)}function _G(r,t,{indexing:e="xy"}={}){if(e!=="xy"&&e!=="ij")throw new TypeError(`${e} is not a valid third argument to meshgrid`);if(r===void 0)return[];let n=E(r,"x","meshgrid",r instanceof ct?r.dtype:"float32");if(t===void 0)return[n];let o=E(t,"y","meshgrid",t instanceof ct?t.dtype:"float32"),s=bt(n.shape),i=bt(o.shape);return e==="xy"?(n=V(n,[1,-1]),o=V(o,[-1,1]),[dt(hn([i,1],n.dtype),n),dt(o,hn([1,s],o.dtype))]):(n=V(n,[-1,1]),o=V(o,[1,-1]),[dt(n,hn([1,i],n.dtype)),dt(hn([s,1],o.dtype),o)])}function xxe(r,t){let e=E(r,"a","minimum"),n=E(t,"b","minimum");[e,n]=wt(e,n),e.dtype==="bool"&&(e=le(e,"int32"),n=le(n,"int32")),st(e.shape,n.shape);let o={a:e,b:n};return R.runKernel(Sa,o)}var rs=D({minimum_:xxe});function vxe(r,t,e){F(e==="reflect"||e==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);let n=E(r,"x","mirrorPad");if(n.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");F(t.length===n.rank,()=>`Padding doesn't match input. Must be ${n.rank}. Got ${t.length}.`);let o=e==="reflect"?1:0;for(let a=0;a<n.rank;a++)F(t[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),F(t[a][0]>=0&&t[a][0]<=n.shape[a]-o&&t[a][1]>=0&&t[a][1]<=n.shape[a]-o,()=>`Padding in dimension ${a} cannot be greater than or equal to ${n.shape[a]-o} or less than 0 for input of shape ${n.shape}`);let s={paddings:t,mode:e},i={x:n};return R.runKernel(sl,i,s)}var Hg=D({mirrorPad_:vxe});function bxe(r,t){let e=E(r,"a","mod"),n=E(t,"b","mod");[e,n]=wt(e,n);let o={a:e,b:n};return R.runKernel(Ia,o)}var XS=D({mod_:bxe});function wxe(r,t=null,e=!1){r=E(r,"x","moments");let n=Cn(t,r.shape),o=Ir(r,n,e),s=o.shape;e||(s=wi(o.shape,n));let i=at(xe(le(r,"float32"),V(o,s))),a=Ir(i,n,e);return{mean:o,variance:a}}var xh=D({moments_:wxe});function Cxe(r,t,e,n){let o=E(t,"data","multiRNNCell"),s=lh(e,"c","multiRNNCell"),i=lh(n,"h","multiRNNCell"),a=o,u=[];for(let p=0;p<r.length;p++){let d=r[p](a,s[p],i[p]);u.push(d[0]),u.push(d[1]),a=d[1]}let l=[],c=[];for(let p=0;p<u.length;p+=2)l.push(u[p]),c.push(u[p+1]);return[l,c]}var EG=D({multiRNNCell_:Cxe});function Sxe(r,t,e,n=!1){let o=E(r,"logits","multinomial"),s=o.size,i=o.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);e=e||Math.random();let u={logits:i===1?V(o,[1,-1]):o},l={numSamples:t,seed:e,normalized:n},c=R.runKernel(nd,u,l);return i===1?V(c,[c.size]):c}var kG=D({multinomial_:Sxe});function Ixe(r,t){let e=E(r,"a","notEqual","string_or_numeric"),n=E(t,"b","notEqual","string_or_numeric");[e,n]=wt(e,n),st(e.shape,n.shape);let o={a:e,b:n};return R.runKernel(wc,o)}var Xa=D({notEqual_:Ixe});function Txe(r,t,e=1,n=0,o="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let i={indices:E(r,"indices","oneHot","int32")},a={dtype:o,depth:t,onValue:e,offValue:n};return R.runKernel(ul,i,a)}var vh=D({oneHot_:Txe});function _xe(r){let e={x:E(r,"x","onesLike")};return R.runKernel(al,e)}var On=D({onesLike_:_xe});function Exe(r,t){let e=E(r,"v1","outerProduct"),n=E(t,"v2","outerProduct");F(e.rank===1&&n.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${n.rank}.`);let o=V(e,[-1,1]),s=V(n,[1,-1]);return dt(o,s)}var NG=D({outerProduct_:Exe});function kxe(r,t,e=0){let n=E(r,"x","pad");if(n.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let o={paddings:t,constantValue:e},s={x:n};return R.runKernel(cl,s,o)}var Vn=D({pad_:kxe});function Nxe(r,t,e=0){return F(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),Vn(r,[t],e)}var DG=D({pad1d_:Nxe});function Dxe(r,t,e=0){return F(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Vn(r,t,e)}var AG=D({pad2d_:Dxe});function Axe(r,t,e=0){return F(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Vn(r,t,e)}var RG=D({pad3d_:Axe});function Rxe(r,t,e=0){return F(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Vn(r,t,e)}var OG=D({pad4d_:Rxe});function Oxe(r,t,e){let n=E(r,"x","spaceToBatchND");F(n.rank>=1+t.length,()=>`input rank ${n.rank} should be > than [blockShape] ${t.length}`),F(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),F(n.shape.reduce((i,a,u)=>u>0&&u<=t.length?i&&(a+e[u-1][0]+e[u-1][1])%t[u-1]===0:i,!0),()=>`input spatial dimensions ${n.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`);let o={x:n},s={blockShape:t,paddings:e};return R.runKernel(bl,o,s)}var Pd=D({spaceToBatchND_:Oxe});function Mxe(r,t,e,n,o,s,i){o==null&&(o=[1,1]),s==null&&(s=1),n===0&&(n="valid");let a=E(r,"x","maxPool"),u=a,l=!1;a.rank===3&&(l=!0,u=V(a,[1,a.shape[0],a.shape[1],a.shape[2]])),F(Jn(s,o),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${o}'`);let c=L2(u.shape,t,s,o,n),p=[c.dilationHeight,c.dilationWidth],d;n==="same"?d=$xe([c.filterHeight,c.filterWidth],p):d=[[0,0],[0,0]];let f=p[0]===1&&p[1]===1,[h,m]=Fxe([c.inHeight,c.inWidth],p,d),g=f?n:"valid",y=f?u:Pd(u,p,h),w=(e==="avg"?()=>Ed(y,t,s,g,i):()=>$d(y,t,s,g,i))(),C=f?w:kd(w,p,m);return l?V(C,[C.shape[1],C.shape[2],C.shape[3]]):C}function Fxe(r,t,e){let n=e.map(c=>c[0]),o=e.map(c=>c[1]),s=r.concat(n,o),i=t.map((c,p)=>(c-s[p]%c)%c),a=o.map((c,p)=>c+i[p]),u=t.map((c,p)=>[n[p],a[p]]),l=t.map((c,p)=>[0,i[p]]);return[u,l]}function $xe(r,t){let n=r.map((i,a)=>i+(i-1)*(t[a]-1)).map(i=>i-1),o=n.map(i=>Math.floor(i/2)),s=n.map((i,a)=>i-o[a]);return n.map((i,a)=>[o[a],s[a]])}var YS=D({pool_:Mxe});function Pxe(r,t){let e=E(r,"x","prelu"),n=E(t,"alpha","prelu"),o={x:e,alpha:n};return R.runKernel(pl,o)}var Ld=D({prelu_:Pxe});function Lxe(r,t=null,e=!1){let n=E(r,"x","prod");n.dtype==="bool"&&(n=le(n,"int32"));let o={x:n},s={axis:t,keepDims:e};return R.runKernel(dl,o,s)}var ZS=D({prod_:Lxe});function zxe(r,t,e,n){let o=r.map((c,p)=>E(c,`tensors${p}`,"raggedGather","int32")),s=E(t,"paramsDenseValues","raggedGather"),i=E(e,"indices","raggedGather","int32"),a={paramsNestedSplits:o,paramsDenseValues:s,indices:i},u={outputRaggedRank:n},l=R.runKernel(hg,a,u);return{outputNestedSplits:l.slice(0,l.length-1),outputDenseValues:l[l.length-1]}}var MG=D({raggedGather_:zxe});function Bxe(r,t,e){let n=E(r,"starts","raggedRange"),o=E(t,"limits","raggedRange",n.dtype),s=E(e,"deltas","raggedRange",n.dtype),i={starts:n,limits:o,deltas:s},a=R.runKernel(mg,i);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}var FG=D({raggedRange_:Bxe});function Vxe(r,t,e,n,o){let s=E(r,"shape","raggedTensorToTensor","int32"),i=E(t,"values","raggedTensorToTensor"),a=E(e,"defaultValue","raggedTensorToTensor",i.dtype),u=n.map((p,d)=>E(p,`tensors${d}`,"raggedTensorToTensor","int32")),l={shape:s,values:i,defaultValue:a,rowPartitionTensors:u},c={rowPartitionTypes:o};return R.runKernel(gg,l,c)}var $G=D({raggedTensorToTensor_:Vxe});function Uxe(r,t,e){Vr(r);let n=bt(r),o=null;if(e==null||e==="float32")o=new Float32Array(n);else if(e==="int32")o=new Int32Array(n);else if(e==="bool")o=new Uint8Array(n);else throw new Error(`Unknown data type ${e}`);for(let s=0;s<n;s++)o[s]=t();return R.makeTensor(o,r,e)}var PG=D({rand_:Uxe});var tI=If(eb());var wh=class{constructor(t,e,n,o,s){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=o,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let i=s||Math.random();this.random=tI.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){let o=this.nextVal;return this.nextVal=NaN,o}let t,e,n=!1;for(;!n;){let o,s,i;do o=2*this.random()-1,s=2*this.random()-1,i=o*o+s*s;while(i>=1||i===0);let a=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*o*a,e=this.mean+this.stdDev*s*a,(!this.truncated||this.isValidTruncated(t))&&(n=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}},JS=class{constructor(t,e,n,o){this.alpha=t,this.beta=1/e,this.dtype=n;let s=o||Math.random();this.randu=tI.alea(s.toString()),this.randn=new wh(0,1,n,!1,this.randu()),t<1?this.d=t+2/3:this.d=t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,n,o,s,i;for(;;){do o=this.randn.nextValue(),i=1+this.c*o;while(i<=0);if(i*=i*i,t=o*o,e=1-.331*t*t,n=.5*t+this.d*(1-i+Math.log(i)),s=this.randu(),s<e||Math.log(s)<n)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(t){return this.dtype==="float32"?t:Math.round(t)}},eI=class{constructor(t=0,e=1,n,o){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=e-t,this.dtype=n,o==null&&(o=Math.random()),typeof o=="number"&&(o=o.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=tI.alea(o)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function Xxe(r,t,e=1,n="float32",o){if(Vr(r),e==null&&(e=1),n==null&&(n="float32"),n!=="float32"&&n!=="int32")throw new Error(`Unsupported data type ${n}`);let s=new JS(t,e,n,o),i=Ne(r,n);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var eW=D({randomGamma_:Xxe});function Yxe(r,t=0,e=1,n,o){if(Vr(r),n!=null&&n==="bool")throw new Error(`Unsupported data type ${n}`);let s=new wh(t,e,n,!1,o),i=Ne(r,n);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var Ch=D({randomNormal_:Yxe});function Zxe(r,t,e){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return Ch(r,0,1,t,e)}var tW=D({randomStandardNormal_:Zxe});function Qxe(r,t=0,e=1,n="float32",o){Vr(r);let s=Ne(r,n),i=new eI(t,e,null,o);for(let a=0;a<s.values.length;a++)s.values[a]=i.nextValue();return s.toTensor()}var Cs=D({randomUniform_:Qxe});function Jxe(r,t,e,n){return Cs(r,t,e,"int32",n)}var rW=D({randomUniformInt_:Jxe});function Pl(r,t,e=1,n="float32"){if(e===0)throw new Error("Cannot have a step of zero");let o={start:r,stop:t,step:e,dtype:n};return R.runKernel(id,{},o)}function eve(r){let e={input:E(r,"input","real")};return R.runKernel(ad,e)}var Rc=D({real_:eve});function tve(r){let e={x:E(r,"x","reciprocal")};return R.runKernel(Ea,e)}var rI=D({reciprocal_:tve});function rve(r){let e={x:E(r,"x","relu")};return R.runKernel(ka,e)}var to=D({relu_:rve});function nve(r){let e={x:E(r,"x","relu6")};return R.runKernel(Na,e)}var qg=D({relu6_:nve});function ove(r,t){let n={x:E(r,"x","reverse")},o={dims:t};return R.runKernel(gl,n,o)}var In=D({reverse_:ove});function sve(r){let t=E(r,"x","reverse");return F(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),In(t,0)}var nW=D({reverse1d_:sve});function ive(r,t){let e=E(r,"x","reverse");return F(e.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),In(e,t)}var oW=D({reverse2d_:ive});function ave(r,t){let e=E(r,"x","reverse");return F(e.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),In(e,t)}var sW=D({reverse3d_:ave});function uve(r,t){let e=E(r,"x","reverse");return F(e.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),In(e,t)}var iW=D({reverse4d_:uve});function lve(r){let e={x:E(r,"x","round")};return R.runKernel(Da,e)}var Kg=D({round_:lve});function cve(r){let e={x:E(r,"x","rsqrt","float32")};return R.runKernel(Aa,e)}var Xg=D({rsqrt_:cve});function pve(r){let e={x:E(r,"x","selu")};return R.runKernel(Ra,e)}var Yg=D({selu_:pve});function dve(r,t,e,n,o,s=[1,1],i="NHWC"){let a=E(r,"x","separableConv2d"),u=E(t,"depthwiseFilter","separableConv2d"),l=E(e,"pointwiseFilter","separableConv2d"),c=a,p=!1;if(a.rank===3&&(p=!0,c=V(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");F(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),F(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),F(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),F(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),F(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);let d=u.shape[2],f=u.shape[3];F(l.shape[2]===d*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*f}, but got ${l.shape[2]}.`);let h=Ol(c,u,n,o,i,s),g=Jo(h,l,1,"valid",i);return p?V(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var Zg=D({separableConv2d_:dve});function fve(r,t){return L(this,null,function*(){let e=E(r,"x","setdiff1d"),n=E(t,"y","setdiff1d");F(e.dtype===n.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${n.dtype}).`),F(e.rank===1,()=>`x should be 1D tensor, but got x (${e.shape}).`),F(n.rank===1,()=>`y should be 1D tensor, but got y (${n.shape}).`);let o=yield e.data(),s=yield n.data(),i=new Set(s),a=0;for(let c=0;c<o.length;c++)i.has(o[c])||a++;let u=new jt([a],e.dtype),l=new jt([a],"int32");for(let c=0,p=0;c<o.length;c++)i.has(o[c])||(u.values[p]=o[c],l.values[p]=c,p++);return[u.toTensor(),l.toTensor()]})}var aW=fve;function hve(r){let e={x:E(r,"x","sign")};return R.runKernel(Fa,e)}var nI=D({sign_:hve});function mve(r){let e={x:E(r,"x","sin","float32")};return R.runKernel(Oa,e)}var Qg=D({sin_:mve});function gve(r){let e={x:E(r,"x","sinh")};return R.runKernel(Ma,e)}var Jg=D({sinh_:gve});function yve(r,t,e){let n=E(r,"x","slice1d");return F(n.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${n.rank} tensor`),Ue(n,[t],[e])}var ey=D({slice1d_:yve});function xve(r,t,e){let n=E(r,"x","slice2d");return F(n.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${n.rank} tensor`),Ue(n,t,e)}var tb=D({slice2d_:xve});function vve(r,t,e){let n=E(r,"x","slice3d");return F(n.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${n.rank} tensor`),Ue(n,t,e)}var ty=D({slice3d_:vve});function bve(r,t,e){let n=E(r,"x","slice4d");return F(n.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${n.rank} tensor`),Ue(n,t,e)}var Sh=D({slice4d_:bve});function wve(r,t=-1){let e=E(r,"logits","softmax","float32");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);let n={logits:e},o={dim:t};return R.runKernel(Cl,n,o)}var zd=D({softmax_:wve});function Cve(r){F(r.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${r.dtype}.`);let t={input:r};return R.runKernel(Hp,t)}var Bd=D({fft_:Cve});function Sve(r){F(r.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${r.dtype}.`);let t={input:r};return R.runKernel(Yp,t)}var Oc=D({ifft_:Sve});function Ive(r){let t=r.shape[r.shape.length-1],e=r.size/t,n;if(t<=2){let o=V(r,[e,t]);n=Oc(o)}else{let o=[e,2*(t-1)],s=V(Rc(r),[e,t]),i=V(Ad(r),[e,t]),a=In(Ue(s,[0,1],[e,t-2]),1),u=B(In(Ue(i,[0,1],[e,t-2]),1),we(-1)),l=Dt([s,a],1),c=Dt([i,u],1),p=V(Qo(l,c),[o[0],o[1]]);n=Oc(p)}if(n=Rc(n),r.rank===3&&r.shape[0]!==0){let o=n,s=r.shape[0];n=V(n,[s,n.shape[0]/s,n.shape[1]]),o.dispose()}return n}var ry=D({irfft_:Ive});function Tve(r,t,e=0){let o={x:E(r,"x","split")},s={numOrSizeSplits:t,axis:e};return R.runKernel(wl,o,s)}var Tn=D({split_:Tve});function _ve(r,t){F(r.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${r.dtype}`);let e=r.shape[r.shape.length-1],n=r.size/e,o;if(t!=null&&t<e){let h=r.shape.map(g=>0),m=r.shape.map(g=>g);m[r.shape.length-1]=t,o=Ue(r,h,m),e=t}else if(t!=null&&t>e){let h=r.shape.map(m=>m);h[r.shape.length-1]=t-e,o=Dt([r,er(h)],r.shape.length-1),e=t}else o=r;let s=je(o),i=V(Qo(o,s),[n,e]),a=Bd(i),u=Math.floor(e/2)+1,l=Rc(a),c=Ad(a),p=Tn(l,[u,e-u],l.shape.length-1),d=Tn(c,[u,e-u],c.shape.length-1),f=o.shape.slice();return f[o.shape.length-1]=u,V(Qo(p[0],d[0]),f)}var Vd=D({rfft_:_ve});function Eve(r,t){let e=E(r,"a","squaredDifference"),n=E(t,"b","squaredDifference");[e,n]=wt(e,n),st(e.shape,n.shape);let o={a:e,b:n},s={};return R.runKernel(za,o,s)}var ny=D({squaredDifference_:Eve});function kve(r,t){let e=E(r,"x","squeeze","string_or_numeric");return V(e,i2(e.shape,t).newShape)}var Rt=D({squeeze_:kve});function Nve(r,t=0){let e=lh(r,"tensors","stack","string_or_numeric");F(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&F(t<=e[0].rank,()=>"Axis must be <= rank of the tensor");let n=e,o={axis:t};return R.runKernel(ll,n,o)}var Wr=D({stack_:Nve});function Dve(r,t=0){let n={x:E(r,"x","step")},o={alpha:t};return R.runKernel(Ga,n,o)}var Ci=D({step_:Dve});function Ave(r,t,e,n,o=0,s=0,i=0,a=0,u=0){let c={x:E(r,"x","stridedSlice","string_or_numeric")},p={begin:t,end:e,strides:n,beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u};return R.runKernel(yd,c,p)}var oI=D({stridedSlice_:Ave});function Rve(r){let e={x:E(r,"x","tan","float32")};return R.runKernel(Va,e)}var sI=D({tan_:Rve});function cr(r,t){Ws(r);let e=Zo(r,t);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Oo(r,null,e,t)}function So(r,t,e){if(Ws(r),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let n=Zo(r,e);if(n.length!==2&&n.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Oo(r,t,n,e)}function iI(r,t,e){if(Ws(r),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let n=Zo(r,e);if(n.length!==3&&n.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Oo(r,t,n,e)}function uW(r,t,e){if(Ws(r),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let n=Zo(r,e);if(n.length!==4&&n.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Oo(r,t,n,e)}function lW(r,t,e){if(Ws(r),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let n=Zo(r,e);if(n.length!==5&&n.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Oo(r,t,n,e)}function cW(r,t,e){if(Ws(r),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let n=Zo(r,e);if(n.length!==6&&n.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||n,Oo(r,t,n,e)}function pW(r,t,e){let n=t.rank>1?t.shape[t.rank-1]:1,o=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${r}, sliceDim: ${n}, and batchDim: ${o}.`;if(e.rank<o)throw new Error(s+` update.rank < ${o}. `);if(r.length<n+(e.rank-o))throw new Error(s+` Output shape length < ${n+(e.rank-o)}`);if(e.rank!==o+r.length-n)throw new Error(s+` update.rank != ${o+r.length-n}`);for(let i=0;i<o;++i)if(e.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${e.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<e.rank-o;++i)if(e.shape[i+o]!==r[i+n])throw new Error(s+` updates.shape[${i+o}] (${e.shape[i+o]}) != shape[${i+o}] (${r[i+o]})`)}function rb(r,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(r.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${r.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(e.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(r.size===0)throw new Error(`Updates specified for empty output. updates shape: ${r.shape}`)}pW(e,t,r)}function Ove(r,t,e){let n=t.shape.length,o=n>1?t.shape[n-1]:1,s=e.length,i=1;for(let p=o;p<s;++p)i*=e[p];let a=o<1?1:o,u=bt(t.shape)/a,l=[...Ru(e.slice(0,o)),1],c=bt(e);return{sliceRank:o,numUpdates:u,sliceSize:i,strides:l,outputSize:c}}function Mve(r,t,e){let n=E(r,"tensor","tensorScatterupdate"),o=E(t,"indices","tensorScatterupdate","int32"),s=E(e,"updates","tensorScatterupdate");if(rb(s,o,n.shape),n.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${n.dtype} and ${s.dtype}.`);let i={tensor:n,indices:o,updates:s},a={};return R.runKernel(pd,i,a)}var fW=D({tensorScatterUpdate_:Mve});function Fve(r,t=1,e=!0){let n=E(r,"x","topk");if(n.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let o=n.shape[n.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${t}`);let s={x:n},i={k:t,sorted:e},[a,u]=R.runKernel(vd,s,i);return{values:a,indices:u}}var aI=D({topk_:Fve});function $ve(r,t=0,e=1,n,o){if(Vr(r),n!=null&&n==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new wh(t,e,n,!0,o),i=Ne(r,n);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var oy=D({truncatedNormal_:$ve});function Pve(r,t=0){let e=E(r,"x","unique","string_or_numeric");F(e.rank>0,()=>"The input tensor must be at least 1D");let n={x:e},o={axis:t},[s,i]=R.runKernel(wg,n,o);return{values:s,indices:i}}var uI=D({unique_:Pve});function Lve(r,t,e){let n=E(r,"x","unsortedSegmentSum"),o=E(t,"segmentIds","unsortedSegmentSum","int32");F(fc(e),()=>"numSegments must be of dtype int");let s={x:n,segmentIds:o},i={numSegments:e};return R.runKernel(Il,s,i)}var sy=D({unsortedSegmentSum_:Lve});function zve(r,t=0){let e=E(r,"x","unstack","string_or_numeric");F(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`);let n={value:e},o={axis:t};return R.runKernel(Sl,n,o)}var _n=D({unstack_:zve});function hW(r,t){return Jv(r,t,"right")}function lI(r,t=!0,e,n){return R.makeVariable(r,t,e,n)}function cI(r,t){let e=[];for(let s=0;s<t.length;s++)t[s]&&e.push(s);let n=Ne(r,"int32"),o=Ne([e.length,r.length],"int32");for(let s=0;s<e.length;s++){let i=n.indexToLoc(e[s]),a=s*r.length;o.values.set(i,a)}return o.toTensor()}function Bve(r){return L(this,null,function*(){let t=E(r,"condition","whereAsync","bool"),e=yield t.data(),n=cI(t.shape,e);return r!==t&&t.dispose(),n})}var pI=Bve;function Vve(r,t,e){return L(this,null,function*(){let n=E(r,"tensor","boolMask"),o=E(t,"mask","boolMask","bool"),s=e??0,i=o.rank,a=n.shape;F(i>0,()=>"mask cannot be scalar"),on(a.slice(s,s+i),o.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let m=s;m<s+i;m++)u*=a[m];let l=a.slice(0,s).concat([u],a.slice(s+i)),c=V(n,l),p=V(o,[-1]),d=yield pI(p),f=Rt(d,[1]),h=$l(c,f,s);return r!==n&&n.dispose(),t!==o&&o.dispose(),f.dispose(),c.dispose(),p.dispose(),d.dispose(),h})}var Uve=Vve;function Gve(r,t,e){let n=E(r,"x","transpose");if(t==null&&(t=n.shape.map((i,a)=>a).reverse()),F(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`),t.forEach(i=>{F(i>=0&&i<n.rank,()=>`All entries in 'perm' must be between 0 and ${n.rank-1} but got ${t}`)}),n.rank<=1)return n.clone();let o={x:n},s={perm:t};return n.dtype==="complex64"?X(()=>{let i=Rc(n),a=Ad(n);return i=R.runKernel(mi,{x:i},s),a=R.runKernel(mi,{x:a},s),e&&(a=yt(a)),Qo(i,a)}):R.runKernel(mi,o,s)}var ft=D({transpose_:Gve});function Wve(r,t,e,n,o=!0){let s=E(r,"v","movingAverage"),i=E(t,"x","movingAverage"),a=E(e,"decay","movingAverage");FU(s,i),F(xs(s.shape,i.shape),()=>"Shape mismatch in v and x");let u=we(1),l=xe(u,a),c=B(xe(i,s),l);if(o){F(n!=null,()=>"When using zeroDebias: true, step is required.");let p=E(n,"step","movingAverage");c=me(c,xe(u,io(a,p)))}return re(s,c)}var jve=D({movingAverage_:Wve});function Hve(r,t,e){Vr(e);let n=E(r,"indices","scatterND","int32"),o=E(t,"updates","scatterND");rb(o,n,e);let s={indices:n,updates:o},i={shape:e};return R.runKernel(cd,s,i)}var qve=D({scatterND_:Hve});function mW(r,t,e,n){if(r.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${r.dtype}.`);if(r.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${r.shape}.`);let o=r.rank>0?r.shape[0]:1,s=r.rank>1?r.shape[1]:1;if(e.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${s}.`);let i=t.size;if(!(t.rank===0||t.rank===1&&i===o))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${o}]`);if(t.dtype!==n.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function Xve(r,t,e,n=0){Vr(e);let o=E(r,"sparseIndices","sparseToDense","int32"),s=E(t,"sparseValues","sparseToDense","string_or_numeric"),i=E(n,"defaultValue","sparseToDense",s.dtype);mW(o,s,e,i);let a={sparseIndices:o,sparseValues:s,defaultValue:i},u={outputShape:e};return R.runKernel(md,a,u)}var Yve=D({sparseToDense_:Xve});function Zve(r,t){let e=E(t,"indices","gatherND","int32"),o={params:E(r,"x","gatherND","string_or_numeric"),indices:e};return R.runKernel(Xp,o)}var Qve=D({gatherND_:Zve});function gW(r,t){if(t==null)return r.shape.slice();if(xs(r.shape,t))return t;if(r.shape.length===t.length){let e=[];for(let n=0;n<r.shape.length;n++)t[n]==null&&r.shape[n]!=null?e.push(r.shape[n]):e.push(t[n]);return e}return t}function Jve(r,t,e,n){let o=E(r,"x","dropout");if(F(o.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`),F(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return r instanceof ct?o.clone():o;let s=gW(o,e),i=1-t,a=me(Fl(re(Cs(s,0,1,"float32",n),i)),i);return B(o,a)}var Z2=D({dropout_:Jve});function Q2(r){return Math.floor(Math.pow(2,Math.ceil(Math.log(r)/Math.log(2))))}function nb(r,t,e){let n=1-r%2,o=new Float32Array(r);for(let s=0;s<r;++s){let i=2*Math.PI*s/(r+n-1);o[s]=t-e*Math.cos(i)}return cr(o,"float32")}function ebe(r,t,e=1){return L(this,null,function*(){let n=E(r,"predictions","inTopK"),o=E(t,"targets","inTopK");F(n.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${n.rank}`),F(n.rank-1===o.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${n.rank} and targets rank ${o.rank}`),on(n.shape.slice(0,n.shape.length-1),o.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=n.shape[n.shape.length-1];F(e>0&&e<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${e}`);let i=yield n.data(),a=yield o.data(),[u,l]=[i.length/s,s],c=a2("bool",u);for(let p=0;p<u;p++){let d=p*l,f=i.subarray(d,d+l),h=[];for(let m=0;m<f.length;m++)h.push({value:f[m],index:m});h.sort((m,g)=>g.value-m.value),c[p]=0;for(let m=0;m<e;m++)if(h[m].index===a[p]){c[p]=1;break}}return r!==n&&n.dispose(),t!==o&&o.dispose(),$n(c,o.shape,"bool")})}var tbe=ebe;var Ud={};ur(Ud,{conv2d:()=>yW,depthwiseConv2d:()=>xW,matMul:()=>vW});function rbe(r,t,e,n,o,s="NHWC",i){let a=r;r.rank===3&&(a=V(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=t;u.rank===3&&(u=V(t,[1,t.shape[0],t.shape[1],t.shape[2]])),F(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),F(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),F(e.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);let l=s==="NHWC"?a.shape[3]:a.shape[1],c=s==="NHWC"?u.shape[3]:u.shape[1];F(l===e[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${e[2]}.`),F(c===e[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${e[3]}).`),wr("conv2dDerFilter",o,i);let p={x:a,dy:u},d={strides:n,pad:o,dataFormat:s,dimRoundingMode:i,filterShape:e};return R.runKernel(Mp,p,d)}var iy=D({conv2DBackpropFilter_:rbe});function Ih(r,t,e){if(e==null||e==="linear")return r;if(e==="relu")return B(r,Ci(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function Th(r,t){let e=t,n=gr(r.shape,t.shape);return n.length>0&&(e=Ie(e,n)),V(e,r.shape)}function _h(r,t,e,n){if(t==="linear")return r;if(t==="relu")return to(r);if(t==="elu")return Ml(r);if(t==="relu6")return qg(r);if(t==="prelu")return Ld(r,e);if(t==="leakyrelu")return Rd(r,n);if(t==="sigmoid")return Rn(r);throw new Error(`Unknown fused activation ${t}.`)}var Eh=(r,t)=>!(r>0)||t==="linear";function nbe({x:r,filter:t,strides:e,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(u=u||"linear",Eh(R.state.gradientDepth,u)===!1){F(o==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${o} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let N=Jo(r,t,e,n,o,s,i);return a!=null&&(N=re(N,a)),_h(N,u,l,c)}let p=E(r,"x","conv2d","float32"),d=E(t,"filter","conv2d","float32"),f=p,h=!1;p.rank===3&&(h=!0,f=V(p,[1,p.shape[0],p.shape[1],p.shape[2]])),F(f.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),F(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),wr("fused conv2d",n,i);let m=o==="NHWC"?f.shape[3]:f.shape[1];F(d.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${d.shape[2]}.`),F(Jn(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`);let g=mh(f.shape,d.shape,e,s,n,i),y;a!=null&&(y=E(a,"bias","fused conv2d"),[y]=wt(y,p),o==="NHWC"?st(g.outShape,y.shape):(F(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),F(y.shape.length===0||y.shape[0]===g.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let x;if(l!=null){let N=l.shape;if(F(N.length<=1||N.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${N.length}.`),N.length===1)F(N[0]===1||N[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the number of output channels (${g.outChannels}).`);else if(N.length===3)try{st(N,g.outShape)}catch{let O=`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(O)}x=E(l,"prelu weights","fused conv2d")}let w=(N,A)=>{F(o==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${o} but only NHWC is currently supported.`);let[O,$,z,G]=A,K=Ih(N,z,u);F(Hs(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let Z=zg($.shape,K,O,e,n),Q=iy($,K,O.shape,e,n),J=[Z,Q];if(G!=null){let te=Th(G,K);J.push(te)}return J},C={x:f,filter:d,bias:y,preluActivationWeights:x},I={strides:e,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return a==null?es((A,O,$)=>{let z=R.runKernel(Sc,C,I);return $([O,A,z]),h&&(z=V(z,[z.shape[1],z.shape[2],z.shape[3]])),{value:z,gradFunc:w}})(f,d):es((A,O,$,z)=>{let G=R.runKernel(Sc,C,I);return z([O,A,G,$]),h&&(G=V(G,[G.shape[1],G.shape[2],G.shape[3]])),{value:G,gradFunc:w}})(f,d,y)}var yW=D({fusedConv2d_:nbe});function obe(r,t,e,n,o,s=[1,1],i){let a=r;r.rank===3&&(a=V(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=t;u.rank===3&&(u=V(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l={x:a,dy:u},c={strides:n,pad:o,dimRoundingMode:i,dilations:s,filterShape:e};return R.runKernel(Vp,l,c)}var dI=D({depthwiseConv2dNativeBackpropFilter_:obe});function sbe(r,t,e,n,o,s=[1,1],i){let a=t,u=!1;t.rank===3&&(u=!0,a=V(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l={dy:a,filter:e},c={strides:n,pad:o,dimRoundingMode:i,dilations:s,inputShape:r},p=R.runKernel(Up,l,c);return u?V(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var fI=D({depthwiseConv2dNativeBackpropInput_:sbe});function ibe({x:r,filter:t,strides:e,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(Eh(R.state.gradientDepth,u)===!1){let I=Ol(r,t,e,n,o,s,i);return a!=null&&(I=re(I,a)),_h(I,u,l,c)}let p=E(r,"x","depthwiseConv2d","float32"),d=E(t,"filter","depthwiseConv2d","float32"),f=p,h=!1;p.rank===3&&(h=!0,f=V(p,[1,p.shape[0],p.shape[1],p.shape[2]])),F(f.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),F(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),F(f.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),s==null&&(s=[1,1]),F(Jn(e,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),wr("fused depthwiseConv2d",n,i);let m=mh(f.shape,d.shape,e,s,n,i,!0),g;a!=null&&(g=E(a,"bias","fused conv2d"),[g]=wt(g,p),st(m.outShape,g.shape));let y;l!=null&&(y=E(l,"prelu weights","fused depthwiseConv2d"));let x=(I,N)=>{F(Hs(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[A,O,$,z]=N,G=Ih(I,$,u),K=fI(O.shape,G,A,e,n,s,i),Z=dI(O,G,A.shape,e,n,s,i);if(z!=null){let Q=Th(g,G);return[K,Z,Q]}return[K,Z]},w={x:f,filter:d,bias:g,preluActivationWeights:y},C={strides:e,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return a==null?es((N,A,O)=>{let $=R.runKernel(Ic,w,C);return O([A,N,$]),h&&($=V($,[$.shape[1],$.shape[2],$.shape[3]])),{value:$,gradFunc:x}})(f,d):es((N,A,O,$)=>{let z=R.runKernel(Ic,w,C);return $([A,N,z,O]),h&&(z=V(z,[z.shape[1],z.shape[2],z.shape[3]])),{value:z,gradFunc:x}})(f,d,g)}var xW=D({fusedDepthwiseConv2d_:ibe});function abe({a:r,b:t,transposeA:e=!1,transposeB:n=!1,bias:o,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(Eh(R.state.gradientDepth,s)===!1){let G=dt(r,t,e,n);return o!=null&&(G=re(G,o)),_h(G,s,i,a)}let u=E(r,"a","fused matMul"),l=E(t,"b","fused matMul");[u,l]=wt(u,l);let c=e?u.shape[u.rank-2]:u.shape[u.rank-1],p=n?l.shape[l.rank-1]:l.shape[l.rank-2],d=e?u.shape[u.rank-1]:u.shape[u.rank-2],f=n?l.shape[l.rank-2]:l.shape[l.rank-1],h=u.shape.slice(0,-2),m=l.shape.slice(0,-2),g=bt(h),y=bt(m);F(c===p,()=>`Error in fused matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${e} and transposeB=${n} must match.`);let w=st(u.shape.slice(0,-2),l.shape.slice(0,-2)).concat([d,f]),C=e?V(u,[g,c,d]):V(u,[g,d,c]),I=n?V(l,[y,f,p]):V(l,[y,p,f]),N;o!=null&&(N=E(o,"bias","fused matMul"),[N]=wt(N,u),st(w,N.shape));let A;i!=null&&(A=E(i,"prelu weights","fused matMul"));let O=(G,K)=>{let[Z,Q,J,te]=K,ie=Ih(V(G,J.shape),J,s),ne,ae;if(!e&&!n?(ne=dt(ie,Q,!1,!0),ae=dt(Z,ie,!0,!1)):!e&&n?(ne=dt(ie,Q,!1,!1),ae=dt(ie,Z,!0,!1)):e&&!n?(ne=dt(Q,ie,!1,!0),ae=dt(Z,ie,!1,!1)):(ne=dt(Q,ie,!0,!0),ae=dt(ie,Z,!0,!0)),o!=null){let ye=Th(te,ie);return[ne,ae,ye]}else return[ne,ae]},$={a:C,b:I,bias:N,preluActivationWeights:A},z={transposeA:e,transposeB:n,activation:s,leakyreluAlpha:a};return o==null?es((K,Z,Q)=>{let J=R.runKernel(Cc,$,z);return Q([K,Z,J]),{value:V(J,w),gradFunc:O}})(C,I):es((K,Z,Q,J)=>{let te=R.runKernel(Cc,$,z);return J([K,Z,te,Q]),{value:V(te,w),gradFunc:O}})(C,I,N)}var vW=D({fusedMatMul_:abe});function ube(r){return nb(r,.54,.46)}var bW=D({hammingWindow_:ube});function lbe(r){return nb(r,.5,.5)}var hI=D({hannWindow_:lbe});function cbe(r,t,e,n=!1,o=0){let s=0,i=[];for(;s+t<=r.size;)i.push(Ue(r,s,t)),s+=e;if(n)for(;s<r.size;){let a=s+t-r.size,u=Dt([Ue(r,s,t-a),bi([a],o)]);i.push(u),s+=e}return i.length===0?So([],[0,t]):V(Dt(i),[i.length,t])}var mI=D({frame_:cbe});function pbe(r,t,e,n,o=hI){n==null&&(n=Q2(t));let s=mI(r,t,e),i=B(s,o(t));return Vd(i,n)}var wW=D({stft_:pbe});function dbe(r,t,e,n,o="bilinear",s=0){let i=E(r,"image","cropAndResize"),a=E(t,"boxes","cropAndResize","float32"),u=E(e,"boxInd","cropAndResize","int32"),l=a.shape[0];F(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),F(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${a.shape}.`),F(u.rank===1&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${a.shape}.`),F(n.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`),F(n[0]>=1&&n[1]>=1,()=>`cropSize must be atleast [1,1], but was ${n}`),F(o==="bilinear"||o==="nearest",()=>`method must be bilinear or nearest, but was ${o}`);let c={image:i,boxes:a,boxInd:u},p={method:o,extrapolationValue:s,cropSize:n};return R.runKernel(Lp,c,p)}var CW=D({cropAndResize_:dbe});function fbe(r){let t=E(r,"image","flipLeftRight","float32");F(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let e={image:t};return R.runKernel(Kp,e,{})}var SW=D({flipLeftRight_:fbe});function hbe(r){let t=E(r,"image","grayscaleToRGB"),e=t.rank-1,n=t.shape[e];F(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),F(n===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`);let o=new Array(t.rank);return o.fill(1,0,e),o[e]=3,eo(t,o)}var IW=D({grayscaleToRGB_:hbe});function mbe(r){let t=E(r,"image","RGBToGrayscale"),e=t.rank-1,n=t.shape[e];F(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),F(n===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${n}.`);let o=t.dtype,s=le(t,"float32"),i=cr([.2989,.587,.114]),a;switch(t.rank){case 2:a=Dd("ij,j->i",s,i);break;case 3:a=Dd("ijk,k->ij",s,i);break;case 4:a=Dd("ijkl,l->ijk",s,i);break;case 5:a=Dd("ijklm,m->ijkl",s,i);break;case 6:a=Dd("ijklmn,n->ijklm",s,i);break;default:throw new Error("Not a valid tensor rank.")}return a=Sr(a,-1),le(a,o)}var TW=D({rgbToGrayscale_:mbe});function gbe(r,t,e=0,n=.5){let o=E(r,"image","rotateWithOffset","float32");F(o.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`);let s={image:o},i={radians:t,fillValue:e,center:n};return R.runKernel(wd,s,i)}var _W=D({rotateWithOffset_:gbe});function Si(r,t,e,n,o,s){n==null&&(n=.5),o==null&&(o=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=r.shape[0];return e=Math.min(e,i),F(0<=n&&n<=1,()=>`iouThreshold must be in [0, 1], but was '${n}'`),F(r.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${r.rank}'`),F(r.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${r.shape[1]}`),F(t.rank===1,()=>"scores must be a 1D tensor"),F(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),F(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:e,iouThreshold:n,scoreThreshold:o,softNmsSigma:s}}function ybe(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY){let s=E(r,"boxes","nonMaxSuppression","float32"),i=E(t,"scores","nonMaxSuppression","float32"),a=Si(s,i,e,n,o);e=a.maxOutputSize,n=a.iouThreshold,o=a.scoreThreshold;let u={maxOutputSize:e,iouThreshold:n,scoreThreshold:o};return R.runKernel(od,{boxes:s,scores:i},u)}var EW=D({nonMaxSuppression_:ybe});function kW(r,t,e){let n=xbe(r,t,e),o=n<0?-(n+1):n;r.splice(o,0,t)}function xbe(r,t,e){return bbe(r,t,e||vbe)}function vbe(r,t){return r>t?1:r<t?-1:0}function bbe(r,t,e){let n=0,o=r.length,s=0,i=!1;for(;n<o;){s=n+(o-n>>>1);let a=e(t,r[s]);a>0?n=s+1:(o=s,i=!a)}return i?n:-n-1}function gI(r,t,e,n,o){return J2(r,t,e,n,o,0)}function yI(r,t,e,n,o,s){return J2(r,t,e,n,o,0,!1,s,!0)}function xI(r,t,e,n,o,s){return J2(r,t,e,n,o,s,!0)}function J2(r,t,e,n,o,s,i=!1,a=!1,u=!1){let l=[];for(let g=0;g<t.length;g++)t[g]>o&&l.push({score:t[g],boxIndex:g,suppressBeginIndex:0});l.sort(NW);let c=s>0?-.5/s:0,p=[],d=[];for(;p.length<e&&l.length>0;){let g=l.pop(),{score:y,boxIndex:x,suppressBeginIndex:w}=g;if(y<o)break;let C=!1;for(let I=p.length-1;I>=w;--I){let N=wbe(r,x,p[I]);if(N>=n){C=!0;break}if(g.score=g.score*Cbe(n,c,N),g.score<=o)break}g.suppressBeginIndex=p.length,C||(g.score===y?(p.push(x),d.push(g.score)):g.score>o&&kW(l,g,NW))}let f=p.length,h=e-f;a&&h>0&&(p.push(...new Array(h).fill(0)),d.push(...new Array(h).fill(0)));let m={selectedIndices:p};return i&&(m.selectedScores=d),u&&(m.validOutputs=f),m}function wbe(r,t,e){let n=r.subarray(t*4,t*4+4),o=r.subarray(e*4,e*4+4),s=Math.min(n[0],n[2]),i=Math.min(n[1],n[3]),a=Math.max(n[0],n[2]),u=Math.max(n[1],n[3]),l=Math.min(o[0],o[2]),c=Math.min(o[1],o[3]),p=Math.max(o[0],o[2]),d=Math.max(o[1],o[3]),f=(a-s)*(u-i),h=(p-l)*(d-c);if(f<=0||h<=0)return 0;let m=Math.max(s,l),g=Math.max(i,c),y=Math.min(a,p),x=Math.min(u,d),w=Math.max(y-m,0)*Math.max(x-g,0);return w/(f+h-w)}function Cbe(r,t,e){let n=Math.exp(t*e*e);return e<=r?n:0}function NW(r,t){return r.score-t.score||r.score===t.score&&t.boxIndex-r.boxIndex}function Sbe(s,i,a){return L(this,arguments,function*(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY){let u=E(r,"boxes","nonMaxSuppressionAsync"),l=E(t,"scores","nonMaxSuppressionAsync"),c=Si(u,l,e,n,o);e=c.maxOutputSize,n=c.iouThreshold,o=c.scoreThreshold;let p=yield Promise.all([u.data(),l.data()]),d=p[0],f=p[1],{selectedIndices:h}=gI(d,f,e,n,o);return u!==r&&u.dispose(),l!==t&&l.dispose(),cr(h,"int32")})}var DW=Sbe;function Ibe(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let i=E(r,"boxes","nonMaxSuppression"),a=E(t,"scores","nonMaxSuppression"),u=Si(i,a,e,n,o,s);e=u.maxOutputSize,n=u.iouThreshold,o=u.scoreThreshold,s=u.softNmsSigma;let l={boxes:i,scores:a},c={maxOutputSize:e,iouThreshold:n,scoreThreshold:o,softNmsSigma:s},p=R.runKernel(sd,l,c);return{selectedIndices:p[0],selectedScores:p[1]}}var AW=D({nonMaxSuppressionWithScore_:Ibe});function Tbe(i,a,u){return L(this,arguments,function*(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let l=E(r,"boxes","nonMaxSuppressionAsync"),c=E(t,"scores","nonMaxSuppressionAsync"),p=Si(l,c,e,n,o,s);e=p.maxOutputSize,n=p.iouThreshold,o=p.scoreThreshold,s=p.softNmsSigma;let d=yield Promise.all([l.data(),c.data()]),f=d[0],h=d[1],{selectedIndices:m,selectedScores:g}=xI(f,h,e,n,o,s);return l!==r&&l.dispose(),c!==t&&c.dispose(),{selectedIndices:cr(m,"int32"),selectedScores:cr(g)}})}var RW=Tbe;function _be(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let i=E(r,"boxes","nonMaxSuppression"),a=E(t,"scores","nonMaxSuppression"),u=Si(i,a,e,n,o,null),l=u.maxOutputSize,c=u.iouThreshold,p=u.scoreThreshold,d={boxes:i,scores:a},f={maxOutputSize:l,iouThreshold:c,scoreThreshold:p,padToMaxOutputSize:s},h=R.runKernel(fg,d,f);return{selectedIndices:h[0],validOutputs:h[1]}}var OW=D({nonMaxSuppressionPadded_:_be});function Ebe(i,a,u){return L(this,arguments,function*(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let l=E(r,"boxes","nonMaxSuppressionAsync"),c=E(t,"scores","nonMaxSuppressionAsync"),p=Si(l,c,e,n,o,null),d=p.maxOutputSize,f=p.iouThreshold,h=p.scoreThreshold,[m,g]=yield Promise.all([l.data(),c.data()]),{selectedIndices:y,validOutputs:x}=yI(m,g,d,f,h,s);return l!==r&&l.dispose(),c!==t&&c.dispose(),{selectedIndices:cr(y,"int32"),validOutputs:we(x,"int32")}})}var MW=Ebe;function kbe(r,t,e=!1,n=!1){let o=E(r,"images","resizeBilinear");F(o.rank===3||o.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`),F(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),F(n===!1||e===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=V(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=t,a={images:s},u={alignCorners:e,halfPixelCenters:n,size:t},l=R.runKernel(ml,a,u);return i?V(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var vI=D({resizeBilinear_:kbe});function Nbe(r,t,e=!1,n=!1){let o=E(r,"images","resizeNearestNeighbor");F(o.rank===3||o.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`),F(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),F(o.dtype==="float32"||o.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),F(n===!1||e===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=V(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=t,a={images:s},u={alignCorners:e,halfPixelCenters:n,size:t},l=R.runKernel(hl,a,u);return i?V(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var bI=D({resizeNearestNeighbor_:Nbe});function Dbe(r,t="binary",e=!1,n=.5){let o=E(r,"image","threshold"),s=.2989,i=.587,a=.114,u=o.shape[0]*o.shape[1],l=B(cr([n]),255),c,p,d,f;if(F(o.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${o.rank}.`),F(o.shape[2]===3||o.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`),F(o.dtype==="int32"||o.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`),F(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),o.shape[2]===3){[c,p,d]=Tn(o,[1,1,1],-1);let g=B(c,s),y=B(p,i),x=B(d,a);f=re(re(g,y),x)}else f=r;if(t==="otsu"){let g=_S(le(Kg(f),"int32"),$n([]),256);l=Abe(g,u)}let h=e?ws(f,l):Gr(f,l);return le(B(h,255),"int32")}function Abe(r,t){let e=cr([-1]),n=cr([0]),o=cr([0]),s,i,a,u,l,c;for(let p=0;p<r.size-1;p++){s=Ue(r,0,p+1),i=Ue(r,p+1),l=me(Ie(s),t),c=me(Ie(i),t);let d=Ie(B(s,Pl(0,s.size)));a=me(d,Ie(s));let f=bi(i.shape,s.size),h=re(Pl(0,i.size),f),m=B(i,h);u=me(Ie(m),Ie(i));let g=xe(a,u),y=xe(a,u),x=B(l,c);o=B(B(x,g),y);let w=Gr(o,n);n=Cr(w,o,n),e=Cr(w,cr([p]),e)}return e}var FW=D({threshold_:Dbe});function Rbe(r,t,e="nearest",n="constant",o=0,s){let i=E(r,"image","transform","float32"),a=E(t,"transforms","transform","float32");F(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),F(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),F(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let u={image:i,transforms:a},l={interpolation:e,fillMode:n,fillValue:o,outputShape:s};return R.runKernel(bd,u,l)}var $W=D({transform_:Rbe});function Obe(r,t,e){let n=E(r,"a","bandPart");F(n.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${n.rank}.`);let o=n.shape,[s,i]=n.shape.slice(-2),a,u;typeof t=="number"?(F(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),F(t<=s,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`),a=E(t<0?s:t,"numLower","bandPart")):(F(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=Cr(Ac(t,0),s,rs(t,s))),typeof e=="number"?(F(e%1===0,()=>`bandPart(): numUpper must be an integer, got ${e}.`),F(e<=i,()=>`bandPart(): numUpper (${e}) must not be greater than the number of columns (${i}).`),u=E(e<0?i:e,"numUpper","bandPart")):(F(e.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=Cr(Ac(e,0),i,rs(e,i)));let l=V(Pl(0,s,1,"int32"),[-1,1]),c=Pl(0,i,1,"int32"),p=xe(l,c),d=ao(ws(p,a),$o(p,yt(u))),f=er([s,i],n.dtype);return V(Wr(_n(V(n,[-1,s,i])).map(h=>Cr(d,h,f))),o)}var PW=D({bandPart_:Obe});function Mbe(r){let t;if(Array.isArray(r)){t=!1,F(r!=null&&r.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let o=r[0].shape[0];for(let s=1;s<r.length;++s)F(r[s].shape[0]===o,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${r[s].shape[0]} vs. ${o})`)}else t=!0,r=Tn(r,r.shape[0],0).map(o=>Rt(o,[0]));F(r.length<=r[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${r.length}) exceeds number of dimensions (${r[0].shape[0]}).`);let e=[],n=r;for(let o=0;o<r.length;++o)e.push(R.tidy(()=>{let s=n[o];if(o>0)for(let i=0;i<o;++i){let a=B(Ie(B(e[i],s)),e[i]);s=xe(s,a)}return me(s,Dc(s,"euclidean"))}));return t?Wr(e,0):e}var LW=D({gramSchmidt_:Mbe});function Fbe(r,t=!1){if(F(r.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${r.rank}`),r.rank===2)return zW(r,t);{let e=r.shape.slice(0,r.shape.length-2).reduce((u,l)=>u*l),n=_n(V(r,[e,r.shape[r.shape.length-2],r.shape[r.shape.length-1]]),0),o=[],s=[];n.forEach(u=>{let[l,c]=zW(u,t);o.push(l),s.push(c)});let i=V(Wr(o,0),r.shape),a=V(Wr(s,0),r.shape);return[i,a]}}function zW(r,t=!1){return R.tidy(()=>{F(r.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${r.shape.length}D Tensor.`);let e=r.shape[0],n=r.shape[1],o=yh(e),s=Mo(r),i=So([[1]],[1,1]),a=Mo(i),u=e>=n?n:e;for(let l=0;l<u;++l){let c=s,p=a,d=o;[a,s,o]=R.tidy(()=>{let f=Ue(s,[l,l],[e-l,1]),h=Dc(f),m=Ue(s,[l,l],[1,1]),g=Cr(Gr(m,0),So([[-1]]),So([[1]])),y=xe(m,B(g,h)),x=me(f,y);x.shape[0]===1?a=Mo(i):a=Dt([i,Ue(x,[1,0],[x.shape[0]-1,x.shape[1]])],0);let w=yt(me(dt(g,y),h)),C=Ue(s,[l,0],[e-l,n]),I=B(w,a),N=ft(a);if(l===0)s=xe(C,dt(I,dt(N,C)));else{let $=xe(C,dt(I,dt(N,C)));s=Dt([Ue(s,[0,0],[l,n]),$],0)}let A=ft(I),O=Ue(o,[0,l],[e,o.shape[1]-l]);if(l===0)o=xe(O,dt(dt(O,a),A));else{let $=xe(O,dt(dt(O,a),A));o=Dt([Ue(o,[0,0],[e,l]),$],1)}return[a,s,o]}),$e([c,p,d])}return!t&&e>n&&(o=Ue(o,[0,0],[e,n]),s=Ue(s,[0,0],[n,n])),[o,s]})}var BW=D({qr_:Fbe});var gn=function(r){return r[r.NONE=0]="NONE",r[r.MEAN=1]="MEAN",r[r.SUM=2]="SUM",r[r.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",r}(gn||{});function $be(r,t,e=gn.SUM_BY_NONZERO_WEIGHTS){let n=E(r,"losses","computeWeightedLoss"),o=null;t!=null&&(o=E(t,"weights","computeWeightedLoss"));let s=o==null?n:B(n,o);if(e===gn.NONE)return s;if(e===gn.SUM)return Ie(s);if(e===gn.MEAN){if(o==null)return Ir(s);{let i=n.size/o.size,a=me(Ie(s),Ie(o));return i>1?me(a,we(i)):a}}if(e===gn.SUM_BY_NONZERO_WEIGHTS){if(o==null)return me(Ie(s),we(n.size));{let i=B(o,hn(n.shape)),a=le(Ie(Xa(i,we(0))),"float32");return me(Ie(s),a)}}throw Error(`Unknown reduction: ${e}`)}var uo=D({computeWeightedLoss_:$be});function Pbe(r,t,e,n=gn.SUM_BY_NONZERO_WEIGHTS){let o=E(r,"labels","absoluteDifference"),s=E(t,"predictions","absoluteDifference"),i=null;e!=null&&(i=E(e,"weights","absoluteDifference")),on(o.shape,s.shape,"Error in absoluteDifference: ");let a=Nr(xe(o,s));return uo(a,i,n)}var VW=D({absoluteDifference_:Pbe});function Lbe(r,t,e,n,o=gn.SUM_BY_NONZERO_WEIGHTS){let s=E(r,"labels","cosineDistance"),i=E(t,"predictions","cosineDistance"),a=null;n!=null&&(a=E(n,"weights","cosineDistance")),on(s.shape,i.shape,"Error in cosineDistance: ");let u=we(1),l=xe(u,Ie(B(s,i),e,!0));return uo(l,a,o)}var UW=D({cosineDistance_:Lbe});function zbe(r,t,e,n=gn.SUM_BY_NONZERO_WEIGHTS){let o=E(r,"labels","hingeLoss"),s=E(t,"predictions","hingeLoss"),i=null;e!=null&&(i=E(e,"weights","hingeLoss")),on(o.shape,s.shape,"Error in hingeLoss: ");let a=we(1);o=xe(B(we(2),o),a);let u=to(xe(a,B(o,s)));return uo(u,i,n)}var GW=D({hingeLoss_:zbe});function Bbe(r,t,e,n=1,o=gn.SUM_BY_NONZERO_WEIGHTS){let s=E(r,"labels","huberLoss"),i=E(t,"predictions","huberLoss"),a=null;e!=null&&(a=E(e,"weights","huberLoss")),on(s.shape,i.shape,"Error in huberLoss: ");let u=we(n),l=Nr(xe(i,s)),c=rs(l,u),p=xe(l,c),d=re(B(we(.5),at(c)),B(u,p));return uo(d,a,o)}var WW=D({huberLoss_:Bbe});function Vbe(r,t,e,n=1e-7,o=gn.SUM_BY_NONZERO_WEIGHTS){let s=E(r,"labels","logLoss"),i=E(t,"predictions","logLoss"),a=null;e!=null&&(a=E(e,"weights","logLoss")),on(s.shape,i.shape,"Error in logLoss: ");let u=we(1),l=we(n),c=yt(B(s,Bn(re(i,l)))),p=B(xe(u,s),Bn(re(xe(u,i),l))),d=xe(c,p);return uo(d,a,o)}var jW=D({logLoss_:Vbe});function Ube(r,t,e,n=gn.SUM_BY_NONZERO_WEIGHTS){let o=E(r,"labels","meanSquaredError"),s=E(t,"predictions","meanSquaredError"),i=null;e!=null&&(i=E(e,"weights","meanSquaredError")),on(o.shape,s.shape,"Error in meanSquaredError: ");let a=ny(o,s);return uo(a,i,n)}var HW=D({meanSquaredError_:Ube});function Gbe(r,t){let e=E(r,"labels","sigmoidCrossEntropyWithLogits"),n=E(t,"logits","sigmoidCrossEntropyWithLogits");on(e.shape,n.shape,"Error in sigmoidCrossEntropyWithLogits: ");let o=to(n),s=B(n,e),i=Od(Rr(yt(Nr(n))));return re(xe(o,s),i)}function Wbe(r,t,e,n=0,o=gn.SUM_BY_NONZERO_WEIGHTS){let s=E(r,"multiClassLabels","sigmoidCrossEntropy"),i=E(t,"logits","sigmoidCrossEntropy"),a=null;if(e!=null&&(a=E(e,"weights","sigmoidCrossEntropy")),on(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),n>0){let l=we(n),c=we(1),p=we(.5);s=re(B(s,xe(c,l)),B(p,l))}let u=Gbe(s,i);return uo(u,a,o)}var qW=D({sigmoidCrossEntropy_:Wbe});function jbe(r,t,e=-1){if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);return es((o,s,i)=>{let u=Md(s,[e],!0),l=xe(le(s,"float32"),u);i([o,l]);let c=yt(B(l,o));return{value:Ie(c,[e]),gradFunc:(f,h)=>{let[m,g]=h,y=wi(f.shape,[e]);return[B(V(f,y),xe(le(m,"float32"),Rr(g))),B(V(f,y),xe(Rr(g),le(m,"float32")))]}}})(r,t)}function Hbe(r,t,e,n=0,o=gn.SUM_BY_NONZERO_WEIGHTS){let s=E(r,"onehotLabels","softmaxCrossEntropy"),i=E(t,"logits","softmaxCrossEntropy"),a=null;if(e!=null&&(a=E(e,"weights","softmaxCrossEntropy")),on(s.shape,i.shape,"Error in softmaxCrossEntropy: "),n>0){let l=we(n),c=we(1),p=we(s.shape[1]);s=re(B(s,xe(c,l)),me(l,p))}let u=jbe(s,i);return uo(u,a,o)}var KW=D({softmaxCrossEntropy_:Hbe});function qbe(r,t,e,n){let o=E(r,"indices","sparseFillEmptyRows","int32"),s=E(t,"values","sparseFillEmptyRows"),i=E(e,"denseShape","sparseFillEmptyRows","int32"),a=E(n,"defaultValue","sparseFillEmptyRows",s.dtype);if(o.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${o.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);let u={indices:o,values:s,denseShape:i,defaultValue:a},l=R.runKernel(yg,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}var XW=D({sparseFillEmptyRows_:qbe});function Kbe(r,t,e){let n=E(r,"inputIndices","sparseReshape","int32"),o=E(t,"inputShape","sparseReshape","int32"),s=E(e,"newShape","sparseReshape","int32");if(n.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${n.shape}`);if(o.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${o.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:n,inputShape:o,newShape:s},a=R.runKernel(xg,i);return{outputIndices:a[0],outputShape:a[1]}}var YW=D({sparseReshape_:Kbe});function Xbe(r,t,e){let n=E(r,"data","sparseSegmentMean"),o=E(t,"indices","sparseSegmentMean","int32"),s=E(e,"segmentIds","sparseSegmentMean","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let i={data:n,indices:o,segmentIds:s};return R.runKernel(fd,i)}var ZW=D({sparseSegmentMean_:Xbe});function Ybe(r,t,e){let n=E(r,"data","sparseSegmentSum"),o=E(t,"indices","sparseSegmentSum","int32"),s=E(e,"segmentIds","sparseSegmentSum","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let i={data:n,indices:o,segmentIds:s};return R.runKernel(hd,i)}var QW=D({sparseSegmentSum_:Ybe});function Zbe(r,t,e,n,o,s,i,a){let u=E(r,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);let l=E(t,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let c={separator:e,nGramWidths:n,leftPad:o,rightPad:s,padWidth:i,preserveShortSequences:a},p={data:u,dataSplits:l},d=R.runKernel(xd,p,c);return{nGrams:d[0],nGramsSplits:d[1]}}var JW=D({stringNGrams_:Zbe});function Qbe(r,t,e=!0){let n=E(r,"input","stringSplit","string"),o=E(t,"delimiter","stringSplit","string");if(n.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${n.shape}`);if(o.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${o.shape}`);let s={skipEmpty:e},i={input:n,delimiter:o},a=R.runKernel(vg,i,s);return{indices:a[0],values:a[1],shape:a[2]}}var e4=D({stringSplit_:Qbe});function Jbe(r,t){let e=E(r,"input","stringToHashBucketFast","string"),n={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let o={input:e};return R.runKernel(bg,o,n)}var t4=D({stringToHashBucketFast_:Jbe});function ewe(r,t,e,n=!0){let o=E(r,"input","staticRegexReplace","string"),s={pattern:t,rewrite:e,replaceGlobal:n};return R.runKernel(rh,{x:o},s)}var r4=D({staticRegexReplace_:ewe});var twe={fft:Bd,ifft:Oc,rfft:Vd,irfft:ry},rwe={hammingWindow:bW,hannWindow:hI,frame:mI,stft:wW},yn={flipLeftRight:SW,grayscaleToRGB:IW,resizeNearestNeighbor:bI,resizeBilinear:vI,rgbToGrayscale:TW,rotateWithOffset:_W,cropAndResize:CW,nonMaxSuppression:EW,nonMaxSuppressionAsync:DW,nonMaxSuppressionWithScore:AW,nonMaxSuppressionWithScoreAsync:RW,nonMaxSuppressionPadded:OW,nonMaxSuppressionPaddedAsync:MW,threshold:FW,transform:$W},eO={bandPart:PW,gramSchmidt:LW,qr:BW},nwe={absoluteDifference:VW,computeWeightedLoss:uo,cosineDistance:UW,hingeLoss:GW,huberLoss:WW,logLoss:jW,meanSquaredError:HW,sigmoidCrossEntropy:qW,softmaxCrossEntropy:KW},owe={sparseFillEmptyRows:XW,sparseReshape:YW,sparseSegmentMean:ZW,sparseSegmentSum:QW},swe={stringNGrams:JW,stringSplit:e4,stringToHashBucketFast:t4,staticRegexReplace:r4};var ce={};ur(ce,{Serializable:()=>ob,SerializationMap:()=>wI,getRegisteredName:()=>awe,registerClass:()=>rO});var iwe=new Map,tO=new Map,ob=class{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}},wI=class r{constructor(){this.classNameMap={}}static getMap(){return r.instance==null&&(r.instance=new r),r.instance}static register(t){r.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function rO(r,t,e){F(r.className!=null,()=>"Class being registered does not have the static className property defined."),F(typeof r.className=="string",()=>"className is required to be a string, but got type "+typeof r.className),F(r.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof e>"u"&&(e=r.className);let n=e,o=t+">"+n;return wI.register(r),iwe.set(o,r),tO.set(r,o),r}function awe(r){return tO.has(r)?tO.get(r):r.className}var lo=class extends ob{minimize(t,e=!1,n){let{value:o,grads:s}=this.computeGradients(t,n);if(n!=null){let i=n.map(a=>({name:a.name,tensor:s[a.name]}));this.applyGradients(i)}else this.applyGradients(s);return $e(s),e?o:(o.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return W2(t,e)}dispose(){this.iterations_!=null&&$e(this.iterations_)}saveIterations(){return L(this,null,function*(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:we(this.iterations_,"int32")}})}getWeights(){return L(this,null,function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})}setWeights(t){return L(this,null,function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)})}extractIterations(t){return L(this,null,function*(){return this.iterations_=(yield t[0].tensor.data())[0],t.slice(1)})}};Object.defineProperty(lo,Symbol.hasInstance,{value:r=>r.minimize!=null&&r.computeGradients!=null&&r.applyGradients!=null});var ay=class extends lo{static get className(){return"Adadelta"}constructor(t,e,n=null){super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=R.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=R.registeredVariables[n],i=!1;this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${n}/accum_grad`,variable:X(()=>je(s).variable(i))}),this.accumulatedUpdates[o]==null&&(this.accumulatedUpdates[o]={originalName:`${n}/accum_var`,variable:X(()=>je(s).variable(i))});let a=Array.isArray(t)?t[o].tensor:t[n];if(a==null)return;let u=this.accumulatedGrads[o].variable,l=this.accumulatedUpdates[o].variable;X(()=>{let c=re(B(u,this.rho),B(at(a),1-this.rho)),p=B(me(lr(re(l,this.epsilon)),lr(re(u,this.epsilon))),a),d=re(B(l,this.rho),B(at(p),1-this.rho));u.assign(c),l.assign(d);let f=re(B(p,-this.learningRate),s);s.assign(f)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&($e(this.accumulatedGrads.map(t=>t.variable)),$e(this.accumulatedUpdates.map(t=>t.variable)))}getWeights(){return L(this,null,function*(){let t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[yield this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))})}setWeights(t){return L(this,null,function*(){t=yield this.extractIterations(t);let e=t.length/2,n=!1;this.accumulatedGrads=t.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedUpdates=t.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)}))})}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}};var uy=class extends lo{static get className(){return"Adagrad"}constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=R.registeredVariables[n];this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${n}/accumulator`,variable:X(()=>bi(s.shape,this.initialAccumulatorValue).variable(!1))});let i=Array.isArray(t)?t[o].tensor:t[n];if(i==null)return;let a=this.accumulatedGrads[o].variable;X(()=>{let u=re(a,at(i));a.assign(u);let l=re(B(me(i,lr(re(u,R.backend.epsilon()))),-this.learningRate),s);s.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&$e(this.accumulatedGrads.map(t=>t.variable))}getWeights(){return L(this,null,function*(){return[yield this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))})}setWeights(t){return L(this,null,function*(){t=yield this.extractIterations(t);let e=!1;this.accumulatedGrads=t.map(n=>({originalName:n.name,variable:n.tensor.variable(e)}))})}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}};var ly=class extends lo{static get className(){return"Adam"}constructor(t,e,n,o=null){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=o,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],X(()=>{this.accBeta1=we(e).variable(),this.accBeta2=we(n).variable()}),o==null&&(this.epsilon=R.backend.epsilon())}applyGradients(t){let e=Array.isArray(t)?t.map(n=>n.name):Object.keys(t);X(()=>{let n=xe(1,this.accBeta1),o=xe(1,this.accBeta2);e.forEach((s,i)=>{let a=R.registeredVariables[s],u=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:X(()=>je(a).variable(u))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${s}/v`,variable:X(()=>je(a).variable(u))});let l=Array.isArray(t)?t[i].tensor:t[s];if(l==null)return;let c=this.accumulatedFirstMoment[i].variable,p=this.accumulatedSecondMoment[i].variable,d=re(B(c,this.beta1),B(l,1-this.beta1)),f=re(B(p,this.beta2),B(at(l),1-this.beta2)),h=me(d,n),m=me(f,o);c.assign(d),p.assign(f);let g=re(B(me(h,re(lr(m),this.epsilon)),-this.learningRate),a);a.assign(g)}),this.accBeta1.assign(B(this.accBeta1,this.beta1)),this.accBeta2.assign(B(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&$e(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&$e(this.accumulatedSecondMoment.map(t=>t.variable))}getWeights(){return L(this,null,function*(){let t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[yield this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))})}setWeights(t){return L(this,null,function*(){t=yield this.extractIterations(t),X(()=>{this.accBeta1.assign(io(this.beta1,this.iterations_+1)),this.accBeta2.assign(io(this.beta2,this.iterations_+1))});let e=t.length/2,n=!1;this.accumulatedFirstMoment=t.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedSecondMoment=t.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)}))})}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}};var cy=class extends lo{static get className(){return"Adamax"}constructor(t,e,n,o=null,s=0){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=o,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],X(()=>{this.iteration=we(0).variable(),this.accBeta1=we(e).variable()}),o==null&&(this.epsilon=R.backend.epsilon())}applyGradients(t){let e=Array.isArray(t)?t.map(n=>n.name):Object.keys(t);X(()=>{let n=xe(1,this.accBeta1),o=me(-this.learningRate,re(B(this.iteration,this.decay),1));e.forEach((s,i)=>{let a=R.registeredVariables[s],u=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:je(a).variable(u)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${s}/v`,variable:je(a).variable(u)});let l=Array.isArray(t)?t[i].tensor:t[s];if(l==null)return;let c=this.accumulatedFirstMoment[i].variable,p=this.accumulatedWeightedInfNorm[i].variable,d=re(B(c,this.beta1),B(l,1-this.beta1)),f=B(p,this.beta2),h=Nr(l),m=ts(f,h);c.assign(d),p.assign(m);let g=re(B(me(o,n),me(d,re(m,this.epsilon))),a);a.assign(g)}),this.iteration.assign(re(this.iteration,1)),this.accBeta1.assign(B(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&$e(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&$e(this.accumulatedWeightedInfNorm.map(t=>t.variable))}getWeights(){return L(this,null,function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})}setWeights(t){return L(this,null,function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}};var Gd=class extends lo{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=Array.isArray(t)?t[o].tensor:t[n];if(s==null)return;let i=R.registeredVariables[n];X(()=>{let a=re(B(this.c,s),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=Ar(we(-t))}dispose(){this.c.dispose()}getWeights(){return L(this,null,function*(){return[yield this.saveIterations()]})}setWeights(t){return L(this,null,function*(){if(t=yield this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")})}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}};var py=class extends Gd{static get className(){return"Momentum"}constructor(t,e,n=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=we(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=R.registeredVariables[n];this.accumulations[o]==null&&(this.accumulations[o]={originalName:`${n}/momentum`,variable:X(()=>je(s).variable(!1))});let i=this.accumulations[o].variable,a=Array.isArray(t)?t[o].tensor:t[n];a!=null&&X(()=>{let u,l=re(B(this.m,i),a);this.useNesterov?u=re(B(this.c,re(a,B(l,this.m))),s):u=re(B(this.c,l),s),i.assign(l),s.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&$e(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}getWeights(){return L(this,null,function*(){return[yield this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))})}setWeights(t){return L(this,null,function*(){t=yield this.extractIterations(t);let e=!1;this.accumulations=t.map(n=>({originalName:n.name,variable:n.tensor.variable(e)}))})}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}};var dy=class extends lo{static get className(){return"RMSProp"}constructor(t,e=.9,n=0,o=null,s=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=o,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,o==null&&(this.epsilon=R.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=R.registeredVariables[n],i=!1;this.accumulatedMeanSquares[o]==null&&(this.accumulatedMeanSquares[o]={originalName:`${n}/rms`,variable:X(()=>je(s).variable(i))}),this.accumulatedMoments[o]==null&&(this.accumulatedMoments[o]={originalName:`${n}/momentum`,variable:X(()=>je(s).variable(i))}),this.accumulatedMeanGrads[o]==null&&this.centered&&(this.accumulatedMeanGrads[o]={originalName:`${n}/mg`,variable:X(()=>je(s).variable(i))});let a=Array.isArray(t)?t[o].tensor:t[n];if(a==null)return;let u=this.accumulatedMeanSquares[o].variable,l=this.accumulatedMoments[o].variable;X(()=>{let c=re(B(u,this.decay),B(at(a),1-this.decay));if(this.centered){let p=this.accumulatedMeanGrads[o].variable,d=re(B(p,this.decay),B(a,1-this.decay)),f=me(B(a,this.learningRate),lr(xe(c,re(at(d),this.epsilon)))),h=re(B(l,this.momentum),f);u.assign(c),p.assign(d),l.assign(h);let m=xe(s,h);s.assign(m)}else{let p=re(B(u,this.decay),B(at(a),1-this.decay)),d=re(B(l,this.momentum),me(B(a,this.learningRate),lr(re(p,this.epsilon))));u.assign(p),l.assign(d);let f=xe(s,d);s.assign(f)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&$e(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&$e(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&$e(this.accumulatedMoments.map(t=>t.variable))}getWeights(){return L(this,null,function*(){let t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[yield this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))})}setWeights(t){return L(this,null,function*(){t=yield this.extractIterations(t);let e=this.centered?t.length/3:t.length/2,n=!1;this.accumulatedMeanSquares=t.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedMoments=t.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=t.slice(e*2,e*3).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})))})}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}};var uwe=[ay,uy,ly,cy,py,dy,Gd];function n4(){for(let r of uwe)rO(r)}var Ya={};ur(Ya,{CompositeArrayBuffer:()=>so,browserFiles:()=>s4,browserHTTPRequest:()=>c4,concatenateArrayBuffers:()=>HU,copyModel:()=>iG,decodeWeights:()=>aS,decodeWeightsStream:()=>uS,encodeWeights:()=>UU,fromMemory:()=>p4,fromMemorySync:()=>lO,getLoadHandlers:()=>YU,getModelArtifactsForJSON:()=>Ag,getModelArtifactsForJSONSync:()=>D2,getModelArtifactsInfoForJSON:()=>Nl,getSaveHandlers:()=>XU,getWeightSpecs:()=>Kv,http:()=>SI,isHTTPScheme:()=>CI,listModels:()=>oG,loadWeights:()=>a4,moveModel:()=>aG,registerLoadRouter:()=>KU,registerSaveRouter:()=>qU,removeModel:()=>sG,weightsLoaderFactory:()=>aO,withSaveHandler:()=>d4,withSaveHandlerSync:()=>f4});var lwe="model",cwe=".json",pwe=".weights.bin";function o4(r){return new Promise(t=>setTimeout(t)).then(r)}var nO=(()=>{class r{constructor(e){if(!j().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(r.URL_SCHEME)&&(e=e.slice(r.URL_SCHEME.length)),(e==null||e.length===0)&&(e=lwe),this.modelJsonFileName=e+cwe,this.weightDataFileName=e+pwe}save(e){return L(this,null,function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let n=so.join(e.weightData),o=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let s=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],i=lS(e,s),a=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),u=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(u.download=this.modelJsonFileName,u.href=a,yield o4(()=>u.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){let l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=o,yield o4(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Nl(e)}}})}}return r.URL_SCHEME="downloads://",r})();var oO=class{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}load(){return L(this,null,function*(){return new Promise((t,e)=>{let n=new FileReader;n.onload=o=>{let s=JSON.parse(o.target.result),i=s.modelTopology;if(i==null){e(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){e(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){t({modelTopology:i});return}let u=Ag(s,l=>this.loadWeights(l));t(u)},n.onerror=o=>e(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})})}loadWeights(t){let e=[],n=[];for(let i of t)e.push(...i.weights),n.push(...i.paths);let o=this.checkManifestAndWeightFiles(t),s=n.map(i=>this.loadWeightsFile(i,o[i]));return Promise.all(s).then(i=>[e,i])}loadWeightsFile(t,e){return new Promise((n,o)=>{let s=new FileReader;s.onload=i=>{let a=i.target.result;n(a)},s.onerror=i=>o(`Failed to weights data from file of path '${t}'.`),s.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){let e=[],n=this.weightsFiles.map(s=>N2(s.name)),o={};for(let s of t)s.paths.forEach(i=>{let a=N2(i);if(e.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(e.push(a),n.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);o[i]=this.weightsFiles[n.indexOf(a)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return o}},dwe=r=>j().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(nO.URL_SCHEME)?fwe(r.slice(nO.URL_SCHEME.length)):null;Ln.registerSaveRouter(dwe);function fwe(r="model"){return new nO(r)}function s4(r){return new oO(r)}function sO(r,t,e,n){i(r),e=e??0,n=n??1,a(e,n);let o=0,s=u=>(u.then(l=>{let c=e+ ++o/r.length*(n-e);return t(c),l}),u);function i(u){F(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function a(u,l){F(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),F(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),F(l>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${l}`)}return Promise.all(r.map(s))}function iO(r,t){return L(this,null,function*(){t==null&&(t={});let e=t.fetchFunc==null?j().platform.fetch:t.fetchFunc,n=r.map(p=>e(p,t.requestInit,{isBinary:!0})),a=(t.onProgress==null?yield Promise.all(n):yield sO(n,t.onProgress,0,.5)).map(p=>p.arrayBuffer());return t.onProgress==null?yield Promise.all(a):yield sO(a,t.onProgress,.5,1)})}function i4(r,t){var e;let n=t.fetchFunc==null?j().platform.fetch:t.fetchFunc,o=0,s;return(e=t.onProgress)===null||e===void 0||e.call(t,0),new ReadableStream({pull:i=>L(this,null,function*(){for(var a;o<r.length;){s||(s=(yield n(r[o],t.requestInit,{isBinary:!0})).body.getReader());let{done:u,value:l}=yield s.read();if(u){o++,s=void 0,(a=t.onProgress)===null||a===void 0||a.call(t,o/r.length);continue}i.enqueue(l);return}i.close()})})}function a4(r,t="",e,n){return L(this,null,function*(){return aO(i=>iO(i,{requestInit:n}))(r,t,e)})}function aO(r){return(t,e="",n)=>L(this,null,function*(){let o=t.map(()=>!1),s={},i=n!=null?n.map(()=>!1):[],a=[];if(t.forEach((f,h)=>{let m=0;f.weights.forEach(g=>{let y="quantization"in g?g.quantization.dtype:g.dtype,x=Ec[y]*bt(g.shape),w=()=>{o[h]=!0,s[h]==null&&(s[h]=[]),s[h].push({manifestEntry:g,groupOffset:m,sizeBytes:x})};n!=null?n.forEach((C,I)=>{C===g.name&&(w(),i[I]=!0)}):w(),a.push(g.name),m+=x})}),!i.every(f=>f)){let f=n.filter((h,m)=>!i[m]);throw new Error(`Could not find weights in manifest with names: ${f.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}let u=o.reduce((f,h,m)=>(h&&f.push(m),f),[]),l=[];u.forEach(f=>{t[f].paths.forEach(h=>{let m=e+(e.endsWith("/")?"":"/")+h;l.push(m)})});let c=yield r(l),p={},d=0;return u.forEach(f=>{let h=t[f].paths.length,m=new so(c.slice(d,d+h));s[f].forEach(y=>{let x=m.slice(y.groupOffset,y.groupOffset+y.sizeBytes),w=aS(x,[y.manifestEntry]);for(let C in w)p[C]=w[C]}),d+=h}),p})}var hwe="application/octet-stream",mwe="application/json",u4=(()=>{class r{constructor(e,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(F(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=j().platform.fetch,F(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&F(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{},this.loadOptions=n}save(e){return L(this,null,function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;let o=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=lS(e,o);if(n.body.append("model.json",new Blob([JSON.stringify(s)],{type:mwe}),"model.json"),e.weightData!=null){let a=so.join(e.weightData);n.body.append("model.weights.bin",new Blob([a],{type:hwe}),"model.weights.bin")}let i=yield this.fetch(this.path,n);if(i.ok)return{modelArtifactsInfo:Nl(e),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)})}loadModelJSON(){return L(this,null,function*(){let e=yield this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=yield e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}let o=n.modelTopology,s=n.weightsManifest;if(o==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return n})}load(){return L(this,null,function*(){if(this.loadOptions.streamWeights)return this.loadStream();let e=yield this.loadModelJSON();return Ag(e,n=>this.loadWeights(n))})}loadStream(){return L(this,null,function*(){let e=yield this.loadModelJSON(),n=yield this.getWeightUrls(e.weightsManifest),o=Kv(e.weightsManifest),s=()=>i4(n,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:o,getWeightStream:s})})}getWeightUrls(e){return L(this,null,function*(){let n=Array.isArray(this.path)?this.path[1]:this.path,[o,s]=gwe(n),i=this.weightPathPrefix||o,a=[],u=[];for(let l of e)for(let c of l.paths)this.weightUrlConverter!=null?u.push(this.weightUrlConverter(c)):a.push(i+c+s);return this.weightUrlConverter&&a.push(...yield Promise.all(u)),a})}loadWeights(e){return L(this,null,function*(){let n=yield this.getWeightUrls(e),o=Kv(e),s=yield iO(n,this.loadOptions);return[o,s]})}}return r.URL_SCHEME_REGEX=/^https?:\/\//,r})();function gwe(r){let t=r.lastIndexOf("/"),e=r.lastIndexOf("?"),n=r.substring(0,t),o=e>t?r.substring(e):"";return[n+"/",o]}function CI(r){return r.match(u4.URL_SCHEME_REGEX)!=null}var l4=(r,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let e=!0;if(Array.isArray(r)?e=r.every(n=>CI(n)):e=CI(r),e)return SI(r,t)}return null};Ln.registerSaveRouter(l4);Ln.registerLoadRouter(l4);function SI(r,t){return new u4(r,t)}function c4(r,t){return SI(r,t)}var sb=class{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}},II=class{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}},uO=class{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}};function p4(r,t,e,n){let o=arguments;return new uO(lO(...o))}function lO(r,t,e,n){return arguments.length===1?r.modelTopology!=null||r.weightSpecs!=null?new sb(r):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new sb({modelTopology:r})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new sb({modelTopology:r,weightSpecs:t,weightData:e,trainingConfig:n}))}function d4(r){return new II(r)}function f4(r){return new II(r)}var Mc={};ur(Mc,{draw:()=>Iwe,fromPixels:()=>Twe,fromPixelsAsync:()=>wwe,toPixels:()=>Swe});var kh,h4=!1;function m4(r,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,n=!1,o=!1,s=!1,i=!1,a=!1;if(r.data instanceof Uint8Array)e=!0;else if(typeof ImageData<"u"&&r instanceof ImageData)n=!0;else if(typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement)o=!0;else if(typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement)s=!0;else if(r.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&r instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${r.constructor.name}`);if(Cg(nh,R.backendName)!=null){let h={pixels:r},m={numChannels:t};return R.runKernel(nh,h,m)}let[l,c]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],p;if(i)p=r.getContext("2d").getImageData(0,0,l,c).data;else if(n||e)p=r.data;else if(s||o||a){if(kh==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")kh=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else kh=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});kh.canvas.width=l,kh.canvas.height=c,kh.drawImage(r,0,0,l,c),p=kh.getImageData(0,0,l,c).data}let d;if(t===4)d=new Int32Array(p);else{let h=l*c;d=new Int32Array(h*t);for(let m=0;m<h;m++)for(let g=0;g<t;++g)d[m*t+g]=p[m*4+g]}return iI(d,[c,l,t],"int32")}function ywe(r){return r!=null&&r.data instanceof Uint8Array}function xwe(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function vwe(r){return r!=null&&r.width!==0&&r.height!==0}function bwe(r){return xwe()&&!(r instanceof ImageBitmap)&&vwe(r)&&!ywe(r)}function wwe(r,t=3){return L(this,null,function*(){let e=null;if(j().getBool("WRAP_TO_IMAGEBITMAP")&&bwe(r)){let n;try{n=yield createImageBitmap(r,{premultiplyAlpha:"none"})}catch{n=null}n!=null&&n.width===r.width&&n.height===r.height?e=n:e=r}else e=r;return m4(e,t)})}function g4(r){if(r.rank!==2&&r.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${r.rank}.`);let t=r.rank===2?1:r.shape[2];if(t>4||t===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if(r.dtype!=="float32"&&r.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${r.dtype}. Please use float32 or int32 tensors.`)}function Cwe(r){let t=r?.alpha||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}function Swe(r,t){return L(this,null,function*(){let e=E(r,"img","toPixels");if(!(r instanceof ct)){let l=e;e=le(l,"int32"),l.dispose()}g4(e);let[n,o]=e.shape.slice(0,2),s=e.rank===2?1:e.shape[2],i=yield e.data(),a=e.dtype==="float32"?255:1,u=new Uint8ClampedArray(o*n*4);for(let l=0;l<n*o;++l){let c=[0,0,0,255];for(let d=0;d<s;d++){let f=i[l*s+d];if(e.dtype==="float32"){if(f<0||f>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${f}.`)}else if(e.dtype==="int32"&&(f<0||f>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${f}.`);s===1?(c[0]=f*a,c[1]=f*a,c[2]=f*a):c[d]=f*a}let p=l*4;u[p+0]=Math.round(c[0]),u[p+1]=Math.round(c[1]),u[p+2]=Math.round(c[2]),u[p+3]=Math.round(c[3])}if(t!=null){h4||Cg(th,R.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),h4=!0),t.width=o,t.height=n;let l=t.getContext("2d"),c=new ImageData(u,o,n);l.putImageData(c,0,0)}return e!==r&&e.dispose(),u})}function Iwe(r,t,e){let n=E(r,"img","draw");if(!(r instanceof ct)){let i=n;n=le(i,"int32"),i.dispose()}g4(n),Cwe(e?.imageOptions);let o={image:n},s={canvas:t,options:e};R.runKernel(th,o,s)}var Twe=D({fromPixels_:m4});function _we(r,t){let e=r.shape.length,n=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(n<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[n-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[n-1]} vs. ${e}`);if(bt(r.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${r.shape}.`);let o=t.shape,s=o[o.length-1],i=1;for(let p=0;p<o.length-1;++p)i*=o[p];let a=r.shape,u=o.slice();u.pop();let l=1;for(let p=s;p<e;++p)l*=a[p],u.push(a[p]);let c=[...Ru(r.shape).map(p=>p/l),1].slice(0,s);return[u,i,l,c]}var en={};ur(en,{assertParamsValid:()=>kwe,computeFlatOffset:()=>Owe,computeOutShape:()=>Dwe,getNormalizedAxes:()=>Awe,isSliceContinous:()=>Rwe,maskToAxes:()=>Nwe,parseSliceParams:()=>pO,sliceInfo:()=>Mwe,startForAxis:()=>I4,startIndicesWithElidedDims:()=>w4,stopForAxis:()=>T4,stopIndicesWithElidedDims:()=>C4,stridesForAxis:()=>S4,stridesWithElidedDims:()=>x4});var cO=-2,Ewe=-1;function kwe(r,t,e){let n=r.shape.length;F(n===t.length,()=>`Error in slice${n}D: Length of begin ${t} must match the rank of the array (${n}).`),F(n===e.length,()=>`Error in slice${n}D: Length of size ${e} must match the rank of the array (${n}).`);for(let o=0;o<n;++o)F(t[o]+e[o]<=r.shape[o],()=>`Error in slice${n}D: begin[${o}] + size[${o}] (${t[o]+e[o]}) would overflow input.shape[${o}] (${r.shape[o]})`)}function Nwe(r){let t=[],e=0;for(;r>0;)r&1&&t.push(e),r/=2,e++;return t}function Dwe(r,t,e){let n=[];for(let o=0;o<r.length;o++)n[o]=Math.ceil((t[o]-r[o])/e[o]);return n}function x4(r,t,e,n){let o=[...r];for(let s=o.length;s<n.length;s++)o.push(1);for(let s=0;s<e;s++)s===0?o[t]=1:(o.splice(t,0,1),o.pop());return o}function v4(r,t,e){return e<=r?e:e-(t-1)}function b4(r,t){let e=[];for(let n=0;n<r;n++)e.push(t+n);return e}function Awe(r,t,e,n,o,s,i,a,u){let l=r.length,c=new Array(l),p=new Array(l),d=new Array(l);if(t.length&&e>0){let f=t[0],h=e+1;c=w4(i,f,h,n,r),p=C4(a,f,h,o,r),d=x4(s,f,h,r)}else for(let f=0;f<l;f++)c[f]=I4(i,n,s,r,f,u),p[f]=T4(a,o,s,r,f,u),d[f]=S4(s,f,u);return{begin:c,end:p,strides:d}}function w4(r,t,e,n,o){let s=[...o],i=b4(e,t);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=0;else{let u=v4(t,e,a),l=n[u];r&1<<u&&(l=0),s[a]=l}return s}function C4(r,t,e,n,o){let s=[...o],i=b4(e,t);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{let u=v4(t,e,a),l=n[u];r&1<<u&&(l=Number.MAX_SAFE_INTEGER),s[a]=l}for(let a=0;a<s.length;a++){let u=o[a];s[a]<0&&(s[a]+=u),s[a]=ag(0,s[a],o[a])}return s}function S4(r,t,e){let n=r[t];return(e&1<<t||n==null)&&(n=1),n}function I4(r,t,e,n,o,s){let i=t[o],a=e[o]||1;(r&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let u=n[o];return i<0&&(i+=u),i=ag(0,i,u-1),i}function T4(r,t,e,n,o,s){let i=t[o],a=e[o]||1;(r&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let u=n[o];return i<0&&(i+=u),a>0?i=ag(0,i,u):i=ag(-1,i,u-1),i}function Rwe(r,t,e){let n=e.length;for(let o=0;o<e.length;o++)if(e[o]>1){n=o;break}for(let o=n+1;o<e.length;o++)if(t[o]>0||e[o]!==r[o])return!1;return!0}function Owe(r,t){let e=r.length>0?r[r.length-1]:1;for(let n=0;n<r.length-1;n++)e+=r[n]*t[n];return e}function pO(r,t,e){let n,o=r.shape.length;typeof t=="number"?n=[t,...new Array(o-1).fill(0)]:t.length<o?n=t.concat(new Array(o-t.length).fill(0)):n=t.slice(),n.forEach(i=>{F(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return e==null?s=new Array(o).fill(-1):typeof e=="number"?s=[e,...new Array(o-1).fill(-1)]:e.length<o?s=e.concat(new Array(o-e.length).fill(-1)):s=e,s=s.map((i,a)=>i>=0?i:(F(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),r.shape[a]-n[a])),[n,s]}function Mwe(r,t,e,n,o,s,i,a,u){let l;if(n==null?(l=new Array(t.length),l.fill(1)):l=n,i!=null&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1,p={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:l.slice(),beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u};for(let w=0;w<p.dims;w++)c&&1<<w&a&&p.numAddAxisAfterEllipsis++,1<<w&i&&(c=!0);c||(p.ellipsisMask|=1<<p.dims,p.dims++);let d={dims:r.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Fwe(p,d);let f=!0,h=!0,m=!0,g=[],y=[];for(let w=0;w<r.length;++w){if(d.strides[w]===0)throw Error(`strides[${w}] must be non-zero`);let C=!!(d.shrinkAxisMask&1<<w),I=r[w];if(I===-1){g.push(C?1:-1);continue}let N=[d.beginMask&1<<w,d.endMask&1<<w],A=[d.strides[w]>0?0:-1,d.strides[w]>0?I:I-1];if(C&&d.strides[w]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&d.strides[w]===1;let O=!!(d.beginMask&1<<w&&d.endMask&1<<w);if(d.beginValid&&d.endValid){if(C){let K=d.begin[w]<0?I+d.begin[w]:d.begin[w];if(d.begin[w]=K,d.end[w]=d.begin[w]+1,K<0||K>=I)throw Error(`slice index ${d.begin[w]} of dimension ${w} out of bounds.`)}else d.begin[w]=y4(d.begin[w],0,d.strides[w],I,N,A),d.end[w]=y4(d.end[w],1,d.strides[w],I,N,A);let G=d.strides[w]===1&&d.begin[w]===0&&d.end[w]===I;f=f&&G,h=h&&(w===0&&d.strides[w]===1||G)}else f=f&&d.strides[w]===1&&O,h=h&&(w===0&&d.strides[w]===1||O);let $,z=!1;if(d.beginValid&&d.endValid?($=d.end[w]-d.begin[w],z=!0):C?($=1,z=!0):O&&I>=0&&(d.strides[w]<0?$=-I:$=I,z=!0),z){let G;$===0||$<0!=d.strides[w]<0?G=0:G=Math.trunc($/d.strides[w])+($%d.strides[w]!==0?1:0),g.push(G)}else g.push(-1)}for(let w=0;w<d.finalShapeGatherIndices.length;++w){let C=d.finalShapeGatherIndices[w];C>=0?y.push(g[C]):C===cO&&y.push(1)}return{finalShapeSparse:y.filter((w,C)=>d.finalShapeGatherIndices[C]!==cO),finalShape:y,isIdentity:f,sliceDim0:h,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function Fwe(r,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=r.begin!=null,t.endValid=r.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let n=0;n<r.dims;n++)if(1<<n&r.ellipsisMask){let o=Math.min(t.dims-(r.dims-n)+1+r.numAddAxisAfterEllipsis,t.dims);for(;e<o;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=n}else if(1<<n&r.newAxisMask)t.finalShapeGatherIndices.push(cO),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);r.begin!=null&&(t.begin[e]=r.begin[n]),r.end!=null&&(t.end[e]=r.end[n]),t.strides[e]=r.strides[n],r.beginMask&1<<n&&(t.beginMask|=1<<e),r.endMask&1<<n&&(t.endMask|=1<<e),r.shrinkAxisMask&1<<n?(t.finalShapeGatherIndices.push(Ewe),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(n)),t.inputShapeGatherIndicesSparse[e]=n,e++}}function y4(r,t,e,n,o,s){if(o[t])return e>0?s[t]:s[t+1&1];{let i=r<0?n+r:r;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var TI=class{static sgd(t){return new Gd(t)}static momentum(t,e,n=!1){return new py(t,e,n)}static rmsprop(t,e=.9,n=0,o=null,s=!1){return new dy(t,e,n,o,s)}static adam(t=.001,e=.9,n=.999,o=null){return new ly(t,e,n,o)}static adadelta(t=.001,e=.95,n=null){return new ay(t,e,n)}static adamax(t=.002,e=.9,n=.999,o=null,s=0){return new cy(t,e,n,o,s)}static adagrad(t,e=.1){return new uy(t,e)}};var Nh=TI;var $we=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:r=>r();function ib(){return new Promise(r=>$we(()=>r()))}var T={};ur(T,{ERF_A1:()=>Zwe,ERF_A2:()=>Qwe,ERF_A3:()=>Jwe,ERF_A4:()=>eCe,ERF_A5:()=>tCe,ERF_P:()=>Ywe,PARALLELIZE_THRESHOLD:()=>_I,RowPartitionType:()=>Fc,SELU_SCALE:()=>fO,SELU_SCALEALPHA:()=>dO,applyActivation:()=>_h,assertAndGetBroadcastShape:()=>st,assertAxesAreInnerMostDims:()=>Eye,assertParamsConsistent:()=>Pwe,assignToTypedArray:()=>aCe,axesAreInnerMostDims:()=>B2,calculateShapes:()=>Ove,checkEinsumDimSizes:()=>fCe,checkPadOnDimRoundingMode:()=>wr,combineLocations:()=>wG,combineRaggedTensorToTensorShapes:()=>zwe,complexWithEvenIndex:()=>oCe,complexWithOddIndex:()=>sCe,computeConv2DInfo:()=>mh,computeConv3DInfo:()=>dG,computeDefaultPad:()=>z2,computeDilation2DInfo:()=>_ge,computeOptimalWindowSize:()=>Gwe,computeOutAndReduceShapes:()=>V2,computeOutShape:()=>Lwe,computePool2DInfo:()=>L2,computePool3DInfo:()=>Ege,convertConv2DDataFormat:()=>fG,decodeEinsumEquation:()=>pCe,eitherStridesOrDilationsAreOne:()=>Jn,expandShapeToKeepDim:()=>wi,exponent:()=>lCe,exponents:()=>uCe,fromStringArrayToUint8:()=>MCe,fromUint8ToStringArray:()=>OCe,getAxesPermutation:()=>U2,getBroadcastDims:()=>vG,getComplexWithIndex:()=>iCe,getEinsumComputePath:()=>hCe,getEinsumPermutation:()=>dCe,getFusedBiasGradient:()=>Th,getFusedDyActivation:()=>Ih,getImageCenter:()=>Wwe,getInnerMostAxes:()=>kye,getPermuted:()=>Hwe,getRaggedRank:()=>Vwe,getReductionAxes:()=>gr,getReshaped:()=>jwe,getReshapedPermuted:()=>qwe,getRowPartitionTypesHelper:()=>Bwe,getSliceBeginCoords:()=>Kwe,getSliceSize:()=>Xwe,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>xCe,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>vCe,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>bCe,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>SCe,getSparseReshapeInputOutputMismatchErrorMessage:()=>TCe,getSparseReshapeInputOutputMultipleErrorMessage:()=>ICe,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>wCe,getSparseReshapeNegativeOutputDimErrorMessage:()=>CCe,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>NCe,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>_Ce,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>ECe,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>kCe,getUndoAxesPermutation:()=>Qv,isIdentityPermutation:()=>mCe,log:()=>yme,mergeRealAndImagArrays:()=>rCe,prepareAndValidate:()=>_we,prepareSplitSize:()=>yCe,segment_util:()=>mO,shouldFuse:()=>Eh,slice_util:()=>en,splitRealAndImagArrays:()=>nCe,stridesOrDilationsArePositive:()=>Dl,tupleValuesAreOne:()=>Hs,upcastType:()=>mr,validateDefaultValueShape:()=>Uwe,validateInput:()=>rb,validateUpdateShape:()=>pW,warn:()=>_l});function Pwe(r,t){let e=r[0].length;r.forEach((o,s)=>{F(o.length===e,()=>`Error in concat${e}D: rank of tensors[${s}] must be the same as the rank of the rest (${e})`)}),F(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);let n=r[0];r.forEach((o,s)=>{for(let i=0;i<e;i++)F(i===t||o[i]===n[i],()=>`Error in concat${e}D: Shape of tensors[${s}] (${o}) does not match the shape of the rest (${n}) along the non-concatenated axis ${s}.`)})}function Lwe(r,t){let e=r[0].slice();for(let n=1;n<r.length;n++)e[t]+=r[n][t];return e}var Fc=function(r){return r[r.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",r[r.VALUE_ROWIDS=1]="VALUE_ROWIDS",r[r.ROW_LENGTHS=2]="ROW_LENGTHS",r[r.ROW_SPLITS=3]="ROW_SPLITS",r[r.ROW_LIMITS=4]="ROW_LIMITS",r[r.ROW_STARTS=5]="ROW_STARTS",r}(Fc||{});function zwe(r,t,e){let n=new Array;if(e==null&&t==null)return n;if(t==null)for(;n.length<r+e.length;)n.push(-1);else n=t.slice();if(e==null)return n;if(r+e.length!==n.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${r+e.length}, but shape.rank = ${n.length}`);for(let o=1;o<e.length;++o){let s=e[o],i=n[n.length-e.length+o],a=n[i];if(s>=0)if(a>=0){if(a!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${o+r}] = ${s} but shape[${o+r}] = ${a}`)}else n[i]=s}return n}function Bwe(r){let t={FIRST_DIM_SIZE:Fc.FIRST_DIM_SIZE,VALUE_ROWIDS:Fc.VALUE_ROWIDS,ROW_LENGTHS:Fc.ROW_LENGTHS,ROW_SPLITS:Fc.ROW_SPLITS,ROW_LIMITS:Fc.ROW_LIMITS,ROW_STARTS:Fc.ROW_STARTS},e=[];for(let n of r)if(n in t)e.push(t[n]);else break;return e}function Vwe(r){return r.length===0?0:r[0]===Fc.FIRST_DIM_SIZE?r.length-1:r.length}function Uwe(r,t){if(r==null||t==null)return;let e=r.length,n=t.length;if(e>=n)throw new Error(`defaultValue.shape=${r} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${n})`);for(let o=0;o<Math.min(e,n-1);++o){let s=r[o],i=t[o+1];if(s>=0&&i>=0&&s!==1&&s!==i)throw new Error(`defaultValue.shape=${r}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${o-r.length}] = ${s} but ragged tensor input.flatValues.shape[${o-r.length}] = ${i}`)}}var _I=30;function Gwe(r){return r<=_I?r:pg(r,Math.floor(Math.sqrt(r)))}function Wwe(r,t,e){let n=e*(typeof r=="number"?r:r[0]),o=t*(typeof r=="number"?r:r[1]);return[n,o]}function jwe(r,t,e,n=!0){let o=[];if(n)o=o.concat(t.slice(0)),o.push(r[0]/e),o=o.concat(r.slice(1));else{o=o.concat(r[0]);let s=t.length;for(let i=0;i<s;++i)o=o.concat([r[i+1]/t[i],t[i]]);o=o.concat(r.slice(s+1))}return o}function Hwe(r,t,e=!0){let n=[];if(e){n.push(t);for(let o=t+1;o<r;++o)o<=2*t?(n.push(o),n.push(o-(t+1))):n.push(o)}else{let o=[],s=[];for(let i=1;i<r;++i)i>=t*2+1||i%2===1?s.push(i):o.push(i);n.push(...o),n.push(0),n.push(...s)}return n}function qwe(r,t,e,n=!0){let o=[];n?o.push(r[0]/e):o.push(r[0]*e);for(let s=1;s<r.length;++s)s<=t.length?n?o.push(t[s-1]*r[s]):o.push(r[s]/t[s-1]):o.push(r[s]);return o}function Kwe(r,t){let e=[0];for(let n=0;n<t;++n)e.push(r[n][0]);return e}function Xwe(r,t,e){let n=r.slice(0,1);for(let o=0;o<e;++o)n.push(r[o+1]-t[o][0]-t[o][1]);return n}var dO=1.7580993408473768,fO=1.0507009873554805;var Ywe=.3275911,Zwe=.254829592,Qwe=-.284496736,Jwe=1.421413741,eCe=-1.453152027,tCe=1.061405429;function rCe(r,t){if(r.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${r.length}, imag: ${t.length}.`);let e=new Float32Array(r.length*2);for(let n=0;n<e.length;n+=2)e[n]=r[n/2],e[n+1]=t[n/2];return e}function nCe(r){let t=new Float32Array(r.length/2),e=new Float32Array(r.length/2);for(let n=0;n<r.length;n+=2)t[n/2]=r[n],e[n/2]=r[n+1];return{real:t,imag:e}}function oCe(r){let t=Math.ceil(r.length/4),e=new Float32Array(t),n=new Float32Array(t);for(let o=0;o<r.length;o+=4)e[Math.floor(o/4)]=r[o],n[Math.floor(o/4)]=r[o+1];return{real:e,imag:n}}function sCe(r){let t=Math.floor(r.length/4),e=new Float32Array(t),n=new Float32Array(t);for(let o=2;o<r.length;o+=4)e[Math.floor(o/4)]=r[o],n[Math.floor(o/4)]=r[o+1];return{real:e,imag:n}}function iCe(r,t){let e=r[t*2],n=r[t*2+1];return{real:e,imag:n}}function aCe(r,t,e,n){r[n*2]=t,r[n*2+1]=e}function uCe(r,t){let e=new Float32Array(r/2),n=new Float32Array(r/2);for(let o=0;o<Math.ceil(r/2);o++){let s=(t?2:-2)*Math.PI*(o/r);e[o]=Math.cos(s),n[o]=Math.sin(s)}return{real:e,imag:n}}function lCe(r,t,e){let n=(e?2:-2)*Math.PI*(r/t),o=Math.cos(n),s=Math.sin(n);return{real:o,imag:s}}var hO="->",cCe=/->/g,_4=",",E4="...";function pCe(r,t){r=r.replace(/\s/g,"");let e=(r.length-r.replace(cCe,"").length)/hO.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${hO}").`);let[n,o]=r.split(hO);F(n.indexOf(E4)===-1,()=>`The ellipsis notation ("${E4}") is not supported yet.`);let s=n.split(_4),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let a=[];for(let d=0;d<o.length;++d){let f=o[d];if(!s.some(h=>h.indexOf(f)!==-1))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);a.indexOf(f)===-1&&a.push(f)}for(let d=0;d<n.length;++d){let f=n[d];a.indexOf(f)===-1&&f!==_4&&a.push(f)}let u=new Array(s.length);for(let d=0;d<i;++d){if(new Set(s[d].split("")).size!==s[d].length)throw new Error(`Found duplicate axes in input component ${s[d]}. Support for duplicate axes in input is not implemented yet.`);u[d]=[];for(let f=0;f<s[d].length;++f)u[d].push(a.indexOf(s[d][f]))}let l=a.length,c=o.length,p=[];for(let d=c;d<l;++d)p.push(d);return{allDims:a,summedDims:p,idDims:u}}function dCe(r,t){let e=new Array(r);e.fill(-1);for(let o=0;o<t.length;++o)e[t[o]]=o;let n=[];for(let o=0;o<r;++o)e[o]===-1&&n.push(o);return e=e.filter(o=>o!==-1),{permutationIndices:e,expandDims:n}}function fCe(r,t,e){let n=new Array(r);for(let o=0;o<e.length;++o){let s=e[o].shape;for(let i=0;i<t[o].length;++i)n[t[o][i]]===void 0?n[t[o][i]]=s[i]:F(n[t[o][i]]===s[i],()=>`Expected dimension ${n[t[o][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function hCe(r,t){let e=r,n=[],o=0;r.length===0&&e.push(-1),o=r.length+1;for(let i=0;i<o;++i)n.push([]);let s=[];for(let i=0;i<e.length;++i){let a=e[i],u=gCe(t,a);for(let l of u)s.indexOf(l)===-1&&(n[i].push(l),s.push(l))}return{path:e,steps:n}}function mCe(r){return r.every((t,e)=>t===e)}function gCe(r,t){let e=[];for(let n=0;n<r.length;++n)(r[n].length===0||r[n].indexOf(t)!==-1||t===-1)&&e.push(n);return e}function yCe(r,t,e=0){let n=[];if(typeof t=="number")F(r.shape[e]%t===0,()=>"Number of splits must evenly divide the axis."),n=new Array(t).fill(r.shape[e]/t);else{let o=t.reduce((i,a)=>(a===-1&&(i+=1),i),0);F(o<=1,()=>"There should be only one negative value in split array.");let s=t.indexOf(-1);if(s!==-1){let i=t.reduce((a,u)=>u>0?a+u:a);t[s]=r.shape[e]-i}F(r.shape[e]===t.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),n=t}return n}function xCe(r){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${r}`}function vCe(r,t){return`indices(${r}, 0) is invalid: ${t} < 0`}function bCe(r,t,e){return`indices(${r}, 0) is invalid: ${t} >= ${e}`}function wCe(r,t){return`only one output dimension may be -1, not both ${r} and ${t}`}function CCe(r,t){return`size ${r} must be non-negative, not ${t}`}function SCe(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function ICe(r,t){let e=bt(r),n=bt(t);return`Input to reshape is a SparseTensor with ${e}
  dense values, but the requested shape requires a multiple of ${n}. inputShape=${r} outputShape= ${t}`}function TCe(r,t){let e=bt(r),n=bt(t);return`Input to reshape is a tensor with ${e} dense values, but the requested shape has ${n}. inputShape=${r} outputShape=${t}`}function _Ce(){return"segment ids must be >= 0"}function ECe(){return"segment ids are not increasing"}function kCe(r,t){return`Segment id ${r} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function NCe(r,t,e){return`Bad: indices[${r}] == ${t} out of range [0, ${e})`}var mO={};ur(mO,{collectGatherOpShapeInfo:()=>RCe,computeOutShape:()=>ACe,segOpComputeOptimalWindowSize:()=>DCe});function DCe(r,t){let e=!1,n;for(r<=_I?(n=r,e=!0):n=pg(r,Math.floor(Math.sqrt(r)));!e;)n>t||n===r?e=!0:n=pg(r,n+1);return n}function ACe(r,t,e){let n=[],o=r.length;for(let s=0;s<o;s++)s!==t?n.push(r[s]):n.push(e);return n}function RCe(r,t,e,n){let o=t.shape.length,s=r.shape.length;if(n!==0&&(n<-o||n>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${n}`);if(n<0&&(n+=o),n>s)throw new Error(`batchDims (${n}) must be less than rank(x) (
    ${s}).`);if(e<n)throw new Error(`batchDims (${n}) must be less than or equal to axis (${e}).`);for(let p=0;p<n;++p)if(r.shape[p]!==t.shape[p])throw new Error(`x.shape[${p}]: ${r.shape[p]} should be equal to indices.shape[${p}]: ${t.shape[p]}.`);let i=r.shape[e],a=[],u=1,l=1,c=1;for(let p=0;p<n;++p)a.push(r.shape[p]),u*=r.shape[p];for(let p=n;p<e;p++)a.push(r.shape[p]),l*=r.shape[p];for(let p=n;p<o;p++)a.push(t.shape[p]);for(let p=e+1;p<s;p++)a.push(r.shape[p]),c*=r.shape[p];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:i,outputShape:a}}function OCe(r){try{return r.map(t=>kg(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function MCe(r){return r.map(t=>Eg(t))}var En={};ur(En,{nonMaxSuppressionV3Impl:()=>gI,nonMaxSuppressionV4Impl:()=>yI,nonMaxSuppressionV5Impl:()=>xI,whereImpl:()=>cI});n4();var FCe=j();FCe.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,r=>{r&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Ss=function(r){return r[r.DT_INVALID=0]="DT_INVALID",r[r.DT_FLOAT=1]="DT_FLOAT",r[r.DT_DOUBLE=2]="DT_DOUBLE",r[r.DT_INT32=3]="DT_INT32",r[r.DT_UINT8=4]="DT_UINT8",r[r.DT_INT16=5]="DT_INT16",r[r.DT_INT8=6]="DT_INT8",r[r.DT_STRING=7]="DT_STRING",r[r.DT_COMPLEX64=8]="DT_COMPLEX64",r[r.DT_INT64=9]="DT_INT64",r[r.DT_BOOL=10]="DT_BOOL",r[r.DT_QINT8=11]="DT_QINT8",r[r.DT_QUINT8=12]="DT_QUINT8",r[r.DT_QINT32=13]="DT_QINT32",r[r.DT_BFLOAT16=14]="DT_BFLOAT16",r[r.DT_QINT16=15]="DT_QINT16",r[r.DT_QUINT16=16]="DT_QUINT16",r[r.DT_UINT16=17]="DT_UINT16",r[r.DT_COMPLEX128=18]="DT_COMPLEX128",r[r.DT_HALF=19]="DT_HALF",r[r.DT_RESOURCE=20]="DT_RESOURCE",r[r.DT_VARIANT=21]="DT_VARIANT",r[r.DT_UINT32=22]="DT_UINT32",r[r.DT_UINT64=23]="DT_UINT64",r[r.DT_FLOAT_REF=101]="DT_FLOAT_REF",r[r.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",r[r.DT_INT32_REF=103]="DT_INT32_REF",r[r.DT_UINT8_REF=104]="DT_UINT8_REF",r[r.DT_INT16_REF=105]="DT_INT16_REF",r[r.DT_INT8_REF=106]="DT_INT8_REF",r[r.DT_STRING_REF=107]="DT_STRING_REF",r[r.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",r[r.DT_INT64_REF=109]="DT_INT64_REF",r[r.DT_BOOL_REF=110]="DT_BOOL_REF",r[r.DT_QINT8_REF=111]="DT_QINT8_REF",r[r.DT_QUINT8_REF=112]="DT_QUINT8_REF",r[r.DT_QINT32_REF=113]="DT_QINT32_REF",r[r.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",r[r.DT_QINT16_REF=115]="DT_QINT16_REF",r[r.DT_QUINT16_REF=116]="DT_QUINT16_REF",r[r.DT_UINT16_REF=117]="DT_UINT16_REF",r[r.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",r[r.DT_HALF_REF=119]="DT_HALF_REF",r[r.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",r[r.DT_VARIANT_REF=121]="DT_VARIANT_REF",r[r.DT_UINT32_REF=122]="DT_UINT32_REF",r[r.DT_UINT64_REF=123]="DT_UINT64_REF",r}(Ss||{}),k4;(function(r){let t;(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t=r.CheckpointFormatVersion||(r.CheckpointFormatVersion={}))})(k4||(k4={}));var PCe={};function EI(r){return PCe[r]}function _(r,t,e,n,o){let s=t.inputParams[r];if(s&&s.inputIndexStart!==void 0){let a=s.inputIndexStart,u=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?a+1:s.inputIndexEnd,l=a<0?t.inputNames.length+a:a;if(s.type==="tensor")return xn(t.inputNames[l],e,n,o);if(s.type==="tensors"){let d=t.inputs.slice(a,u);return t.inputNames.slice(a,u).filter((h,m)=>{var g;return((g=d[m])===null||g===void 0?void 0:g.op)!=="NoOp"}).map(h=>xn(h,e,n,o))}let c=xn(t.inputNames[l],e,n,o),p=c.dataSync();return s.type==="number"?p[0]:b.toNestedArray(c.shape,p)}let i=t.attrParams[r];return i&&i.value}function xn(r,t,e,n){let[o,s]=Po(r,e);if(n!=null){let a=n.getHashTableHandleByName(o);if(a!=null)return a}let i=e.currentContextIds.find(a=>!!t[kI(o,a)]);return i!==void 0?t[kI(o,i)][s]:void 0}function gO(r,t,e){return t[kI(r,e.currentContextId)]}function Za(r,t){let[e,n,o]=Po(r,t);return[kI(e,t&&t.currentContextId),n,o]}function kI(r,t){return t?`${r}-${t}`:r}function Po(r,t){if(r==="")return["",0,void 0];let e=t!=null&&t.parseNodeNameCache!=null;if(e){let s=t.parseNodeNameCache.get(r);if(s!=null)return s}let n=r.split(":"),o;if(n.length===1)o=[r,0,void 0];else{let s=n[0],i=n.length===3?n[1]:void 0,a=Number(n[n.length-1]);o=[s,a,i]}return e&&t.parseNodeNameCache.set(r,o),o}function ab(r,t,e){let n=_("pad",r,t,e);if(n==="explicit"){n=_("explicitPaddings",r,t,e);let o=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)o[s][0]=n[s*2],o[s][1]=n[s*2+1];return o}return n}function Qa(r){return r.kept?r:Mo(r)}var yO={};ur(yO,{json:()=>LCe});var LCe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var xO={};ur(xO,{json:()=>zCe});var zCe=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var vO={};ur(vO,{json:()=>BCe});var BCe=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];var bO={};ur(bO,{json:()=>VCe});var VCe=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var wO={};ur(wO,{json:()=>UCe});var UCe=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var CO={};ur(CO,{json:()=>GCe});var GCe=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var SO={};ur(SO,{json:()=>WCe});var WCe=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var IO={};ur(IO,{json:()=>jCe});var jCe=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var TO={};ur(TO,{json:()=>HCe});var HCe=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}];var _O={};ur(_O,{json:()=>qCe});var qCe=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var EO={};ur(EO,{json:()=>KCe});var KCe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}];var kO={};ur(kO,{json:()=>XCe});var XCe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}];var NO={};ur(NO,{json:()=>YCe});var YCe=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}];var DO={};ur(DO,{json:()=>ZCe});var ZCe=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var AO={};ur(AO,{json:()=>QCe});var QCe=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}];var RO={};ur(RO,{json:()=>JCe});var JCe=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var OO={};ur(OO,{json:()=>e0e});var e0e=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var MO={};ur(MO,{json:()=>t0e});var t0e=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var FO={};ur(FO,{json:()=>r0e});var r0e=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var ub=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let t=[yO,xO,vO,bO,wO,CO,SO,IO,TO,_O,EO,kO,NO,DO,AO,RO,OO,MO,FO],e=[].concat(...t.map(n=>n.json));this.opMappers=e.reduce((n,o)=>(n[o.tfOpName]=o,n),{})}transformGraph(t,e={}){let n=t.node,o=[],s=[],i=[],a=n.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?o.push(m[g.name]):g.op==="Const"?s.push(m[g.name]):(g.input==null||g.input.length===0)&&i.push(m[g.name]),m),{}),u=[],l=[],c={},p={};e!=null&&(c=this.mapSignatureEntries(e.inputs),p=this.mapSignatureEntries(e.outputs));let d=Object.keys(a);d.forEach(m=>{let g=a[m];g.inputNames.forEach((y,x)=>{let[w,,C]=Za(y),I=a[w];if(I.outputs!=null){let N=I.outputs.indexOf(C);if(N!==-1){let A=`${w}:${N}`;g.inputNames[x]=A}}g.inputs.push(I),I.children.push(g)})}),Object.keys(p).length===0?d.forEach(m=>{let g=a[m];g.children.length===0&&l.push(g)}):Object.keys(p).forEach(m=>{let[g]=Za(m),y=a[g];y!=null&&(y.signatureKey=p[m],l.push(y))}),Object.keys(c).length>0?Object.keys(c).forEach(m=>{let[g]=Za(m),y=a[g];y&&(y.signatureKey=c[m],u.push(y))}):u=o;let f={};t.library!=null&&t.library.function!=null&&(f=t.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));let h={nodes:a,inputs:u,outputs:l,weights:s,placeholders:o,signature:e,functions:f};return i.length>0&&(h.initNodes=i),h}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,n)=>(e[t[n].name]=n,e),{})}mapNode(t){let e=EI(t.op)||this.opMappers[t.op]||{};t.attr==null&&(t.attr={});let n={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(o=>o.startsWith("^")?o.slice(1):o),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return e.inputs!=null&&(n.inputParams=e.inputs.reduce((o,s)=>(o[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},o),{})),e.attrs!=null&&(n.attrParams=e.attrs.reduce((o,s)=>{let i=s.type,a;switch(s.type){case"string":a=NI(t.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=NI(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":a=$I(t.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=$I(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":a=AI(t.attr,s.tfName,s.defaultValue||0),a===void 0&&s.tfDeprecatedName&&(a=AI(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":a=FI(t.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=FI(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":a=DI(t.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=DI(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":a=LI(t.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=LI(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":a=MI(t.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=MI(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":a=PI(t.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=PI(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":a=RI(t.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=RI(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":a=OI(t.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=OI(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":a=N4(t.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=N4(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${t.op}`)}return o[s.name]={value:a,type:i},o},{})),n}mapFunction(t){let e=t.nodeDef,n=[],o=[],s={};e!=null&&(s=e.reduce((p,d)=>(p[d.name]=this.mapNode(d),d.op==="Const"&&o.push(p[d.name]),p),{}));let i=[],a=[];t.signature.inputArg.forEach(p=>{let[d]=Za(p.name),f={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:$O(p.type),type:"dtype"}},children:[]};f.signatureKey=p.name,i.push(f),s[d]=f}),Object.keys(s).forEach(p=>{let d=s[p];d.inputNames.forEach((f,h)=>{let[m,,g]=Za(f),y=s[m];if(y.outputs!=null){let x=y.outputs.indexOf(g);if(x!==-1){let w=`${m}:${x}`;d.inputNames[h]=w}}d.inputs.push(y),y.children.push(d)})});let l=t.ret;t.signature.outputArg.forEach(p=>{let[d,f]=Za(l[p.name]),h=s[d];h!=null&&(h.defaultOutput=f,a.push(h))});let c=this.mapArgsToSignature(t);return{nodes:s,inputs:i,outputs:a,weights:o,placeholders:n,signature:c}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,n)=>(e[n.name]=this.mapArgToTensorInfo(n),e),{}),outputs:t.signature.outputArg.reduce((e,n)=>(e[n.name]=this.mapArgToTensorInfo(n,t.ret),e),{})}}mapArgToTensorInfo(t,e){let n=t.name;return e!=null&&(n=e[n]),{name:n,dtype:t.type}}};function n0e(r){let t=j().global;if(typeof t.atob<"u")return t.atob(r);if(typeof Buffer<"u")return new Buffer(r,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function D4(r,t){let e=Array.isArray(r)?String.fromCharCode.apply(null,r):n0e(r);return t?e:e.toLowerCase()}function NI(r,t,e,n=!1){let o=r[t];return o!=null?D4(o.s,n):e}function DI(r,t,e){let n=r[t];return n?n.b:e}function AI(r,t,e){let n=r[t]||{},o=n.i!=null?n.i:n.f!=null?n.f:e;return typeof o=="number"?o:parseInt(o,10)}function $O(r){switch(typeof r=="string"&&(r=Ss[r]),r){case Ss.DT_FLOAT:case Ss.DT_HALF:return"float32";case Ss.DT_INT32:case Ss.DT_INT64:case Ss.DT_INT8:case Ss.DT_UINT8:return"int32";case Ss.DT_BOOL:return"bool";case Ss.DT_DOUBLE:return"float32";case Ss.DT_STRING:return"string";case Ss.DT_COMPLEX64:case Ss.DT_COMPLEX128:return"complex64";default:return null}}function N4(r,t,e){let n=r[t];return n&&n.func?n.func.name:e}function RI(r,t,e){let n=r[t];return n&&n.type?$O(n.type):e}function OI(r,t,e){let n=r[t];return n&&n.list&&n.list.type?n.list.type.map(o=>$O(o)):e}function A4(r){if(!r.unknownRank)return r.dim!=null?r.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function MI(r,t,e){let n=r[t];return n&&n.shape?A4(n.shape):e}function FI(r,t,e){let n=r[t];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(o=>typeof o=="number"?o:parseInt(o,10)):e}function $I(r,t,e,n=!1){let o=r[t];return o&&o.list&&o.list.s?o.list.s.map(s=>D4(s,n)):e}function PI(r,t,e){let n=r[t];return n&&n.list&&n.list.shape?n.list.shape.map(o=>A4(o)):e}function LI(r,t,e){let n=r[t];return n&&n.list&&n.list.b?n.list.b:e}var zI=class{constructor(t,e,n){this.node=t,this.tensorMap=e,this.context=n,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(o=>this.getInput(o)),t.rawAttrs!=null&&(this.attrs=Object.keys(t.rawAttrs).reduce((o,s)=>(o[s]=this.getAttr(s),o),{}))}getInput(t){return xn(t,this.tensorMap,this.context)}getAttr(t,e){let n=this.node.rawAttrs[t];if(n.tensor!=null)return xn(t,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return AI(this.node.rawAttrs,t,e);if(n.s!=null)return NI(this.node.rawAttrs,t,e);if(n.b!=null)return DI(this.node.rawAttrs,t,e);if(n.shape!=null)return MI(this.node.rawAttrs,t,e);if(n.type!=null)return RI(this.node.rawAttrs,t,e);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return FI(this.node.rawAttrs,t,e);if(n.list.s!=null)return $I(this.node.rawAttrs,t,e);if(n.list.shape!=null)return PI(this.node.rawAttrs,t,e);if(n.list.b!=null)return LI(this.node.rawAttrs,t,e);if(n.list.type!=null)return OI(this.node.rawAttrs,t,e)}return e}};var Bt={};ur(Bt,{OP_SCOPE_SUFFIX:()=>E2,abs:()=>Nr,acos:()=>hS,acosh:()=>mS,add:()=>re,addN:()=>pG,all:()=>$g,any:()=>hh,argMax:()=>vi,argMin:()=>gS,asin:()=>yS,asinh:()=>xS,atan:()=>vS,atan2:()=>bS,atanh:()=>wS,avgPool:()=>Ed,avgPool3d:()=>CS,basicLSTMCell:()=>hG,batchNorm:()=>Al,batchNorm2d:()=>SS,batchNorm3d:()=>IS,batchNorm4d:()=>TS,batchToSpaceND:()=>kd,bincount:()=>_S,bitwiseAnd:()=>gG,booleanMaskAsync:()=>Uve,broadcastArgs:()=>yG,broadcastTo:()=>Rl,buffer:()=>Ne,cast:()=>le,ceil:()=>ES,clipByValue:()=>Sn,clone:()=>Mo,complex:()=>Qo,concat:()=>Dt,concat1d:()=>kS,concat2d:()=>NS,concat3d:()=>DS,concat4d:()=>AS,conv1d:()=>Lg,conv2d:()=>Jo,conv2dTranspose:()=>Bg,conv3d:()=>RS,conv3dTranspose:()=>MS,cos:()=>Nd,cosh:()=>Vg,cosineWindow:()=>nb,cumprod:()=>gh,cumsum:()=>Ug,denseBincount:()=>Zv,depthToSpace:()=>FS,depthwiseConv2d:()=>Ol,diag:()=>xG,dilation2d:()=>$S,div:()=>me,divNoNan:()=>PS,dot:()=>LS,dropout:()=>Z2,einsum:()=>Dd,elu:()=>Ml,enclosingPowerOfTwo:()=>Q2,ensureShape:()=>bG,equal:()=>Co,erf:()=>Gg,euclideanNorm:()=>zS,exp:()=>Rr,expandDims:()=>Sr,expm1:()=>BS,eye:()=>yh,fft:()=>Bd,fill:()=>bi,floor:()=>Fl,floorDiv:()=>Fg,fused:()=>Ud,gather:()=>$l,gatherND:()=>Qve,greater:()=>Gr,greaterEqual:()=>$o,ifft:()=>Oc,imag:()=>Ad,image:()=>yn,inTopKAsync:()=>tbe,irfft:()=>ry,isFinite:()=>VS,isInf:()=>US,isNaN:()=>GS,leakyRelu:()=>Rd,less:()=>Ac,lessEqual:()=>ws,linalg:()=>eO,linspace:()=>SG,localResponseNormalization:()=>WS,log:()=>Bn,log1p:()=>Od,logSigmoid:()=>jS,logSoftmax:()=>Wg,logSumExp:()=>Md,logicalAnd:()=>ao,logicalNot:()=>Fd,logicalOr:()=>jg,logicalXor:()=>HS,losses:()=>nwe,lowerBound:()=>IG,matMul:()=>dt,max:()=>zn,maxPool:()=>$d,maxPool3d:()=>KS,maxPoolWithArgmax:()=>TG,maximum:()=>ts,mean:()=>Ir,meshgrid:()=>_G,min:()=>Nc,minimum:()=>rs,mirrorPad:()=>Hg,mod:()=>XS,moments:()=>xh,movingAverage:()=>jve,mul:()=>B,multiRNNCell:()=>EG,multinomial:()=>kG,neg:()=>yt,norm:()=>Dc,notEqual:()=>Xa,oneHot:()=>vh,ones:()=>hn,onesLike:()=>On,op:()=>D,outerProduct:()=>NG,pad:()=>Vn,pad1d:()=>DG,pad2d:()=>AG,pad3d:()=>RG,pad4d:()=>OG,pool:()=>YS,pow:()=>io,prelu:()=>Ld,print:()=>fS,prod:()=>ZS,raggedGather:()=>MG,raggedRange:()=>FG,raggedTensorToTensor:()=>$G,rand:()=>PG,randomGamma:()=>eW,randomNormal:()=>Ch,randomStandardNormal:()=>tW,randomUniform:()=>Cs,randomUniformInt:()=>rW,range:()=>Pl,real:()=>Rc,reciprocal:()=>rI,relu:()=>to,relu6:()=>qg,reshape:()=>V,reverse:()=>In,reverse1d:()=>nW,reverse2d:()=>oW,reverse3d:()=>sW,reverse4d:()=>iW,rfft:()=>Vd,round:()=>Kg,rsqrt:()=>Xg,scalar:()=>we,scatterND:()=>qve,searchSorted:()=>Jv,selu:()=>Yg,separableConv2d:()=>Zg,setdiff1dAsync:()=>aW,sigmoid:()=>Rn,sign:()=>nI,signal:()=>rwe,sin:()=>Qg,sinh:()=>Jg,slice:()=>Ue,slice1d:()=>ey,slice2d:()=>tb,slice3d:()=>ty,slice4d:()=>Sh,softmax:()=>zd,softplus:()=>Ka,spaceToBatchND:()=>Pd,sparse:()=>owe,sparseToDense:()=>Yve,spectral:()=>twe,split:()=>Tn,sqrt:()=>lr,square:()=>at,squaredDifference:()=>ny,squeeze:()=>Rt,stack:()=>Wr,step:()=>Ci,stridedSlice:()=>oI,string:()=>swe,sub:()=>xe,sum:()=>Ie,tan:()=>sI,tanh:()=>qa,tensor:()=>$n,tensor1d:()=>cr,tensor2d:()=>So,tensor3d:()=>iI,tensor4d:()=>uW,tensor5d:()=>lW,tensor6d:()=>cW,tensorScatterUpdate:()=>fW,tile:()=>eo,topk:()=>aI,transpose:()=>ft,truncatedNormal:()=>oy,unique:()=>uI,unsortedSegmentSum:()=>sy,unstack:()=>_n,upperBound:()=>hW,variable:()=>lI,where:()=>Cr,whereAsync:()=>pI,zeros:()=>er,zerosLike:()=>je});var R4=(r,t,e,n=Bt)=>{switch(r.op){case"BiasAdd":case"AddV2":case"Add":return[n.add(_("a",r,t,e),_("b",r,t,e))];case"AddN":return[n.addN(_("tensors",r,t,e))];case"FloorMod":case"Mod":return[n.mod(_("a",r,t,e),_("b",r,t,e))];case"Mul":return[n.mul(_("a",r,t,e),_("b",r,t,e))];case"RealDiv":case"Div":return[n.div(_("a",r,t,e),_("b",r,t,e))];case"DivNoNan":return[n.divNoNan(_("a",r,t,e),_("b",r,t,e))];case"FloorDiv":return[n.floorDiv(_("a",r,t,e),_("b",r,t,e))];case"Sub":return[n.sub(_("a",r,t,e),_("b",r,t,e))];case"Minimum":return[n.minimum(_("a",r,t,e),_("b",r,t,e))];case"Maximum":return[n.maximum(_("a",r,t,e),_("b",r,t,e))];case"Pow":return[n.pow(_("a",r,t,e),_("b",r,t,e))];case"SquaredDifference":return[n.squaredDifference(_("a",r,t,e),_("b",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var O4=(r,t,e,n=Bt)=>{switch(r.op){case"Abs":case"ComplexAbs":return[n.abs(_("x",r,t,e))];case"Acos":return[n.acos(_("x",r,t,e))];case"Acosh":return[n.acosh(_("x",r,t,e))];case"Asin":return[n.asin(_("x",r,t,e))];case"Asinh":return[n.asinh(_("x",r,t,e))];case"Atan":return[n.atan(_("x",r,t,e))];case"Atan2":return[n.atan2(_("x",r,t,e),_("y",r,t,e))];case"Atanh":return[n.atanh(_("x",r,t,e))];case"Ceil":return[n.ceil(_("x",r,t,e))];case"Complex":return[n.complex(_("real",r,t,e),_("imag",r,t,e))];case"Cos":return[n.cos(_("x",r,t,e))];case"Cosh":return[n.cosh(_("x",r,t,e))];case"Elu":return[n.elu(_("x",r,t,e))];case"Erf":return[n.erf(_("x",r,t,e))];case"Exp":return[n.exp(_("x",r,t,e))];case"Expm1":return[n.expm1(_("x",r,t,e))];case"Floor":return[n.floor(_("x",r,t,e))];case"Log":return[n.log(_("x",r,t,e))];case"Log1p":return[n.log1p(_("x",r,t,e))];case"Imag":return[n.imag(_("x",r,t,e))];case"Neg":return[n.neg(_("x",r,t,e))];case"Reciprocal":return[n.reciprocal(_("x",r,t,e))];case"Real":return[n.real(_("x",r,t,e))];case"Relu":return[n.relu(_("x",r,t,e))];case"Round":return[n.round(_("x",r,t,e))];case"Selu":return[n.selu(_("x",r,t,e))];case"Sigmoid":return[n.sigmoid(_("x",r,t,e))];case"Sin":return[n.sin(_("x",r,t,e))];case"Sign":return[n.sign(_("x",r,t,e))];case"Sinh":return[n.sinh(_("x",r,t,e))];case"Softplus":return[n.softplus(_("x",r,t,e))];case"Sqrt":return[n.sqrt(_("x",r,t,e))];case"Square":return[n.square(_("x",r,t,e))];case"Tanh":return[n.tanh(_("x",r,t,e))];case"Tan":return[n.tan(_("x",r,t,e))];case"ClipByValue":return[n.clipByValue(_("x",r,t,e),_("clipValueMin",r,t,e),_("clipValueMax",r,t,e))];case"Relu6":return[n.relu6(_("x",r,t,e))];case"Rsqrt":return[n.rsqrt(xn(r.inputNames[0],t,e))];case"LeakyRelu":return[n.leakyRelu(_("x",r,t,e),_("alpha",r,t,e))];case"Prelu":return[n.prelu(_("x",r,t,e),_("alpha",r,t,e))];case"IsNan":return[n.isNaN(xn(r.inputNames[0],t,e))];case"IsInf":return[n.isInf(xn(r.inputNames[0],t,e))];case"IsFinite":return[n.isFinite(xn(r.inputNames[0],t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function Is(r,t,e=""){if(!(typeof r=="number"||typeof t=="number")){b.assert(r.length===t.length,()=>e+` Shapes ${r} and ${t} must match`);for(let n=0;n<r.length;n++){let o=r[n],s=t[n];b.assert(o<0||s<0||o===s,()=>e+` Shapes ${r} and ${t} must match`)}}}function M4(r){return!(typeof r=="number"||r.some(t=>t<0))}function fy(r,t,e){let n=BI(r,e),o=!M4(n);if(o&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(o&&t.forEach(s=>{n=BI(s.shape,n)}),!M4(n))throw new Error(`Non-fully-defined elementShape: ${n}`);return n}function BI(r,t){if(typeof r=="number")return t;if(typeof t=="number")return r;if(r.length!==t.length)throw new Error(`Incompatible ranks during merge: ${r} vs. ${t}`);let e=[];for(let n=0;n<r.length;++n){let o=r[n],s=t[n];if(o>=0&&s>=0&&o!==s)throw new Error(`Incompatible shape during merge: ${r} vs. ${t}`);e[n]=o>=0?o:s}return e}var VI=class{constructor(t,e,n,o,s,i,a){this.name=t,this.dtype=e,this.maxSize=n,this.elementShape=o,this.identicalElementShapes=s,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=we(0),Ar(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);let e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},
          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=e.shape),Is(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);n.tensor=e,Ar(e),n.written=!0,this.tensors[t]=n}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((n,o)=>this.write(n,e[o]))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let o=0;o<this.size();o++)t.push(o)}if(t.length===0)return $n([],[0].concat(this.elementShape));let n=this.readMany(t);return Is(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Wr(n,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(this.size()===0)return $n([],[0].concat(this.elementShape));let e=[];for(let o=0;o<this.size();o++)e.push(o);let n=this.readMany(e);return Is(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Dt(n,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let n=Math.max(...t);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(t,_n(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let n=0,o=t.map(u=>(n+=u,n));if(n!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);let s=n===0?0:e.size/n,i=[];X(()=>{e=V(e,[1,n,s]);for(let u=0;u<t.length;++u){let c=[0,u===0?0:o[u-1],0],p=[1,t[u],s];i[u]=V(Ue(e,c,p),this.elementShape)}return i});let a=[];for(let u=0;u<t.length;u++)a[u]=u;this.writeMany(a,i)}};var hy=class r{get id(){return this.idTensor.id}constructor(t,e,n,o=-1){this.tensors=t,this.elementShape=e,this.elementDtype=n,t?.forEach(s=>{if(n!==s.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${s.dtype}`);Is(e,s.shape,"TensorList shape mismatch: "),Ar(s)}),this.idTensor=we(0),this.maxNumElements=o,Ar(this.idTensor)}copy(){return new r([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,n=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);Is(t,this.elementShape,"TensorList shape mismatch: ");let o=fy(this.elementShape,this.tensors,t);return X(()=>{let s=this.tensors.map(i=>V(i,o));return Wr(s,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let n=fy(this.elementShape,this.tensors,t),o=this.tensors.pop();return o.kept=!1,Is(o.shape,t,"TensorList shape mismatch: "),V(o,n)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Is(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Ar(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let e=new r([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=t;for(let n=0;n<Math.min(this.tensors.length,t);++n)e.tensors[n]=this.tensors[n];return e}getItem(t,e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);Is(this.tensors[t].shape,e,"TensorList shape mismatch: ");let o=fy(this.elementShape,this.tensors,e);return V(this.tensors[t],o)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Is(this.elementShape,e.shape,"TensorList shape mismatch: "),Ar(e),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=e}gather(t,e,n){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);Is(this.elementShape,n,"TensorList shape mismatch: "),t=t.slice(0,this.size());let o=fy(this.elementShape,this.tensors,n);return t.length===0?$n([],[0].concat(o)):X(()=>{let s=t.map(i=>V(this.tensors[i],o));return Wr(s,0)})}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Is(this.elementShape,e,"TensorList shape mismatch: ");let n=fy(this.elementShape,this.tensors,e);return this.size()===0?$n([],[0].concat(n)):X(()=>{let o=this.tensors.map(s=>V(s,n));return Dt(o,0)})}};function F4(r,t,e){let n=r.dtype;if(r.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${r.shape}`);if(r.dtype!==e)throw new Error(`Invalid data types; op elements ${r.dtype}, but list elements ${e}`);let o=r.shape.slice(1);Is(o,t,"TensorList shape mismatch: ");let s=_n(r);return new hy(s,t,n)}function $4(r,t,e,n){return new hy([],r,t,n)}function P4(r,t,e,n){if(t.length!==r.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${r.shape[0]}`);let o=Math.max(...t);if(n!=null&&n!==-1&&o>=n)throw new Error(`Max index must be < array size (${o}  vs. ${n})`);let s=new hy([],e,r.dtype,n),i=_n(r,0);return t.forEach((a,u)=>{s.setItem(a,i[u])}),s}function L4(r,t,e){let n=0,o=t.map(c=>(n+=c,n));if(n!==r.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${r.shape}`);let s=r.shape.slice(1),i=BI(s,e),a=n===0?0:r.size/n,u=X(()=>{let c=[];r=V(r,[1,n,a]);for(let p=0;p<t.length;++p){let f=[0,p===0?0:o[p-1],0],h=[1,t[p],a];c[p]=V(Ue(r,f,h),i)}return r.dispose(),c}),l=new hy([],e,r.dtype,t.length);for(let c=0;c<u.length;c++)l.setItem(c,u[c]);return l}var z4=(r,t,e)=>L(void 0,null,function*(){switch(r.op){case"If":case"StatelessIf":{let n=_("thenBranch",r,t,e),o=_("elseBranch",r,t,e),s=_("cond",r,t,e),i=_("args",r,t,e);return(yield s.data())[0]?e.functionMap[n].executeFunctionAsync(i,e.tensorArrayMap,e.tensorListMap):e.functionMap[o].executeFunctionAsync(i,e.tensorArrayMap,e.tensorListMap)}case"While":case"StatelessWhile":{let n=_("body",r,t,e),o=_("cond",r,t,e),s=_("args",r,t,e),i=yield e.functionMap[o].executeFunctionAsync(s,e.tensorArrayMap,e.tensorListMap),a=s.map(c=>c.id),u=yield i[0].data();i.forEach(c=>{!c.kept&&a.indexOf(c.id)===-1&&c.dispose()});let l=s;for(;u[0];){let c=l;l=yield e.functionMap[n].executeFunctionAsync(l,e.tensorArrayMap,e.tensorListMap);let p=l.map(f=>f.id);c.forEach(f=>{!f.kept&&a.indexOf(f.id)===-1&&p.indexOf(f.id)===-1&&f.dispose()});let d=yield e.functionMap[o].executeFunctionAsync(l,e.tensorArrayMap,e.tensorListMap);u=yield d[0].data(),d.forEach(f=>{!f.kept&&a.indexOf(f.id)===-1&&p.indexOf(f.id)===-1&&f.dispose()})}return l}case"LoopCond":{let n=_("pred",r,t,e);return[Qa(n)]}case"Switch":{let n=_("pred",r,t,e),o=_("data",r,t,e);return o.kept||(o=Qa(o)),(yield n.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{let n=r.inputNames.find(o=>xn(o,t,e)!==void 0);if(n){let o=xn(n,t,e);return[Qa(o)]}return}case"Enter":{let n=_("frameName",r,t,e),o=_("tensor",r,t,e);return e.enterFrame(n),[Qa(o)]}case"Exit":{let n=_("tensor",r,t,e);return e.exitFrame(),[Qa(n)]}case"NextIteration":{let n=_("tensor",r,t,e);return e.nextIteration(),[Qa(n)]}case"TensorArrayV3":{let n=_("size",r,t,e),o=_("dtype",r,t,e),s=_("elementShape",r,t,e),i=_("dynamicSize",r,t,e),a=_("clearAfterRead",r,t,e),u=_("identicalElementShapes",r,t,e),l=_("name",r,t,e),c=new VI(l,o,n,s,u,i,a);return e.addTensorArray(c),[c.idTensor,we(1)]}case"TensorArrayWriteV3":{let n=_("tensorArrayId",r,t,e),o=_("index",r,t,e),s=_("tensor",r,t,e),i=e.getTensorArray(n.id);return i.write(o,s),[i.idTensor]}case"TensorArrayReadV3":{let n=_("tensorArrayId",r,t,e),o=_("index",r,t,e);return[e.getTensorArray(n.id).read(o)]}case"TensorArrayGatherV3":{let n=_("tensorArrayId",r,t,e),o=_("indices",r,t,e),s=_("dtype",r,t,e);return[e.getTensorArray(n.id).gather(o,s)]}case"TensorArrayScatterV3":{let n=_("tensorArrayId",r,t,e),o=_("indices",r,t,e),s=_("tensor",r,t,e),i=e.getTensorArray(n.id);return i.scatter(o,s),[i.idTensor]}case"TensorArrayConcatV3":{let n=_("tensorArrayId",r,t,e),o=e.getTensorArray(n.id),s=_("dtype",r,t,e);return[o.concat(s)]}case"TensorArraySplitV3":{let n=_("tensorArrayId",r,t,e),o=_("tensor",r,t,e),s=_("lengths",r,t,e),i=e.getTensorArray(n.id);return i.split(s,o),[i.idTensor]}case"TensorArraySizeV3":{let n=_("tensorArrayId",r,t,e),o=e.getTensorArray(n.id);return[we(o.size(),"int32")]}case"TensorArrayCloseV3":{let n=_("tensorArrayId",r,t,e),o=e.getTensorArray(n.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{let n=_("tensorListId",r,t,e),o=_("index",r,t,e),s=_("tensor",r,t,e),i=e.getTensorList(n.id);return i.setItem(o,s),[i.idTensor]}case"TensorListGetItem":{let n=_("tensorListId",r,t,e),o=_("index",r,t,e),s=_("elementShape",r,t,e),i=_("elementDType",r,t,e);return[e.getTensorList(n.id).getItem(o,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let n=_("indices",r,t,e),o=_("tensor",r,t,e),s=_("elementShape",r,t,e),i=_("numElements",r,t,e),a=P4(o,n,s,i);return e.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let n=_("elementShape",r,t,e),o=_("elementDType",r,t,e),s;r.op==="TensorListReserve"?s="numElements":s="maxNumElements";let i=_(s,r,t,e),a=r.op==="TensorListReserve"?-1:i,u=$4(n,o,i,a);return e.addTensorList(u),[u.idTensor]}case"TensorListGather":{let n=_("tensorListId",r,t,e),o=_("indices",r,t,e),s=_("elementShape",r,t,e),i=_("elementDType",r,t,e);return[e.getTensorList(n.id).gather(o,i,s)]}case"TensorListStack":{let n=_("tensorListId",r,t,e),o=_("elementShape",r,t,e),s=_("elementDType",r,t,e),i=_("numElements",r,t,e);return[e.getTensorList(n.id).stack(o,s,i)]}case"TensorListFromTensor":{let n=_("tensor",r,t,e),o=_("elementShape",r,t,e),s=_("elementDType",r,t,e),i=F4(n,o,s);return e.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let n=_("tensorListId",r,t,e),o=e.getTensorList(n.id),s=_("dtype",r,t,e),i=_("elementShape",r,t,e);return[o.concat(s,i)]}case"TensorListPushBack":{let n=_("tensorListId",r,t,e),o=_("tensor",r,t,e),s=e.getTensorList(n.id);return s.pushBack(o),[s.idTensor]}case"TensorListPopBack":{let n=_("tensorListId",r,t,e),o=_("elementShape",r,t,e),s=_("elementDType",r,t,e);return[e.getTensorList(n.id).popBack(o,s)]}case"TensorListSplit":{let n=_("tensor",r,t,e),o=_("elementShape",r,t,e),s=_("lengths",r,t,e),i=L4(n,s,o);return e.addTensorList(i),[i.idTensor]}case"TensorListLength":{let n=_("tensorListId",r,t,e),o=e.getTensorList(n.id);return[we(o.size(),"int32")]}case"TensorListResize":{let n=_("tensorListId",r,t,e),o=_("size",r,t,e),i=e.getTensorList(n.id).resize(o);return e.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${r.op} is not implemented`)}});function B4(r,t,e){let[n,o]=_("fusedOps",r,t,e),s=n==="biasadd",i=!s,a=o==="prelu",u=n==="fusedbatchnorm",l=_("numArgs",r,t,e);if(s){if(a&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&s&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=_("strides",r,t,e),p=ab(r,t,e),d=_("dataFormat",r,t,e).toUpperCase(),f=_("dilations",r,t,e),[h,m]=_("args",r,t,e);i&&(m=h,h=void 0);let g=_("leakyreluAlpha",r,t,e);return{stride:c,pad:p,dataFormat:d,dilations:f,biasArg:h,preluArg:m,activationFunc:o,leakyreluAlpha:g}}var V4=(r,t,e,n=Bt)=>{switch(r.op){case"Conv1D":{let o=_("stride",r,t,e),s=_("pad",r,t,e),i=_("dataFormat",r,t,e).toUpperCase(),a=_("dilation",r,t,e);return[n.conv1d(_("x",r,t,e),_("filter",r,t,e),o,s,i,a)]}case"Conv2D":{let o=_("strides",r,t,e),s=ab(r,t,e),i=_("dataFormat",r,t,e).toUpperCase(),a=_("dilations",r,t,e);return[n.conv2d(_("x",r,t,e),_("filter",r,t,e),[o[1],o[2]],s,i,[a[1],a[2]])]}case"_FusedConv2D":{let{stride:o,pad:s,dataFormat:i,dilations:a,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:p}=B4(r,t,e);return[n.fused.conv2d({x:_("x",r,t,e),filter:_("filter",r,t,e),strides:[o[1],o[2]],pad:s,dataFormat:i,dilations:[a[1],a[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:p})]}case"FusedDepthwiseConv2dNative":{let{stride:o,pad:s,dataFormat:i,dilations:a,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:p}=B4(r,t,e);return[n.fused.depthwiseConv2d({x:_("x",r,t,e),filter:_("filter",r,t,e),strides:[o[1],o[2]],pad:s,dataFormat:i,dilations:[a[1],a[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:p})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let o=_("outputShape",r,t,e),s=_("strides",r,t,e),i=ab(r,t,e);return[n.conv2dTranspose(_("x",r,t,e),_("filter",r,t,e),o,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let o=_("strides",r,t,e),s=ab(r,t,e),i=_("dilations",r,t,e),a=_("dataFormat",r,t,e).toUpperCase();return[n.depthwiseConv2d(_("input",r,t,e),_("filter",r,t,e),[o[1],o[2]],s,a,[i[1],i[2]])]}case"Conv3D":{let o=_("strides",r,t,e),s=_("pad",r,t,e),i=_("dataFormat",r,t,e).toUpperCase(),a=_("dilations",r,t,e);return[n.conv3d(_("x",r,t,e),_("filter",r,t,e),[o[1],o[2],o[3]],s,i,[a[1],a[2],a[3]])]}case"AvgPool":{let o=_("strides",r,t,e),s=_("pad",r,t,e),i=_("kernelSize",r,t,e);return[n.avgPool(_("x",r,t,e),[i[1],i[2]],[o[1],o[2]],s)]}case"MaxPool":{let o=_("strides",r,t,e),s=_("pad",r,t,e),i=_("kernelSize",r,t,e);return[n.maxPool(_("x",r,t,e),[i[1],i[2]],[o[1],o[2]],s)]}case"MaxPoolWithArgmax":{let o=_("strides",r,t,e),s=_("pad",r,t,e),i=_("kernelSize",r,t,e),a=_("includeBatchInIndex",r,t,e),{result:u,indexes:l}=n.maxPoolWithArgmax(_("x",r,t,e),[i[1],i[2]],[o[1],o[2]],s,a);return[u,l]}case"AvgPool3D":{let o=_("strides",r,t,e),s=_("pad",r,t,e),i=_("kernelSize",r,t,e);return[n.avgPool3d(_("x",r,t,e),[i[1],i[2],i[3]],[o[1],o[2],o[3]],s)]}case"MaxPool3D":{let o=_("strides",r,t,e),s=_("pad",r,t,e),i=_("kernelSize",r,t,e);return[n.maxPool3d(_("x",r,t,e),[i[1],i[2],i[3]],[o[1],o[2],o[3]],s)]}case"Dilation2D":{let o=_("strides",r,t,e),s=_("pad",r,t,e),i=_("dilations",r,t,e),a=o[1],u=o[2],l=i[1],c=i[2];return[n.dilation2d(_("x",r,t,e),_("filter",r,t,e),[a,u],s,[l,c],"NHWC")]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var U4=(r,t,e,n=Bt)=>{switch(r.op){case"Fill":{let o=_("shape",r,t,e),s=_("dtype",r,t,e),i=_("value",r,t,e);return[n.fill(o,i,s)]}case"LinSpace":{let o=_("start",r,t,e),s=_("stop",r,t,e),i=_("num",r,t,e);return[n.linspace(o,s,i)]}case"Multinomial":{let o=_("logits",r,t,e),s=_("numSamples",r,t,e),i=_("seed",r,t,e);return[n.multinomial(o,s,i)]}case"OneHot":{let o=_("indices",r,t,e),s=_("depth",r,t,e),i=_("onValue",r,t,e),a=_("offValue",r,t,e),u=_("dtype",r,t,e);return[n.oneHot(o,s,i,a,u)]}case"Ones":return[n.ones(_("shape",r,t,e),_("dtype",r,t,e))];case"OnesLike":return[n.onesLike(_("x",r,t,e))];case"RandomStandardNormal":return[n.randomStandardNormal(_("shape",r,t,e),_("dtype",r,t,e),_("seed",r,t,e))];case"RandomUniform":return[n.randomUniform(_("shape",r,t,e),_("minval",r,t,e),_("maxval",r,t,e),_("dtype",r,t,e))];case"RandomUniformInt":return[n.randomUniformInt(_("shape",r,t,e),_("minval",r,t,e),_("maxval",r,t,e),_("seed",r,t,e))];case"Range":{let o=_("start",r,t,e),s=_("stop",r,t,e),i=_("step",r,t,e);return[n.range(o,s,i,_("dtype",r,t,e))]}case"TruncatedNormal":{let o=_("shape",r,t,e),s=_("mean",r,t,e),i=_("stdDev",r,t,e),a=_("seed",r,t,e);return[n.truncatedNormal(o,s,i,_("dtype",r,t,e),a)]}case"Zeros":return[n.zeros(_("shape",r,t,e),_("dtype",r,t,e))];case"ZerosLike":return[n.zerosLike(_("x",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function PO(r,t,e){let n=_("boxes",r,t,e),o=_("scores",r,t,e),s=_("maxOutputSize",r,t,e),i=_("iouThreshold",r,t,e),a=_("scoreThreshold",r,t,e),u=_("softNmsSigma",r,t,e);return{boxes:n,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a,softNmsSigma:u}}var G4=(s,i,a,u,...l)=>L(void 0,[s,i,a,u,...l],function*(r,t,e,n,o=Bt){switch(r.op){case"NonMaxSuppressionV5":{let{boxes:c,scores:p,maxOutputSize:d,iouThreshold:f,scoreThreshold:h,softNmsSigma:m}=PO(r,t,e),g=yield o.image.nonMaxSuppressionWithScoreAsync(c,p,d,f,h,m);return[g.selectedIndices,g.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:c,scores:p,maxOutputSize:d,iouThreshold:f,scoreThreshold:h}=PO(r,t,e),m=_("padToMaxOutputSize",r,t,e),g=yield o.image.nonMaxSuppressionPaddedAsync(c,p,d,f,h,m);return[g.selectedIndices,g.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:c,scores:p,maxOutputSize:d,iouThreshold:f,scoreThreshold:h}=PO(r,t,e);return[yield o.image.nonMaxSuppressionAsync(c,p,d,f,h)]}case"Where":{let c=o.cast(_("condition",r,t,e),"bool"),p=[yield o.whereAsync(c)];return c.dispose(),p}case"ListDiff":return o.setdiff1dAsync(_("x",r,t,e),_("y",r,t,e));default:throw TypeError(`Node type ${r.op} is not implemented`)}});var W4=(r,t,e,n=Bt)=>{switch(r.op){case"LowerBound":{let o=_("sortedSequence",r,t,e),s=_("values",r,t,e);return[n.lowerBound(o,s)]}case"TopKV2":{let o=_("x",r,t,e),s=_("k",r,t,e),i=_("sorted",r,t,e),a=n.topk(o,s,i);return[a.values,a.indices]}case"UpperBound":{let o=_("sortedSequence",r,t,e),s=_("values",r,t,e);return[n.upperBound(o,s)]}case"Unique":{let o=_("x",r,t,e),s=n.unique(o);return[s.values,s.indices]}case"UniqueV2":{let o=_("x",r,t,e),s=_("axis",r,t,e),i=n.unique(o,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var j4=(r,t,e,n=Bt)=>{switch(r.op){case"Const":return t[r.name];case"PlaceholderWithDefault":let o=_("default",r,t,e);return[xn(r.name,t,e)||o];case"Placeholder":return[xn(r.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let c=_("x",r,t,e);return[Qa(c)]}case"IdentityN":return _("x",r,t,e).map(c=>Qa(c));case"Snapshot":let s=_("x",r,t,e);return[Qa(s)];case"Shape":return[n.tensor1d(_("x",r,t,e).shape,"int32")];case"ShapeN":return _("x",r,t,e).map(c=>n.tensor1d(c.shape));case"Size":return[n.scalar(_("x",r,t,e).size,"int32")];case"Rank":return[n.scalar(_("x",r,t,e).rank,"int32")];case"NoOp":return[n.scalar(1)];case"Print":let i=_("x",r,t,e),a=_("data",r,t,e),u=_("message",r,t,e),l=_("summarize",r,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let c=0;c<a.length;c++)console.log(Array.prototype.slice.call(a[c].dataSync()).slice(0,l));return[i];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var UI=class{get id(){return this.handle.id}constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=we(0),this.tensorMap=new Map,Ar(this.handle)}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return we(this.size(),"int32")}import(t,e){return L(this,null,function*(){this.checkKeyAndValueTensor(t,e);let n=yield t.data();return this.tensorMap.forEach(o=>o.dispose()),this.tensorMap.clear(),X(()=>{let o=_n(e),s=n.length,i=o.length;b.assert(s===i,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${i} elements.`);for(let a=0;a<s;a++){let u=n[a],l=o[a];Ar(l),this.tensorMap.set(u,l)}return this.handle})})}find(t,e){return L(this,null,function*(){this.checkKeyAndValueTensor(t,e);let n=yield t.data();return X(()=>{let o=[];for(let s=0;s<n.length;s++){let i=n[s],a=this.findWithDefault(i,e);o.push(a)}return Wr(o)})})}findWithDefault(t,e){let n=this.tensorMap.get(t);return n??e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}};var H4=(r,t,e,n)=>L(void 0,null,function*(){switch(r.op){case"HashTable":case"HashTableV2":{let o=n.getHashTableHandleByName(r.name);if(o!=null)return[o];{let s=_("keyDType",r,t,e),i=_("valueDType",r,t,e),a=new UI(s,i);return n.addHashTable(r.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let o=_("tableHandle",r,t,e,n),s=_("keys",r,t,e),i=_("values",r,t,e);return[yield n.getHashTableById(o.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let o=_("tableHandle",r,t,e,n),s=_("keys",r,t,e),i=_("defaultValue",r,t,e);return[yield n.getHashTableById(o.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let o=_("tableHandle",r,t,e,n);return[n.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${r.op} is not implemented`)}});var q4=(r,t,e,n=Bt)=>{switch(r.op){case"ResizeBilinear":{let o=_("images",r,t,e),s=_("size",r,t,e),i=_("alignCorners",r,t,e),a=_("halfPixelCenters",r,t,e);return[n.image.resizeBilinear(o,[s[0],s[1]],i,a)]}case"ResizeNearestNeighbor":{let o=_("images",r,t,e),s=_("size",r,t,e),i=_("alignCorners",r,t,e),a=_("halfPixelCenters",r,t,e);return[n.image.resizeNearestNeighbor(o,[s[0],s[1]],i,a)]}case"CropAndResize":{let o=_("image",r,t,e),s=_("boxes",r,t,e),i=_("boxInd",r,t,e),a=_("cropSize",r,t,e),u=_("method",r,t,e),l=_("extrapolationValue",r,t,e);return[n.image.cropAndResize(o,s,i,a,u,l)]}case"ImageProjectiveTransformV3":{let o=_("images",r,t,e),s=_("transforms",r,t,e),i=_("outputShape",r,t,e),a=_("fillValue",r,t,e),u=_("interpolation",r,t,e),l=_("fillMode",r,t,e);return[n.image.transform(o,s,u.toLowerCase(),l.toLowerCase(),a,i)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var K4=(r,t,e,n=Bt)=>{switch(r.op){case"Equal":return[n.equal(_("a",r,t,e),_("b",r,t,e))];case"NotEqual":return[n.notEqual(_("a",r,t,e),_("b",r,t,e))];case"Greater":return[n.greater(_("a",r,t,e),_("b",r,t,e))];case"GreaterEqual":return[n.greaterEqual(_("a",r,t,e),_("b",r,t,e))];case"Less":return[n.less(_("a",r,t,e),_("b",r,t,e))];case"LessEqual":return[n.lessEqual(_("a",r,t,e),_("b",r,t,e))];case"LogicalAnd":return[n.logicalAnd(_("a",r,t,e),_("b",r,t,e))];case"LogicalNot":return[n.logicalNot(_("a",r,t,e))];case"LogicalOr":return[n.logicalOr(_("a",r,t,e),_("b",r,t,e))];case"Select":case"SelectV2":return[n.where(_("condition",r,t,e),_("a",r,t,e),_("b",r,t,e))];case"BitwiseAnd":return[n.bitwiseAnd(_("a",r,t,e),_("b",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var X4=(r,t,e,n=Bt)=>{switch(r.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[n.matMul(_("a",r,t,e),_("b",r,t,e),_("transposeA",r,t,e),_("transposeB",r,t,e))];case"Einsum":return[n.einsum(_("equation",r,t,e),..._("tensors",r,t,e))];case"Transpose":return[n.transpose(_("x",r,t,e),_("perm",r,t,e))];case"_FusedMatMul":let[o,s]=_("fusedOps",r,t,e),i=o==="biasadd",a=s==="prelu",u=_("numArgs",r,t,e),l=_("leakyreluAlpha",r,t,e);if(i){if(a&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[c,p]=_("args",r,t,e);return[n.fused.matMul({a:_("a",r,t,e),b:_("b",r,t,e),transposeA:_("transposeA",r,t,e),transposeB:_("transposeB",r,t,e),bias:c,activation:s,preluActivationWeights:p,leakyreluAlpha:l})];case"MatrixBandPart":return[n.linalg.bandPart(_("a",r,t,e),_("numLower",r,t,e),_("numUpper",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var Y4=(r,t,e,n=Bt)=>{switch(r.op){case"EuclideanNorm":return[n.euclideanNorm(_("x",r,t,e),_("axis",r,t,e),_("keepDims",r,t,e))];case"FusedBatchNorm":case"FusedBatchNormV2":return[n.batchNorm(_("x",r,t,e),_("mean",r,t,e),_("variance",r,t,e),_("offset",r,t,e),_("scale",r,t,e),_("epsilon",r,t,e))];case"FusedBatchNormV3":return[n.batchNorm(_("x",r,t,e),_("mean",r,t,e),_("variance",r,t,e),_("offset",r,t,e),_("scale",r,t,e),_("epsilon",r,t,e))];case"LRN":return[n.localResponseNormalization(_("x",r,t,e),_("radius",r,t,e),_("bias",r,t,e),_("alpha",r,t,e),_("beta",r,t,e))];case"Softmax":return[n.softmax(_("x",r,t,e))];case"LogSoftmax":return[n.logSoftmax(_("x",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var Z4=(r,t,e,n=Bt)=>{switch(r.op){case"RaggedGather":{let{outputNestedSplits:o,outputDenseValues:s}=n.raggedGather(_("paramsNestedSplits",r,t,e),_("paramsDenseValues",r,t,e),_("indices",r,t,e),_("outputRaggedRank",r,t,e));return o.concat(s)}case"RaggedRange":{let{rtNestedSplits:o,rtDenseValues:s}=n.raggedRange(_("starts",r,t,e),_("limits",r,t,e),_("splits",r,t,e));return[o,s]}case"RaggedTensorToTensor":return[n.raggedTensorToTensor(_("shape",r,t,e),_("values",r,t,e),_("defaultValue",r,t,e),_("rowPartitionTensors",r,t,e),_("rowPartitionTypes",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var Q4=(r,t,e,n=Bt)=>{switch(r.op){case"Max":{let a=_("axis",r,t,e),u=_("keepDims",r,t,e);return[n.max(_("x",r,t,e),a,u)]}case"Mean":{let a=_("axis",r,t,e),u=_("keepDims",r,t,e);return[n.mean(_("x",r,t,e),a,u)]}case"Min":{let a=_("axis",r,t,e),u=_("keepDims",r,t,e);return[n.min(_("x",r,t,e),a,u)]}case"Sum":{let a=_("axis",r,t,e),u=_("keepDims",r,t,e);return[n.sum(_("x",r,t,e),a,u)]}case"All":{let a=_("axis",r,t,e),u=_("keepDims",r,t,e);return[n.all(_("x",r,t,e),a,u)]}case"Any":{let a=_("axis",r,t,e),u=_("keepDims",r,t,e);return[n.any(_("x",r,t,e),a,u)]}case"ArgMax":{let a=_("axis",r,t,e);return[n.argMax(_("x",r,t,e),a)]}case"ArgMin":{let a=_("axis",r,t,e);return[n.argMin(_("x",r,t,e),a)]}case"Prod":{let a=_("axis",r,t,e),u=_("keepDims",r,t,e);return[n.prod(_("x",r,t,e),a,u)]}case"Cumprod":{let a=_("axis",r,t,e),u=_("exclusive",r,t,e),l=_("reverse",r,t,e);return[n.cumprod(_("x",r,t,e),a,u,l)]}case"Cumsum":{let a=_("axis",r,t,e),u=_("exclusive",r,t,e),l=_("reverse",r,t,e);return[n.cumsum(_("x",r,t,e),a,u,l)]}case"Bincount":let o=_("x",r,t,e),s=_("weights",r,t,e),i=_("size",r,t,e);return[n.bincount(o,s,i)];case"DenseBincount":{let a=_("x",r,t,e),u=_("weights",r,t,e),l=_("size",r,t,e),c=_("binaryOutput",r,t,e);return[n.denseBincount(a,u,l,c)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var J4=(r,t,e,n=Bt)=>{switch(r.op){case"ConcatV2":case"Concat":{let o=_("n",r,t,e),s=_("axis",r,t,e),i=_("tensors",r,t,e);return i=i.slice(0,o),[n.concat(i,s)]}case"Gather":{let o=_("x",r,t,e),s=_("indices",r,t,e);return[n.gather(o,n.cast(s,"int32"),0)]}case"GatherV2":{let o=_("axis",r,t,e),s=_("batchDims",r,t,e),i=_("x",r,t,e),a=_("indices",r,t,e);return[n.gather(i,n.cast(a,"int32"),o,s)]}case"Reverse":{let o=_("dims",r,t,e),s=[];for(let a=0;a<o.length;a++)o[a]&&s.push(a);let i=_("x",r,t,e);return[n.reverse(i,s)]}case"ReverseV2":{let o=_("axis",r,t,e),s=_("x",r,t,e);return[n.reverse(s,o)]}case"Slice":{let o=_("begin",r,t,e),s=_("size",r,t,e);return[n.slice(_("x",r,t,e),o,s)]}case"StridedSlice":{let o=_("begin",r,t,e),s=_("end",r,t,e),i=_("strides",r,t,e),a=_("beginMask",r,t,e),u=_("endMask",r,t,e),l=_("ellipsisMask",r,t,e),c=_("newAxisMask",r,t,e),p=_("shrinkAxisMask",r,t,e),d=_("x",r,t,e);return[n.stridedSlice(d,o,s,i,a,u,l,c,p)]}case"Pack":return X(()=>{let o=_("axis",r,t,e),s=_("tensors",r,t,e),i=s[0].shape,a=n.squeeze(s[0]).shape,u=s.map(l=>{let c=b.arraysEqual(l.shape,i);if(!c&&!b.arraysEqual(n.squeeze(l).shape,a))throw new Error("the input tensors shape does not match");return c?l:n.reshape(l,i)});return[n.stack(u,o)]});case"Unpack":{let o=_("axis",r,t,e),s=_("tensor",r,t,e);return n.unstack(s,o)}case"Tile":{let o=_("reps",r,t,e);return[n.tile(_("x",r,t,e),o)]}case"Split":case"SplitV":{let o=_("axis",r,t,e),s=_("numOrSizeSplits",r,t,e),i=_("x",r,t,e);return n.split(i,s,o)}case"ScatterNd":{let o=_("indices",r,t,e),s=_("values",r,t,e),i=_("shape",r,t,e);return[n.scatterND(o,s,i)]}case"GatherNd":{let o=_("x",r,t,e),s=_("indices",r,t,e);return[n.gatherND(o,s)]}case"SparseToDense":{let o=_("sparseIndices",r,t,e),s=_("outputShape",r,t,e),i=_("sparseValues",r,t,e),a=_("defaultValue",r,t,e);return[n.sparseToDense(o,i,s,i.dtype===a.dtype?a:n.cast(a,i.dtype))]}case"TensorScatterUpdate":{let o=_("indices",r,t,e),s=_("values",r,t,e),i=_("tensor",r,t,e);return[n.tensorScatterUpdate(i,o,s)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var ej=(r,t,e,n=Bt)=>{switch(r.op){case"SparseFillEmptyRows":{let{outputIndices:o,outputValues:s,emptyRowIndicator:i,reverseIndexMap:a}=n.sparse.sparseFillEmptyRows(_("indices",r,t,e),_("values",r,t,e),_("denseShape",r,t,e),_("defaultValue",r,t,e));return[o,s,i,a]}case"SparseReshape":{let{outputIndices:o,outputShape:s}=n.sparse.sparseReshape(_("inputIndices",r,t,e),_("inputShape",r,t,e),_("newShape",r,t,e));return[o,s]}case"SparseSegmentMean":return[n.sparse.sparseSegmentMean(_("data",r,t,e),_("indices",r,t,e),_("segmentIds",r,t,e))];case"SparseSegmentSum":return[n.sparse.sparseSegmentSum(_("data",r,t,e),_("indices",r,t,e),_("segmentIds",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var tj=(r,t,e,n=Bt)=>{switch(r.op){case"FFT":return[n.fft(_("x",r,t,e))];case"IFFT":return[n.ifft(_("x",r,t,e))];case"RFFT":return[n.rfft(_("x",r,t,e))];case"IRFFT":return[n.irfft(_("x",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var rj=(r,t,e,n=Bt)=>{switch(r.op){case"StaticRegexReplace":return[n.string.staticRegexReplace(_("input",r,t,e),_("pattern",r,t,e),_("rewrite",r,t,e),_("replaceGlobal",r,t,e))];case"StringNGrams":{let{nGrams:o,nGramsSplits:s}=n.string.stringNGrams(_("data",r,t,e),_("dataSplits",r,t,e),_("separator",r,t,e),_("nGramWidths",r,t,e),_("leftPad",r,t,e),_("rightPad",r,t,e),_("padWidth",r,t,e),_("preserveShortSequences",r,t,e));return[o,s]}case"StringSplit":{let{indices:o,values:s,shape:i}=n.string.stringSplit(_("input",r,t,e),_("delimiter",r,t,e),_("skipEmpty",r,t,e));return[o,s,i]}case"StringToHashBucketFast":return[n.string.stringToHashBucketFast(_("input",r,t,e),_("numBuckets",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var nj=(r,t,e,n=Bt)=>{switch(r.op){case"Cast":return[n.cast(_("x",r,t,e),_("dtype",r,t,e))];case"ExpandDims":{let o=_("axis",r,t,e);return[n.expandDims(_("x",r,t,e),o)]}case"Squeeze":{let o=_("axis",r,t,e);return[n.squeeze(_("x",r,t,e),o)]}case"Reshape":return[n.reshape(_("x",r,t,e),_("shape",r,t,e))];case"EnsureShape":return[n.ensureShape(_("x",r,t,e),_("shape",r,t,e))];case"MirrorPad":return[n.mirrorPad(_("x",r,t,e),_("padding",r,t,e),_("mode",r,t,e))];case"PadV2":case"Pad":return[n.pad(_("x",r,t,e),_("padding",r,t,e),_("constantValue",r,t,e))];case"SpaceToBatchND":{let o=_("blockShape",r,t,e),s=_("paddings",r,t,e);return[n.spaceToBatchND(_("x",r,t,e),o,s)]}case"BatchToSpaceND":{let o=_("blockShape",r,t,e),s=_("crops",r,t,e);return[n.batchToSpaceND(_("x",r,t,e),o,s)]}case"DepthToSpace":{let o=_("blockSize",r,t,e),s=_("dataFormat",r,t,e).toUpperCase();return[n.depthToSpace(_("x",r,t,e),o,s)]}case"BroadcastTo":return[n.broadcastTo(_("x",r,t,e),_("shape",r,t,e))];case"BroadcastArgs":return[n.broadcastArgs(_("s0",r,t,e),_("s1",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function LO(r,t,e,n,o=X){let s=((i,a,u)=>{switch(i.category){case"arithmetic":return o(()=>R4(i,a,u));case"basic_math":return o(()=>O4(i,a,u));case"control":return z4(i,a,u);case"convolution":return o(()=>V4(i,a,u));case"creation":return o(()=>U4(i,a,u));case"dynamic":return G4(i,a,u);case"evaluation":return o(()=>W4(i,a,u));case"image":return o(()=>q4(i,a,u));case"graph":return o(()=>j4(i,a,u));case"logical":return o(()=>K4(i,a,u));case"matrices":return o(()=>X4(i,a,u));case"normalization":return o(()=>Y4(i,a,u));case"ragged":return o(()=>Z4(i,a,u));case"reduction":return o(()=>Q4(i,a,u));case"slice_join":return o(()=>J4(i,a,u));case"sparse":return o(()=>ej(i,a,u));case"spectral":return o(()=>tj(i,a,u));case"string":return o(()=>rj(i,a,u));case"transformation":return o(()=>nj(i,a,u));case"hash_table":return H4(i,a,u,n);case"custom":let l=EI(i.op);if(l&&l.customExecutor)return l.customExecutor(new zI(i,a,u));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(r,t,e);return b.isPromise(s)?s.then(i=>[].concat(i)):[].concat(s)}var lb=class{constructor(t={},e={},n={},o={},s){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=n,this.functionMap=o,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let t=[];for(let e=0;e<this.contexts.length-1;e++){let n=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(n))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>e.id===0&&e.iterationId===0?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(let e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(let e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}};function zO(r,t,e,n){let o=new Set,s=[],i=null,a=null,u=new Set,l=new Set(Object.keys(r).map(d=>Po(d)[0]));n=n||[];let c=new Set(n.map(d=>Po(d.name)[0])),p=[...t];for(;p.length>0;){let d=p.pop();if((Wd(d)||N0e(d)||D0e(d))&&i==null&&(i=d,a=i.children.map(f=>f.name).filter(f=>o.has(f))),o.add(d.name),e[d.name]==null&&!l.has(d.name)&&!c.has(d.name)){if(d.inputs.length===0){s.push(d.name);continue}d.inputs.forEach(f=>{u.has(f.name)||(u.add(f.name),p.push(f))})}}return{inputs:r,outputs:t,usedNodes:o,missingInputs:s,dynamicNode:i,syncInputs:a}}function oj(r,t){let{usedNodes:e,inputs:n}=t,o=Object.keys(n).map(g=>Po(g)[0]).map(g=>r.nodes[g]),s=r.initNodes||[],i=g=>e.has(typeof g=="string"?g:g.name);function a(g){return[...new Map(g.map(y=>[y.name,y])).values()]}let u=a([...o,...r.weights,...s]).filter(i),l=a([...u,...Object.values(r.nodes)]).filter(i),c=new Map(l.map(g=>[g.name,g])),p={};for(let g of l){p[g.name]=p[g.name]||0;for(let y of g.children)i(y)||(p[y.name]=Number.POSITIVE_INFINITY),p[y.name]=(p[y.name]||0)+1}let d=Object.entries(p).filter(([,g])=>g===0).map(([g])=>g),f=[...d];for(;d.length>0;){let g=d.pop(),y=c.get(g);for(let x of y.children.filter(i))--p[x.name]===0&&(f.push(x.name),d.push(x.name))}let h=f.map(g=>c.get(g)),m=I0e(h,u);return T0e(m,u),m}function I0e(r,t){let e=new Map(r.map(i=>[i.name,i])),n=t.map(i=>i.name),o=new Set(n);for(;n.length>0;){let i=n.pop(),a=e.get(i);for(let u of a.children)!e.has(u.name)||o.has(u.name)||(o.add(u.name),n.push(u.name))}return r.filter(i=>o.has(i.name))}var my=class extends Error{constructor(t){super(`NodesExecutionOrderError: ${t}`)}};function T0e(r,t){let e=new Map(r.map((a,u)=>[a.name,u])),n=new Set(t.map(a=>a.name)),o=a=>n.has(typeof a=="string"?a:a.name),s=new Set(r.map(a=>a.name)),i=a=>s.has(typeof a=="string"?a:a.name);for(let a of r){for(let u of a.children.filter(i)){if(!e.has(u.name))throw new my(`Child ${u.name} of node ${a.name} is unreachable.`);if(e.get(a.name)>e.get(u.name))throw new my(`Node ${a.name} is scheduled to run after its child ${u.name}.`)}if(!o(a))for(let u of a.inputs){if(!e.has(u.name))throw new my(`Input ${u.name} of node ${a.name} is unreachable.`);if(e.get(u.name)>e.get(a.name))throw new my(`Node ${a.name} is scheduled to run before its input ${u.name}.`)}}}function sj(r){let t=new Map(r.map((a,u)=>[a.name,u])),e=Number.MAX_SAFE_INTEGER,n=r.map((a,u)=>Wd(a)?e:u),o=a=>{let u=n[t.get(a.name)];return u??-1},s=r.map((a,u)=>a.children.map(o).reduce((l,c)=>Math.max(l,c),n[u])),i=new Map;for(let a=0;a<r.length;++a){let u=s[a];if(u===e)continue;let l=r[a],c=r[u];i.has(c.name)||i.set(c.name,[]),i.get(c.name).push(l)}return i}var _0e=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),E0e=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),k0e=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Wd(r){return _0e.has(r.op)}function N0e(r){return E0e.has(r.op)}function D0e(r){return k0e.has(r.op)}var cb=class r{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let e=Object.keys(t).map(n=>t[n].map(o=>o.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(n=>{this._functionExecutorMap[n]=new r(t.functions[n],this)})}getCompilationKey(t,e){let n=t.map(s=>s.name).sort(),o=e.map(s=>s.name).sort();return n.join(this.SEPARATOR)+"--"+o.join(this.SEPARATOR)}compile(t,e){let n=zO(t,e,this.weightMap,this._initNodes),{missingInputs:o,dynamicNode:s,syncInputs:i}=n;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(o.length>0){let l=e.map(p=>p.name),c=Object.keys(t);throw new Error(`Cannot compute the outputs [${l}] from the provided inputs [${c}]. Missing the following inputs: [${o}]`)}let a=oj(this.graph,n),u=sj(a);return{orderedNodes:a,nodeLiveUntilMap:u}}cloneAndKeepTensor(t){if(t==null)return null;let e=t.clone();return Ar(e),e}cloneTensorList(t){return t?t.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([e,n])=>[e,this.cloneTensorList(n)]))}execute(t,e){this.disposeIntermediateTensors(),t=this.mapInputs(t);let n=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);let o=n.map(d=>this.graph.nodes[Po(d)[0]]),s=e.map(d=>Po(d)[0]),i=new Set(s),a=s.map(d=>this.graph.nodes[d]);a.length===0&&(a=this._outputs);let u=this.getCompilationKey(o,a),l=this.compiledMap.get(u);l==null&&(l=this.compile(t,a),this.compiledMap.set(u,l));try{this.keepIntermediateTensors=j().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}let c={},p={};return X(()=>{let d=new lb(this.weightMap,c,p,this.functionExecutorMap,this.parseNodeNameCache),f=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(y=>{let[x,w]=Po(y,d),C=[];C[w]=t[y],f[x]=C,this.keepIntermediateTensors&&(this.clonedTensorsMap[x]=this.cloneTensorList(C))});let h=this.getFrozenTensorIds(f),{orderedNodes:m,nodeLiveUntilMap:g}=l;for(let y of m){if(f[y.name])continue;let x=LO(y,f,d,this._resourceManager);if(b.isPromise(x))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);f[y.name]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(x)),this.checkTensorForDisposalWithNodeLiveUntilInfo(y,f,d,h,i,g.get(y.name))}return this.parent==null&&d.dispose(h),e.map(y=>xn(y,f,d))})}getFrozenTensorIds(t){let e=[].concat.apply([],Object.keys(t).map(n=>t[n]).map(n=>n.map(o=>o.id)));return new Set(e)}checkTensorForDisposal(t,e,n,o,s,i,a){if(!(Wd(e)||i.has(t))){for(let u of n[t])u!=null&&(a[u.id]=(a[u.id]||0)+e.children.length);for(let u of e.inputs){if(Wd(u))continue;let l=gO(u.name,n,o);if(l!=null)for(let c of l){if(!c||c.kept||s.has(c.id))continue;let p=a[c.id];p===1?(c.dispose(),delete a[c.id]):p!=null&&a[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,e,n,o,s,i){function a(u){return Wd(u)||s.has(u.name)}if(!(Wd(t)||i==null))for(let u of i){if(a(u))continue;let l=gO(u.name,e,n);for(let c of l)!c||c.kept||o.has(c.id)||c.dispose()}}executeAsync(t,e){return L(this,null,function*(){return this._executeAsync(t,e)})}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(let e of t)e&&!e.isDisposed&&e.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}_executeAsync(i,a){return L(this,arguments,function*(t,e,n=!1,o={},s={}){this.disposeIntermediateTensors(),n||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e));try{this.keepIntermediateTensors=j().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}let u=new lb(this.weightMap,o,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let l=yield this.executeWithControlFlow(t,u,e,n),c=e.map(h=>xn(h,l,u)),p=c.map(h=>h.id),d=Object.keys(t).map(h=>t[h].id),f=new Set([...p,...d,...this.weightIds]);return Object.values(l).forEach(h=>{h.forEach(m=>{m&&!m.isDisposed&&!f.has(m.id)&&m.dispose()})}),this.parent==null&&u.dispose(f),c})}executeFunctionAsync(t,e,n){return L(this,null,function*(){let o=t.reduce((s,i,a)=>(s[this.inputs[a].name]=i,s),{});return this._executeAsync(o,this.outputNodes,!0,e,n)})}executeWithControlFlow(t,e,n,o){return L(this,null,function*(){let s=Object.keys(t),i=s.map(C=>this.graph.nodes[Po(C)[0]]),a=n.map(C=>Po(C)[0]),u=new Set(a),l=a.map(C=>this.graph.nodes[C]);l.length===0&&(l=this._outputs);let{usedNodes:c,missingInputs:p,dynamicNode:d,syncInputs:f}=zO(t,l,this.weightMap,this._initNodes),h=[...i,...this.graph.weights,...this._initNodes||[]].map(C=>({node:C,contexts:e.currentContext})),m=Object.assign({},this.weightMap);Object.keys(t).forEach(C=>{let[I,N]=Po(C),A=[];A[N]=t[C],m[I]=A});let g={},y=this.getFrozenTensorIds(m),x={};for(;h.length>0;){let C=this.processStack(i,h,e,m,x,y,u,g,c);yield Promise.all(C)}d==null&&!o&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let w=l.filter(C=>!Wd(C)&&!xn(C.name,m,e)).map(C=>C.name);if(w.length>0){let C="";throw d!=null&&(C=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${f}]`),new Error(`Cannot compute the outputs [${w}] from the provided inputs [${s}]. Consider providing the following inputs: [${p}]. ${C}`)}return m})}processStack(t,e,n,o,s,i,a,u,l){let c=[];for(;e.length>0;){let p=e.pop();n.currentContext=p.contexts;let d="";if(p.node.op==="Enter"&&_("isConstant",p.node,o,n)&&([d]=Za(p.node.name,n)),o[p.node.name]==null){let f=LO(p.node,o,n,this._resourceManager);d||([d]=Za(p.node.name,n));let h=n.currentContext;b.isPromise(f)?c.push(f.then(m=>(o[d]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(m)),n.currentContext=h,this.checkTensorForDisposal(d,p.node,o,n,i,a,u),this.processChildNodes(p.node,e,n,o,s,l),m))):(o[d]=f,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(f)),this.checkTensorForDisposal(d,p.node,o,n,i,a,u),this.processChildNodes(p.node,e,n,o,s,l))}else this.processChildNodes(p.node,e,n,o,s,l)}return c}processChildNodes(t,e,n,o,s,i){t.children.forEach(a=>{let[u]=Za(a.name,n);s[u]||!i.has(a.name)||(a.op==="Merge"?a.inputNames.some(l=>!!xn(l,o,n))&&(s[u]=!0,e.push({contexts:n.currentContext,node:a})):a.inputNames.every(l=>!!xn(l,o,n))&&(s[u]=!0,e.push({contexts:n.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{let n=t[e],[o]=Po(e),s=this.graph.nodes[o];if(s.attrParams.shape&&s.attrParams.shape.value){let i=s.attrParams.shape.value,a=i.length===n.shape.length&&n.shape.every((u,l)=>i[l]===-1||i[l]===u);b.assert(a,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&b.assert(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(t){var e,n;let o={};for(let s in t){let i=(n=(e=this._signature)===null||e===void 0?void 0:e.inputs)===null||n===void 0?void 0:n[s];i!=null?o[i.name]=t[s]:o[s]=t[s]}return o}checkInputs(t){let e=Object.keys(t).filter(n=>{let[o]=Po(n);return this.graph.nodes[o]==null});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>{var n,o;let s=(o=(n=this._signature)===null||n===void 0?void 0:n.outputs)===null||o===void 0?void 0:o[e];return s!=null?s.name:e},{})}checkOutputs(t){t.forEach(e=>{let[n]=Po(e);if(!this.graph.nodes[n])throw new Error(`The output '${e}' is not found in the graph`)})}};var GI=class{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(let t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(let t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}};var A0e="?tfjs-format=file",R0e="model.json",WI=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t,e={},n=Ya){this.modelUrl=t,this.loadOptions=e,this.version="n/a",this.io=n,e==null&&(this.loadOptions={}),this.resourceManager=new GI}findIOHandler(){let t=this.modelUrl;if(t.load!=null)this.handler=t;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{let e=this.io.getLoadHandlers(t,this.loadOptions);if(e.length===0)e.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let t=this.handler.load();return b.isPromise(t)?t.then(e=>e.getWeightStream==null?this.loadSync(e):this.loadStreaming(e)):this.loadSync(t)}loadSync(t){let e=this.io.decodeWeights(t.weightData,t.weightSpecs);return this.loadWithWeightMap(t,e)}loadStreaming(t){return L(this,null,function*(){if(t.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");let e=yield uS(t.getWeightStream(),t.weightSpecs);return this.loadWithWeightMap(t,e)})}loadWithWeightMap(t,e){this.artifacts=t;let n=this.artifacts.modelTopology,o=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let s=this.artifacts.userDefinedMetadata;s.signature!=null&&(o=s.signature),s.structuredOutputKeys!=null&&(this.structuredOutputKeys=s.structuredOutputKeys)}if(this.signature=o,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new cb(ub.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(e),this.executor.resourceManager=this.resourceManager,t.modelInitializer!=null&&t.modelInitializer.node!=null){let s=ub.Instance.transformGraph(t.modelInitializer);this.initializer=new cb(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}save(t,e){return L(this,null,function*(){if(typeof t=="string"){let n=this.io.getSaveHandlers(t);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${t}'`);t=n[0]}if(t.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)})}addStructuredOutputNames(t){if(this.structuredOutputKeys){let e=t instanceof ct?[t]:t,n={};return e.forEach((o,s)=>n[this.structuredOutputKeys[s]]=o),n}return t}predict(t,e){let n=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(n)}predictAsync(t,e){return L(this,null,function*(){let n=yield this.executeAsync(t,this.outputNodes);return this.addStructuredOutputNames(n)})}normalizeInputs(t){var e;if(!(t instanceof ct)&&!Array.isArray(t)){let s=(e=this.signature)===null||e===void 0?void 0:e.inputs;if(s!=null)for(let i in s){let a=s[i];a.resourceId!=null&&(t[i]=this.resourceIdToCapturedInput[a.resourceId])}return t}t=Array.isArray(t)?t:[t];let n=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${t.length} input tensors provided.`);let o=0;return this.inputNodes.reduce((s,i)=>{var a,u,l;let c=(l=(u=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||u===void 0?void 0:u[i])===null||l===void 0?void 0:l.resourceId;return c!=null?s[i]=this.resourceIdToCapturedInput[c]:s[i]=t[o++],s},{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}executeInitializerGraphAsync(){return L(this,null,function*(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))})}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){let e=this.initializerSignature.outputs,n=Object.keys(e);for(let o=0;o<n.length;o++){let s=n[o],i=e[s];this.resourceIdToCapturedInput[i.resourceId]=t[o]}}}execute(t,e){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);let n=this.executor.execute(t,e);return n.length>1?n:n[0]}executeAsync(t,e){return L(this,null,function*(){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(yield this.executeInitializerGraphAsync()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);let n=yield this.executor.executeAsync(t,e);return n.length>1?n:n[0]})}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,n)=>(e[n]=[t[n]],e),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&$e(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};function jd(n){return L(this,arguments,function*(r,t={},e=Ya){if(r==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof r=="string"&&(r=O0e(r));let o=new WI(r,t,e);return yield o.load(),o})}function O0e(r){return r.endsWith("/")||(r=r+"/"),`${r}${R0e}${A0e}`}var Ks=j();Ks.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);Ks.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);Ks.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);Ks.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0);Ks.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);Ks.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);Ks.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);Ks.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);Ks.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);Ks.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1);Ks.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);Ks.registerFlag("WEBGPU_PRINT_SHADER",()=>"");Ks.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);var jI=class{constructor(t){t&&(this.vendor=t.vendor,this.architecture=t.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}};var HI=class{constructor(t){this.device=t,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(t,e,n=!1,o=!0){let s,i=ij(t,e);return o?(this.freeBuffers.has(i)||this.freeBuffers.set(i,[]),this.freeBuffers.get(i).length>0?(s=this.freeBuffers.get(i).pop(),this.numFreeBuffers--):(s=this.device.createBuffer({size:t,usage:e,mappedAtCreation:n}),this.numBytesAllocated+=t)):(s=this.device.createBuffer({size:t,usage:e,mappedAtCreation:n}),this.numBytesAllocated+=t),this.usedBuffers.has(i)||this.usedBuffers.set(i,[]),this.usedBuffers.get(i).push(s),this.numUsedBuffers++,this.numBytesUsed+=t,s}releaseBuffer(t,e=!0){if(this.freeBuffers.size===0)return;let n=t.size,o=t.usage,s=ij(n,o),i=this.usedBuffers.get(s),a=i.indexOf(t);if(a<0)throw new Error("Cannot find the buffer in buffer manager");i[a]=i[i.length-1],i.pop(),this.numUsedBuffers--,this.numBytesUsed-=n,e?(this.freeBuffers.get(s).push(t),this.numFreeBuffers++):(t.destroy(),this.numBytesAllocated-=n)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((t,e)=>{t.forEach(n=>{n.destroy()})}),this.usedBuffers.forEach((t,e)=>{t.forEach(n=>{n.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}};function ij(r,t){return`${r}_${t}`}var qI=class{constructor(t){this.device=t,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(t,e,n,o){let s=uj(n),i=t*e*s,a=aj(t,e,n,o);if(this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.usedTextures.has(a)||this.usedTextures.set(a,[]),this.numBytesUsed+=i,this.numUsedTextures++,this.freeTextures.get(a).length>0){this.numFreeTextures--;let l=this.freeTextures.get(a).shift();return this.usedTextures.get(a).push(l),l}this.numBytesAllocated+=i;let u=this.device.createTexture({size:[t,e],format:n,usage:o});return this.usedTextures.get(a).push(u),u}releaseTexture(t){if(this.freeTextures.size===0)return;let e=t.width,n=t.height,o=t.format,s=t.usage,i=aj(e,n,o,s);this.freeTextures.has(i)||this.freeTextures.set(i,[]),this.freeTextures.get(i).push(t),this.numFreeTextures++,this.numUsedTextures--;let a=this.usedTextures.get(i),u=a.indexOf(t);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(u,1);let l=uj(o),c=e*n*l;this.numBytesUsed-=c}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((t,e)=>{t.forEach(n=>{n.destroy()})}),this.usedTextures.forEach((t,e)=>{t.forEach(n=>{n.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}};function aj(r,t,e,n){return`${r}_${t}_${e}_${n}`}function uj(r){if(r==="rgba8unorm")return 16;throw new Error(`${r} is not supported!`)}function lj(r,t){if(Math.max(...r)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");let e=r.length,n="xyzwuv",o=r.map(i=>`${t}.${n[i]}`),s=new Array(e-1);s[e-2]=o[e-1];for(let i=e-3;i>=0;--i)s[i]=`(${s[i+1]} * ${o[i+1]})`;return s}var Ts=(r,t,e)=>e==="int32"?`atomicAdd(${r}, bitcast<i32>(${t}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${t});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${r}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;var qd=function(r){return r[r.FROM_PIXELS=0]="FROM_PIXELS",r[r.DRAW=1]="DRAW",r}(qd||{}),fj=(r,t,e,n,o)=>{let s={dtype:n.dtype,shape:n.shape},i=$0e(e,s,t),a=r.createShaderModule({code:i,label:t.constructor.name}),u=j().get("WEBGPU_PRINT_SHADER");if(u!==""){u=u.toLowerCase();let l=u.split(",");(u==="all"||l.some(c=>t.shaderKey.toLowerCase().includes(c)))&&(console.group(t.shaderKey),console.debug(i),console.groupEnd())}return o?r.createComputePipelineAsync({compute:{module:a,entryPoint:"_start"},label:t.constructor.name,layout:"auto"}):r.createComputePipeline({compute:{module:a,entryPoint:"_start"},label:t.constructor.name,layout:"auto"})},xt=(r,t="f32")=>{switch(r){case 1:return`${t}`;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${r}-component ${t} is not supported.`)}};function Dr(r){if(r<=1)return"i32";if(r===2)return"vec2<i32>";if(r===3)return"vec3<i32>";if(r===4)return"vec4<i32>";if(r===5)return"vec5";if(r===6)return"vec6";throw Error(`GPU for rank ${r} is not yet supported`)}function Ii(r){if(r===0)return"x";if(r===1)return"y";if(r===2)return"z";if(r===3)return"w";if(r===4)return"u";if(r===5)return"v";throw Error(`Index ${r} is not yet supported`)}function oe(...r){let t;switch(r.length){case 0:t=`
        fn main()
      `;break;case 1:t=`
        fn main(${r[0]} : i32)
      `;break;default:throw Error("Unreachable")}return t}function cj(r,t){let e;return e=`
     ${F0e(t)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${r?"main(getGlobalIndex());":"main();"};
      }
    `,e}function F0e(r){return`
  @compute @workgroup_size(${r.workgroupSize[0]}, ${r.workgroupSize[1]}, ${r.workgroupSize[2]})
`}function $0e(r,t,e){let n=[],o=e.workgroupSize[0]*e.workgroupSize[1]*e.workgroupSize[2];if(e.outputComponent=e.outputComponent?e.outputComponent:1,n.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${mj(e)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${o}u +
                localIndex);
        `}
      }
    `),e.pixelsOpType!=null){let h=e.pixelsOpType===qd.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${Hd(t.dtype,e.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${Hd(r[0].dtype,e.outputComponent)}>;`,m=t.shape.length===3?"vec2<i32>":"i32";n.push(`
        struct Uniform {
          outShapeStrides : ${m},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${h}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);let g=dj(e);return[pj,n.join(`
`),pb(t.shape),e.getUserCode(),cj(g,e)].join(`
`)}let s,i,a="struct Uniforms { NAN : f32, INFINITY : f32, ";e.variableNames.forEach((h,m)=>{let g=Dr(r[m].shape.length);a+=`${h.charAt(0).toLowerCase()+h.slice(1)}Shape : ${g}, `,s=r[m].shape.length-1,i=Dr(s),a+=`${h.charAt(0).toLowerCase()+h.slice(1)}ShapeStrides: ${i}, `});let u=Dr(t.shape.length);a+=`outShape : ${u}, `,s=t.shape.length-1,i=Dr(s),a+=`
         outShapeStrides: ${i}, `,e.size&&(a+="size : i32, "),e.uniforms&&(a+=e.uniforms),a+="};",a=W0e(a),n.push(a),e.atomic?n.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):n.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${Hd(t.dtype,e.outputComponent)}>;
    `),e.variableNames.forEach((h,m)=>{n.push(`
      @group(0) @binding(${1+m}) var<storage, read> ${h}: array<${e.variableComponents?Hd(r[m].dtype,e.variableComponents[m]):Hd(r[m].dtype,e.outputComponent)}>;
        `)}),a!==""&&n.push(`
      @group(0) @binding(${1+e.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);let l=V0e(t.shape,e.dispatchLayout),c=[pj,n.join(`
`)+P0e,pb(t.shape),l,U0e(t.shape.length)];e.atomic||c.push(G0e(t.shape,t.dtype,e.outputComponent)),e.variableNames.forEach((h,m)=>{c.push(`${pb(r[m].shape,h)}`)});let p=r.map((h,m)=>B0e(h,t.shape,e.variableComponents?e.variableComponents[m]:e.outputComponent,e.dispatchLayout.x.length===t.shape.length)).join(`
`);c.push(p),c.push(e.getUserCode());let d=dj(e);return c.push(cj(d,e)),c.join(`
`)}function hj(r,t,e){let n=r.shaderKey;if(r.pixelsOpType!=null)return n;let o=[],s=[];t.forEach(c=>{o.push(c.shape),s.push(c.dtype)}),o.push(e.shape),s.push(e.dtype);let i=t.map(c=>T.getBroadcastDims(c.shape,e.shape)),a=t.map(c=>b.arraysEqual(c.shape,e.shape)).join("_"),u=i.map(c=>c.join("_")).join(";"),l=mj(r)?"flatDispatch":"";return n+="_"+(r.workgroupSize?r.workgroupSize.join(","):"")+o.map(c=>c.length).join(",")+s.join(",")+r.variableNames.join(",")+u+a+l,n}var pj=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,P0e=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function pb(r,t=""){let e=r.length,n=t!==""?`get${t.charAt(0).toUpperCase()+t.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",o=t!==""?`${t.charAt(0).toLowerCase()+t.slice(1)}ShapeStrides`:"outShapeStrides";if(e<=1)return`fn ${n}(index : i32) -> i32 { return index; }`;let s=b.computeStrides(r),i=Dr(e),a=[];for(let l=0;l<e;l++)a.push(`d${l}`);if(s.length===1)return`    fn ${n}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${o}; let d1 = index - d0 * uniforms.${o};
      return vec2<i32>(d0, d1);
    }`;let u;return u="var index2 = index;"+s.map((l,c)=>{let p=`let ${a[c]} = index2 / uniforms.${o}.${Ii(c)}`,d=c===s.length-1?`let ${a[c+1]} = index2 - ${a[c]} * uniforms.${o}.${Ii(c)}`:`index2 = index2 - ${a[c]} * uniforms.${o}.${Ii(c)}`;return`${p}; ${d};`}).join(""),`
    fn ${n}(index : i32) -> ${i} {
      ${u}
      return ${i}(${a.join(",")});
    }
  `}function L0e(r,t){let e=r.name,n=r.shape.length,o=Dr(n),s="get"+e.charAt(0).toUpperCase()+e.slice(1),i=["d0","d1","d2","d3","d4","d5"].slice(0,n),a=i.map(c=>`${c} : i32`).join(", ");if(n<1)return`
      fn ${s}() -> ${xt(t)} {
        return ${xt(t)}(${e}[0]);
      }
    `;let u=`uniforms.${e.charAt(0).toLowerCase()+e.slice(1)}Shape`,l=`${n}D`;return n===0&&(l="1D"),`
    fn ${s}(${a}) -> ${xt(t)} {
      return ${xt(t)}(${e}[getIndexFromCoords${l}(${o}(${i.join(",")}),
        ${u})${t===1?"":` / ${t}`}]);
    }
   `}function z0e(r,t,e,n){let o=r.name,s=o.charAt(0).toUpperCase()+o.slice(1),i="get"+s+"ByOutput",a=r.shape.length,u=t.length,l=Dr(u);if(b.arraysEqual(r.shape,t)&&n)return`
    fn ${i}Index(globalIndex : i32) -> ${xt(e)} {
      return ${xt(e)}(${o}[globalIndex]);
    }

    fn ${i}Coords(coords : ${l}) -> ${xt(e)} {
      return ${xt(e)}(${o}[${u>1?"getOutputIndexFromCoords(coords)":"coords"}${e===1?"":` / ${e}`}]);
    }
    `;let c=T.getBroadcastDims(r.shape,t),p=u-a,d="";if(a===0)return`
    fn ${i}Index(globalIndex : i32) -> ${xt(e)}{
      return get${s}();
    }

    fn ${i}Coords(coords : ${l}) -> ${xt(e)}{
      return get${s}();
    }
  `;u<2&&c.length>=1?d="coords = 0;":d=c.map(g=>`coords.${Ii(g+p)} = 0;`).join(`
`);let f="";if(u<2&&a>0)f="coords";else if(u>1){let g=Dr(a),y=r.shape.map((x,w)=>`coords.${Ii(w+p)}`).join(", ");f=`${g}(${y})`}else f="coords";let h=`uniforms.${o.charAt(0).toLowerCase()+o.slice(1)}Shape`,m=`${a}D`;return`
  fn ${i}Index(globalIndex : i32) -> ${xt(e)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${d}
    return ${xt(e)}(${o}[getIndexFromCoords${m}(${f}, ${h})${e===1?"":` / ${e}`}]);
  }

  fn ${i}Coords(coordsIn : ${l}) -> ${xt(e)} {
    var coords = coordsIn;
    ${d}
    return ${xt(e)}(${o}[getIndexFromCoords${m}(${f}, ${h})${e===1?"":` / ${e}`}]);
  }
`}function B0e(r,t,e,n){let o=L0e(r,e);return r.shape.length<=t.length&&(o+=z0e(r,t,e,n)),o}function V0e(r,t){let{x:e,y:n=[],z:o=[]}=t,s=r.length,i=e.length+n.length+o.length;if(i!==s)return"";if(e.length===s)return`fn getOutputCoords() -> ${Dr(s)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let a="",u=[e,n,o];for(let d=0;d<u.length;d++){let f=u[d];if(f.length!==0)if(f.length===1)a+=`let d${f[0]} = i32(globalId[${d}]);`;else{let h=lj(f,"uniforms.outShape");a+=`var index${d} = i32(globalId[${d}]);`;for(let m=0;m<h.length;m++)a+=`let d${f[m]} = index${d} / ${h[m]};`,m===h.length-1?a+=`let d${f[m+1]} = index${d} - d${f[m]} * ${h[m]};`:a+=`index${d} = index${d} - d${f[m]} * ${h[m]};`}}let l=[];for(let d=0;d<i;d++)l.push(`d${d}`);let c=Dr(i),p=`fn getOutputCoords() -> ${c} {
  ${a}
`;return l.length===0?p+=`return ${c}(0); }`:p+=`return ${c}(${l.join(",")}); }`,p}function U0e(r){let t="";switch(r){case 0:case 1:t+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:t+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:t+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:t+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:t+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:t+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:b.assert(!1,()=>`Unsupported ${r}D shape`);break}return t}function mj(r){return r.dispatch[1]===1&&r.dispatch[2]===1}function Hd(r,t=1){if(r==="float32")return xt(t,"f32");if(r==="int32"||r==="bool")return xt(t,"i32");throw new Error(`type ${r} is not supported.`)}function G0e(r,t,e){let n=r.length,o=Hd(t,e),s=`fn setOutputAtIndex(flatIndex : i32, value : ${xt(e)}) {
      result[flatIndex] = ${o}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${xt(e,"i32")}) {
      result[flatIndex] = ${o}(value);
    }
    `;if(n>=2){let i=["d0","d1","d2","d3","d4","d5"].slice(0,n),a=Dr(n);s+=`
      fn setOutputAtCoords(${i.map(u=>`${u} : i32`).join(", ")}, value : ${xt(e)}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${i.join(", ")}));
        setOutputAtIndex(flatIndex${e===1?"":` / ${e}`}, value);
      }
      fn setOutputAtCoordsI32(${i.map(u=>`${u} : i32`).join(", ")}, value : ${xt(e,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${i.join(", ")}));
        setOutputAtIndexI32(flatIndex${e===1?"":` / ${e}`}, value);
      }
    `}return s}function W0e(r){let t=/(\w+)\s*:\s*vec(5|6)/g;r=r.replace(t,n=>"@align(16) "+n);let e=/vec(5|6)\s*,\s*(\w+)/g;return r=r.replace(e,(n,o,s)=>`vec${o}, @align(16) ${s}`),r}function dj(r){return!(r.dispatchLayout.hasOwnProperty("y")&&r.dispatchLayout.y.length!==0||r.dispatchLayout.hasOwnProperty("z")&&r.dispatchLayout.z.length!==0)}var Kd={};ur(Kd,{GPUBytesPerElement:()=>KI,MatMulProgramType:()=>Ja,assertNotComplex:()=>mb,computeDispatch:()=>se,computeWorkPerThreadForConv2d:()=>fb,computeWorkgroupInfoForMatMul:()=>BO,computeWorkgroupSizeForConv2d:()=>db,flatDispatchLayout:()=>pe,isWebGPUSupported:()=>hb,tilesFitEvenlyIntoShape:()=>H0e});var Dh=r=>{let t=1;for(let e=0;e<r.length;e++)t*=r[e];return t};function H0e(r,t){if(r.length!==t.length)throw new Error(`Cannot compute whether rank ${r.length} tiles fit evenly into rank ${t.length} shape - ranks must match.`);return t.every((e,n)=>e%r[n]===0)}function se(r,t,e=[1,1,1],n=[1,1,1]){let[o,s,i]=[Math.ceil(Dh(r.x.map(a=>t[a]))/(e[0]*n[0])),r.y?Math.ceil(Dh(r.y.map(a=>t[a]))/(e[1]*n[1])):1,r.z?Math.ceil(Dh(r.z.map(a=>t[a]))/(e[2]*n[2])):1];return[o,s,i]}function BO(r,t,e,n=!1){let o=[8,8,1],s=[4,4,1];return n||(r<=8&&(s[1]=1),t<=16&&e<=16&&(o[0]=4)),{workgroupSize:o,elementsPerThread:s}}function db(r,t,e=!1){if(e)return[8,8,1];let n=Dh(r.x.map(s=>t[s])),o=Dh(r.y.map(s=>t[s]));return n<=4?[4,16,1]:o<=4?[16,4,1]:[16,16,1]}function fb(r,t,e=!1){if(e)return[4,4,1];let n=Dh(r.x.map(s=>t[s])),o=Dh(r.y.map(s=>t[s]));return n<=4?[1,2,1]:o<=4?[2,1,1]:[2,2,1]}function pe(r){return{x:r.map((t,e)=>e)}}function KI(r){if(r==="float32"||r==="int32"||r==="bool"||r==="string")return 4;if(r==="complex64")return 8;throw new Error(`Unknown dtype ${r}`)}function hb(){return!!(typeof globalThis<"u"&&globalThis.navigator&&globalThis.navigator.gpu)}function mb(r,t){Array.isArray(r)||(r=[r]),r.forEach(e=>{e!=null&&b.assert(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGPU backend.`)})}var Ja=function(r){return r[r.MatMulReduceProgram=0]="MatMulReduceProgram",r[r.MatMulSplitKProgram=1]="MatMulSplitKProgram",r[r.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",r[r.MatMulPackedProgram=3]="MatMulPackedProgram",r[r.MatMulMax=4]="MatMulMax",r}(Ja||{});var q0e=j().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),K0e=(r,t)=>{let e=r.limits.maxComputeWorkgroupsPerDimension,n=t.dispatchLayout,o=t.dispatch;if(o.every(i=>i<=e))return o;b.assert(o[0]>e&&n.y===void 0&&n.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let s=Math.ceil(Math.sqrt(o[0]));return s>e?(s=Math.ceil(Math.cbrt(o[0])),b.assert(s<=e,()=>"Total dispatch size exceeds WebGPU maximum."),[s,s,s]):[s,s,1]},gy=(()=>{class r extends Zi{nextDataId(){return r.nextDataId++}constructor(e,n){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!hb())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new jI(n),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new HI(this.device),this.textureManager=new qI(this.device),this.tensorMap=new dc(this,Pn()),j().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e,n=!1){if(!this.tensorMap.has(e))return!0;let o=this.tensorMap.get(e);return n?o.refCount=0:o.refCount--,o.refCount>0?!1:(o.complexTensorInfos!=null&&(this.disposeData(o.complexTensorInfos.real.dataId),this.disposeData(o.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){let n=this.tensorMap.get(e);if(!(!n||!n.resource)){if(n.external){n.resource=null;return}n.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(n.resource):n.resource instanceof GPUTexture&&this.textureManager.releaseTexture(n.resource),n.resource=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){let n=this.tensorMap.get(e);n.refCount++}decRef(e){if(this.tensorMap.has(e)){let n=this.tensorMap.get(e);n.refCount--}}write(e,n,o){if(o==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let s={id:this.nextDataId()};return this.tensorMap.set(s,{dtype:o,shape:n,values:e,refCount:1}),s}move(e,n,o,s,i){if(s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:s,shape:o,values:n,refCount:i})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}checkCompileCompletionAsync(){return L(this,null,function*(){let e;try{e=yield Promise.all(Object.values(this.pipelineCache))}catch(n){throw new Error(n.message)}Object.keys(this.pipelineCache).map((n,o)=>{this.pipelineCache[n]=e[o]})})}getBufferData(e){return L(this,null,function*(){if(j().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;let n=e.size,o=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,o,0,n),this.submitQueue(),yield o.mapAsync(GPUMapMode.READ);let s=o.getMappedRange().slice(0);return o.unmap(),o!=null&&this.bufferManager.releaseBuffer(o),j().getBool("WEBGPU_USE_PROFILE_TOOL")&&(b.assert(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),s})}convertAndCacheOnCPU(e,n){let o=this.tensorMap.get(e);return o.values=n,o.values}readSync(e){let n=this.tensorMap.get(e),{values:o,complexTensorInfos:s}=n;if(o!=null||n.dtype==="string")return o;if(n.dtype==="complex64"){let g=this.readSync(s.real.dataId),y=this.readSync(s.imag.dataId),x=b.convertBackendValuesAndArrayBuffer(T.mergeRealAndImagArrays(g,y).buffer,"float32");return this.convertAndCacheOnCPU(e,x),x}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));let i=["opaque","premultiplied"],a=n.resource,u=a.size;b.assert(u%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");let l=u/4,c=new ArrayBuffer(u),p=256,d=256,f=i.map(g=>new OffscreenCanvas(p,d)),h=new OffscreenCanvas(p,d);this.endComputePassEncoder(),f.map((g,y)=>{let x=g.getContext("webgpu");return x.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:i[y]}),x.getCurrentTexture()}).map((g,y)=>{let x=p*4,w=($,z,G)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:a,bytesPerRow:x,offset:G},{texture:g},{width:$,height:z}),this.submitQueue();let K=h.getContext("2d",{willReadFrequently:!0});K.clearRect(0,0,$,z),K.drawImage(f[y],0,0);let Z=K.getImageData(0,0,$,z).data,Q=i[y],J=new Uint8ClampedArray(c,G,$*z*4);for(let te=0;te<J.length;te+=4)if(Q==="premultiplied")J[te+3]=Z[te+3];else{let ie=Z[te];J[te]=Z[te+2],J[te+1]=Z[te+1],J[te+2]=ie}},C=Math.floor(l/(p*d)),I=p,N=d,A=0;for(let $=0;$<C;$++)w(I,N,A),A+=p*d*4;let O=l%(p*d);N=Math.floor(O/p),N>0&&(w(I,N,A),A+=N*(p*4)),I=O%p,I>0&&w(I,1,A)});let m=b.convertBackendValuesAndArrayBuffer(c,n.dtype);return this.convertAndCacheOnCPU(e,m),m}read(e){return L(this,null,function*(){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);let n=this.tensorMap.get(e),{values:o}=n;if(o!=null)return o;let s;if(n.dtype==="complex64"){let i=yield Promise.all([this.read(n.complexTensorInfos.real.dataId),this.read(n.complexTensorInfos.imag.dataId)]),a=i[0],u=i[1];s=T.mergeRealAndImagArrays(a,u)}else{let i=yield this.getBufferData(n.resource);s=b.convertBackendValuesAndArrayBuffer(i,n.dtype)}return this.convertAndCacheOnCPU(e,s),s})}copyBuffer(e){let n=e.size,o=e.usage,s=this.bufferManager.acquireBuffer(n,o);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,s,0,n),this.submitQueue(),s}createTensorFromGPUData(e,n,o){let s=e.buffer;if(o==="complex64")throw new Error("Cannot write to a complex64 dtype. ");let i={id:this.nextDataId()};this.tensorMap.set(i,{dtype:o,shape:n,values:null,refCount:1,external:e.zeroCopy});let a=this.tensorMap.get(i),u=KI(a.dtype)*b.sizeFromShape(a.shape);if(e.buffer.size<u)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${u})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return e.zeroCopy!==!0&&(s=this.copyBuffer(s)),a.resource=s,Pn().makeTensorFromDataId(i,n,o,this)}readToGPU(e){let n=this.tensorMap.get(e),{values:o,dtype:s,shape:i,resource:a}=n;if(s==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(a==null)throw o!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let u=a,l=u.size,c=u.usage,p=this.bufferManager.acquireBuffer(l,c);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(a,0,p,0,l),this.submitQueue();let d=this.makeTensorInfo(i,s),f=Pn().makeTensorFromTensorInfo(d),h=this.tensorMap.get(d.dataId);return h.resource=p,{tensorRef:f,buffer:p}}bufferSync(e){let n=this.readSync(e.dataId);if(e.dtype==="string")try{let o=n.map(s=>b.decodeString(s));return Ne(e.shape,e.dtype,o)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ne(e.shape,e.dtype,n)}time(e){return L(this,null,function*(){!this.supportTimestampQuery&&!this.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);let n=this.activeTimers,o=[],s=!1;this.programTimersStack==null?(this.programTimersStack=o,s=!0):this.activeTimers.push(o),this.activeTimers=o,e();let i=b.flatten(this.activeTimers.map(c=>c.query)).filter(c=>c!=null),a=b.flatten(this.activeTimers.map(c=>c.name)).filter(c=>c!=null);this.activeTimers=n,s&&(this.programTimersStack=null);let u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},l=yield Promise.all(i);return u.kernelMs=b.sum(l),u.getExtraProfileInfo=()=>l.map((c,p)=>({name:a[p],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,u})}makeTensorInfo(e,n,o){return n==="string"&&o!=null&&o.length>0&&b.isString(o[0])&&(o=o.map(i=>b.encodeString(i))),{dataId:this.write(o,e,n),shape:e,dtype:n}}tensorToBinding(e){if(!e)return null;let o=this.tensorMap.get(e.dataId).resource;return o instanceof GPUBuffer?{buffer:o}:o instanceof GPUTexture?o.createView():o}uploadToGPU(e){let n=this.tensorMap.get(e);if(n.resource!=null)return;let o=KI(n.dtype)*b.sizeFromShape(n.shape),s,i=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(n.values){if(s=this.bufferManager.acquireBuffer(o,i,!0),s.mapState==="unmapped"){let a=this.bufferManager.acquireBuffer(o,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),u=a.getMappedRange();n.dtype==="int32"||n.dtype==="bool"?new Int32Array(u).set(n.values):new Float32Array(u).set(n.values),a.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(a,0,s,0,o),this.stagingPendingDisposal.push(a)}else{let a=s.getMappedRange();n.dtype==="int32"||n.dtype==="bool"?new Int32Array(a).set(n.values):new Float32Array(a).set(n.values),s.unmap()}n.values=null}else s=this.bufferManager.acquireBuffer(o,i);n.resource=s}makeUniforms(e){let n=0,o=0,s=[],i=1;e.forEach(l=>{l.data.length===0&&(l.data=[1]);let c;switch(l.data.length){case 1:c=4;break;case 2:c=8;break;case 3:c=16;break;case 4:c=16;break;case 5:c=16;break;case 6:c=16;break;default:b.assert(!1,()=>`Unsupported ${l.data.length}D shape`)}(o===5||o===6)&&(c=16),c>i&&(i=c),n=Math.ceil(n/c)*c,o=l.data.length,s.push(n),n+=l.data.length*4}),n=Math.ceil(n/i)*i;let a=new ArrayBuffer(n);e.forEach((l,c)=>{let p=s[c];l.type==="int32"?new Int32Array(a,p,l.data.length).set(l.data):l.type==="uint32"?new Uint32Array(a,p,l.data.length).set(l.data):new Float32Array(a,p,l.data.length).set(l.data)});let u=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(u,0,a,0,n),this.uniformPendingDisposal.push(u),{offset:0,size:n,buffer:u}}runWebGPUProgram(e,n,o,s,i){if(i||(i=this.makeTensorInfo(e.outputShape,o)),b.sizeFromShape(i.shape)===0)return this.tensorMap.get(i.dataId).values=b.getTypedArrayFromDType(i.dtype,0),i;this.uploadToGPU(i.dataId),e.dispatch=K0e(this.device,e);let a=n.map((l,c)=>{if(l.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(l.dataId),{dtype:this.tensorMap.get(l.dataId).dtype,shape:l.shape,name:e.variableNames[c]}});e.shaderKey=hj(e,a,i);let u=j().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=fj(this.device,e,a,i,u)),e.pipeline=this.pipelineCache[e.shaderKey],u||this.recordAndSubmit(e,i,n,s),i}recordAndSubmit(e,n,o,s){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let i=[],a=[],u="int32";if(e.pixelsOpType==null){i.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),a=o.concat(n).map(h=>h.shape);let f="int32";a.map(h=>{i.push({type:f,data:h});let m=b.computeStrides(h);i.push({type:f,data:m})})}else{let f=b.computeStrides(n.shape);i.push({type:u,data:f})}if(e.size){let f=b.sizeFromShape(e.outputShape);i.push({type:u,data:[e.outputComponent?f/e.outputComponent:f]})}s&&(i=[...i,...s]);let l=[this.tensorToBinding(n),...o.map(f=>this.tensorToBinding(f)),this.makeUniforms(i)];o.forEach(f=>{this.commandQueueOwnedIds.add(f.dataId)}),this.commandQueueOwnedIds.add(n.dataId);let c=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:l.map((f,h)=>({binding:h,resource:f}))}),p=this.activeTimers!=null;this.ensureCommandEncoderReady();let d={};p&&this.supportTimestampQuery?(this.endComputePassEncoder(),this.querySet==null&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),d.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(d)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(d)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,c),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(p||j().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===qd.DRAW)&&(this.endComputePassEncoder(),p?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}getQueryTime(){return L(this,null,function*(){if(!this.supportTimestampQuery)return 0;this.queryResolveBuffer==null&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);let e=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.querySetCount*8),this.submitQueue(),yield e.mapAsync(GPUMapMode.READ);let n=new BigUint64Array(e.getMappedRange()),o=Number(n[1]-n[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),o})}shouldExecuteOnCPU(e,n=q0e){return j().getBool("WEBGPU_CPU_FORWARD")&&e.every(o=>this.tensorMap.get(o.dataId).resource==null&&b.sizeFromShape(o.shape)<n)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.querySet!=null&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}return r.nextDataId=0,r})();hb()&&Dg("webgpu",()=>L(void 0,null,function*(){let r={powerPreference:j().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},t=yield navigator.gpu.requestAdapter(r),e={},n=[];t.features.has("timestamp-query")&&n.push("timestamp-query"),t.features.has("bgra8unorm-storage")&&n.push(["bgra8unorm-storage"]),e.requiredFeatures=n;let o=t.limits;e.requiredLimits={maxComputeWorkgroupStorageSize:o.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:o.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:o.maxStorageBufferBindingSize,maxBufferSize:o.maxBufferSize,maxComputeWorkgroupSizeX:o.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:o.maxComputeInvocationsPerWorkgroup};let s=yield t.requestDevice(e),i=yield t.requestAdapterInfo();return new gy(s,i)}),3);var Le=function(r){return r[r.ADD=0]="ADD",r[r.ATAN2=1]="ATAN2",r[r.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",r[r.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",r[r.DIV=4]="DIV",r[r.ELU_DER=5]="ELU_DER",r[r.EQUAL=6]="EQUAL",r[r.FLOOR_DIV=7]="FLOOR_DIV",r[r.GREATER=8]="GREATER",r[r.GREATER_EQUAL=9]="GREATER_EQUAL",r[r.LESS=10]="LESS",r[r.LESS_EQUAL=11]="LESS_EQUAL",r[r.LOGICAL_AND=12]="LOGICAL_AND",r[r.LOGICAL_OR=13]="LOGICAL_OR",r[r.MAX=14]="MAX",r[r.MIN=15]="MIN",r[r.MOD=16]="MOD",r[r.MUL=17]="MUL",r[r.NOT_EQUAL=18]="NOT_EQUAL",r[r.POW=19]="POW",r[r.PRELU=20]="PRELU",r[r.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",r[r.SUB=22]="SUB",r}(Le||{}),X0e="let resultTemp = a + b;",Y0e="let resultTemp = atan2(a, b);",Z0e="let resultTemp = areal * breal - aimag * bimag;",Q0e="let resultTemp = areal * bimag + aimag * breal;",J0e="let resultTemp = a / b;",eSe="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",tSe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,rSe=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,nSe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,oSe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,sSe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,iSe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,aSe="return f32(a >= 1.0 && b >= 1.0);",uSe=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,lSe="return f32(a >= 1.0 || b >= 1.0);",cSe=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,pSe="let resultTemp = max(a, b);",dSe="let resultTemp = min(a, b);",fSe=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,hSe=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,mSe="let resultTemp = a * b;",gSe=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,ySe=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,xSe=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,vSe=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,bSe="if (a < 0.0) { return b * a; }  return a;",wSe=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,CSe="let resultTemp = (a - b) * (a - b);",SSe="let resultTemp = a - b;";function yy(r,t){let e;do{switch(r){case Le.ATAN2:e=Y0e;break;case Le.MAX:e=pSe;break;case Le.MIN:e=dSe;break;case Le.MOD:e=t?hSe:fSe;break;case Le.NOT_EQUAL:e=t?ySe:gSe;break;case Le.POW:e=t?vSe:xSe;break;default:continue}let n,o,s;return t?(n="isnanVec4",o="vec4<f32>",s="vec4<bool>"):(n="isnan",o="f32",s="bool"),`
      let aIsNaN = ${n}(a);
      let aPostLegalization = select(a, ${o}(42), aIsNaN);
      let bIsNaN = ${n}(b);
      let bPostLegalization = select(b, ${o}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${e}
        return select(
            resultTemp, ${o}(valueForNaN),
            ${s}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(r){case Le.ADD:e=X0e;break;case Le.COMPLEX_MULTIPLY_IMAG:e=Q0e;break;case Le.COMPLEX_MULTIPLY_REAL:e=Z0e;break;case Le.DIV:e=J0e;break;case Le.ELU_DER:e=eSe;break;case Le.EQUAL:e=tSe;break;case Le.FLOOR_DIV:e=rSe;break;case Le.GREATER:e=nSe;break;case Le.GREATER_EQUAL:e=oSe;break;case Le.LESS:e=sSe;break;case Le.LESS_EQUAL:e=iSe;break;case Le.LOGICAL_AND:return t?uSe:aSe;case Le.LOGICAL_OR:return t?cSe:lSe;case Le.MUL:e=mSe;break;case Le.PRELU:return t?wSe:bSe;case Le.SQUARED_DIFFERENCE:e=CSe;break;case Le.SUB:e=SSe;break;default:}return`
    ${e}
    return resultTemp;
  `}var fe=function(r){return r[r.ABS=0]="ABS",r[r.ACOS=1]="ACOS",r[r.ACOSH=2]="ACOSH",r[r.ASIN=3]="ASIN",r[r.ASINH=4]="ASINH",r[r.ATAN=5]="ATAN",r[r.ATANH=6]="ATANH",r[r.CEIL=7]="CEIL",r[r.COS=8]="COS",r[r.COSH=9]="COSH",r[r.ELU=10]="ELU",r[r.ERF=11]="ERF",r[r.EXP=12]="EXP",r[r.EXPM1=13]="EXPM1",r[r.FLOOR=14]="FLOOR",r[r.IS_FINITE=15]="IS_FINITE",r[r.IS_INF=16]="IS_INF",r[r.IS_NAN=17]="IS_NAN",r[r.LINEAR=18]="LINEAR",r[r.LOG=19]="LOG",r[r.LOG1P=20]="LOG1P",r[r.LOGICAL_NOT=21]="LOGICAL_NOT",r[r.NEG=22]="NEG",r[r.RELU=23]="RELU",r[r.RELU6=24]="RELU6",r[r.LEAKYRELU=25]="LEAKYRELU",r[r.RECIPROCAL=26]="RECIPROCAL",r[r.ROUND=27]="ROUND",r[r.RSQRT=28]="RSQRT",r[r.SELU=29]="SELU",r[r.SIGMOID=30]="SIGMOID",r[r.SIGN=31]="SIGN",r[r.SIN=32]="SIN",r[r.SINH=33]="SINH",r[r.SOFTPLUS=34]="SOFTPLUS",r[r.SQRT=35]="SQRT",r[r.SQUARE=36]="SQUARE",r[r.STEP=37]="STEP",r[r.TAN=38]="TAN",r[r.TANH=39]="TANH",r[r.TO_INT=40]="TO_INT",r}(fe||{}),ISe="return abs(a);",TSe=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,_Se=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,ESe=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,kSe="return asinh(a);",NSe=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,DSe=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,ASe="return ceil(a);",RSe="return cos(a);",OSe=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,MSe="return exp(a) - 1.0;",FSe="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",$Se=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,PSe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${T.ERF_P};
  let a1 = ${T.ERF_A1};
  let a2 = ${T.ERF_A2};
  let a3 = ${T.ERF_A3};
  let a4 = ${T.ERF_A4};
  let a5 = ${T.ERF_A5};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,LSe="return exp(a);",zSe="return floor(a);",BSe="return f32(!isnan(a) && !isinf(a));",VSe="return f32(isinf(a));",USe="return f32(isnan(a));",GSe="return a;",WSe=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,jSe=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,HSe="return f32(!(a >= 1.0));",qSe="return -a;",KSe="if (a < 0.0) { return uniforms.alpha * a; } return a;",XSe=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,YSe="return 1.0 / a;",ZSe="return select(a, 0.0, a < 0.0);",QSe="return clamp(a, 0.0, 6.0);",JSe="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",eIe=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,tIe="return round(a);",rIe="return inverseSqrt(a);",nIe=`
  if (a >= 0.0) {
    return ${T.SELU_SCALE} * a;
  } else {
    return ${T.SELU_SCALEALPHA} * (exp(a) - 1.0);
  }
`,oIe="return 1.0 / (1.0 + exp(-1.0 * a));",sIe="return sign(a);",iIe="return sin(a);",aIe=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,uIe=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,lIe="return sqrt(a);",cIe="return a * a;",pIe=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,dIe="return tan(a);",fIe=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,hIe="return f32(i32((a)));";function $c(r,t){switch(r){case fe.ABS:return ISe;case fe.ACOS:return TSe;case fe.ACOSH:return _Se;case fe.ASIN:return ESe;case fe.ASINH:return kSe;case fe.ATAN:return NSe;case fe.ATANH:return DSe;case fe.COS:return RSe;case fe.COSH:return OSe;case fe.CEIL:return ASe;case fe.ELU:return t?$Se:FSe;case fe.ERF:return PSe;case fe.EXP:return LSe;case fe.EXPM1:return MSe;case fe.FLOOR:return zSe;case fe.IS_FINITE:return BSe;case fe.IS_INF:return VSe;case fe.IS_NAN:return USe;case fe.LINEAR:return GSe;case fe.LOG:return WSe;case fe.LOG1P:return jSe;case fe.LOGICAL_NOT:return HSe;case fe.NEG:return qSe;case fe.LEAKYRELU:return t?XSe:KSe;case fe.RECIPROCAL:return YSe;case fe.RELU:return t?eIe:ZSe;case fe.RELU6:return t?JSe:QSe;case fe.ROUND:return tIe;case fe.RSQRT:return rIe;case fe.SELU:return nIe;case fe.SIGMOID:return oIe;case fe.SIGN:return sIe;case fe.SIN:return iIe;case fe.SINH:return aIe;case fe.SOFTPLUS:return uIe;case fe.SQRT:return lIe;case fe.SQUARE:return cIe;case fe.STEP:return pIe;case fe.TAN:return dIe;case fe.TANH:return fIe;case fe.TO_INT:return hIe;default:throw new Error(`BinaryType ${r} is not implemented!`)}}function co(r,t=!1,e=!1,n=3){if(r===null)return"";let o="";if(r==="linear")o=$c(fe.LINEAR);else if(r==="relu")o=$c(fe.RELU,e);else if(r==="elu")o=$c(fe.ELU,e);else if(r==="relu6")o=$c(fe.RELU6,e);else if(r==="prelu")o=yy(Le.PRELU,e);else if(r==="sigmoid")o=$c(fe.SIGMOID,e);else if(r==="leakyrelu")o=$c(fe.LEAKYRELU,e);else throw new Error(`Activation ${r} has not been implemented for the WebGPU backend.`);let i=xt(e?4:1),a="";return t?a=`
      fn activation(a : ${i}, coords : vec${n}<i32>) -> ${i} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${o}
      }`:a=`
      fn activation(a : ${i}, coords : vec${n}<i32>) -> ${i} {
        ${o}
      }`,a}function _s(r,t){return`
      ${r?"value = value + getBiasByOutputCoords(coords);":""}
      ${t?"value = activation(value, coords);":""}
      `}function VO(r,t,e=!1,n=!1,o=!1,s=1){b.assert(r&&s===1||!r,()=>`transposeA ${r} is not compatible with component size ${s}`);let i=`
      ${r?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,a=t?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${xt(s)} {
    var value = ${xt(s)}(0.0);
    ${e&&o?i:`
    ${r?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${i}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${xt(s)} {
    var value = ${xt(s)}(0.0);
    ${a}
    return value;
  }
  `}function gb(r,t,e,n,o=!1,s=!1,i=!1,a=1){return`
  ${VO(e,n,o,s,i,a)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${xt(a)}) {
    ${o&&s?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${_s(r,t)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}var mIe=(r,t)=>r?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${t});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${t});
        `,gIe=(r,t,e,n)=>{if(r)return`
      for (var k = 0; k < ${n}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${e}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let o="",s="";for(let i=0;i<t;i++)o+=`let BCached${i} = mm_Bsub[k * ${t} + ${i}][tileCol];`,s+=`acc[i] = fma(BCached${i}, vec4<f32>(ACached[${i}]), acc[i]);`;return`
      for (var k = 0; k < ${n/t}; k++) {
        ${o}
        for (var i = 0; i < ${e}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${s}
        }
      }`}};function Ah(r,t,e=!1,n=32,o=!1,s=32,i=!1){let a=t[1]*r[1],u=t[0]*r[0],l=e?a:n,c=e?n:a,p=l/t[0],d=n/t[1],f=r[1],h=r[0];return b.assert((e&&p===4&&r[1]===4||!e&&(p===3||p===4))&&l%t[0]===0&&n%t[1]===0&&r[0]===4,()=>`If transposeA ${e} is true, innerElementSize ${p} and workPerThread[1] ${r[1]} must be 4.
          Otherwise, innerElementSize ${p} must be 3 or 4.
      tileAWidth ${l} must be divisible by workgroupSize[0]${t[0]}. tileInner ${n} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${r[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${p}<f32>, ${l/p}>, ${c}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${u/r[0]}>, ${n}>;

  ${oe()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${f};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${f};
    let globalCol = i32(globalId.x) * ${h};
    let batch = ${o?"0":"i32(globalId.z)"};
    let batchA = ${o||!i?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${o||!i?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${a};

    let numTiles = ${o?`${Math.ceil(s/n)}`:`(uniforms.dimInner - 1) / ${n} + 1`};
    var kStart = ${o?`i32(globalId.z) * ${s}`:"0"};

    var acc: array<vec4<f32>, ${f}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${d};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${f}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${mIe(e,p)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${d}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${n};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${gIe(e,p,f,n)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${f}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}var gj=r=>r?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,yIe=r=>r?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function Rh(r,t,e=!1,n=32,o=!1,s=32,i=!1,a=!1){let u=r[1]*t[1],l=r[0]*t[0],c=e?u:n,p=e?n:u;b.assert(p%t[1]===0&&c%t[0]===0&&n%t[1]===0,()=>`tileAHight ${p} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}, tileInner ${n} must be divisible by workgroupSize[1]${t[1]}`);let d=p/t[1],f=c/t[0],h=n/t[1],m=r[1],g=r[0],y=i?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${u};
      let globalColStart = i32(workgroupId.x) * ${l};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${t[1]}) {
          for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {
            ${gj(e)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${t[1]}) {
              for (var inputCol = localCol; inputCol < ${l}; inputCol = inputCol + ${t[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${n};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${g}>;
        for (var k = 0; k < ${n}; k++) {
          for (var inner = 0; inner < ${g}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];
          }
          for (var innerRow = 0; innerRow < ${m}; innerRow++) {
            let ACached = ${e?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}
            for (var innerCol = 0; innerCol < ${g}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${m}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${t[1]};
        for (var innerCol = 0; innerCol < ${g}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${t[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${m};
  let tileCol = i32(localId.x) * ${g};

  let globalRow = i32(globalId.y) * ${m};
  let globalCol = i32(globalId.x) * ${g};
  let globalRowStart = i32(workgroupId.y) * ${u};

  let tileRowA = i32(localId.y) * ${d};
  let tileColA = i32(localId.x) * ${f};
  let tileRowB = i32(localId.y) * ${h};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${d}; innerRow++) {
      for (var innerCol = 0; innerCol < ${f}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${gj(e)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${h}; innerRow++) {
      for (var innerCol = 0; innerCol < ${g}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${n};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${g}>;
    for (var k = 0; k < ${n}; k++) {
      for (var inner = 0; inner < ${g}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${m}; innerRow++) {
        ${yIe(e)}
        for (var innerCol = 0; innerCol < ${g}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${m}; innerRow++) {
    for (var innerCol = 0; innerCol < ${g}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${c}>, ${p}>;
    var<workgroup> mm_Bsub : array<array<f32, ${l}>, ${n}>;

    ${oe()} {
      let batch = ${o?"0":"i32(globalId.z)"};
      let batchA = ${o||!a?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${o||!a?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${o?`${Math.ceil(s/n)}`:`(uniforms.dimInner - 1) / ${n} + 1`};
      var kStart = ${o?`i32(globalId.z) * ${s}`:"0"};

      var acc : array<array<f32, ${g}>, ${m}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${m}; innerRow++) {
        for (var innerCol = 0; innerCol < ${g}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${y}
    }
  `}var xIe=r=>r?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;function vIe(r,t=!1){b.assert(r[1]===1&&r[2]===1,()=>`A linear work group size is required. But got ${r}.`);let e=r[0]*4;return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${r[0]}>;

    ${oe()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${e} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${e} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${xIe(t)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${e/4}; k++) {
          let rowB = t * ${e} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}var XI=class{constructor(t,e,n=!1,o=!1,s=null,i=null,a=null,u=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0]};let l=n?t[1]:t[2];if(this.isVec4=(l%4===0&&!n||e[1]%4===0&&n)&&e[2]%4===0&&!o,this.outputComponent=this.isVec4?4:1,this.isVectorA=e[1]===1&&!n,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{let d=BO(e[1],l,e[2],n);this.workgroupSize=d.workgroupSize,this.elementsPerThread=d.elementsPerThread}this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);let c=s!=null,p=a!=null;c&&this.variableNames.push("bias"),p&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=u,this.transposeA=n,this.transposeB=o,this.addBias=c,this.activation=i,this.hasPreluActivationWeights=p,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(e[1],e[2],l),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${n}_${o}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(t,e,n){let o=this.workgroupSize[1]*this.elementsPerThread[1],s=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=s;let i=t%o===0,a=e%s===0,u=n%this.tileInner===0;return[i,a,u]}getUserCode(){return`
      ${co(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${gb(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?Ah(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?vIe(this.workgroupSize,this.transposeA):Rh(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}};function bIe(r){return`
    var<workgroup> sumValues : array<f32, ${r}>;
    ${oe()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${r}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${r/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}var YI=class{constructor(t,e=!1,n=!1,o=null,s=null,i=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=t,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize);let a=o!=null,u=i!=null;a&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),this.transposeA=e,this.transposeB=n,this.addBias=a,this.activation=s,this.hasPreluActivationWeights=u,this.shaderKey=`matMulReduce_${this.activation}_${e}_${n}`}getUserCode(){return`
      ${co(this.activation,this.hasPreluActivationWeights)}
      ${gb(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${bIe(this.workgroupSize[0])}
    `}};function wIe(r){let t=r[1],e=r[0],n=t>e?t:e;return`
  var<workgroup> mm_Asub : array<array<f32, ${n}>, ${t}>;
  var<workgroup> mm_Bsub : array<array<f32, ${e}>, ${n}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${oe()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${n} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${n};
    globalRowB = globalRowB + ${n};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${n};
      globalRowB = globalRowB + ${n};

      for (var k = 0; k < ${n}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}var ZI=class{constructor(t,e,n,o=!1,s=!1,i=null,a=null,u=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workgroupSize[0]),Math.ceil(n[1]/this.workgroupSize[1]),n[0]];let l=i!=null;l&&this.variableNames.push("bias");let c=u!=null;c&&this.variableNames.push("preluActivationWeights"),this.transposeA=o,this.transposeB=s,this.addBias=l,this.activation=a,this.hasPreluActivationWeights=c,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${o}_${s}`}getUserCode(){return`
      ${co(this.activation,this.hasPreluActivationWeights)}
      ${gb(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${wIe(this.workgroupSize)}
    `}};var QI=class{constructor(t,e,n=!1,o=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,b.assert(t[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0,3]};let s=(n&&this.outputShape[1]%4===0||!n&&e%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=s?4:1,s||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=se(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],e],this.workgroupSize,this.elementsPerThread),this.transposeA=n,this.transposeB=o,this.shaderKey=`matMulSplitK_${n}_${o}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){let t=this.outputComponent;return`
      ${VO(!1,this.transposeB,!1,!1,!1,t)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${xt(t)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${t}; i = i + 1) {
            ${Ts("&result[flatIndex + i]",`${t>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${t===4?Ah(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):Rh(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}},JI=class{constructor(t,e=null,n=null,o=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=e!=null,this.hasPreluActivationWeights=o!=null,this.activation=n,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${n}`}getUserCode(){return`
    ${co(this.activation,this.hasPreluActivationWeights)}
    ${oe("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${_s(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}};var eT=class{constructor(t){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${oe("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}};function jr(r){let{backend:t,attrs:e}=r,{shape:n,value:o}=e,{dtype:s}=e;if(s=s||b.inferDtype(o),s==="string"){let i=b.getArrayFromDType(s,b.sizeFromShape(n));return i.fill(o),t.makeTensorInfo(n,s,i)}else{let i=new eT(n),a=[{type:"float32",data:[o]}];return t.runWebGPUProgram(i,[],s,a)}}var yj={kernelName:qp,backendName:"webgpu",kernelFunc:jr};function Ee(r){let{inputs:t,attrs:e}=r,{x:n}=t,{shape:o}=e,s=b.sizeFromShape(n.shape),i=b.inferFromImplicitShape(o,s),a=b.sizeFromShape(i);return b.assert(s===a,()=>`The new shape (${i}) has ${a} elements and the old shape (${n.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`),r.backend.incRef(n.dataId),{dataId:n.dataId,shape:i,dtype:n.dtype}}var xj={kernelName:fl,backendName:"webgpu",kernelFunc:Ee};function Oh({a:r,b:t,transposeA:e,transposeB:n,backend:o,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:u=null}){let l=r.shape.length,c=t.shape.length,p=e?r.shape[l-2]:r.shape[l-1],d=n?t.shape[c-1]:t.shape[c-2],f=e?r.shape[l-1]:r.shape[l-2],h=n?t.shape[c-2]:t.shape[c-1],m=r.shape.slice(0,-2),g=t.shape.slice(0,-2),y=b.sizeFromShape(m),x=b.sizeFromShape(g),C=Fo.assertAndGetBroadcastShape(r.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,h]);b.assert(p===d,()=>`Error in matMul: inner shapes (${p}) and (${d}) of Tensors with shapes ${r.shape} and ${t.shape} and transposeA=${e} and transposeB=${n} must match.`);let I=e?[y,p,f]:[y,f,p],N=n?[x,h,d]:[x,d,h],A=Ee({inputs:{x:r},backend:o,attrs:{shape:I}}),O=Ee({inputs:{x:t},backend:o,attrs:{shape:N}}),$=[A,O],z=Math.max(y,x),G=[A,O],K=[{type:"int32",data:[f]},{type:"int32",data:[h]},{type:"int32",data:[p]}],Z,Q,J=[z,f,h],te=j().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(te<0){let ne=j().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),ae=ne>0?ne:o.thresholdToIncreaseWorkgroups,ye=z*Math.ceil(f/32)*Math.ceil(h/32);ye<=ae||f<=8&&ye<=ae*2?z*f*h<=128?te=Ja.MatMulReduceProgram:z===1&&d>=2e3?te=Ja.MatMulSplitKProgram:te=Ja.MatMulSmallOutputSizeProgram:te=Ja.MatMulPackedProgram}switch(te){case Ja.MatMulReduceProgram:Z=new YI(J,e,n,s,u,i);break;case Ja.MatMulSplitKProgram:{if(Q=jr({backend:o,attrs:{shape:J,value:0,dtype:r.dtype}}),Z=new QI(J,d,e,n),s||u){Q=o.runWebGPUProgram(Z,G,r.dtype,K,Q);let ae=new JI(Q.shape,s,u,i),ye=null,ge=[Q];s&&ge.push(s),i&&ge.push(i),u==="leakyrelu"&&(ye=[{type:"float32",data:[a]}],ae.uniforms+=" alpha : f32,");let Se=o.runWebGPUProgram(ae,ge,Q.dtype,ye);$.push(Q);let be=Ee({inputs:{x:Se},backend:o,attrs:{shape:C}});$.push(Se);for(let ke of $)o.disposeData(ke.dataId);return be}break}case Ja.MatMulSmallOutputSizeProgram:Z=new ZI(I,N,J,e,n,s,u,i);break;case Ja.MatMulPackedProgram:let ne=o.adapterInfo.isIntel();Z=new XI(I,J,e,n,s,u,i,ne);break;default:throw new Error(`Unsupported MatMulProgramType ${te}.`)}s&&G.push(s),i&&G.push(i),u==="leakyrelu"&&(K.push({type:"float32",data:[a]}),Z.uniforms+=" alpha : f32,"),Q=o.runWebGPUProgram(Z,G,r.dtype,K,Q);let ie=Ee({inputs:{x:Q},backend:o,attrs:{shape:C}});$.push(Q);for(let ne of $)o.disposeData(ne.dataId);return ie}function CIe(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s,bias:i,preluActivationWeights:a}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:p}=n;return Oh({a:o,b:s,transposeA:u,transposeB:l,backend:e,bias:i,preluActivationWeights:a,leakyreluAlpha:p,activation:c})}var vj={kernelName:Cc,backendName:"webgpu",kernelFunc:CIe};var yb=class{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=T.assertAndGetBroadcastShape(e,n),this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${t}`,this.op=t}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${yy(this.op,!1)}
      }

      ${oe("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}};var Pc=class{constructor(t,e,n){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=T.assertAndGetBroadcastShape(e,n),this.dispatchLayout=pe(this.outputShape),this.op=t,this.useSharedMemoryWithA=e.length<=1&&n.length>1&&e[0]<128,this.useSharedMemoryWithB=n.length<=1&&e.length>1&&n[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?n[0]:e[0],this.shaderKey=`binary_${t}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{let o=e.length>0&&e[e.length-1]%4===0,s=n.length>0&&n[n.length-1]%4===0;o&&s?(this.outputComponent=4,this.variableComponents=[4,4]):o&&(b.isScalarShape(n)||n[n.length-1]===1)||s&&(b.isScalarShape(e)||e[e.length-1]===1)?(this.outputComponent=4,this.variableComponents=o?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${t}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let t,e=this.outputComponent===4?"vec4<f32>":"f32",n=`
    fn binaryOperation(a : ${e}, b : ${e}) -> ${e} {
      ${yy(this.op,this.outputComponent===4)}
    };
    `;if(this.type==="shared"){let o=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",s=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${o}];`:`let a = sharedBuf[${o}];
          let b = getBByOutputIndex(index);`;t=`
        ${n}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${oe("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${s}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else t=`
       ${n}
       ${oe("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${e}(getAByOutputCoords(coords));
           let b = ${e}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return t}};function sn(r){let{inputs:t}=r,{x:e}=t;return r.backend.incRef(e.dataId),{dataId:e.dataId,shape:e.shape,dtype:e.dtype}}var bj={kernelName:fi,backendName:"webgpu",kernelFunc:sn};function Xs(r){let{inputs:t,backend:e}=r,{real:n,imag:o}=t,s=e.makeTensorInfo(n.shape,"complex64"),i=e.tensorMap.get(s.dataId),a=sn({inputs:{x:n},backend:e}),u=sn({inputs:{x:o},backend:e});return i.complexTensorInfos={real:a,imag:u},s}var wj={kernelName:Op,backendName:"webgpu",kernelFunc:Xs};var Es=class{constructor(t,e,n=""){this.variableNames=["A"],this.size=!0;let o=128;this.workgroupSize=[o,1,1],this.outputShape=t,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=e,n!==""&&(this.uniforms=n),this.shaderKey=`unary_${e}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${$c(this.op,!1)}
      }
      ${oe("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}};function Be({opType:r,cpuKernelImpl:t,dtype:e}){return({inputs:n,backend:o})=>{let{x:s}=n,i=o,a=e||s.dtype;if(i.shouldExecuteOnCPU([s])&&t!=null){let l=i.tensorMap.get(s.dataId),c=t(l.values,a);return i.makeTensorInfo(s.shape,a,c)}let u=new Es(s.shape,r);return i.runWebGPUProgram(u,[s],a)}}function Vt({opType:r,cpuKernelImpl:t,supportsComplex:e=!1,dtype:n}){return({inputs:o,backend:s})=>{let{a:i,b:a}=o,u=s;if(e&&i.dtype==="complex64"){let p=u.tensorMap.get(i.dataId),d=u.tensorMap.get(a.dataId),f,h;if(r!==Le.MUL)[f,h]=[[p.complexTensorInfos.real,d.complexTensorInfos.real],[p.complexTensorInfos.imag,d.complexTensorInfos.imag]].map(g=>{let[y,x]=g,w={dataId:y.dataId,dtype:y.dtype,shape:i.shape},C={dataId:x.dataId,dtype:x.dtype,shape:a.shape},I=new Pc(r,i.shape,a.shape);return u.runWebGPUProgram(I,[w,C],mr(y.dtype,x.dtype))});else{let g=new yb(Le.COMPLEX_MULTIPLY_REAL,i.shape,a.shape),y=new yb(Le.COMPLEX_MULTIPLY_IMAG,i.shape,a.shape),x=[{dataId:p.complexTensorInfos.real.dataId,dtype:p.complexTensorInfos.real.dtype,shape:i.shape},{dataId:p.complexTensorInfos.imag.dataId,dtype:p.complexTensorInfos.imag.dtype,shape:i.shape},{dataId:d.complexTensorInfos.real.dataId,dtype:d.complexTensorInfos.real.dtype,shape:a.shape},{dataId:d.complexTensorInfos.imag.dataId,dtype:d.complexTensorInfos.imag.dtype,shape:a.shape}];f=u.runWebGPUProgram(g,x,"float32"),h=u.runWebGPUProgram(y,x,"float32")}let m=Xs({inputs:{real:f,imag:h},backend:u});return u.disposeData(f.dataId),u.disposeData(h.dataId),m}let l=n||mr(i.dtype,a.dtype);if((i.dtype==="string"||a.dtype==="string"||u.shouldExecuteOnCPU([i,a]))&&t!=null){let p=u.tensorMap.get(i.dataId).values,d=u.tensorMap.get(a.dataId).values,f=i.dtype==="string"?T.fromUint8ToStringArray(p):p,h=i.dtype==="string"?T.fromUint8ToStringArray(d):d,[m,g]=t(i.shape,a.shape,f,h,l);return u.makeTensorInfo(g,l,m)}let c=new Pc(r,i.shape,a.shape);return u.runWebGPUProgram(c,[i,a],l)}}var wb={};ur(wb,{addImpl:()=>WO,bincountImpl:()=>by,bincountReduceImpl:()=>tT,bitwiseAndImpl:()=>jO,castImpl:()=>GO,ceilImpl:()=>HO,concatImpl:()=>rT,equalImpl:()=>qO,expImpl:()=>XO,expm1Impl:()=>ZO,floorDivImpl:()=>JO,floorImpl:()=>QO,gatherNdImpl:()=>nT,gatherV2Impl:()=>oT,greaterEqualImpl:()=>tM,greaterImpl:()=>eM,lessEqualImpl:()=>nM,lessImpl:()=>rM,linSpaceImpl:()=>sT,logImpl:()=>oM,maxImpl:()=>iT,maximumImpl:()=>sM,minimumImpl:()=>iM,multiplyImpl:()=>xb,negImpl:()=>aM,notEqualImpl:()=>uM,prodImpl:()=>lM,raggedGatherImpl:()=>aT,raggedRangeImpl:()=>uT,raggedTensorToTensorImpl:()=>lT,rangeImpl:()=>cT,rsqrtImpl:()=>pM,scatterImpl:()=>eu,sigmoidImpl:()=>Qj,simpleAbsImpl:()=>UO,sliceImpl:()=>fM,sparseFillEmptyRowsImpl:()=>pT,sparseReshapeImpl:()=>dT,sparseSegmentReductionImpl:()=>Cy,sqrtImpl:()=>tH,squaredDifferenceImpl:()=>hM,staticRegexReplaceImpl:()=>mM,stridedSliceImpl:()=>fT,stringNGramsImpl:()=>hT,stringSplitImpl:()=>mT,stringToHashBucketFastImpl:()=>gT,subImpl:()=>yM,tileImpl:()=>yT,topKImpl:()=>xT,transposeImpl:()=>wy,uniqueImpl:()=>vT});function de(r,t){Array.isArray(r)||(r=[r]),r.forEach(e=>{e!=null&&b.assert(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}function UO(r){let t=new Float32Array(r.length);for(let e=0;e<r.length;++e)t[e]=Math.abs(r[e]);return t}var SIe=r=>{let{x:t}=r.inputs,e=r.backend;de(t,"abs");let n=new Float32Array(b.sizeFromShape(t.shape)),o=e.data.get(t.dataId).values;return n=UO(o),e.makeOutput(n,t.shape,t.dtype)},Cj={kernelName:Ou,backendName:"cpu",kernelFunc:SIe};function It(r){return(t,e,n,o,s)=>{let i=T.assertAndGetBroadcastShape(t,e),a=i.length,u=b.computeStrides(i),l=b.sizeFromShape(i),c=b.getTypedArrayFromDType(s,l),p=t.length,d=e.length,f=b.computeStrides(t),h=b.computeStrides(e),m=T.getBroadcastDims(t,i),g=T.getBroadcastDims(e,i);if(m.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=r(n[y%n.length],o[y%o.length]);else for(let y=0;y<c.length;++y){let x=b.indexToLoc(y,a,u),w=x.slice(-p);m.forEach(A=>w[A]=0);let C=b.locToIndex(w,p,f),I=x.slice(-d);g.forEach(A=>I[A]=0);let N=b.locToIndex(I,d,h);c[y]=r(n[C],o[N])}return[c,i]}}function Mn(r){let{inputs:t,backend:e}=r,{real:n,imag:o}=t,s=e.data.get(n.dataId).values,i=e.data.get(o.dataId).values,a=e.makeTensorInfo(n.shape,"complex64"),u=e.data.get(a.dataId);return u.complexTensorInfos={real:e.makeTensorInfo(n.shape,"float32",s),imag:e.makeTensorInfo(o.shape,"float32",i)},a}var Sj={kernelName:Op,backendName:"cpu",kernelFunc:Mn};function xy(r,t,e="float32"){if(e==="complex64"){let o=xy(r,t,"float32"),s=xy(r,t,"float32");return Mn({inputs:{real:o,imag:s},backend:r})}let n=b.makeZerosTypedArray(b.sizeFromShape(t),e);return r.makeTensorInfo(t,e,n)}function po(r){let{inputs:t,backend:e}=r,{x:n}=t;return e.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var Ij={kernelName:fi,backendName:"cpu",kernelFunc:po};function Ti(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.data.get(n.dataId).complexTensorInfos.real,s=e.data.get(o.dataId).values;return e.makeTensorInfo(o.shape,o.dtype,s)}var Tj={kernelName:ad,backendName:"cpu",kernelFunc:Ti};function GO(r,t,e,n){if(n==="int32"){let o=Int32Array.from(r);return[t,"int32",o]}if(n==="bool"){let o=b.toTypedArray([0],e),[s,i]=It((a,u)=>a!==u?1:0)(t,[],r,o,"bool");return[i,"bool",s]}throw new Error(`Error in Cast: failed to cast ${e} to ${n}`)}function _i(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return po({inputs:{x:o},backend:e});let c=xy(e,o.shape,o.dtype),p=_i({inputs:{x:o},backend:e,attrs:{dtype:"float32"}}),d=Mn({inputs:{real:p,imag:c},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),d}if(o.dtype==="complex64"){let c=Ti({inputs:{input:o},backend:e}),p=_i({inputs:{x:c},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(c),p}if(!b.hasEncodingLoss(o.dtype,s)){let c=po({inputs:{x:o},backend:e});return{dataId:c.dataId,shape:c.shape,dtype:s}}let i=e.data.get(o.dataId).values,[a,u,l]=GO(i,o.shape,o.dtype,s);return e.makeTensorInfo(a,u,l)}var _j={kernelName:di,backendName:"cpu",kernelFunc:_i};function Mt(r,t,e,n){return e==null?({inputs:o,backend:s})=>{let{a:i,b:a}=o,u=s;de([i,a],r);let l=u.data.get(i.dataId).values,c=u.data.get(a.dataId).values,p=i.dtype==="string"?T.fromUint8ToStringArray(l):l,d=i.dtype==="string"?T.fromUint8ToStringArray(c):c,f=n||i.dtype,[h,m]=t(i.shape,a.shape,p,d,f);return u.makeTensorInfo(m,f,h)}:({inputs:o,backend:s})=>{let{a:i,b:a}=o,u=s;if(i.dtype==="complex64"||a.dtype==="complex64"){let l=_i({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),c=u.data.get(l.dataId),p=c.complexTensorInfos.real,d=c.complexTensorInfos.imag,f=u.data.get(p.dataId).values,h=u.data.get(d.dataId).values,m=_i({inputs:{x:a},backend:u,attrs:{dtype:"complex64"}}),g=u.data.get(m.dataId),y=g.complexTensorInfos.real,x=g.complexTensorInfos.imag,w=u.data.get(y.dataId).values,C=u.data.get(x.dataId).values,[I,N,A]=e(i.shape,a.shape,f,h,w,C),O=u.makeTensorInfo(A,"float32",I),$=u.makeTensorInfo(A,"float32",N),z=Mn({inputs:{real:O,imag:$},backend:u});return u.disposeIntermediateTensorInfo(l),u.disposeIntermediateTensorInfo(m),u.disposeIntermediateTensorInfo(O),u.disposeIntermediateTensorInfo($),z}else{let l=u.data.get(i.dataId).values,c=u.data.get(a.dataId).values,p=n||i.dtype,[d,f]=t(i.shape,a.shape,l,c,p);return u.makeTensorInfo(f,p,d)}}}function vy(r){return(t,e,n,o,s,i)=>{let a=T.assertAndGetBroadcastShape(t,e),u=b.sizeFromShape(a),l=a.length,c=b.computeStrides(a),p=b.getTypedArrayFromDType("float32",u),d=b.getTypedArrayFromDType("float32",u),f=T.getBroadcastDims(t,a),h=T.getBroadcastDims(e,a),m=T.mergeRealAndImagArrays(n,o),g=T.mergeRealAndImagArrays(s,i),y=t.length,x=b.computeStrides(t),w=e.length,C=b.computeStrides(e);if(f.length+h.length===0)for(let I=0;I<p.length;I++){let N=I%m.length,A=I%g.length,O=r(m[N*2],m[N*2+1],g[A*2],g[A*2+1]);p[I]=O.real,d[I]=O.imag}else for(let I=0;I<p.length;I++){let N=b.indexToLoc(I,l,c),A=N.slice(-y);f.forEach(K=>A[K]=0);let O=b.locToIndex(A,y,x),$=N.slice(-w);h.forEach(K=>$[K]=0);let z=b.locToIndex($,w,C),G=r(m[O*2],m[O*2+1],g[z*2],g[z*2+1]);p[I]=G.real,d[I]=G.imag}return[p,d,a]}}var WO=It((r,t)=>r+t),IIe=vy((r,t,e,n)=>({real:r+e,imag:t+n})),Ll=Mt(js,WO,IIe),Ej={kernelName:js,backendName:"cpu",kernelFunc:Ll};function by(r,t,e,n,o){let s=b.sizeFromShape(n),i=b.makeZerosTypedArray(o,e);for(let a=0;a<r.length;a++){let u=r[a];if(u<0)throw new Error("Input x must be non-negative!");u>=o||(s>0?i[u]+=t[a]:i[u]+=1)}return i}function tT(r,t,e,n=!1){let o=r.shape[0],s=r.shape[1],i=Ne([o,e],t.dtype);for(let a=0;a<o;a++)for(let u=0;u<s;u++){let l=r.get(a,u);if(l<0)throw new Error("Input x must be non-negative!");l>=e||(n?i.set(1,a,l):t.size>0?i.set(i.get(a,l)+t.get(a,u),a,l):i.set(i.get(a,l)+1,a,l))}return i}var jO=It((r,t)=>r&t),TIe=Mt(Qf,jO),kj={kernelName:Qf,backendName:"cpu",kernelFunc:TIe};function Un(r){return(t,e,n)=>{let o=b.getArrayFromDType(e,t.length);for(let s=0;s<t.length;++s)o[s]=r(t[s],n);return o}}function Je(r,t,e){let n=Un(t);return ns(r,n,e)}function ns(r,t,e){return({inputs:n,attrs:o,backend:s})=>{let{x:i}=n;de(i,r);let a=s,u=a.data.get(i.dataId).values,l;if(i.dtype==="string"){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");l=T.fromUint8ToStringArray(u)}else l=u;let c=e||i.dtype,p=t(l,c,o);return a.makeTensorInfo(i.shape,c,p)}}var HO=Un(r=>Math.ceil(r)),_Ie=ns(sa,HO),Nj={kernelName:sa,backendName:"cpu",kernelFunc:_Ie};function rT(r,t,e,n){let o=b.getArrayFromDType(e,b.sizeFromShape(t));if(n&&e!=="string"){let s=0;r.forEach(i=>{let a=b.sizeFromShape(i.shape);o.set(i.vals,s),s+=a})}else{let s=0;r.forEach(i=>{let a=e==="string"?T.fromUint8ToStringArray(i.vals):i.vals,u=0;for(let l=0;l<i.shape[0];++l){let c=l*t[1]+s;for(let p=0;p<i.shape[1];++p)o[c+p]=a[u++]}s+=i.shape[1]})}return o}var qO=It((r,t)=>r===t?1:0),KO=Mt(hc,qO,null,"bool"),Dj={kernelName:hc,backendName:"cpu",kernelFunc:KO};var XO=Un(r=>Math.exp(r)),YO=ns(da,XO,"float32"),Aj={kernelName:da,backendName:"cpu",kernelFunc:YO};var ZO=Un(r=>Math.expm1(r)),EIe=ns(fa,ZO),Rj={kernelName:fa,backendName:"cpu",kernelFunc:EIe};var QO=Un(r=>Math.floor(r)),kIe=ns(ha,QO),Oj={kernelName:ha,backendName:"cpu",kernelFunc:kIe};var JO=It((r,t)=>Math.floor(r/t)),NIe=Mt(ma,JO,null,"int32"),Mj={kernelName:ma,backendName:"cpu",kernelFunc:NIe};function nT(r,t,e,n,o,s,i,a,u){let l=Ne([n,s],e);for(let c=0;c<n;c++){let p=[],d=0;for(let f=0;f<o;f++){let h=r[c*o+f];d+=h*i[f],p.push(h)}if(d<0||d>=u/s)throw new Error(`Invalid indices: ${p} does not index into ${a}`);for(let f=0;f<s;f++)l.values[c*s+f]=t.get(...t.indexToLoc(d*s+f))}return l}function oT(r,t,e){let n=Ne(e,r.dtype);for(let o=0;o<n.size;++o){let i=n.indexToLoc(o).slice(),a=i[0],u=i[2],l=t.locToIndex([a,u]);i[2]=t.values[l];let c=r.locToIndex(i);0<=c&&c<r.values.length&&(n.values[o]=r.values[c])}return n}var eM=It((r,t)=>r>t?1:0),DIe=Mt(mc,eM,null,"bool"),Fj={kernelName:mc,backendName:"cpu",kernelFunc:DIe};var tM=It((r,t)=>r>=t?1:0),AIe=Mt(ga,tM,null,"bool"),$j={kernelName:ga,backendName:"cpu",kernelFunc:AIe};var rM=It((r,t)=>r<t?1:0),RIe=Mt(gc,rM,null,"bool"),Pj={kernelName:gc,backendName:"cpu",kernelFunc:RIe};var nM=It((r,t)=>r<=t?1:0),OIe=Mt(yc,nM,null,"bool"),Lj={kernelName:yc,backendName:"cpu",kernelFunc:OIe};function sT(r,t,e){let n=(t-r)/(e-1),o=b.makeZerosTypedArray(e,"float32");o[0]=r;for(let s=1;s<o.length;s++)o[s]=o[s-1]+n;return o}var oM=Un(r=>Math.log(r)),MIe=ns(ba,oM),zj={kernelName:ba,backendName:"cpu",kernelFunc:MIe};function iT(r,t,e,n){let o=b.getTypedArrayFromDType(n,b.sizeFromShape(e));for(let s=0;s<o.length;++s){let i=s*t,a=r[i];for(let u=0;u<t;++u){let l=r[i+u];(Number.isNaN(l)||l>a)&&(a=l)}o[s]=a}return o}var sM=It((r,t)=>Math.max(r,t)),FIe=Mt(Ca,sM),Bj={kernelName:Ca,backendName:"cpu",kernelFunc:FIe};var iM=It((r,t)=>Math.min(r,t)),$Ie=Mt(Sa,iM),Vj={kernelName:Sa,backendName:"cpu",kernelFunc:$Ie};var xb=It((r,t)=>r*t),PIe=vy((r,t,e,n)=>({real:r*e-t*n,imag:r*n+t*e})),Mh=Mt(Ta,xb,PIe),Uj={kernelName:Ta,backendName:"cpu",kernelFunc:Mh};function aM(r,t,e){let n=b.createScalarValue(-1,e);return xb([],t,n,r,e)}function LIe(r){let{inputs:t,backend:e}=r,{x:n}=t;de(n,"neg");let o=e.data.get(n.dataId).values,[s,i]=aM(o,n.shape,n.dtype);return e.makeTensorInfo(i,n.dtype,s)}var Gj={kernelName:il,backendName:"cpu",kernelFunc:LIe};var uM=It((r,t)=>r!==t?1:0),zIe=Mt(wc,uM,null,"bool"),Wj={kernelName:wc,backendName:"cpu",kernelFunc:zIe};function wy(r,t,e,n,o){let s=t.length,i=b.sizeFromShape(t),a=b.computeStrides(t),u=b.computeStrides(o),l=b.getTypedArrayFromDType(e,b.sizeFromShape(o));for(let c=0;c<i;++c){let p=b.indexToLoc(c,s,a),d=new Array(p.length);for(let h=0;h<d.length;h++)d[h]=p[n[h]];let f=b.locToIndex(d,s,u);l[f]=r[c]}return l}function Hr(r){let{inputs:t,attrs:e,backend:n}=r,{x:o}=t,{perm:s}=e;de(o,"transpose");let i=o.shape.length,a=new Array(i);for(let p=0;p<a.length;p++)a[p]=o.shape[s[p]];let u=n.data.get(o.dataId).values,l=wy(u,o.shape,o.dtype,s,a);return{dataId:n.write(l,a,o.dtype),shape:a,dtype:o.dtype}}var jj={kernelName:mi,backendName:"cpu",kernelFunc:Hr};function lM(r,t,e,n){let[o,s]=T.computeOutAndReduceShapes(r,n),i=mr(t,"int32"),a=b.makeZerosTypedArray(b.sizeFromShape(o),i),u=b.sizeFromShape(s);for(let l=0;l<a.length;++l){let c=l*u,p=1;for(let d=0;d<u;++d)p*=e[c+d];a[l]=p}return{outVals:a,outShape:o,outDtype:i}}function BIe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;de(o,"prod");let a=o.shape.length,u=b.parseAxisParam(s,o.shape),l=T.getAxesPermutation(u,a),c=u,p=o,d=[];l!=null&&(p=Hr({inputs:{x:o},backend:e,attrs:{perm:l}}),d.push(p),c=T.getInnerMostAxes(c.length,a));let f=e.data.get(p.dataId).values,{outVals:h,outShape:m,outDtype:g}=lM(p.shape,p.dtype,f,c),y=m;return i&&(y=T.expandShapeToKeepDim(m,u)),d.forEach(x=>e.disposeIntermediateTensorInfo(x)),e.makeTensorInfo(y,g,h)}var Hj={kernelName:dl,backendName:"cpu",kernelFunc:BIe};function VIe(r,t,e){r.forEach((n,o)=>{if(n<0||n>=e){let s=b.indexToLoc(o,t.length,b.computeStrides(t)).join(",");throw new Error(`indices[${s}] = ${n} is not in [0, ${e})`)}})}function UIe(r,t){for(let e=0;e<r.length;++e){let n=r[e],o=e===r.length-1?t:r[e+1].length;if(n.length===0)throw new Error("Ragged splits may not be empty");if(n[0]<0)throw new Error("Ragged splits must be non-negative");if(n[n.length-1]>o)throw new Error("Ragged splits must not point past values");for(let s=1;s<n.length;++s)if(n[s-1]>n[s])throw new Error("Ragged splits must be sorted in ascending order")}}function GIe(r,t,e,n){let o=[],s=0,i=t.length-1+e.length,a=new Array(i).fill(null).map(()=>[0]);UIe(e,n);let u=1;for(let l=0;l<t.length-1;++l){u*=t[l];let c=t[l+1];for(let p=1;p<u+1;++p)a[l].push(p*c)}for(let l=0;l<r.length;++l){let c=r[l],p=r[l]+1;for(let d=0;d<e.length;++d){let f=e[d],h=d+t.length-1;if(h>=0){let m=a[h],g=m[m.length-1]-f[c];for(let y=c;y<p;++y)a[h].push(f[y+1]+g)}c=f[c],p=f[p]}p!==c&&(o.push([c,p]),s+=p-c)}return{outSplits:a,valueSlices:o,numValues:s}}function WIe(r){let t=[];for(let e=0;e<r.length;++e){let n=r[e].length,o=b.getArrayFromDType("int32",n);t.push(o),r[e].forEach((s,i)=>o[i]=s)}return t}function qj(r,t){let e=r.slice(0,t);for(;e.length<t;)e.push(1);for(let n=t;n<r.length;n++)e[t-1]*=r[n];return e}function jIe(r,t,e,n,o,s){let i=qj(t,2)[1],a=qj(s,2)[1],u=0;for(let l of e)for(let c=l[0];c<l[1];++c){for(let p=0;p<n;++p)o[u*a+p]=r[c*i+p];++u}}function HIe(r,t,e,n,o){let s=t.slice();s[0]=o;let i=b.getArrayFromDType(e,b.sizeFromShape(s)),a=r.length,u=a===0?0:a/t[0];return jIe(r,t,n,u,i,s),[i,s]}function aT(r,t,e,n,o,s,i,a){if(r.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");let u=t[0][0]-1;if(VIe(s,i,u),n.length===0)throw new Error("params.rank must be nonzero");let l=n[0],{outSplits:c,valueSlices:p,numValues:d}=GIe(s,i,r,l),f=WIe(c),h=HIe(e,n,o,p,d);return[f,h[0],h[1]]}var Kj=2147483647;function uT(r,t,e,n,o,s,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(o.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let a=t.length===0,u=o.length===0,l=i.length===0,c=[];a||c.push(t[0]),u||c.push(o[0]),l||c.push(i[0]);for(let g=1;g<c.length;++g)if(c[g]!==c[g-1])throw new Error("starts, limits, and deltas must have the same shape");let p=c.length===0?1:c[0],d=b.getArrayFromDType("int32",p+1);d[0]=0;for(let g=0;g<p;++g){let y=a?r[0]:r[g],x=u?n[0]:n[g],w=l?s[0]:s[g];if(w===0)throw new Error("Requires delta != 0");let C;if(w>0&&x<y||w<0&&x>y)C=0;else if(C=Math.ceil(Math.abs((x-y)/w)),C>Kj)throw new Error(`Requires ((limit - start) / delta) <= ${Kj}`);d[g+1]=d[g]+C}let f=d[p],h=b.getArrayFromDType(e,f),m=0;for(let g=0;g<p;++g){let y=d[g+1]-d[g],x=a?r[0]:r[g],w=l?s[0]:s[g];for(let C=0;C<y;++C)h[m++]=x,x+=w}return[d,h]}var Ei=T.RowPartitionType,cM=class r{constructor(t,e,n,o,s,i,a,u,l,c){this.shape=t,this.shapeShape=e,this.values=n,this.valuesShape=o,this.valuesDType=s,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=u,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=T.getRowPartitionTypesHelper(c),this.raggedRank=T.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Ei.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Ei.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){let e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Ei.VALUE_ROWIDS:return r.getMaxWidthValueRowID(e);case Ei.ROW_SPLITS:return r.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${Ei[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){let e=t.length;if(e===0||e===1)return 0;let n=0;for(let o=0;o<e-1;++o){let s=t[o+1]-t[o];s>n&&(n=s)}return n}static getMaxWidthValueRowID(t){let e=t.length;if(e===0)return 0;let n=0,o=t[0],s=0;for(let i=1;i<e;++i){let a=t[i];a!==o&&(o=a,s=Math.max(i-n,s),n=i)}return Math.max(e-n,s)}tensorShapeFromTensor(t,e,n=!0){if(e.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return Yj(t,n)}calculateOutputSize(t){let e=this.valuesShape,n=this.defaultValueShape;T.validateDefaultValueShape(n,e);let o=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=T.combineRaggedTensorToTensorShapes(this.raggedRank,o,e);i[0]<0&&(i[0]=t);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(t,e,n){let o=Math.min(t,n),s=[],i=0;for(let a=0;a<o;++a,i+=e)s.push(i);for(let a=o;a<t;++a)s.push(-1);return b.assert(s.length===t,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(t,e,n,o){let s=t.length,i=[];for(let a=0;a<s-1;++a){let u=t[a+1]-t[a],l=Math.min(o,u),c=e[a];c===-1&&(l=0);for(let p=0;p<l;++p)i.push(c),c+=n;for(let p=0;p<u-l;++p)i.push(-1)}if(s>0&&i.length!==t[s-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,e,n,o){let s=t.length,i=[];if(s===0)return[];let a=0,u=t[0];if(u>=e.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${e.length}`);let l=e[u];i.push(l);for(let c=1;c<s;++c){let p=t[c];if(p===u)l>=0&&(++a,a<o?l+=n:l=-1);else{if(a=0,u=p,p>=e.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${e.length}`);l=e[p]}i.push(l)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,e,n,o){let s=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case Ei.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,e,n,o);case Ei.ROW_SPLITS:if(s.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(s,e,n,o);default:throw new Error(`Unsupported partition type: ${Ei[i]}`)}}getFirstDimensionSize(){let t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let e=this.rowPartitionTypes[0];switch(e){case Ei.FIRST_DIM_SIZE:return t[0];case Ei.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Ei.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Ei[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let e=this.getFirstDimensionSize(),n=this.calculateOutputSize(e),o=new Array(this.raggedRank+1);o[o.length-1]=1;for(let u=o.length-2;u>=0;--u)o[u]=o[u+1]*n[u+1];let s=Yj(n,!1),i=b.getArrayFromDType(this.valuesDType,b.sizeFromShape(s));if(o[0]*n[0]>0){let u=this.calculateFirstParentOutputIndex(e,o[0],n[0]);for(let l=1;l<=this.raggedRank;++l)u=this.calculateOutputIndex(l-1,u,o[l],n[l]);this.setOutput(this.raggedRank,u,i,s)}return[s,i]}setOutput(t,e,n,o){if(n.length===0)return;let s=this.values,i=n,a=o.slice();a=a.slice(t+1);let u=b.sizeFromShape(a),l=e.length,c=this.defaultValue;if(c.length!==u&&c.length!==1){let h=this.defaultValueShape;X(()=>{let m=V(c,h);c=Rl(m,a).dataSync()})}let p=0,d=0,f=0;for(let h=0;h<=l;++h){let m=h<l?e[h]:-1;if(m===f){++f;continue}if(d<f){let g=s.subarray(p*u),y=i.subarray(d*u),x=(f-d)*u;Xj(y,g,x)}if(h>=l){let g=n.length;m=Math.floor(g/u)}if(m>f)if(this.defaultValue.length===1)i.subarray(f*u,m*u).fill(this.defaultValue[0]),f=m;else for(;m>f;){let g=i.slice(f*u);Xj(g,c,u),++f}m<0?(p=h+1,d=f):(p=h,d=f,f=d+1)}}};function Xj(r,t,e){for(let n=0;n<e;n++)r[n]=t[n]}function Yj(r,t){let e=[];for(let n of r){if(n<0){if(!t)throw new Error(`Dimension ${n} must be >= 0`);if(n<-1)throw new Error(`Dimension ${n} must be >= -1`);n=-1}e.push(n)}return e}function lT(r,t,e,n,o,s,i,a,u,l){return new cM(r,t,e,n,o,s,i,a,u,l).compute()}function cT(r,t,e,n){let o=r===t,s=r<t&&e<0,i=t<r&&e>1;if(o||s||i)return b.makeZerosTypedArray(0,n);let a=Math.abs(Math.ceil((t-r)/e)),u=b.makeZerosTypedArray(a,n);t<r&&e===1&&(e=-1),u[0]=r;for(let l=1;l<u.length;l++)u[l]=u[l-1]+e;return u}var pM=Un(r=>1/Math.sqrt(r)),qIe=ns(Aa,pM),Zj={kernelName:Aa,backendName:"cpu",kernelFunc:qIe};function eu(r,t,e,n,o,s,i,a,u,l){let c=[n/o,o],p=r.values,d=t.values;if(n===0)return Ne(e,t.dtype);let f=u instanceof jt?u:Ne(c,t.dtype);typeof u=="string"||typeof u=="number"?f.values.fill(u):typeof u=="boolean"&&f.values.fill(+u);for(let h=0;h<s;h++){let m=[],g=0;for(let y=0;y<i;y++){let x=p[h*i+y];m.push(x),g+=x*a[y]}if(g<0||g>=n/o)throw new Error(`Invalid indices: ${m} does not index into ${e}`);for(let y=0;y<o;y++)l?f.values[g*o+y]+=d[h*o+y]:f.values[g*o+y]=t.rank===0?d[0]:d[h*o+y]}return f}var Qj=Un(r=>1/(1+Math.exp(-r))),dM=Je($a,r=>1/(1+Math.exp(-r))),Jj={kernelName:$a,backendName:"cpu",kernelFunc:dM};function fM(r,t,e,n,o){let s=en.isSliceContinous(n,t,e),i=b.sizeFromShape(e),a=b.computeStrides(n);if(s){let p=en.computeFlatOffset(t,a);return o==="string"?r.slice(p,p+i):r.subarray(p,p+i)}let u=o==="string"?T.fromUint8ToStringArray(r):r,l=Ne(n,o,u),c=Ne(e,o);for(let p=0;p<c.size;++p){let d=c.indexToLoc(p),f=d.map((h,m)=>h+t[m]);c.set(l.get(...f),...d)}return o==="string"?T.fromStringArrayToUint8(c.values):c.values}function ki(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,size:i}=n;de(o,"slice");let[a,u]=en.parseSliceParams(o,s,i);en.assertParamsValid(o,a,u);let l=e.data.get(o.dataId).values,c=fM(l,a,u,o.shape,o.dtype);return e.makeTensorInfo(u,o.dtype,c)}var eH={kernelName:xl,backendName:"cpu",kernelFunc:ki};function pT(r,t,e,n,o,s,i){let a=t[0],u=s[0],l=new Array(u),c=new Array(a),p=t[1];if(u===0){if(a!==0)throw new Error(T.getSparseFillEmptyRowsIndicesDenseShapeMismatch(a));let g=b.getArrayFromDType(e,0),y=b.getArrayFromDType(o,0);return[g,[0,p],y,l,c]}let d=!0,f=0,h=new Array(u).fill(0);for(let g=0;g<a;++g){let y=r[g*p];if(y<0)throw new Error(T.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,y));if(y>=u)throw new Error(T.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,y,u));++h[y],d=d&&y>=f,f=y}let m=!0;for(let g=0;g<u;++g){let y=h[g]===0;l[g]=y,m=m&&!y,h[g]=Math.max(h[g],1),g>0&&(h[g]+=h[g-1])}if(m&&d){let g=r,y=n;for(let x=0;x<a;++x)c[x]=x;return[g,[a,p],y,l,c]}else{let g=h[u-1],y=b.getArrayFromDType(e,g*p),x=b.getArrayFromDType(o,g),w=new Array(u).fill(0);for(let C=0;C<a;++C){let I=r[C*p],N=w[I],A=(I===0?0:h[I-1])+N;w[I]++;for(let O=0;O<p;++O)y[A*p+O]=r[C*p+O];x[A]=n[C],c[C]=A}for(let C=0;C<u;++C)if(w[C]===0){let N=C===0?0:h[C-1];y[N*p+0]=C;for(let A=1;A<p;++A)y[N*p+A]=0;x[N]=i}return[y,[g,p],x,l,c]}}function dT(r,t,e,n,o){let s=b.sizeFromShape(n),i=t[0],a=o.length,u=[],l=1,c=-1;for(let g=0;g<a;++g){let y=o[g];if(y===-1){if(c!==-1)throw new Error(T.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,g));c=g,u.push(1)}else{if(y<0)throw new Error(T.getSparseReshapeNegativeOutputDimErrorMessage(g,y));l*=y,u.push(y)}}if(c!==-1){if(l<=0)throw new Error(T.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let g=Math.trunc(s/l);if(l*g!==s)throw new Error(T.getSparseReshapeInputOutputMultipleErrorMessage(n,u));u[c]=g}if(b.sizeFromShape(u)!==s)throw new Error(T.getSparseReshapeInputOutputMismatchErrorMessage(n,u));let d=n.length,f=[];if(d>0){f[d-1]=1;for(let g=d-2;g>=0;--g)f[g]=f[g+1]*n[g+1]}let h=[];if(a>0){h[a-1]=1;for(let g=a-2;g>=0;--g)h[g]=h[g+1]*u[g+1]}let m=b.getArrayFromDType(e,i*a);for(let g=0;g<i;++g){let y=0;for(let x=0;x<d;++x)y+=r[g*d+x]*f[x];for(let x=0;x<a;++x)m[g*a+x]=Math.trunc(y/h[x]),y%=h[x]}return[m,[i,a],u]}function Cy(r,t,e,n,o,s=!1,i=0){let a=n.length,u=[t[0],r.length/t[0]],l=u[1],p=a>0?o[a-1]+1:0;if(p<0)throw new Error(T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let d=t.slice();d[0]=p;let f=d.reduce((w,C)=>w*C,1),h=b.getArrayFromDType(e,f);if(a===0)return p>0&&h.fill(i),[h,d];if(p<=0)throw new Error(T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=0,g=1,y=0,x=o[m];for(;;){let w=0;if(g<a){if(w=o[g],x===w){++g;continue}if(x>=w)throw new Error(T.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(x<0||x>=p)throw new Error(T.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(x,p));x>y&&h.fill(i,y*l,x*l);for(let C=m;C<g;++C){let I=n[C];if(I<0||I>=u[0])throw new Error(T.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(C,n[C],u[0]));for(let N=0;N<l;N++)h[x*l+N]+=r[I*l+N]}if(s)for(let C=0;C<l;C++)h[x*l+C]/=g-m;if(m=g,++g,y=x+1,x=w,g>a)break}return y<p&&h.fill(i,y*l,p*l),[h,d]}var tH=Un(r=>Math.sqrt(r)),KIe=Je(La,r=>Math.sqrt(r)),rH={kernelName:La,backendName:"cpu",kernelFunc:KIe};var hM=It((r,t)=>{let e=r-t;return e*e}),XIe=Mt(za,hM),nH={kernelName:za,backendName:"cpu",kernelFunc:XIe};var mM=Un((r,t)=>{let{pattern:e,replaceGlobal:n,rewrite:o}=t;return r.replace(new RegExp(e,n?"g":""),o)}),YIe=ns(rh,mM),oH={kernelName:rh,backendName:"cpu",kernelFunc:YIe};function fT(r,t,e,n){let o=Ne(r,t.dtype);for(let s=0;s<o.size;s++){let i=o.indexToLoc(s),a=new Array(i.length);for(let u=0;u<a.length;u++)a[u]=i[u]*e[u]+n[u];o.set(t.get(...a),...i)}return o}var gM=class{constructor(t,e,n,o,s,i){this.separator=b.encodeString(t),this.nGramWidths=e,this.leftPad=b.encodeString(n),this.rightPad=b.encodeString(o),this.padWidth=s,this.preserveShort=i}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){let n=this.getPadWidth(e);return Math.max(0,t+2*n-e+1)}createNGrams(t,e,n,o,s,i){for(let a=0;a<s;++a){let u=this.getPadWidth(i),l=Math.max(0,u-a),c=Math.max(0,u-(s-(a+1))),p=i-(l+c),d=e+(l>0?0:a-u),f=0;f+=l*this.leftPad.length;for(let x=0;x<p;++x)f+=t[d+x].length;f+=c*this.rightPad.length;let h=l+c+p-1;f+=h*this.separator.length,n[o+a]=new Uint8Array(f);let m=n[o+a],g=0,y=x=>x.forEach(w=>m[g++]=w);for(let x=0;x<l;++x)y(this.leftPad),y(this.separator);for(let x=0;x<p-1;++x)y(t[d+x]),y(this.separator);if(p>0){y(t[d+p-1]);for(let x=0;x<c;++x)y(this.separator),y(this.rightPad)}else{for(let x=0;x<c-1;++x)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(t,e){let n=t.length,o=e.length;if(o>0){let u=e[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let l=1;l<o;++l){let c=e[l]>=u;if(c=c&&e[l]<=n,!c)throw new Error(`Invalid split value ${e[l]}, must be in [${u}, ${n}]`);u=e[l]}if(u!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${u}`)}let s=o-1,i=b.getArrayFromDType("int32",o);if(n===0||o===0){let u=new Array(n);for(let l=0;l<=s;++l)i[l]=0;return[u,i]}i[0]=0;for(let u=1;u<=s;++u){let l=e[u]-e[u-1],c=0;this.nGramWidths.forEach(p=>{c+=this.getNumNGrams(l,p)}),this.preserveShort&&l>0&&c===0&&(c=1),i[u]=i[u-1]+c}let a=new Array(i[s]);for(let u=0;u<s;++u){let l=e[u],c=i[u];if(this.nGramWidths.forEach(p=>{let d=e[u+1]-e[u],f=this.getNumNGrams(d,p);this.createNGrams(t,l,a,c,f,p),c+=f}),this.preserveShort&&c===i[u]){let p=e[u+1]-e[u];if(p===0)continue;let d=p+2*this.padWidth;this.createNGrams(t,l,a,c,1,d)}}return[a,i]}};function hT(r,t,e,n,o,s,i,a){return new gM(e,n,o,s,i,a).compute(r,t)}function ZIe(r,t,e,n){if(!r.length)return;if(t.length===0){for(let s=0;s<r.length;++s)n.push(r.subarray(s,s+1));return}if(t.length===1){let s=t[0],i=r.indexOf(s);for(;i!==-1;){let a=r.subarray(0,i);(!e||a.length!==0)&&n.push(a),r=r.subarray(i+1),i=r.indexOf(s)}(!e||r.length!==0)&&n.push(r);return}let o=0;for(let s=0;s<r.length+1;s++)if(s===r.length||t.indexOf(r[s])!==-1){let i=r.subarray(o,s);(!e||i.length!==0)&&n.push(i),o=s+1}}function mT(r,t,e){let n=r.length,o=[],s=0,i=0,a=new Array(n);for(let d=0;d<n;++d){let f=o.length;ZIe(r[d],t,e,o);let h=o.length-f;a[d]=h,s+=h,i=Math.max(i,h)}let u=b.getArrayFromDType("int32",s*2),l=new Array(s),c=[n,i],p=0;for(let d=0;d<n;++d)for(let f=0;f<a[d];++f)u[p*2]=d,u[p*2+1]=f,l[p]=o[p],++p;return[u,l,c]}function gT(r,t){let e=b.getArrayFromDType("int32",r.length);for(let n=0;n<r.length;++n)e[n]=b.fingerPrint64(r[n]).modulo(t).getLowBitsUnsigned();return e}var yM=It((r,t)=>r-t),QIe=vy((r,t,e,n)=>({real:r-e,imag:t-n})),vb=Mt(Ba,yM,QIe),sH={kernelName:Ba,backendName:"cpu",kernelFunc:vb};function yT(r,t){let e=new Array(r.rank);for(let o=0;o<e.length;o++)e[o]=r.shape[o]*t[o];let n=Ne(e,r.dtype);for(let o=0;o<n.values.length;++o){let s=n.indexToLoc(o),i=new Array(r.rank);for(let u=0;u<i.length;u++)i[u]=s[u]%r.shape[u];let a=r.locToIndex(i);n.values[o]=r.values[a]}return n}var bb=(r,t)=>{let e=t.value-r.value;return e===0?r.index-t.index:e};function iH(r,t,e=0,n=r.length-1){for(;n>e;){if(n-e>600){let a=n-e+1,u=t-e+1,l=Math.log(a),c=.5*Math.exp(2*l/3),p=.5*Math.sqrt(l*c*(a-c)/a)*Math.sign(u-a/2),d=Math.max(e,Math.floor(t-u*c/a+p)),f=Math.min(n,Math.floor(t+(a-u)*c/a+p));iH(r,t,d,f)}let o=r[t],s=e,i=n;for(b.swap(r,e,t),bb(r[n],o)>0&&b.swap(r,e,n);s<i;){for(b.swap(r,s,i),s++,i--;bb(r[s],o)<0;)s=s+1;for(;bb(r[i],o)>0;)i=i-1}bb(r[e],o)===0?b.swap(r,e,i):(i=i+1,b.swap(r,i,n)),i<=t&&(e=i+1),t<=i&&(n=i-1)}}function xT(r,t,e,n,o){let s=t[t.length-1],[i,a]=[r.length/s,s],u=b.getTypedArrayFromDType(e,i*n),l=b.getTypedArrayFromDType("int32",i*n);for(let p=0;p<i;p++){let d=p*a,f=r.subarray(d,d+a),h=new Array(f.length);f.forEach((x,w)=>h[w]={value:x,index:w}),n<h.length&&(iH(h,n),h=h.slice(0,n)),o&&h.sort(bb);let m=p*n,g=u.subarray(m,m+n),y=l.subarray(m,m+n);for(let x=0;x<n;x++)g[x]=h[x].value,y[x]=h[x].index}let c=t.slice();return c[c.length-1]=n,[Ne(c,e,u),Ne(c,"int32",l)]}function vT(r,t,e,n){let o=b.parseAxisParam(t,e)[0],s=[1,e[0],1];for(let h=0;h<o;h++)s[0]*=e[h];s[1]=e[o];for(let h=o+1;h<e.length;h++)s[2]*=e[h];let i=new Map,a=new Int32Array(e[o]),u=new jt(s,n,r),l=[],c=s[0]===1&&s[2]===1;for(let h=0;h<e[o];h++){let m;if(c)m=r[h].toString();else{let y=[];for(let x=0;x<s[0];x++)for(let w=0;w<s[2];w++)y.push(u.get(x,h,w));m=y.join(",")}let g=i.get(m);if(g!=null)a[h]=g;else{let y=i.size;i.set(m,y),a[h]=y,l.push(h)}}let p=s.slice();p[1]=i.size;let d=new jt(p,n);l.forEach((h,m)=>{for(let g=0;g<s[0];g++)for(let y=0;y<s[2];y++)d.set(u.get(g,h,y),g,m,y)});let f=e.slice();return f[o]=p[1],{outputValues:d.values,outputShape:f,indices:a}}var{addImpl:aH,castImpl:uH,ceilImpl:lH,concatImpl:cH,equalImpl:pH,expImpl:dH,expm1Impl:fH,floorImpl:hH,floorDivImpl:mH,gatherNdImpl:gH,gatherV2Impl:yH,greaterEqualImpl:xH,greaterImpl:vH,lessEqualImpl:bH,lessImpl:wH,logImpl:CH,maxImpl:SH,maximumImpl:IH,minimumImpl:TH,multiplyImpl:_H,negImpl:EH,notEqualImpl:kH,prodImpl:NH,rangeImpl:DH,rsqrtImpl:AH,scatterImpl:RH,simpleAbsImpl:OH,sliceImpl:MH,stridedSliceImpl:FH,stringNGramsImpl:$H,subImpl:PH,tileImpl:LH,topKImpl:zH,transposeImpl:BH,uniqueImpl:ZAt}=wb;var JIe=Be({opType:fe.ABS,cpuKernelImpl:OH}),VH={kernelName:Ou,backendName:"webgpu",kernelFunc:JIe};var eTe=Be({opType:fe.ACOS}),UH={kernelName:Qi,backendName:"webgpu",kernelFunc:eTe};var tTe=Be({opType:fe.ACOSH}),GH={kernelName:Ji,backendName:"webgpu",kernelFunc:tTe};var rTe=Vt({opType:Le.ADD,cpuKernelImpl:aH,supportsComplex:!0}),WH={kernelName:js,backendName:"webgpu",kernelFunc:rTe};var bT=class{constructor(t){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t[0],this.variableNames=t.map((e,n)=>`T${n}`),this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){let t=[];this.variableNames.forEach(o=>{t.push(`let v${o} = get${o}ByOutputCoords(coords);`)});let e=this.variableNames.map(o=>`v${o}`).join(" + ");return`
      ${oe("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${t.join(`
        `)}
            setOutputAtIndex(flatIndex, ${e});
          }
        }
      }
    `}};function nTe(r){let{inputs:t,backend:e}=r,n=t;if(n.length===1)return sn({inputs:{x:n[0]},backend:e});let o=n.map(a=>a.dtype).reduce((a,u)=>mr(a,u)),s=n.map(a=>a.shape),i=new bT(s);return e.runWebGPUProgram(i,n,o)}var jH={kernelName:Mu,backendName:"webgpu",kernelFunc:nTe};var wT=class{constructor(t,e){this.variableNames=["A"],this.workgroupSize=[16,16,1];let n=new Array(t.length);for(let o=0;o<n.length;o++)n[o]=t[e[o]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){b.assert(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);let t=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${oe()} {
        var x = i32(workgroupId.x) * ${t} + i32(localId.x);
        var y = i32(workgroupId.y) * ${t} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${t} + i32(localId.x);
        y = i32(workgroupId.x) * ${t} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}};var CT=class{constructor(t,e){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;let n=new Array(t.length);for(let o=0;o<n.length;o++)n[o]=t[e[o]];this.outputShape=n,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=e,this.shaderKey=`transpose_${e}`}getUserCode(){let t=Dr(this.outputShape.length),e=xM(this.newDim);return`
      ${oe("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${t}(${e}), uniforms.aShape)]);
          }
        }
      }
    `}};function xM(r){let t=r.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let e=new Array(t);for(let n=0;n<r.length;n++)e[r[n]]=`coords.${Ii(n)}`;return e.join()}function Io(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{perm:s}=n,i=e,a=o.shape.length,u=new Array(a);for(let c=0;c<u.length;c++)u[c]=o.shape[s[c]];if(e.shouldExecuteOnCPU([o])){let p=i.tensorMap.get(o.dataId).values,d=BH(p,o.shape,o.dtype,s,u);return e.makeTensorInfo(u,o.dtype,d)}if(o.shape.length===2&&b.arraysEqual(s,[1,0])){let c=new wT(o.shape,s);return i.runWebGPUProgram(c,[o],o.dtype)}let l=new CT(o.shape,s);return i.runWebGPUProgram(l,[o],o.dtype)}var HH={kernelName:mi,backendName:"webgpu",kernelFunc:Io};var ST=class{constructor(t,e,n){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[t.batchSize,t.inSize];let[o]=T.computeOutAndReduceShapes(this.inputShape,[1]);this.outputShape=o.length===0?[1]:o,t.inSize>=32768&&n>=512?this.workgroupSize=[512,1,1]:t.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=e,this.shaderKey=`reduce_${e}`}getUserCode(){let t="",e="0.0",n=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(t=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,e="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?t=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(t=" bestValue = bestValue * candidate; ",e="1.0"):this.reduceType==="all"?(t=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",e="1.0"):this.reduceType==="any"&&(t=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",e="0.0");let o=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${n}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${oe("index")} {
         let outputIndex = index / ${n};
         let offset = getOffset(outputIndex);
         var bestValue = ${e};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${n}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${n}) {
           let candidate = f32(x[offset + k]);
           ${t}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${n}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${t}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${o}
        }
       }
     `}};var oTe={mean:"float32",all:"bool",any:"bool"};function ks(r,t,e,n,o){let s=r.shape.length,i=[],a=b.parseAxisParam(t,r.shape),u=a,l=T.getAxesPermutation(u,s),c=r;l!=null&&(c=Io({inputs:{x:r},attrs:{perm:l},backend:o}),u=T.getInnerMostAxes(u.length,s),i.push(c)),T.assertAxesAreInnerMostDims(n,u,s);let[p,d]=T.computeOutAndReduceShapes(c.shape,u),f=p;e&&(f=T.expandShapeToKeepDim(p,a));let h;if((n==="max"||n==="prod")&&o.shouldExecuteOnCPU([c])){let m=o.tensorMap.get(c.dataId).values;switch(n){case"max":let g=SH(m,b.sizeFromShape(d),f,r.dtype);h=o.makeTensorInfo(f,r.dtype,g);break;case"prod":let{outVals:y,outShape:x,outDtype:w}=NH(c.shape,c.dtype,m,u);h=o.makeTensorInfo(x,w,y);break;default:throw new Error(`${n} CPU implementation is not yet supported.`)}}else{let m=b.sizeFromShape(d),y=b.sizeFromShape(c.shape)/m,x={windowSize:m,inSize:m,batchSize:y,outSize:1},w=oTe[n]||_c(r.dtype),C=[{type:"int32",data:[m]}],I=new ST(x,n,o.device.limits.maxComputeWorkgroupSizeX),N=o.runWebGPUProgram(I,[c],w,C);i.push(N),h=Ee({inputs:{x:N},attrs:{shape:f},backend:o})}return i.forEach(m=>o.disposeData(m.dataId)),h}function sTe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{keepDims:s,axis:i}=n;return ks(o,i,s,"all",e)}var qH={kernelName:Ep,backendName:"webgpu",kernelFunc:sTe};function iTe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{keepDims:s,axis:i}=n;return ks(o,i,s,"any",e)}var KH={kernelName:kp,backendName:"webgpu",kernelFunc:iTe};var Sy=class{constructor(t,e,n){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;let o=[e];this.op=n==="min"?"<":">";let[s,i]=T.computeOutAndReduceShapes(t,o);this.outputShape=s.length===0?[1]:s,this.dispatchLayout=pe(this.outputShape),b.sizeFromShape(i)<32?(this.type="plain",this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=se(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=t,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){let t=this.workgroupSize[0],e=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${Ii(this.inputShape.length-1)}`,n=()=>{let o="";if(this.outputShape.length===1)this.inputShape.length!==1&&(o+="outputCoords,");else for(let s=0;s<this.outputShape.length;s++)o+=`outputCoords.${Ii(s)},`;return o};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${t}>;
      var<workgroup> xBestValues : array<f32, ${t}>;
    `}

      ${oe("index")} {
        let outputIndex = index / ${t};
        let reduceLength = ${e()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${t}) {
          let candidate = getX(${n()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${t}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${oe("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${n()} 0);
          let reduceLength = ${e()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${n()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}};function aTe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n,i=b.parseAxisParam(s,o.shape),a=T.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=Io({inputs:{x:o},backend:e,attrs:{perm:a}}),l.push(u),i=T.getInnerMostAxes(i.length,u.shape.length)),T.assertAxesAreInnerMostDims("argMax",[i[0]],u.shape.length);let c=new Sy(u.shape,i[0],"max"),p=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],d=e.runWebGPUProgram(c,[u],"int32",p);return l.forEach(f=>e.disposeData(f.dataId)),d}var XH={kernelName:Fu,backendName:"webgpu",kernelFunc:aTe};function uTe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n,i=b.parseAxisParam(s,o.shape),a=T.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=Io({inputs:{x:o},backend:e,attrs:{perm:a}}),l.push(u),i=T.getInnerMostAxes(i.length,u.shape.length)),T.assertAxesAreInnerMostDims("argMin",[i[0]],u.shape.length);let c=new Sy(u.shape,i[0],"min"),p=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],d=e.runWebGPUProgram(c,[u],"int32",p);return l.forEach(f=>e.disposeData(f.dataId)),d}var YH={kernelName:$u,backendName:"webgpu",kernelFunc:uTe};var lTe=Be({opType:fe.ASIN}),ZH={kernelName:ea,backendName:"webgpu",kernelFunc:lTe};var cTe=Be({opType:fe.ASINH}),QH={kernelName:ta,backendName:"webgpu",kernelFunc:cTe};var pTe=Be({opType:fe.ATAN}),JH={kernelName:ra,backendName:"webgpu",kernelFunc:pTe};var dTe=Vt({opType:Le.ATAN2}),eq={kernelName:oa,backendName:"webgpu",kernelFunc:dTe};var fTe=Be({opType:fe.ATANH}),tq={kernelName:na,backendName:"webgpu",kernelFunc:fTe};var IT=class{constructor(t){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=t.outShape,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${oe("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}};var zl=class{constructor(t,e,n=!1,o=!1,s=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,e==="avg"&&n)throw new Error("Cannot compute positions for average pool.");this.outputShape=t.outShape,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=e,this.computePositions=n,this.flattenPositions=o,this.includeBatchIndex=s,this.shaderKey=`pool2D_${e}_${n}_${o}_${s}`}getUserCode(){let t;this.poolType==="avg"?t="resultValue = resultValue + value; count = count + 1.0;":this.computePositions?t=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};
      }`:t="resultValue = max(value, resultValue);";let e="resultValue";return this.poolType==="avg"&&(e="resultValue / max(count, 1.0)"),`
      ${oe("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${t}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${e});`}
        }
      }
    `}},Xd=class{constructor(t,e,n=!1,o=!1,s=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,e==="avg"&&n)throw new Error("Cannot compute positions for average pool.");this.outputShape=t.outShape,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=e,this.computePositions=n,this.flattenPositions=o,this.includeBatchIndex=s,this.shaderKey=`pool3D_${e}_${n}_${o}_${s}`}getUserCode(){let t;this.poolType==="avg"?t="resultValue += value; count += 1.0;":this.computePositions?t=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }`:t="resultValue = max(value, resultValue);";let e="resultValue";return this.poolType==="avg"&&(e="resultValue / max(count, 1.0)"),`
      ${oe("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${t}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${e});`}
        }
      }
    `}};function vM(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reductionIndices:s,keepDims:i}=n;return ks(o,s,i,"max",e)}var rq={kernelName:el,backendName:"webgpu",kernelFunc:vM};function bM(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{keepDims:s,axis:i}=n;return ks(o,i,s,"mean",e)}var nq={kernelName:nl,backendName:"webgpu",kernelFunc:bM};function TT(r,t,e,n){if(t.filterWidth===1&&t.filterHeight===1&&b.arraysEqual(t.inShape,t.outShape))return sn({inputs:{x:r},backend:n});if(t.filterWidth===t.inWidth&&t.filterHeight===t.inHeight&&t.batchSize===1&&t.padInfo.type==="VALID"){let i=r.shape.length,a=Ee({inputs:{x:r},backend:n,attrs:{shape:[r.shape[i-3]*r.shape[i-2],r.shape[i-1]]}}),u;e==="avg"?u=bM({inputs:{x:a},backend:n,attrs:{axis:0,keepDims:!1}}):(b.assert(e==="max",()=>`Invalid pool type ${e}`),u=vM({inputs:{x:a},backend:n,attrs:{reductionIndices:0,keepDims:!1}}));let l=Ee({inputs:{x:u},backend:n,attrs:{shape:t.outShape}});return n.disposeData(a.dataId),n.disposeData(u.dataId),l}let o,s=[{type:"int32",data:[t.strideHeight,t.strideWidth]}];return t.filterHeight===1&&t.filterWidth===1?o=new IT(t):(e==="avg"?o=new zl(t,"avg"):(b.assert(e==="max",()=>`Invalid pool type ${e}`),o=new zl(t,"max")),s.push({type:"int32",data:[t.padInfo.top,t.padInfo.left]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]},{type:"int32",data:[t.inHeight,t.inWidth]},{type:"int32",data:[t.effectiveFilterHeight,t.effectiveFilterWidth]})),n.runWebGPUProgram(o,[r],r.dtype,s)}function hTe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,c=T.computePool2DInfo(o.shape,s,i,1,a,u);return TT(o,c,"avg",e)}var oq={kernelName:Pu,backendName:"webgpu",kernelFunc:hTe};function mTe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:i,pad:a,dataFormat:u,dimRoundingMode:l}=n,c=[1,1,1],p=T.computePool3DInfo(o.shape,s,i,c,a,l,u),d=new Xd(p,"avg"),f=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.front,p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inDepth,p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]}];return e.runWebGPUProgram(d,[o],o.dtype,f)}var sq={kernelName:Lu,backendName:"webgpu",kernelFunc:mTe};var _T=class{constructor(t){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`
      ${oe("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}},ET=class{constructor(t){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`
      ${oe("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}};function gTe(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,i=s,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=n,p=T.computePool3DInfo(i.shape,a,u,1,l,c),d=new ET(p),f=1/(p.filterDepth*p.filterHeight*p.filterWidth),h=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.effectiveFilterDepth-1-p.padInfo.front,p.effectiveFilterHeight-1-p.padInfo.top,p.effectiveFilterWidth-1-p.padInfo.left]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]},{type:"int32",data:[p.outDepth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"float32",data:[f]}];return e.runWebGPUProgram(d,[o],i.dtype,h)}var iq={kernelName:Dp,backendName:"webgpu",kernelFunc:gTe};function yTe(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,i=s;mb([o,s],"avgPoolGrad");let{filterSize:a,strides:u,pad:l}=n,c=T.computePool2DInfo(i.shape,a,u,1,l),p=new _T(c),d=1/(c.filterHeight*c.filterWidth),f=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.effectiveFilterHeight-1-c.padInfo.top,c.effectiveFilterWidth-1-c.padInfo.left]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[c.effectiveFilterHeight,c.effectiveFilterWidth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"float32",data:[d]}];return e.runWebGPUProgram(p,[o],i.dtype,f)}var aq={kernelName:Np,backendName:"webgpu",kernelFunc:yTe};function xTe(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s}=t,{transposeA:i,transposeB:a}=n;return Oh({a:o,b:s,transposeA:i,transposeB:a,backend:e})}var uq={kernelName:zu,backendName:"webgpu",kernelFunc:xTe};var kT=class{constructor(t,e){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.rank=e.length,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=t,this.uniforms=`start : ${Dr(t.length)}, `,this.shaderKey="slice"}getUserCode(){let t=Dr(this.rank),e=vTe(this.rank),n;return this.start.length===1?n=this.outputShape.map((s,i)=>"sourceLoc = uniforms.start + coords;"):n=this.outputShape.map((s,i)=>`sourceLoc.${wM[i]} = uniforms.start.${Ii(i)} + coords.${wM[i]};`),`
      ${oe("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${t};
          let coords = getCoordsFromIndex(index);
          ${n.join(`
`)}
          setOutputAtIndex(index, getSource(${e}));
        }
      }
    `}},wM=["x","y","z","w","u","v"];function vTe(r){if(r===1)return"sourceLoc";if(r<=6)return wM.slice(0,r).map(t=>`sourceLoc.${t}`).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}function tu(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,size:i}=n,[a,u]=en.parseSliceParams(o,s,i);if(en.assertParamsValid(o,a,u),e.shouldExecuteOnCPU([o])||o.dtype==="string"){let p=e.tensorMap.get(o.dataId),d=MH(p.values,a,u,o.shape,o.dtype);return e.makeTensorInfo(u,o.dtype,d)}if(b.sizeFromShape(u)===0)return e.makeTensorInfo(u,o.dtype,[]);let l=new kT(a,u),c=[{type:"int32",data:a}];return e.runWebGPUProgram(l,[o],o.dtype,c)}var lq={kernelName:xl,backendName:"webgpu",kernelFunc:tu};var bTe=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,crops:i}=n;b.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");let a=s.reduce((x,w)=>x*w),u=T.getReshaped(o.shape,s,a),l=T.getPermuted(u.length,s.length),c=T.getReshapedPermuted(o.shape,s,a),p=T.getSliceBeginCoords(i,s.length),d=T.getSliceSize(c,i,s.length),f=[],h=Ee({inputs:{x:o},backend:e,attrs:{shape:u}}),m=Io({inputs:{x:h},backend:e,attrs:{perm:l}}),g=Ee({inputs:{x:m},backend:e,attrs:{shape:c}}),y=tu({inputs:{x:g},backend:e,attrs:{begin:p,size:d}});return f.push(h),f.push(m),f.push(g),f.forEach(x=>e.disposeData(x.dataId)),y},cq={kernelName:Bu,backendName:"webgpu",kernelFunc:bTe};var wTe=`
  fn bincount_write(index: i32, value: f32) {
    ${Ts("&result[index]","value","float32")}
  }
`,CTe=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`,Iy=class{constructor(t,e,n=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=t,this.rank=t.length,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=n,n&&(this.atomic=!1),this.hasWeights=e,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?CTe:wTe}
  ${oe("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}};function STe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:i}=n,a=b.sizeFromShape(o.shape),l=b.sizeFromShape(s.shape)>0,c=[i],p=s.dtype,d=jr({backend:e,attrs:{shape:c,value:0,dtype:p}}),f=new Iy([a],l),h=[{type:"int32",data:[i]}],m=l?[o,s]:[o];return e.runWebGPUProgram(f,m,p,h,d)}var pq={kernelName:Ap,backendName:"webgpu",kernelFunc:STe};var NT=class{constructor(t){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t],this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`
  ${oe("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `}};function ITe(r){let{inputs:t,backend:e}=r,{s0:n,s1:o}=t;if(e.shouldExecuteOnCPU([n,o])){let c=e.tensorMap.get(n.dataId),p=e.tensorMap.get(o.dataId),d=c.values,f=p.values,h=T.assertAndGetBroadcastShape(Array.from(d),Array.from(f));return e.makeTensorInfo([h.length],"int32",Int32Array.from(h))}let s=b.sizeFromShape(n.shape),i=b.sizeFromShape(o.shape),a=Math.max(s,i),u=new NT(a),l=[{type:"int32",data:[s]},{type:"int32",data:[i]}];return e.runWebGPUProgram(u,[n,o],"int32",l)}var dq={kernelName:Rp,backendName:"webgpu",kernelFunc:ITe};var CM=Vt({opType:Le.NOT_EQUAL,dtype:"bool",cpuKernelImpl:kH}),fq={kernelName:wc,backendName:"webgpu",kernelFunc:CM};function Lc(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.tensorMap.get(n.dataId);return sn({inputs:{x:o.complexTensorInfos.real},backend:e})}var hq={kernelName:ad,backendName:"webgpu",kernelFunc:Lc};function mq(r,t){let e=new Es(r.shape,fe.TO_INT),n=t.runWebGPUProgram(e,[r],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}function SM(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return sn({inputs:{x:o},backend:e});let i=er(o.shape),a=SM({inputs:{x:o},backend:e,attrs:{dtype:"float32"}}),u=Xs({inputs:{real:a,imag:i},backend:e});return i.dispose(),e.disposeData(a.dataId),u}if(o.dtype==="complex64"){let i=Lc({inputs:{input:o},backend:e}),a=SM({inputs:{x:i},backend:e,attrs:{dtype:s}});return e.disposeData(i.dataId),a}if(!b.hasEncodingLoss(o.dtype,s)){let i=sn({inputs:{x:o},backend:e});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(e.shouldExecuteOnCPU([o])){let i=e.tensorMap.get(o.dataId).values,[a,u,l]=uH(i,o.shape,o.dtype,s);return e.makeTensorInfo(a,u,l)}if(s==="int32")return mq(o,e);if(s==="bool"){let i=e.makeTensorInfo([],"bool",b.getTypedArrayFromDType("bool",1)),u=CM({inputs:{a:o,b:i},backend:e});return e.disposeData(i.dataId),u}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var gq={kernelName:di,backendName:"webgpu",kernelFunc:SM};var TTe=Be({opType:fe.CEIL,cpuKernelImpl:lH}),yq={kernelName:sa,backendName:"webgpu",kernelFunc:TTe};var DT=class{constructor(t){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=t,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${oe("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}};var AT=class{constructor(t){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${oe("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}};function _Te(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{clipValueMin:s,clipValueMax:i}=n,a,u=[{type:"float32",data:[s]},{type:"float32",data:[i]}];return b.sizeFromShape(o.shape)%4===0?a=new DT(o.shape):a=new AT(o.shape),e.runWebGPUProgram(a,[o],o.dtype,u)}var xq={kernelName:ia,backendName:"webgpu",kernelFunc:_Te};var RT=class{constructor(t){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`
    ${oe("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `}};function vq(r,t){return{dataId:t.dataId,dtype:t.dtype,shape:r.shape}}function ETe(r){let{inputs:t,backend:e}=r,{x:n}=t,o=e.tensorMap.get(n.dataId),s=new RT(n.shape),i=[vq(n,o.complexTensorInfos.real),vq(n,o.complexTensorInfos.imag)];return e.runWebGPUProgram(s,i,i[0].dtype)}var bq={kernelName:Vu,backendName:"webgpu",kernelFunc:ETe};var OT=class{constructor(t){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=T.computeOutShape(t,1),this.variableNames=t.map((e,n)=>`T${n}`),this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=t.length-1;for(let e=0;e<this.offsetLength;e++)this.uniforms+=`offset${e} : i32,`;this.shaderKey="concat"}getUserCode(){let t=[];if(this.offsetLength>0){t.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let s=1;s<this.offsetLength;s++)t.push(`else if (yC < uniforms.offset${[s]}){ setOutputAtCoords(coords.x, coords.y, getT${s}(yR, yC - uniforms.offset${s-1})); }`);let n=this.offsetLength,o=this.offsetLength-1;t.push(`else { setOutputAtCoords(coords.x, coords.y, getT${n}(yR, yC - uniforms.offset${o})); }`)}else t.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${oe("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${t.join(`
        `)}
          }
        }
      }
    `}};function Fh(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.tensorMap.get(n.dataId);return sn({inputs:{x:o.complexTensorInfos.imag},backend:e})}var wq={kernelName:Zp,backendName:"webgpu",kernelFunc:Fh};function Ty(r,t,e){let n=r[0].dtype;if(n==="complex64"){let h=r.map(w=>Lc({inputs:{input:w},backend:e})),m=r.map(w=>Fh({inputs:{input:w},backend:e})),g=Ty(h,t,e),y=Ty(m,t,e),x=Xs({inputs:{real:g,imag:y},backend:e});return h.forEach(w=>e.disposeData(w.dataId)),m.forEach(w=>e.disposeData(w.dataId)),e.disposeData(g.dataId),e.disposeData(y.dataId),x}let o=e.shouldExecuteOnCPU(r);if(n==="string"&&(o=!0),o){let h=r.map(I=>{let A=[-1,b.sizeFromShape(I.shape.slice(t))];return Ee({inputs:{x:I},backend:e,attrs:{shape:A}})}),m=h.map(I=>({vals:e.readSync(I.dataId),shape:I.shape})),g=T.computeOutShape(h.map(I=>I.shape),1),y=h[0].shape[0]===1,x=cH(m,g,n,y),w=T.computeOutShape(r.map(I=>I.shape),t),C=e.makeTensorInfo(w,n,x);return h.forEach(I=>e.disposeData(I.dataId)),C}let s=e.device.limits.maxStorageBuffersPerShaderStage-1;if(r.length>s){let h=[];for(let g=0;g<r.length;g+=s){let y=r.slice(g,g+s);h.push(Ty(y,t,e))}let m=Ty(h,t,e);for(let g of h)e.disposeData(g.dataId);return m}let{tensors2D:i,outShape:a}=kTe(r,t,e),u=i.map(h=>h.shape),l=new OT(u),c=[],p=new Array(u.length-1);if(p.length>0){p[0]=u[0][1],c.push({type:"int32",data:[p[0]]});for(let h=1;h<p.length;h++)p[h]=p[h-1]+u[h][1],c.push({type:"int32",data:[p[h]]})}let d=e.runWebGPUProgram(l,i,i[0].dtype,c);i.forEach(h=>e.disposeData(h.dataId));let f=Ee({inputs:{x:d},backend:e,attrs:{shape:a}});return e.disposeData(d.dataId),f}function kTe(r,t,e){let n=T.computeOutShape(r.map(s=>s.shape),t);return{tensors2D:r.map(s=>Ee({inputs:{x:s},backend:e,attrs:{shape:[b.sizeFromShape(s.shape.slice(0,t)),b.sizeFromShape(s.shape.slice(t))]}})),outShape:n}}function IM(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n,s=b.parseAxisParam(o,t[0].shape)[0],i=t.map(l=>l.shape);T.assertParamsConsistent(i,s);let a=T.computeOutShape(t.map(l=>l.shape),s);if(b.sizeFromShape(a)===0)return e.makeTensorInfo(a,t[0].dtype,[]);let u=t.filter(l=>b.sizeFromShape(l.shape)>0);return u.length===1?sn({inputs:{x:u[0]},backend:e}):Ty(u,s,e)}var Cq={kernelName:Uu,backendName:"webgpu",kernelFunc:IM};function NTe(r,t,e,n,o=!1,s=null,i=!1,a=4,u=4,l=4){let c=$=>{switch($){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${$} is not supported.`)}},p=$=>{switch($){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${$} is not supported.`)}},d=r?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,f=r?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,h=r?"uniforms.xShape[1]":"uniforms.xShape[2]",m=r?"uniforms.xShape[2]":"uniforms.xShape[3]",g=r?"row":"col",y=r?"col":"row",x=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${r?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${g} / outWidth;
      let outCol = ${g} % outWidth;

      let WRow = ${y} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${y} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${y} % inChannels;
      var resData = ${xt(a)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${h} && xCol >= 0 && xCol < ${m}) {
        ${d}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${c(a)}
      }
      return resData;`,w=r?t&&n?`
      ${x}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${x}
      }
      return ${xt(a)}(0.0);`:n&&e?`
      ${x}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${x}
      }
      return ${xt(a)}(0.0);`,C=`${p(u)}`,I=xt(l),N=r?xt(a):xt(u),A=r?xt(u):xt(a);return`
      ${co(s,i,l===4,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${N} {
        ${r?w:C}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${A} {
        ${r?C:w}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${I}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${r?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${f}
        ${_s(o,s)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}var MT=class{constructor(t,e,n,o,s=!1,i=null,a=!1,u=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t.outShape,this.isChannelsLast=t.dataFormat==="channelsLast",this.isVec4=((t.inChannels%4===0||t.inChannels%3===0)&&this.isChannelsLast||t.outWidth%4===0&&!this.isChannelsLast)&&t.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=db(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=fb(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&t.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),s&&(this.variableNames.push("bias"),this.variableComponents.push(4)),a&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],s&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=u,this.addBias=s,this.activation=i,this.hasPreluActivationWeights=a,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=e%this.tileAOuter===0,this.fitBOuter=n%this.tileBOuter===0,this.fitInner=o%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){let t=this.isVec4?Ah(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):Rh(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),e=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${NTe(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,e[0],e[1],e[2])}
    ${t}
  `}};var FT=class{constructor(t,e=!1,n=null,o=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=t.outShape,this.isChannelsLast=t.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=e,this.activation=n,this.hasPreluActivationWeights=o,e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${co(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${_s(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${oe("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}};var $T=class{constructor(t,e){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){let t=this.isChannelsLast?1:2,e=this.isChannelsLast?2:3,n=this.isChannelsLast?"coords[1]":"coords[2]",o=this.isChannelsLast?"coords[2]":"coords[1]",s=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${oe("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${n};
        let col = ${o};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${t}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${e}] && xCol >= 0) {
            value = ${s};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}};function PT(r,t){let e=r.length;return e>=3?t?[...r.slice(0,-3),r[e-3]*r[e-2],r[e-1]]:[...r.slice(0,-3),r[e-3],r[e-2]*r[e-1]]:!t&&e===1&&r[0]>1?[r[0],1]:null}function DTe({x:r,filter:t,convInfo:e,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let u=e.dataFormat==="channelsLast",l=!u,c=!1,p=u&&e.filterHeight===e.inHeight&&e.filterWidth===e.inWidth&&e.padInfo.type==="VALID",d=[],f,h;if(p){let y=e.inHeight*e.inWidth*e.inChannels;f=Ee({inputs:{x:r},backend:n,attrs:{shape:[1,e.batchSize,y]}}),h=Ee({inputs:{x:t},backend:n,attrs:{shape:[1,y,e.outChannels]}})}else f=Ee({inputs:{x:r},backend:n,attrs:{shape:u?[e.batchSize,e.inHeight*e.inWidth,e.inChannels]:[e.batchSize,e.inChannels,e.inHeight*e.inWidth]}}),h=Ee({inputs:{x:t},backend:n,attrs:{shape:[1,e.inChannels,e.outChannels]}});if(d.push(f),d.push(h),s!=null){let y=PT(s.shape,u);y!=null&&(s=Ee({inputs:{x:s},backend:n,attrs:{shape:y}}),d.push(s))}if(o!=null){let y=PT(o.shape,u);y!=null&&(o=Ee({inputs:{x:o},backend:n,attrs:{shape:y}}),d.push(o))}let m=Oh({a:u?f:h,b:u?h:f,transposeA:l,transposeB:c,backend:n,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i}),g=Ee({inputs:{x:m},backend:n,attrs:{shape:e.outShape}});d.push(m);for(let y of d)n.disposeData(y.dataId);return g}function ATe({x:r,filter:t,convInfo:e,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let{filterWidth:u,filterHeight:l,inChannels:c,strideWidth:p,strideHeight:d,padInfo:f,outWidth:h,outHeight:m,dilationWidth:g,dilationHeight:y,dataFormat:x}=e,w=x==="channelsLast",C=u*l*c,I=m*h,N=w?[e.batchSize,I,C]:[e.batchSize,C,I],A=new $T(N,w),O=[{type:"int32",data:[f.top,f.left]},{type:"int32",data:[d,p]},{type:"int32",data:[y,g]},{type:"int32",data:[h]},{type:"int32",data:[c*u]},{type:"int32",data:[c]}],$=n.runWebGPUProgram(A,[r],r.dtype,O),z=[];z.push($);let G=Ee({inputs:{x:t},backend:n,attrs:{shape:[1,C,-1]}});if(z.push(G),s!=null){let te=PT(s.shape,w);te!=null&&(s=Ee({inputs:{x:s},backend:n,attrs:{shape:te}}),z.push(s))}if(o!=null){let te=PT(o.shape,w);te!=null&&(o=Ee({inputs:{x:o},backend:n,attrs:{shape:te}}),z.push(o))}let Q=Oh({a:w?$:G,b:w?G:$,transposeA:!w,transposeB:!1,backend:n,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i}),J=Ee({inputs:{x:Q},backend:n,attrs:{shape:e.outShape}});z.push(Q);for(let te of z)n.disposeData(te.dataId);return J}function LT({x:r,filter:t,convInfo:e,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let u=o!=null,l=s!=null,c=e.dataFormat==="channelsLast",p=c&&e.filterHeight===e.inHeight&&e.filterWidth===e.inWidth&&e.padInfo.type==="VALID",d=j().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!d&&(p||e.filterHeight===1&&e.filterWidth===1&&e.dilationHeight===1&&e.dilationWidth===1&&e.strideHeight===1&&e.strideWidth===1&&(e.padInfo.type==="SAME"||e.padInfo.type==="VALID")))return DTe({x:r,filter:t,convInfo:e,backend:n,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i});let f=j().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),h=f>-1?f:n.thresholdToIncreaseWorkgroups,m=e.batchSize*Math.ceil(e.outHeight*e.outWidth/32)*Math.ceil(e.outChannels/32);if(j().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||m<=h)return ATe({x:r,filter:t,convInfo:e,backend:n,bias:o,preluActivationWeights:s,leakyreluAlpha:i,activation:a});let g,y=[e.padInfo.top,e.padInfo.left],x=[{type:"int32",data:[e.filterHeight,e.filterWidth]},{type:"int32",data:[...y]},{type:"int32",data:[e.strideHeight,e.strideWidth]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]}];if(d)g=new FT(e,u,a,l);else{let N=c?e.outHeight*e.outWidth:e.outChannels,A=c?e.outChannels:e.outHeight*e.outWidth,O=e.filterHeight*e.filterWidth*e.inChannels;x.push({type:"int32",data:[N]},{type:"int32",data:[A]},{type:"int32",data:[O]});let $=n.adapterInfo.isIntel();g=new MT(e,N,A,O,u,a,l,$)}let w=[],C=[r,t];u&&(!c&&o.shape.length===1&&(o=Ee({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}}),w.push(o)),C.push(o)),l&&(!c&&s.shape.length===1&&(s=Ee({inputs:{x:s},backend:n,attrs:{shape:[s.shape[0],1,1]}}),w.push(s)),C.push(s)),a==="leakyrelu"&&(x.push({type:"float32",data:[i]}),g.uniforms+=" alpha : f32,");let I=n.runWebGPUProgram(g,C,r.dtype,x);for(let N of w)n.disposeData(N.dataId);return I}function RTe(r){let{inputs:t,attrs:e,backend:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=e,p=T.convertConv2DDataFormat(u),d=T.computeConv2DInfo(o.shape,s.shape,i,l,a,c,!1,p);return LT({x:o,filter:s,convInfo:d,backend:n})}var Sq={kernelName:Gu,backendName:"webgpu",kernelFunc:RTe};var zT=class{constructor(t){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=t.inShape,this.isChannelsLast=t.dataFormat==="channelsLast",this.isVec4=this.isChannelsLast&&t.outChannels%4===0&&t.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){let t=this.isChannelsLast?1:2,e=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1,o=`
    ${oe()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${o}
    `:`
    ${oe("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${n}];

        let dyCorner = vec2<i32>(coords[${t}], coords[${e}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}},BT=class{constructor(t){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.filterShape,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t.dataFormat==="channelsLast",this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${oe("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}},VT=class{constructor(t){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.filterShape,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${oe("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}},UT=class{constructor(t){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${oe("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}};function OTe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:c}=n,p=T.convertConv2DDataFormat(u),d=T.computeConv2DInfo(o.shape,c,i,1,a,l,!1,p),f=new BT(d),h=[{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"int32",data:[d.inHeight]},{type:"int32",data:[d.inWidth]}];return e.runWebGPUProgram(f,[o,s],o.dtype,h)}var Iq={kernelName:Mp,backendName:"webgpu",kernelFunc:OTe};function MTe(r=4){let t=s=>{switch(s){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${s} is not supported.`)}},n=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${xt(r)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${xt(r)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${r}];`}
      }
      return ${xt(r)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${xt(r)} {
    ${n}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${xt(r)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${t(r)}
    }
    return ${xt(r)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${xt(r)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${r}] = value;
    }
  }`}var GT=class{constructor(t){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t.inShape,b.assert(t.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=t.inChannels%4===0&&t.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=db(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=fb(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){let t=this.isVec4?Ah(this.elementsPerThread,this.workgroupSize):Rh(this.elementsPerThread,this.workgroupSize);return`
    ${MTe(this.isVec4?4:1)}
    ${t}
    `}};function FTe(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{inputShape:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:c}=n,p=T.convertConv2DDataFormat(l),d=T.computeConv2DInfo(i,s.shape,a,1,u,c,!1,p),f=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.filterHeight-1-d.padInfo.top,d.filterWidth-1-d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize,d.outHeight,d.outWidth,d.outChannels]}],h;if(j().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||d.dataFormat!=="channelsLast")h=new zT(d);else{h=new GT(d);let m=d.inHeight*d.inWidth,g=d.inChannels,y=d.filterHeight*d.filterWidth*d.outChannels;f.push({type:"uint32",data:[m]},{type:"uint32",data:[g]},{type:"uint32",data:[y]})}return e.runWebGPUProgram(h,[o,s],"float32",f)}var Tq={kernelName:Wu,backendName:"webgpu",kernelFunc:FTe};var WT=class{constructor(t){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.outShape,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`
    ${oe("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`}};function $Te(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u}=n,l=T.computeConv3DInfo(o.shape,s.shape,i,u,a),c=[l.padInfo.front,l.padInfo.top,l.padInfo.left],p=[{type:"int32",data:[l.filterDepth,l.filterHeight,l.filterWidth]},{type:"int32",data:[...c]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationDepth,l.dilationHeight,l.dilationWidth]}],d=new WT(l),f=mr(o.dtype,s.dtype);return e.runWebGPUProgram(d,[o,s],f,p)}var _q={kernelName:ju,backendName:"webgpu",kernelFunc:$Te};function PTe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,pad:a,filterShape:u}=n,l=T.computeConv3DInfo(o.shape,u,i,1,a),c=new VT(l),p=[{type:"int32",data:[l.padInfo.front,l.padInfo.top,l.padInfo.left]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.batchSize]},{type:"int32",data:[l.outDepth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.inDepth]},{type:"int32",data:[l.inHeight]},{type:"int32",data:[l.inWidth]}];return e.runWebGPUProgram(c,[o,s],s.dtype,p)}var Eq={kernelName:Fp,backendName:"webgpu",kernelFunc:PTe};function LTe(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{strides:i,pad:a,inputShape:u}=n,l=T.computeConv3DInfo(u,s.shape,i,1,a),c=new UT(l),p=[{type:"int32",data:[l.filterDepth,l.filterHeight,l.filterWidth]},{type:"int32",data:[l.filterDepth-1-l.padInfo.front,l.filterHeight-1-l.padInfo.top,l.filterWidth-1-l.padInfo.left]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.outDepth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.outChannels]}];return e.runWebGPUProgram(c,[o,s],o.dtype,p)}var kq={kernelName:$p,backendName:"webgpu",kernelFunc:LTe};var zTe=Be({opType:fe.COS}),Nq={kernelName:aa,backendName:"webgpu",kernelFunc:zTe};var BTe=Be({opType:fe.COSH}),Dq={kernelName:ua,backendName:"webgpu",kernelFunc:BTe};var jT=class{constructor(t,e,n,o){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;let[s]=e;this.outputShape=[s,n[0],n[1],t],this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=o==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){let[t,e]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[n,o,s]=this.cropHeightBiggerThan1?[`(${t} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${t} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${t}`],[i,a,u]=this.cropWidthBiggerThan1?[`(${e} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${e} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${e}`];return`
    ${oe("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${n});
        let width_ratio = f32(${i});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${o};
        let width_scale = ${a};
        let in_y = ${s};
        if( in_y < 0.0 || in_y > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${u};
        if( in_x < 0.0 || in_x > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}};var VTe=r=>{let{inputs:t,backend:e,attrs:n}=r,{image:o,boxes:s,boxInd:i}=t,{cropSize:a,method:u,extrapolationValue:l}=n,c=new jT(o.shape[3],s.shape,a,u),p=[{type:"float32",data:[l]}];return e.runWebGPUProgram(c,[o,s,i],"float32",p)},Aq={kernelName:Lp,backendName:"webgpu",kernelFunc:VTe};var _y=function(r){return r.Prod="*",r.Sum="+",r}(_y||{}),Cb=class{constructor(t,e,n,o){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=n,this.reverse=o,this.op=t,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){let t=this.outputShape.length,e=this.op===_y.Prod?"1.0":"0.0",n=this.exclusive?e:`getX(${Rq(t,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],s="",i="";return this.exclusive?(s=this.reverse?`end != ${o-1}`:"end != 0",i=this.reverse?"end + 1":"end - 1"):(s=this.reverse?`end + pow2 < ${o}`:"end >= pow2",i=this.reverse?"end + pow2":"end - pow2"),`
      ${oe("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${Oq(t,"coords",this.op)};
         var val = ${n};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${s}) {
           let idx = ${i};
           ${Oq(t,"coords",this.op)} = idx;
           val ${this.op}= getX(${Rq(t,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}};function Rq(r,t,e){if(r===1)return`${t}`;if(r===2)return`${t}.x, ${t}.y`;if(r===3)return`${t}.x, ${t}.y, ${t}.z`;if(r===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative ${e} for rank ${r} is not yet supported`)}function Oq(r,t,e){if(r===1)return`${t}`;if(r===2)return`${t}.y`;if(r===3)return`${t}.z`;if(r===4)return`${t}.w`;throw Error(`Cumulative ${e} for rank ${r} is not yet supported`)}function HT(r,t,e,n,o,s){let i=t.shape.length,a=T.getAxesPermutation([n],i),u=t;a!=null&&(u=Io({inputs:{x:t},backend:e,attrs:{perm:a}}));let l=T.getInnerMostAxes(1,i)[0];if(l!==i-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${n}`);let c=u.shape[l],p=sn({inputs:{x:u},backend:e});for(let d=0;d<=Math.ceil(Math.log2(c))-1;d++){let f=new Cb(r,u.shape,!1,s),h=p,m=[{type:"float32",data:[d]}];p=e.runWebGPUProgram(f,[p],p.dtype,m),e.disposeData(h.dataId)}if(o){let d=new Cb(r,u.shape,o,s),f=p,h=[{type:"float32",data:[0]}];p=e.runWebGPUProgram(d,[p],p.dtype,h),e.disposeData(f.dataId)}if(a!=null){let d=T.getUndoAxesPermutation(a),f=Io({inputs:{x:p},backend:e,attrs:{perm:d}});return e.disposeData(p.dataId),e.disposeData(u.dataId),f}return p}function UTe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n;return HT(_y.Prod,o,e,s,i,a)}var Mq={kernelName:Pp,backendName:"webgpu",kernelFunc:UTe};function GTe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n;return HT(_y.Sum,o,e,s,i,a)}var Fq={kernelName:Hu,backendName:"webgpu",kernelFunc:GTe};function WTe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:i,binaryOutput:a}=n,u=o.shape.length===1,c=b.sizeFromShape(s.shape)>0,p=s.dtype,d=u?[o.shape[0]]:[o.shape[0],o.shape[1]],f=u?[i]:[o.shape[0],i],h=jr({backend:e,attrs:{shape:f,value:0,dtype:p}}),m=new Iy(d,c,a),g=[{type:"int32",data:[i]}],y=c?[o,s]:[o];return e.runWebGPUProgram(m,y,p,g,h)}var $q={kernelName:zp,backendName:"webgpu",kernelFunc:WTe};var qT=class{constructor(t,e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=t,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${e}`,this.dataFormat=e}getUserCode(){return`
      ${oe("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function jTe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockSize:s,dataFormat:i}=n,a=o.shape[0],u=i==="NHWC"?o.shape[1]:o.shape[2],l=i==="NHWC"?o.shape[2]:o.shape[3],c=i==="NHWC"?o.shape[3]:o.shape[1],p=u*s,d=l*s,f=c/(s*s),h=i==="NHWC"?[a,p,d,f]:[a,f,p,d],m=[{type:"int32",data:[s]}],g=new qT(h,i);return e.runWebGPUProgram(g,[o],o.dtype,m)}var Pq={kernelName:Bp,backendName:"webgpu",kernelFunc:jTe};var KT=class{constructor(t,e,n,o=!1,s=null,i=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=t,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),o&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.addBias=o,this.activation=s,this.hasPreluActivation=i,this.filterHeight=e,this.filterWidth=n,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){let t=this.filterWidth*this.filterHeight,e=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],n=this.workgroupSize[1]+this.filterHeight-1,o=this.workgroupSize[0]+this.filterWidth-1;return`
      ${co(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${o}>, ${n}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${oe()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${o}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${t<e?`if (wIndex < ${t})`:`for(; wIndex < ${t}; wIndex = wIndex + ${e})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${_s(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}};var Ey=class{constructor(t,e=!1,n=null,o=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=t.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;let s=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=pe(s),this.dispatch=se(this.dispatchLayout,s,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),b.assert(t.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.convInfo=t,this.addBias=e,this.activation=n,this.hasPreluActivation=o,this.shaderKey=`depthwiseVec4_${n}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){let t=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,e=this.convInfo.strideHeight,n=this.convInfo.strideWidth;return`
      ${co(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${oe("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${e}, ${n}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${t}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${t}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${n} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${_s(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}};var ky=class{constructor(t,e=!1,n=null,o=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=t.outShape,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t.dataFormat==="channelsLast",e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.convInfo=t,this.addBias=e,this.activation=n,this.hasPreluActivation=o,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){let t=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${co(this.activation,this.hasPreluActivation,!1,4)}

      ${oe("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${t};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${t};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${_s(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}};function HTe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=n,p=T.convertConv2DDataFormat(u),d=l;d==null&&(d=[1,1]);let f=T.computeConv2DInfo(o.shape,s.shape,i,d,a,c,!0,p),h=[{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inHeight,f.inWidth]}],m=f.dataFormat==="channelsLast",g;return!m&&f.inHeight>16&&f.inWidth>16&&f.strideHeight===1&&f.strideWidth===1&&f.dilationWidth===1&&f.dilationHeight===1&&f.inChannels===f.outChannels?g=new KT(f.outShape,f.filterHeight,f.filterWidth):m&&f.outHeight>4&&f.outWidth>4&&f.strideWidth<=2&&f.inChannels===f.outChannels&&f.dilationHeight===1&&f.dilationWidth===1&&f.inChannels%4===0?(g=new Ey(f),h.push({type:"int32",data:[g.virtualWidth]})):(g=new ky(f),h.push({type:"int32",data:[f.filterHeight]},{type:"int32",data:[f.filterWidth]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]})),e.runWebGPUProgram(g,[o,s],o.dtype,h)}var Lq={kernelName:qu,backendName:"webgpu",kernelFunc:HTe};var XT=class{constructor(t){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.filterShape,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`
      ${oe("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}},YT=class{constructor(t){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`
      ${oe("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}};function qTe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,filterShape:c}=n,p=T.computeConv2DInfo(o.shape,c,i,a,u,l,!0),d=new XT(p),f=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"int32",data:[p.inHeight]},{type:"int32",data:[p.inWidth]},{type:"int32",data:[p.batchSize]},{type:"int32",data:[p.outChannels/p.inChannels]}];return e.runWebGPUProgram(d,[o,s],"float32",f)}var zq={kernelName:Vp,backendName:"webgpu",kernelFunc:qTe};function KTe(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,inputShape:c}=n,p=T.computeConv2DInfo(c,s.shape,i,a,u,l,!0),d=new YT(p),f=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.filterHeight-1-p.padInfo.top,p.filterWidth-1-p.padInfo.left]},{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"int32",data:[p.outChannels/p.inChannels]}];return e.runWebGPUProgram(d,[o,s],o.dtype,f)}var Bq={kernelName:Up,backendName:"webgpu",kernelFunc:KTe};var ZT=class{constructor(t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t,t],this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${oe("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}};function XTe(r){let{inputs:t,backend:e}=r,{x:n}=t,o=[...n.shape,...n.shape],s=b.sizeFromShape(n.shape),i=Ee({inputs:{x:n},backend:e,attrs:{shape:[s]}}),a=new ZT(s),u=e.runWebGPUProgram(a,[i],i.dtype),l=Ee({inputs:{x:u},backend:e,attrs:{shape:o}});return e.disposeData(i.dataId),e.disposeData(u.dataId),l}var Vq={kernelName:Gp,backendName:"webgpu",kernelFunc:XTe};var QT=class{constructor(t){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.outShape,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${oe("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}};function YTe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u}=n,l=T.computeDilation2DInfo(o.shape,s.shape,i,a,"NHWC",u),c=[l.padInfo.top,l.padInfo.left],p=[{type:"int32",data:[l.filterHeight,l.filterWidth]},{type:"int32",data:[...c]},{type:"int32",data:[l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationHeight,l.dilationWidth]}],d=new QT(l);return e.runWebGPUProgram(d,[o,s],o.dtype,p)}var Uq={kernelName:Ku,backendName:"webgpu",kernelFunc:YTe};var JT=class{constructor(t,e){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t.inShape,this.dispatchLayout=pe(t.outShape),this.dispatch=se(this.dispatchLayout,t.outShape,this.workgroupSize),e!=="float32"&&e!=="int32")throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${e} type.`);this.type=e,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`
       ${oe("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${Ts("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}},e_=class{constructor(t,e,n){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t.filterShape,this.dispatchLayout=pe(t.outShape),this.dispatch=se(this.dispatchLayout,t.outShape,this.workgroupSize),n!=="float32"&&n!=="int32")throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${n} type.`);this.type=n,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`
       ${oe("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${Ts("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}};function ZTe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,dy:i}=t,{strides:a,pad:u,dilations:l}=n,c=T.computeDilation2DInfo(o.shape,s.shape,a,u,"NHWC",l),p=s.dtype,d=new e_(c,s.shape,p),f=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[b.sizeFromShape(c.outShape)]}],h=jr({backend:e,attrs:{shape:s.shape,value:0,dtype:p}});return e.runWebGPUProgram(d,[o,s,i],p,f,h)}var Gq={kernelName:eh,backendName:"webgpu",kernelFunc:ZTe};function QTe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,dy:i}=t,{strides:a,pad:u,dilations:l}=n,c=T.computeDilation2DInfo(o.shape,s.shape,a,u,"NHWC",l),p=o.dtype,d=new JT(c,p),f=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[b.sizeFromShape(c.outShape)]}],h=jr({backend:e,attrs:{shape:c.inShape,value:0,dtype:p}});return e.runWebGPUProgram(d,[o,s,i],p,f,h)}var Wq={kernelName:Jf,backendName:"webgpu",kernelFunc:QTe};var t_=class{constructor(t,e,n){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=qd.DRAW,this.size=!0,this.outputShape=t,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=e,this.textureFormat=n,this.shaderKey=`draw_${e}_${n}`}getUserCode(){let t,e=this.type==="float32"?"value":"value / 255.0";return t=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${e};
        rgba[1] = ${e};
        rgba[2] = ${e};
      } else {
        rgba[d] = ${e};
      }`,`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${oe("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${t}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `}};function JTe(r){let{inputs:t,backend:e,attrs:n}=r,{image:o}=t,{canvas:s,options:i}=n,[a,u]=o.shape.slice(0,2),{imageOptions:l}=i||{},c=l?.alpha||1,p=e.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",d=[a,u],f=new t_(d,o.dtype,p);s.width=u,s.height=a;let h="webgpu",m=s.getContext(h),g;m||(g=new OffscreenCanvas(u,a),m=g.getContext(h));let y=o.shape.length===3?o.shape[2]:1;m.configure({device:e.device,format:p,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});let x="int32",w=e.makeTensorInfo(d,x),C=e.tensorMap.get(w.dataId);C.resource=m.getCurrentTexture(),C.external=!0;let I=[{type:"uint32",data:[y]},{type:"float32",data:[c]}];if(e.runWebGPUProgram(f,[o],x,I,w),g){let N=s.getContext("2d");if(!N)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");N.drawImage(g,0,0)}return e.disposeData(w.dataId),o}var jq={kernelName:th,backendName:"webgpu",kernelFunc:JTe};var TM=Vt({opType:Le.MUL,cpuKernelImpl:_H,supportsComplex:!0}),Hq={kernelName:Ta,backendName:"webgpu",kernelFunc:TM};function _M(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;return ks(o,s,i,"sum",e)}var qq={kernelName:vl,backendName:"webgpu",kernelFunc:_M};function e_e(r){let{inputs:t,backend:e,attrs:n}=r,{equation:o}=n,s=t,{allDims:i,summedDims:a,idDims:u}=T.decodeEinsumEquation(o,s.length);T.checkEinsumDimSizes(i.length,u,s);let{path:l,steps:c}=T.getEinsumComputePath(a,u),p=c.length,d=null,f=i.length,h=[];for(let m=0;m<p;++m){for(let g of c[m]){let{permutationIndices:y,expandDims:x}=T.getEinsumPermutation(f,u[g]),w;T.isIdentityPermutation(y)?w=s[g]:(w=Io({inputs:{x:s[g]},backend:e,attrs:{perm:y}}),h.push(w));let C=w.shape.slice();for(let I=0;I<x.length;++I)C.splice(x[I],0,1);b.arraysEqual(w.shape,C)||(w=Ee({inputs:{x:w},backend:e,attrs:{shape:C}}),h.push(w)),d===null?d=w:(d=TM({inputs:{a:w,b:d},backend:e}),h.push(d))}m<p-1&&(l[m]>=0&&(d=_M({inputs:{x:d},backend:e,attrs:{axis:l[m]-(i.length-f),keepDims:!1}}),h.push(d)),f--)}for(let m of h)m!==d&&e.disposeData(m.dataId);return d}var Kq={kernelName:Wp,backendName:"webgpu",kernelFunc:e_e};var t_e=Be({opType:fe.ELU}),Xq={kernelName:ca,backendName:"webgpu",kernelFunc:t_e};var r_e=r=>{let{inputs:t,backend:e}=r,{dy:n,y:o}=t,s=new Pc(Le.ELU_DER,n.shape,o.shape);return e.runWebGPUProgram(s,[n,o],n.dtype)},Yq={kernelName:jp,backendName:"webgpu",kernelFunc:r_e};var n_e=Vt({opType:Le.EQUAL,dtype:"bool",cpuKernelImpl:pH}),Zq={kernelName:hc,backendName:"webgpu",kernelFunc:n_e};var o_e=Be({opType:fe.ERF}),Qq={kernelName:pa,backendName:"webgpu",kernelFunc:o_e};var s_e=Be({opType:fe.EXP,cpuKernelImpl:dH,dtype:"float32"}),Jq={kernelName:da,backendName:"webgpu",kernelFunc:s_e};function r_(r){let{inputs:t,attrs:e,backend:n}=r,{dim:o}=e,{input:s}=t,i=s.shape.length,a=s.shape.slice(),u=o;return o<0&&(b.assert(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+o+1),a.splice(u,0,1),Ee({inputs:{x:s},backend:n,attrs:{shape:a}})}var eK={kernelName:Xu,backendName:"webgpu",kernelFunc:r_};var i_e=Be({opType:fe.EXPM1,cpuKernelImpl:fH}),tK={kernelName:fa,backendName:"webgpu",kernelFunc:i_e};var Sb=class{constructor(t,e){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=t,this.shaderKey=`fft_${t}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${oe("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}};function n_(r,t,e){let n=e.tensorMap.get(r.dataId),o=b.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=o/s,a=[],u=Ee({inputs:{x:r},backend:e,attrs:{shape:[i,s]}});a.push(u);let l=u.shape,c=new Sb("real",l),p=new Sb("imag",l),d=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:l},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:l}],f=t?2*Math.PI:-2*Math.PI,h=t?l[1]:1,m=[{type:"float32",data:[f]},{type:"float32",data:[h]}],g=e.runWebGPUProgram(c,d,"float32",m);a.push(g);let y=e.runWebGPUProgram(p,d,"float32",m);a.push(y);let x=Xs({inputs:{real:g,imag:y},backend:e});a.push(x);let w=Ee({inputs:{x},backend:e,attrs:{shape:r.shape}});return a.forEach(C=>e.disposeData(C.dataId)),w}function a_e(r){let{inputs:t,backend:e}=r,{input:n}=t;return n_(n,!1,e)}var rK={kernelName:Hp,backendName:"webgpu",kernelFunc:a_e};var o_=class{constructor(t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${oe("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}};var nK={kernelName:Kp,backendName:"webgpu",kernelFunc:({inputs:r,backend:t})=>{let{image:e}=r,n=t,o=new o_(e.shape);return n.runWebGPUProgram(o,[e],e.dtype)}};var u_e=Be({opType:fe.FLOOR,cpuKernelImpl:hH}),oK={kernelName:ha,backendName:"webgpu",kernelFunc:u_e};var l_e=Vt({opType:Le.FLOOR_DIV,cpuKernelImpl:mH,dtype:"int32"}),sK={kernelName:ma,backendName:"webgpu",kernelFunc:l_e};var s_=class{constructor(t,e,n=!1){this.pixelsOpType=qd.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=t,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize,[e,1,1]),this.importVideo=n,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){let t=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${oe("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${t};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}};var iK={kernelName:nh,backendName:"webgpu",kernelFunc:c_e},Ny,EM=j().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function c_e(r){let{inputs:t,backend:e,attrs:n}=r,{pixels:o}=t,{numChannels:s}=n;if(o==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let i=typeof HTMLVideoElement<"u"&&o instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement,u=typeof HTMLCanvasElement<"u"&&o instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&o instanceof OffscreenCanvas,l=typeof ImageBitmap<"u"&&o instanceof ImageBitmap,[c,p]=i?[o.videoWidth,o.videoHeight]:[o.width,o.height],d=[p,c,s],f=j().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&i,h=i||a;if(l||u||h){let x;if(f)x=e.device.importExternalTexture({source:o});else{if(h){let Z=j().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Ny==null||Z!==EM)&&(EM=Z,Ny=document.createElement("canvas").getContext("2d",{willReadFrequently:EM})),Ny.canvas.width=c,Ny.canvas.height=p,Ny.drawImage(o,0,0,c,p),o=Ny.canvas}let z=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,K=e.textureManager.acquireTexture(d[1],d[0],"rgba8unorm",z);e.queue.copyExternalImageToTexture({source:o},{texture:K},[d[1],d[0]]),x=K}let w=b.sizeFromShape(d),C=b.computeStrides(d),I=new s_(d,s,f),N=[{type:"uint32",data:[w]},{type:"uint32",data:[s]},{type:"uint32",data:[...C]}],A=e.makeTensorInfo([p,c],"int32"),O=e.tensorMap.get(A.dataId);O.resource=x;let $=e.runWebGPUProgram(I,[A],"int32",N);return e.disposeData(A.dataId),$}let m=o.data,g=m;if(s!=null&&s!==4){g=new Uint8Array(o.width*o.height*s);let x=m.length,w=0;for(let C=0;C<x;C++)C%4<s&&(g[w++]=m[C])}let y=e.makeTensorInfo(d,"int32",new Int32Array(g));return e.uploadToGPU(y.dataId),y}var i_=class{constructor(t,e,n,o,s){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],T.assertAndGetBroadcastShape(t,e),T.assertAndGetBroadcastShape(t,n),this.outputShape=t,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),o!=null&&(T.assertAndGetBroadcastShape(t,o),this.variableNames.push("offset")),s!=null&&(T.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale")),this.offsetShape=o,this.scaleShape=s,this.shaderKey="batchNorm"}getUserCode(){let t="0.0";this.offsetShape!=null&&(t="getOffsetByOutputIndex(index)");let e="1.0";return this.scaleShape!=null&&(e="getScaleByOutputIndex(index)"),`
      ${oe("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${t};
          let scaleValue = ${e};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}};var aK={kernelName:Yu,backendName:"webgpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n,scale:o,offset:s,mean:i,variance:a}=r,{varianceEpsilon:u}=t,l=e,c=[n,i,a],p=null;s!=null&&(p=s.shape,c.push(s));let d=null;o!=null&&(d=o.shape,c.push(o));let f=new i_(n.shape,i.shape,a.shape,p,d),h=[{type:"float32",data:[u]}];return l.runWebGPUProgram(f,c,n.dtype,h)}};function p_e(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:d,activation:f,leakyreluAlpha:h}=n,m=T.convertConv2DDataFormat(c),g=T.computeConv2DInfo(o.shape,s.shape,u,p,l,d,!1,m);return LT({x:o,filter:s,convInfo:g,backend:e,bias:i,preluActivationWeights:a,leakyreluAlpha:h,activation:f})}var uK={kernelName:Sc,backendName:"webgpu",kernelFunc:p_e};function d_e(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dilations:c,dimRoundingMode:p,activation:d,leakyreluAlpha:f}=n,h=c;h==null&&(h=[1,1]),b.assert(T.eitherStridesOrDilationsAreOne(u,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${h}'`);let m=T.computeConv2DInfo(o.shape,s.shape,u,h,l,p,!0),g=[o,s],y=i!=null,x=a!=null;y&&g.push(i),x&&g.push(a);let w=[{type:"int32",data:[m.padInfo.top,m.padInfo.left]},{type:"int32",data:[m.inHeight,m.inWidth]}],C;return m.outHeight>4&&m.outWidth>4&&m.strideWidth<=2&&m.inChannels===m.outChannels&&m.dilationHeight===1&&m.dilationWidth===1&&m.inChannels%4===0?(C=new Ey(m,y,d,x),w.push({type:"int32",data:[C.virtualWidth]})):(C=new ky(m,y,d,x),w.push({type:"int32",data:[m.filterHeight]},{type:"int32",data:[m.filterWidth]},{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.dilationHeight,m.dilationWidth]})),d==="leakyrelu"&&(w.push({type:"float32",data:[f]}),C.uniforms+=" alpha : f32,"),e.runWebGPUProgram(C,g,"float32",w)}var lK={kernelName:Ic,backendName:"webgpu",kernelFunc:d_e};var a_=class{constructor(t,e){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${t}`,this.sliceDim=t,this.uniforms=`sliceDim : i32, strides : ${Dr(t)},`}getUserCode(){let t;return this.sliceDim>1?t="uniforms.strides[j]":t="uniforms.strides",`
      ${oe("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${t};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}};function f_e(r){let{inputs:t,backend:e}=r,{params:n,indices:o}=t,s=o.shape,i=s[s.length-1],a=b.sizeFromShape(n.shape),[u,l,c,p]=T.prepareAndValidate(n,o),d=Ee({inputs:{x:o},backend:e,attrs:{shape:[l,i]}}),f=Ee({inputs:{x:n},backend:e,attrs:{shape:[b.sizeFromShape(n.shape)/c,c]}});if(e.shouldExecuteOnCPU([n,o])||n.dtype==="string"){let x=e.readSync(o.dataId),w=e.bufferSync(n),C=gH(x,w,n.dtype,l,i,c,p,n.shape,a);return e.makeTensorInfo(u,n.dtype,C.values)}let h=new a_(i,[l,c]),m=[{type:"int32",data:[i]},{type:"int32",data:p}],g=e.runWebGPUProgram(h,[f,d],f.dtype,m),y=Ee({inputs:{x:g},backend:e,attrs:{shape:u}});return e.disposeData(d.dataId),e.disposeData(f.dataId),e.disposeData(g.dataId),y}var cK={kernelName:Xp,backendName:"webgpu",kernelFunc:f_e};var u_=class{constructor(t,e){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.slice(),this.aShape=t,this.outputShape=e,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){let t=h_e(this.aShape);return`
      ${oe("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${t}));
        }
      }
    `}};function h_e(r){let t=["resRC.x","resRC.y","resRC.z","resRC.w"],e=[];for(let n=0;n<r.length;n++)n===2?e.push("indexZ"):e.push(`${t[n]}`);return e.join()}function kM(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,indices:s}=t,{axis:i,batchDims:a}=n,u=b.parseAxisParam(i,o.shape)[0],l=T.segment_util.collectGatherOpShapeInfo(o,s,u,a),c=b.sizeFromShape(s.shape),p=[],d=Ee({inputs:{x:o},backend:e,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),f=Ee({inputs:{x:s},backend:e,attrs:{shape:[l.batchSize,c/l.batchSize]}});p.push(d),p.push(f);let h=[l.batchSize,l.outerSize,c/l.batchSize,l.sliceSize];if(e.shouldExecuteOnCPU([o,s])){let w=e.tensorMap.get(f.dataId).values,C=Ne(f.shape,f.dtype,w),N=e.tensorMap.get(d.dataId).values,A=Ne(d.shape,d.dtype,N),O=yH(A,C,h);return p.forEach($=>e.disposeData($.dataId)),e.makeTensorInfo(l.outputShape,O.dtype,O.values)}let m=new u_(d.shape,h),g=e.runWebGPUProgram(m,[d,f],d.dtype);p.push(g);let y=Ee({inputs:{x:g},backend:e,attrs:{shape:l.outputShape}});return p.forEach(x=>e.disposeData(x.dataId)),y}var pK={kernelName:Zu,backendName:"webgpu",kernelFunc:kM};var m_e=Vt({opType:Le.GREATER,cpuKernelImpl:vH,dtype:"bool"}),dK={kernelName:mc,backendName:"webgpu",kernelFunc:m_e};var g_e=Vt({opType:Le.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:xH}),fK={kernelName:ga,backendName:"webgpu",kernelFunc:g_e};function y_e(r){let{inputs:t,backend:e}=r,{input:n}=t;return n_(n,!0,e)}var hK={kernelName:Yp,backendName:"webgpu",kernelFunc:y_e};var x_e=Be({opType:fe.IS_FINITE,dtype:"bool"}),mK={kernelName:ya,backendName:"webgpu",kernelFunc:x_e};var v_e=Be({opType:fe.IS_INF,dtype:"bool"}),gK={kernelName:xa,backendName:"webgpu",kernelFunc:v_e};var b_e=Be({opType:fe.IS_NAN,dtype:"bool"}),yK={kernelName:va,backendName:"webgpu",kernelFunc:b_e};function w_e(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{alpha:s}=n,i=[{type:"float32",data:[s]}],a=new Es(o.shape,fe.LEAKYRELU,"alpha : f32,");return e.runWebGPUProgram(a,[o],"float32",i)}var xK={kernelName:Qu,backendName:"webgpu",kernelFunc:w_e};var C_e=Vt({opType:Le.LESS,dtype:"bool",cpuKernelImpl:wH}),vK={kernelName:gc,backendName:"webgpu",kernelFunc:C_e};var S_e=Vt({opType:Le.LESS_EQUAL,dtype:"bool",cpuKernelImpl:bH}),bK={kernelName:yc,backendName:"webgpu",kernelFunc:S_e};var l_=class{constructor(t){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t],this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${oe("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}};function I_e(r){let{backend:t,attrs:e}=r,{start:n,stop:o,num:s}=e,i=(o-n)/(s-1),a=new l_(s),u=[{type:"float32",data:[n]},{type:"float32",data:[i]}];return t.runWebGPUProgram(a,[],"float32",u)}var wK={kernelName:Qp,backendName:"webgpu",kernelFunc:I_e};var T_e=Be({opType:fe.LOG,cpuKernelImpl:CH}),CK={kernelName:ba,backendName:"webgpu",kernelFunc:T_e};var __e=Be({opType:fe.LOG1P}),SK={kernelName:wa,backendName:"webgpu",kernelFunc:__e};var E_e=Vt({opType:Le.LOGICAL_AND,dtype:"bool"}),IK={kernelName:xc,backendName:"webgpu",kernelFunc:E_e};var k_e=Be({opType:fe.LOGICAL_NOT}),TK={kernelName:vc,backendName:"webgpu",kernelFunc:k_e};var N_e=Vt({opType:Le.LOGICAL_OR}),_K={kernelName:bc,backendName:"webgpu",kernelFunc:N_e};var EK=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`,c_=class{constructor(t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${oe("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${EK}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}},p_=class{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,b.assert(e<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${e}`),this.outputShape=t,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=se(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${oe()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${EK}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}};function D_e(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{depthRadius:s,bias:i,alpha:a,beta:u}=n,l;s>16?l=new c_(o.shape):l=new p_(o.shape,s);let c=[{type:"int32",data:[s]},{type:"float32",data:[i]},{type:"float32",data:[a]},{type:"float32",data:[u]}];return e.runWebGPUProgram(l,[o],o.dtype,c)}var kK={kernelName:Ju,backendName:"webgpu",kernelFunc:D_e};var d_=class{constructor(t){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`
    ${oe("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `}};function A_e(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,y:s,dy:i}=t,{depthRadius:a,bias:u,alpha:l,beta:c}=n,p=new d_(o.shape),d=[{type:"int32",data:[a]},{type:"float32",data:[u]},{type:"float32",data:[l]},{type:"float32",data:[c]}];return e.runWebGPUProgram(p,[o,s,i],o.dtype,d)}var NK={kernelName:Jp,backendName:"webgpu",kernelFunc:A_e};var R_e=Vt({opType:Le.MAX,cpuKernelImpl:IH}),DK={kernelName:Ca,backendName:"webgpu",kernelFunc:R_e};function O_e(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,c=T.computePool2DInfo(o.shape,s,i,1,a,u);return TT(o,c,"max",e)}var AK={kernelName:tl,backendName:"webgpu",kernelFunc:O_e};function M_e(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:i,pad:a,dataFormat:u,dimRoundingMode:l}=n,c=[1,1,1],p=T.computePool3DInfo(o.shape,s,i,c,a,l,u),d=new Xd(p,"max"),f=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.front,p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inDepth,p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]}];return e.runWebGPUProgram(d,[o],o.dtype,f)}var RK={kernelName:rl,backendName:"webgpu",kernelFunc:M_e};var f_=class{constructor(t){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`
      ${oe("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}},h_=class{constructor(t){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`
      ${oe("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `}};function F_e(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,i=s,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=n,p=[1,1,1],d=T.computePool3DInfo(i.shape,a,u,p,l,c),f=new Xd(d,"max",!0),h=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.front,d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inDepth,d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]}],m=e.runWebGPUProgram(f,[i],"int32",h),g=new h_(d);h=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterDepth-1-d.padInfo.front,d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outDepth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]}];let y=e.runWebGPUProgram(g,[o,m],i.dtype,h);return e.disposeData(m.dataId),y}var OK={kernelName:td,backendName:"webgpu",kernelFunc:F_e};function $_e(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s,output:i}=t,a=s;mb([s,i],"maxPoolGrad");let{filterSize:u,strides:l,pad:c,dimRoundingMode:p}=n,d=T.computePool2DInfo(a.shape,u,l,1,c,p),f=new zl(d,"max",!0),h=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]}],m=e.runWebGPUProgram(f,[a],"int32",h),g=new f_(d);h=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]}];let y=e.runWebGPUProgram(g,[o,m],a.dtype,h);return e.disposeData(m.dataId),y}var MK={kernelName:ed,backendName:"webgpu",kernelFunc:$_e};function P_e(r){let{inputs:t,backend:e,attrs:n}=r,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=n,{x:u}=t;b.assert(u.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${u.shape.length}.`);let l=[1,1];b.assert(T.eitherStridesOrDilationsAreOne(s,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${l}'`);let c=T.computePool2DInfo(u.shape,o,s,l,i),p=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[c.inHeight,c.inWidth]},{type:"int32",data:[c.effectiveFilterHeight,c.effectiveFilterWidth]}],d=new zl(c,"max",!1),f=e.runWebGPUProgram(d,[u],u.dtype,p);d=new zl(c,"max",!0,!0,a);let h=e.runWebGPUProgram(d,[u],"int32",p);return[f,h]}var FK={kernelName:rd,backendName:"webgpu",kernelFunc:P_e};function L_e(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;return ks(o,s,i,"min",e)}var $K={kernelName:ol,backendName:"webgpu",kernelFunc:L_e};var z_e=Vt({opType:Le.MIN,cpuKernelImpl:TH}),PK={kernelName:Sa,backendName:"webgpu",kernelFunc:z_e};var m_=class{constructor(t,e,n){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.map((o,s)=>o[0]+t[s]+o[1]),this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=t,e.map((o,s)=>{this.uniforms+=` pad${s} : vec2<i32>,`}),this.offset=n==="reflect"?0:1,this.shaderKey=`mirrorPad_${n}`}getUserCode(){let t=this.xShape.length,e=this.xShape.map((l,c)=>`uniforms.pad${c}[0]`).join(","),n=this.xShape.map((l,c)=>`uniforms.pad${c}[0] + uniforms.xShape${t>1?`[${c}]`:""}`).join(","),o=t===1?"start":"start[i]",s=t===1?"end":"end[i]",i=t===1?"outC":"outC[i]",a=Dr(t),u=t>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,t):"coords";return`
      ${oe("index")} {
        if (index < uniforms.size) {
          let start = ${a}(${e});
          let end = ${a}(${n});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${t}; i = i + 1) {
            if (${i} < ${o}) {
              ${i} = ${o} * 2 - ${i} - ${this.offset};
            } else if(${i} >= ${s}) {
              ${i} = (${s} - 1) * 2 - ${i} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${u}));
        }
      }
    `}};var LK={kernelName:sl,backendName:"webgpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n}=r,{paddings:o,mode:s}=t,i=e,a=o.map(c=>({type:"int32",data:[c[0],c[1]]})),u=new m_(n.shape,o,s);return i.runWebGPUProgram(u,[n],n.dtype,a)}};var B_e=Vt({opType:Le.MOD}),zK={kernelName:Ia,backendName:"webgpu",kernelFunc:B_e};var g_=class{constructor(t,e){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t,e],this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${oe("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `}};var y_=class{constructor(t){this.variableNames=["logits"],this.outputShape=t,this.dispatchLayout=pe(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${oe("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `}};function NM(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{dim:s}=n,i=Ee({inputs:{x:o},backend:e,attrs:{shape:[b.sizeFromShape(o.shape)/o.shape[s],o.shape[s]]}}),a=new y_(i.shape),u=e.runWebGPUProgram(a,[i],o.dtype),l=Ee({inputs:{x:u},backend:e,attrs:{shape:o.shape}});return e.disposeData(i.dataId),e.disposeData(u.dataId),l}var BK={kernelName:Cl,backendName:"webgpu",kernelFunc:NM};function V_e(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{numSamples:s,seed:i,normalized:a}=n,u=a?o:NM({inputs:{logits:o},backend:e,attrs:{dim:o.shape.length-1}}),l=u.shape[0],c=u.shape[1],p=new g_(l,s),d=[{type:"float32",data:[i]},{type:"int32",data:[c]}],f=e.runWebGPUProgram(p,[u],"int32",d);return a||e.disposeData(u.dataId),f}var VK={kernelName:nd,backendName:"webgpu",kernelFunc:V_e};function U_e(r){let{inputs:t,backend:e}=r,{x:n}=t;if(e.shouldExecuteOnCPU([n])){let s=e.tensorMap.get(n.dataId),[i,a]=EH(s.values,n.shape,n.dtype);return e.makeTensorInfo(a,n.dtype,i)}let o=new Es(n.shape,fe.NEG);return e.runWebGPUProgram(o,[n],n.dtype)}var UK={kernelName:il,backendName:"webgpu",kernelFunc:U_e};function G_e(r){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=n,l=e.readSync(o.dataId),c=e.readSync(s.dataId),{selectedIndices:p}=En.nonMaxSuppressionV3Impl(l,c,i,a,u);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}var GK={kernelName:od,backendName:"webgpu",kernelFunc:G_e};function W_e(r){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=n,c=e.readSync(o.dataId),p=e.readSync(s.dataId),d=i,f=a,h=u,m=l,{selectedIndices:g,selectedScores:y}=En.nonMaxSuppressionV5Impl(c,p,d,f,h,m);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var WK={kernelName:sd,backendName:"webgpu",kernelFunc:W_e};var x_=class{constructor(t,e){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t,e],this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${oe("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}};function j_e(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o}=t,{dtype:s,depth:i,onValue:a,offValue:u}=n,l=b.sizeFromShape(o.shape),c=new x_(l,i),p=Ee({inputs:{x:o},backend:e,attrs:{shape:[l]}}),d=[{type:"float32",data:[a]},{type:"float32",data:[u]}],f=e.runWebGPUProgram(c,[p],s,d);e.disposeData(p.dataId);let h=[...o.shape,i],m=Ee({inputs:{x:f},backend:e,attrs:{shape:h}});return e.disposeData(f.dataId),m}var jK={kernelName:ul,backendName:"webgpu",kernelFunc:j_e};function Ib(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="complex64"){let o=Lc({inputs:{input:n},backend:e}),s=Ib({inputs:{x:o},backend:e}),i=Fh({inputs:{input:n},backend:e}),a=Ib({inputs:{x:i},backend:e}),u=Xs({inputs:{real:s,imag:a},backend:e});return e.disposeData(o.dataId),e.disposeData(s.dataId),e.disposeData(i.dataId),e.disposeData(a.dataId),u}else return jr({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:e})}var HK={kernelName:Tl,backendName:"webgpu",kernelFunc:Ib};function qK(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(n.dtype==="complex64"){let o=Lc({inputs:{input:n},backend:e}),s=qK({inputs:{x:o},backend:e}),i=Fh({inputs:{input:n},backend:e}),a=Ib({inputs:{x:i},backend:e}),u=Xs({inputs:{real:s,imag:a},backend:e});return e.disposeData(o.dataId),e.disposeData(s.dataId),e.disposeData(i.dataId),e.disposeData(a.dataId),u}else return jr({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:e})}var KK={kernelName:al,backendName:"webgpu",kernelFunc:qK};function H_e(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n;if(t.length===1)return r_({inputs:{input:t[0]},backend:e,attrs:{dim:o}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{b.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),b.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],u=t.map(c=>{let p=r_({inputs:{input:c},backend:e,attrs:{dim:o}});return a.push(p),p}),l=IM({inputs:u,backend:e,attrs:{axis:o}});return a.forEach(c=>e.disposeData(c.dataId)),l}var XK={kernelName:ll,backendName:"webgpu",kernelFunc:H_e};function DM(r,t=!1){let e=r.length,n=Dr(e),o=r.map((p,d)=>`uniforms.pad${d}[0]`).join(","),s=r.map((p,d)=>`uniforms.pad${d}[0] + uniforms.xShape${e>1?`[${d}]`:""}`).join(","),i=e>1?`${n}(${o})`:`${o}`,a=e>1?`${n}(${s})`:`${s}`,u=e>1?"any(paddedCoords < start)":"paddedCoords < start",l=e>1?"any(paddedCoords >= end)":"paddedCoords >= end",c=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
        let start = ${i};
        let end = ${a};
        if (${u} || ${l}) {
          setOutputAtIndex(index, ${t?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${c}));
        }
  `}var v_=class{constructor(t,e){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.map((n,o)=>n[0]+t[o]+n[1]),this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),e.map((n,o)=>{this.uniforms+=` pad${o} : vec2<i32>,`}),this.xShape=t,this.shaderKey="pad"}getUserCode(){return`
      ${oe("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${DM(this.xShape)}
        }
      }
    `}};var q_e=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{paddings:s,constantValue:i}=n;if(s.every(l=>b.arraysEqual(l,[0,0])))return sn({inputs:{x:o},backend:e});if(b.sizeFromShape(o.shape)===0){let l=s.map((c,p)=>c[0]+o.shape[p]+c[1]);return jr({backend:e,attrs:{shape:l,value:i,dtype:o.dtype}})}let a=[{type:"float32",data:[i]}];s.map(l=>a.push({type:"int32",data:[l[0],l[1]]}));let u=new v_(o.shape,s);return e.runWebGPUProgram(u,[o],o.dtype,a)},YK={kernelName:cl,backendName:"webgpu",kernelFunc:q_e};var K_e=Vt({opType:Le.POW}),ZK={kernelName:_a,backendName:"webgpu",kernelFunc:K_e};function X_e(r){let{inputs:t,backend:e}=r,{x:n,alpha:o}=t,s=new Pc(Le.PRELU,n.shape,o.shape);return e.runWebGPUProgram(s,[n,o],"float32")}var QK={kernelName:pl,backendName:"webgpu",kernelFunc:X_e};function Y_e(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;return ks(o,s,i,"prod",e)}var JK={kernelName:dl,backendName:"webgpu",kernelFunc:Y_e};var Z_e=r=>{let{backend:t,attrs:e}=r,{start:n,stop:o,step:s,dtype:i}=e,a=DH(n,o,s,i);return t.makeTensorInfo([a.length],i,a)},e6={kernelName:id,backendName:"webgpu",kernelFunc:Z_e};var Q_e=Vt({opType:Le.DIV}),t6={kernelName:la,backendName:"webgpu",kernelFunc:Q_e};var J_e=Be({opType:fe.RECIPROCAL}),r6={kernelName:Ea,backendName:"webgpu",kernelFunc:J_e};var e1e=Be({opType:fe.RELU}),n6={kernelName:ka,backendName:"webgpu",kernelFunc:e1e};var t1e=Be({opType:fe.RELU6}),o6={kernelName:Na,backendName:"webgpu",kernelFunc:t1e};var b_=class{constructor(t,e,n){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t[0],e,n,t[3]],this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${oe("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}};function r1e(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,size:i,halfPixelCenters:a}=n,[u,l]=i,c=s&&u>1?1:0,p=s&&l>1?1:0,f=[{type:"float32",data:[c,p]},{type:"float32",data:[a?.5:0]}],h=new b_(o.shape,u,l);return e.runWebGPUProgram(h,[o],"float32",f)}var s6={kernelName:ml,backendName:"webgpu",kernelFunc:r1e};var w_=class{constructor(t,e){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=e,this.shaderKey=`resizeBilinearBackprop_${e}`}getUserCode(){return`
      ${oe("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}};function n1e(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:i}=n,[,a,u]=o.shape,[,l,c]=s.shape,p=[i&&l>1?a-1:a,i&&c>1?u-1:u],d=[i&&l>1?l-1:l,i&&c>1?c-1:c],f=p[0]/d[0],h=p[1]/d[1],m=1/f,g=1/h,y=Math.ceil(m)*2+2,x=Math.ceil(g)*2+2,w=new w_(o.shape,i),C=[{type:"int32",data:p},{type:"int32",data:d},{type:"float32",data:[f]},{type:"float32",data:[h]},{type:"float32",data:[m]},{type:"float32",data:[g]},{type:"int32",data:[y]},{type:"int32",data:[x]}];return e.runWebGPUProgram(w,[s],s.dtype,C)}var i6={kernelName:ld,backendName:"webgpu",kernelFunc:n1e};var C_=class{constructor(t,e,n,o){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t[0],e,n,t[3]],this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=o,this.shaderKey=`resizeNearest_${o}`}getUserCode(){let t;return this.halfPixelCenters?t="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":t="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${oe("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${t};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}};function o1e(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n,[u,l]=a,c=s&&u>1?1:0,p=s&&l>1?1:0,f=[{type:"float32",data:[c,p]},{type:"float32",data:[s?.5:0]}],h=new C_(o.shape,u,l,i);return e.runWebGPUProgram(h,[o],o.dtype,f)}var a6={kernelName:hl,backendName:"webgpu",kernelFunc:o1e};var S_=class{constructor(t,e){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=e,this.shaderKey=`resizeNearestNeigborBackprop_${e}`}getUserCode(){return`
      ${oe("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}};function s1e(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:i}=n,[,a,u]=o.shape,[,l,c]=s.shape,p=[i&&l>1?a-1:a,i&&c>1?u-1:u],d=[i&&l>1?l-1:l,i&&c>1?c-1:c],f=p[0]/d[0],h=p[1]/d[1],m=1/f,g=1/h,y=Math.ceil(m)*2+2,x=Math.ceil(g)*2+2,w=new S_(o.shape,i),C=[{type:"int32",data:p},{type:"int32",data:d},{type:"float32",data:[m]},{type:"float32",data:[g]},{type:"int32",data:[y]},{type:"int32",data:[x]}];return e.runWebGPUProgram(w,[s],s.dtype,C)}var u6={kernelName:ud,backendName:"webgpu",kernelFunc:s1e};var I_=class{constructor(t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${oe("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}};function i1e(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dims:s}=n,i=o.shape.length;if(i===0)return sn({inputs:{x:o},backend:e});let a=o.shape,u=[1,1,1,1];a.forEach((g,y)=>{let x=y+4-i;u[x]=g});let l=b.parseAxisParam(s,o.shape),c=[0,0,0,0];l.forEach(g=>{let y=g+4-i;c[y]=1});let p=[{type:"int32",data:c}],d=Ee({inputs:{x:o},backend:e,attrs:{shape:u}}),f=new I_(u),h=e.runWebGPUProgram(f,[d],d.dtype,p);e.disposeData(d.dataId);let m=Ee({inputs:{x:h},backend:e,attrs:{shape:a}});return e.disposeData(h.dataId),m}var l6={kernelName:gl,backendName:"webgpu",kernelFunc:i1e};var T_=class{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=t,typeof e=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${oe("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}};var c6={kernelName:wd,backendName:"webgpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:n}=r,{radians:o,fillValue:s,center:i}=t,a=e,u=new T_(n.shape,s),[l,c]=T.getImageCenter(i,n.shape[1],n.shape[2]),p=[{type:"float32",data:[l]},{type:"float32",data:[c]},{type:"float32",data:[Math.sin(o)]},{type:"float32",data:[Math.cos(o)]}];return typeof s=="number"?p.push({type:"float32",data:[Number.parseFloat(s.toFixed(2))]}):p.push({type:"float32",data:s}),a.runWebGPUProgram(u,[n],n.dtype,p)}};var a1e=Be({opType:fe.ROUND}),p6={kernelName:Da,backendName:"webgpu",kernelFunc:a1e};var u1e=Be({opType:fe.RSQRT,cpuKernelImpl:AH}),d6={kernelName:Aa,backendName:"webgpu",kernelFunc:u1e};var Bl=class{constructor(t,e,n,o,s,i,a,u=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=i,this.type=a,this.sumDupeIndices=u,this.dispatchLayout=pe(t),this.dispatch=se(this.dispatchLayout,t,this.workgroupSize),this.sliceDimGreaterThanOne=e>1,this.shaderKey=`scatter_${n}_${o}_${this.sliceDimGreaterThanOne}_${a}_${u}_${s.length}`;let l=Dr(s.length);this.uniforms=`sliceDim : i32, strides: ${l}, updatesSize: i32,`,this.updatesRank=o,this.indicesRank=n}getUserCode(){let t="";this.indicesRank===1?t="coords[0]":this.indicesRank===2&&(t="coords[0], j");let e=`getIndices(${t})`,n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides",o="",s="";this.dispatchLayout.x.length===1?(o="flattenedIndex",s=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(o="vec2<i32>(flattenedIndex, coords[1])",s=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);let a=`getUpdates(${Array.from({length:this.updatesRank},(l,c)=>`coords[${c}]`).join(", ")})`;return`
    ${s}
      ${oe("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${e}));
            flattenedIndex = flattenedIndex + indexInside * ${n};
          }
          let updateValue =
              ${Hd(this.type)}(${a});
          let flatIndex = getOutputIndexFromCoords(${o});

          ${this.sumDupeIndices?Ts("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}};function l1e(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o,updates:s}=t,{shape:i}=n,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:p}=T.calculateShapes(s,o,i),d=[p/l,l];if(p===0)return e.makeTensorInfo(i,o.dtype);let f=Ee({inputs:{x:o},backend:e,attrs:{shape:[u,a]}}),h=Ee({inputs:{x:s},backend:e,attrs:{shape:[u,l]}}),m=h.dtype,g=jr({backend:e,attrs:{shape:d,value:0,dtype:m}}),y=b.sizeFromShape(h.shape),x=[{type:"int32",data:[a]},{type:"int32",data:c},{type:"int32",data:[y]}],w=new Bl(h.shape,a,f.shape.length,h.shape.length,c,d,m),C=e.runWebGPUProgram(w,[h,f],m,x,g),I=Ee({inputs:{x:C},backend:e,attrs:{shape:i}});return e.disposeData(f.dataId),e.disposeData(h.dataId),e.disposeData(C.dataId),I}var f6={kernelName:cd,backendName:"webgpu",kernelFunc:l1e};var __=class{constructor(t,e){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=e,this.shaderKey=`search_sorted_${e}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${oe("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}};function c1e(r){let{inputs:t,backend:e,attrs:n}=r,{sortedSequence:o,values:s}=t,{side:i}=n,a=new __([s.shape[0],s.shape[1]],i),u=[{type:"int32",data:[o.shape[1]]}];return e.runWebGPUProgram(a,[o,s],"int32",u)}var h6={kernelName:dd,backendName:"webgpu",kernelFunc:c1e};var E_=class{constructor(t,e,n){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=t,this.rank=n,this.shaderKey="select"}getUserCode(){let t,e;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)e="resRC",t="resRC";else{let o=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],i=[];for(let a=0;a<this.outputShape.length;a++)i.push(`${o[a]}`),a<this.cRank&&s.push(`${o[a]}`);t=s.join(),e=i.join()}return`
      ${oe("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${t});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${e}));
          } else {
            setOutputAtIndex(index, getB(${e}));
          }
        }
      }
    `}};function p1e(r){let{inputs:t,backend:e}=r,{condition:n,t:o,e:s}=t,i=new E_(n.shape.length,o.shape,o.shape.length);return e.runWebGPUProgram(i,[n,o,s],mr(o.dtype,s.dtype))}var m6={kernelName:yl,backendName:"webgpu",kernelFunc:p1e};var d1e=Be({opType:fe.SELU}),g6={kernelName:Ra,backendName:"webgpu",kernelFunc:d1e};var f1e=Be({opType:fe.SIGMOID}),y6={kernelName:$a,backendName:"webgpu",kernelFunc:f1e};var h1e=Be({opType:fe.SIGN}),x6={kernelName:Fa,backendName:"webgpu",kernelFunc:h1e};var m1e=Be({opType:fe.SIN}),v6={kernelName:Oa,backendName:"webgpu",kernelFunc:m1e};var g1e=Be({opType:fe.SINH}),b6={kernelName:Ma,backendName:"webgpu",kernelFunc:g1e};var y1e=Be({opType:fe.SOFTPLUS}),w6={kernelName:Pa,backendName:"webgpu",kernelFunc:y1e};var k_=class{constructor(t,e,n,o,s,i){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;let a=new Array(o.length);for(let u=0;u<a.length;u++)a[u]=o[s[u]];this.outputShape=a,this.newDim=s,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=t,this.paddedXShape=e,this.uniforms+=`reshapedPaddedXShape : ${Dr(o.length)}, paddedXShapeStrides : ${Dr(i)}, `,n.map((u,l)=>{this.uniforms+=` pad${l} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${s}`}getUserCode(){let t=Dr(this.outputShape.length),e=xM(this.newDim);return`
      ${pb(this.paddedXShape,"PaddedX")}
      ${oe("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${t}(${e}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${DM(this.xShape,!0)}
        }
      }
    `}};var x1e=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,paddings:i}=n;b.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");let a=s.reduce((x,w)=>x*w),u=[[0,0]];u.push(...i);for(let x=1+s.length;x<o.shape.length;++x)u.push([0,0]);let l=u.map((x,w)=>x[0]+o.shape[w]+x[1]),c=T.getReshaped(l,s,a,!1),p=T.getPermuted(c.length,s.length,!1),d=T.getReshapedPermuted(l,s,a,!1),f=b.computeStrides(l),h=new k_(o.shape,l,u,c,p,f.length),m=[{type:"int32",data:c},{type:"int32",data:f}];u.map(x=>m.push({type:"int32",data:[x[0],x[1]]}));let g=e.runWebGPUProgram(h,[o],o.dtype,m),y=Ee({inputs:{x:g},backend:e,attrs:{shape:d}});return e.disposeData(g.dataId),y},C6={kernelName:bl,backendName:"webgpu",kernelFunc:x1e};var N_=class{constructor(t,e,n){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.type=n,this.dispatchLayout=pe([e]),this.dispatch=se(this.dispatchLayout,[e],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`
    ${oe("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${Ts("&result[outIndex]","value",this.type)}
      }
    }
  `}},D_=class{constructor(t,e){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[t],this.dispatchLayout=pe(e),this.dispatch=se(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`
    ${oe("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${Ts("&result[segmentId]","1","int32")}
      }
    }
  `}},A_=class{constructor(t,e){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.type=e,this.dispatchLayout=pe(t),this.dispatch=se(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`
    ${oe("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type==="float32"?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `}};function R_(r,t,e,n=!1,o){let i=b.sizeFromShape(r.shape)/r.shape[0],a=r.dtype,u=b.sizeFromShape(t.shape),l=o.readSync(e.dataId),p=u>0?l[u-1]+1:0,d,f=r.shape.slice();f[0]=p;let h=u*i,m=jr({backend:o,attrs:{shape:f,value:0,dtype:a}});d=new N_(f,h,a);let g=[{type:"int32",data:[i]},{type:"int32",data:[h]}],y=o.runWebGPUProgram(d,[r,t,e],a,g,m);if(n)return y;let x=jr({backend:o,attrs:{shape:[p],value:0,dtype:"int32"}});d=new D_(p,e.shape);let w=o.runWebGPUProgram(d,[e],"int32",null,x),C=jr({backend:o,attrs:{shape:f,value:0,dtype:a}});d=new A_(f,a),g=[{type:"int32",data:[i]}];let I=o.runWebGPUProgram(d,[y,w],a,g,C);return o.disposeData(y.dataId),o.disposeData(w.dataId),I}function v1e(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;return R_(n,o,s,!1,e)}var S6={kernelName:fd,backendName:"webgpu",kernelFunc:v1e};function b1e(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;return R_(n,o,s,!0,e)}var I6={kernelName:hd,backendName:"webgpu",kernelFunc:b1e};var O_=class{constructor(t,e){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;let n=new Array(t.length);for(let o=0;o<n.length;o++)n[o]=t[o]*e[o];this.outputShape=n,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){let t=w1e(this.rank,"uniforms.");return`
      ${oe("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${t}));
        }
      }
    `}};function w1e(r,t=""){if(r>=5)throw Error(`Tile for rank ${r} is not yet supported`);if(r===1)return`(resRC % ${t}aShape)`;let e=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let o=0;o<r;o++)n.push(`(${e[o]} % ${t}aShape[${o}])`);return n.join()}function Tb(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reps:s}=n;if(e.shouldExecuteOnCPU([o])||o.dtype==="string"||o.shape.length>=5){let u=e.readSync(o.dataId),l=o.dtype==="string"?u.map(d=>b.decodeString(d)):u,c=Ne(o.shape,o.dtype,l),p=LH(c,s);return e.makeTensorInfo(p.shape,p.dtype,p.values)}let i=new O_(o.shape,s);return e.runWebGPUProgram(i,[o],o.dtype)}var T6={kernelName:hi,backendName:"webgpu",kernelFunc:Tb};function C1e(r){let{inputs:t,backend:e,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:i}=t,{outputShape:a}=n,{sliceRank:u,numUpdates:l,sliceSize:c,strides:p,outputSize:d}=T.calculateShapes(s,o,a),f=!1;if(s.dtype==="string"){let O=e.bufferSync(o),$=e.bufferSync(s),z=b.decodeString(e.readSync(i.dataId)[0]),G=RH(O,$,a,d,c,l,u,p,z,f);return e.makeTensorInfo(a,G.dtype,G.values)}let h=[d/c,c],m=Ee({inputs:{x:o},backend:e,attrs:{shape:[l,u]}}),g=s.shape.length?Ee({inputs:{x:s},backend:e,attrs:{shape:[l,c]}}):sn({inputs:{x:s},backend:e}),y=g.dtype,x=e.makeTensorInfo([],y,b.makeZerosTypedArray(1,y)),w=Ee({inputs:{x:i},backend:e,attrs:{shape:Array(h.length).fill(1)}}),C=Tb({inputs:{x:w},backend:e,attrs:{reps:h}}),I=b.sizeFromShape([l,c]),N=[{type:"int32",data:[u]},{type:"int32",data:p},{type:"int32",data:[I]}];switch(l){case 0:break;case 1:{let O=new Bl([l,c],u,m.shape.length,g.shape.length,p,h,y,f);e.runWebGPUProgram(O,[g,m],y,N,C)}break;default:{let O=new Bl([l,c],u,m.shape.length,x.shape.length,p,h,y,f);e.runWebGPUProgram(O,[x,m],y,N,C)}{let O=new Bl([l,c],u,m.shape.length,g.shape.length,p,h,y);e.runWebGPUProgram(O,[g,m],y,N,C)}}let A=Ee({inputs:{x:C},backend:e,attrs:{shape:a}});return e.disposeData(m.dataId),e.disposeData(g.dataId),e.disposeData(w.dataId),e.disposeData(x.dataId),e.disposeData(C.dataId),A}var _6={kernelName:md,backendName:"webgpu",kernelFunc:C1e};function S1e(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{numOrSizeSplits:s,axis:i}=n,a=b.parseAxisParam(i,o.shape)[0],u=T.prepareSplitSize(o,s,a),l=o.shape.length,c=new Array(l).fill(0),p=o.shape.slice();return u.map(d=>{let f=[...p];f[a]=d;let h=tu({inputs:{x:o},backend:e,attrs:{begin:c,size:f}});return c[a]+=d,h})}var E6={kernelName:wl,backendName:"webgpu",kernelFunc:S1e};var I1e=Be({opType:fe.SQRT}),k6={kernelName:La,backendName:"webgpu",kernelFunc:I1e};var N6={kernelName:gd,backendName:"webgpu",kernelFunc:({inputs:r,backend:t})=>{let{x:e}=r,n=t,o=new Es(e.shape,fe.SQUARE);return n.runWebGPUProgram(o,[e],e.dtype)}};var T1e=Vt({opType:Le.SQUARED_DIFFERENCE}),D6={kernelName:za,backendName:"webgpu",kernelFunc:T1e};function _1e({inputs:r,attrs:t,backend:e}){let{x:n}=r,o=new Es(n.shape,fe.STEP,"stepAlpha : f32,"),s=[{type:"float32",data:[t.alpha]}];return e.runWebGPUProgram(o,[n],n.dtype,s)}var A6={kernelName:Ga,backendName:"webgpu",kernelFunc:_1e};var M_=class{constructor(t){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);let e=Dr(this.outputShape.length);this.uniforms=`begin : ${e},  strides : ${e}, `,this.shaderKey="stridedSlice"}getUserCode(){let t=this.outputShape.length,e="";if(t===1)e="coords * uniforms.strides + uniforms.begin";else{let o=0;e=this.outputShape.map((s,i)=>(o++,this.outputShape.length===1?`coords * uniforms.strides[${i}] + uniforms.begin[${i}]`:`coords[${o-1}] * uniforms.strides[${i}] + uniforms.begin[${i}]`)).join(",")}return`
       ${oe("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${e}));
         }
       }
     `}};function E1e(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:d}=n,{finalShapeSparse:f,finalShape:h,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:x,end:w,strides:C}=en.sliceInfo(o.shape,s,i,a,u,l,c,p,d),I;if(m)I=Ee({inputs:{x:o},backend:e,attrs:{shape:h}});else if(g||y){b.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let N=en.computeOutShape(x,w,C),A=tu({inputs:{x:o},backend:e,attrs:{begin:x,size:N}});I=Ee({inputs:{x:A},backend:e,attrs:{shape:h}}),e.disposeData(A.dataId)}else if(e.shouldExecuteOnCPU([o])){let A=e.readSync(o.dataId),O=Ne(o.shape,o.dtype,A),$=FH(f,O,C,x);I=e.makeTensorInfo(h,o.dtype,$.values)}else{let A=new M_(f),O=[{type:"int32",data:x},{type:"int32",data:C}],$=e.runWebGPUProgram(A,[o],o.dtype,O);I=Ee({inputs:{x:$},backend:e,attrs:{shape:h}}),e.disposeData($.dataId)}return I}var R6={kernelName:yd,backendName:"webgpu",kernelFunc:E1e};function k1e(r){let{inputs:t,backend:e,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:l}=n,{data:c,dataSplits:p}=t,d=e.readSync(c.dataId),f=e.readSync(p.dataId),[h,m]=$H(d,f,o,s,i,a,u,l);return[e.makeTensorInfo([h.length],"string",h),e.makeTensorInfo(p.shape,"int32",m)]}var O6={kernelName:xd,backendName:"webgpu",kernelFunc:k1e};var N1e=Vt({opType:Le.SUB,cpuKernelImpl:PH,supportsComplex:!0}),M6={kernelName:Ba,backendName:"webgpu",kernelFunc:N1e};var D1e=Be({opType:fe.TAN}),F6={kernelName:Va,backendName:"webgpu",kernelFunc:D1e};var A1e=Be({opType:fe.TANH}),$6={kernelName:Ua,backendName:"webgpu",kernelFunc:A1e};function R1e(r){let{inputs:t,backend:e,attrs:n}=r,{tensor:o,indices:s,updates:i}=t,{}=n,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:p}=T.calculateShapes(i,s,o.shape),d=[p/l,l];if(p===0)return e.makeTensorInfo(o.shape,s.dtype);let f=[],h=Ee({inputs:{x:s},backend:e,attrs:{shape:[u,a]}});f.push(h);let m=Ee({inputs:{x:i},backend:e,attrs:{shape:[u,l]}});f.push(m);let g=Ee({inputs:{x:o},backend:e,attrs:{shape:d}});f.push(g);let y=Tb({inputs:{x:g},backend:e,attrs:{reps:Array(d.length).fill(1)}}),x=new Bl([u,l],a,h.shape.length,m.shape.length,c,d,o.dtype,!1),w=b.sizeFromShape([u,l]),C=[{type:"int32",data:[a]},{type:"int32",data:c},{type:"int32",data:[w]}],I=e.runWebGPUProgram(x,[m,h],g.dtype,C,y);f.push(I);let N=Ee({inputs:{x:I},backend:e,attrs:{shape:o.shape}});return f.forEach(A=>e.disposeData(A.dataId)),N}var P6={kernelName:pd,backendName:"webgpu",kernelFunc:R1e};var F_=class{constructor(t){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${oe("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}},$_=class{constructor(t){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${oe("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}};function Dy(r,t){t!==null&&r.disposeData(t.dataId)}function L6(r){let t=1;for(;t<r;)t*=2;return t}function O1e(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{k:s,sorted:i}=n,a=o.shape,u=a[a.length-1];if(e.shouldExecuteOnCPU([o])){let I=e.readSync(o.dataId),[N,A]=zH(I,a,o.dtype,s,i);return[e.makeTensorInfo(N.shape,N.dtype,N.values),e.makeTensorInfo(A.shape,A.dtype,A.values)]}if(s===0)return a[a.length-1]=0,[e.makeTensorInfo(a,o.dtype,[]),e.makeTensorInfo(a,"int32",[])];if(u===1)return[o,jr({attrs:{shape:a,dtype:"int32",value:0},backend:e})];let c=b.sizeFromShape(a)/u,p=Ee({inputs:{x:o},attrs:{shape:[c,u]},backend:e}),d=L6(s),f=L6(u),h=null,m=()=>h===null?[p,p]:[p,h],g=(I,N,A)=>{let O=m(),$=new F_(A),G=[{type:"int32",data:[u]},{type:"int32",data:[h===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[I]},{type:"int32",data:[N]}],K=h;h=e.runWebGPUProgram($,O,"int32",G),Dy(e,K)};for(let I=1;I<d;I*=2){let N=I*2;for(let A=I;A>=1;A/=2)g(N,A,[c,f])}for(let I=f;I>d;I/=2){let N=m(),A=new $_([c,I/2]),$=[{type:"int32",data:[u]},{type:"int32",data:[h===null?1:0]},{type:"int32",data:[d]}],z=h;h=e.runWebGPUProgram(A,N,"int32",$),Dy(e,z);let G=d/2,K=G*2;for(let Z=G;Z>=1;Z/=2)g(K,Z,h.shape)}let y=h;h=tu({inputs:{x:h},backend:e,attrs:{begin:0,size:[c,s]}}),Dy(e,y);let x=kM({inputs:{x:p,indices:h},backend:e,attrs:{axis:1,batchDims:1}});Dy(e,p);let w=a.slice(0,-1);w.push(s),y=h,h=Ee({inputs:{x:h},attrs:{shape:w},backend:e}),Dy(e,y);let C=x;return x=Ee({inputs:{x},attrs:{shape:w},backend:e}),Dy(e,C),[x,h]}var z6={kernelName:vd,backendName:"webgpu",kernelFunc:O1e};var P_=class{constructor(t){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=pe(this.outputShape),this.dispatch=se(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${oe("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}};function M1e(r){let{inputs:t,backend:e,attrs:n}=r,{image:o,transforms:s}=t,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=n,[c,p,d,f]=o.shape,[h,m]=l??[p,d],g=[c,h,m,f],y=new P_(g),x=i==="nearest"?1:2,w;switch(a){case"constant":w=1;break;case"reflect":w=2;break;case"wrap":w=3;break;case"nearest":w=4;break;default:w=1;break}let C=[{type:"int32",data:[x]},{type:"int32",data:[w]},{type:"float32",data:[u]}];return e.runWebGPUProgram(y,[o,s],"float32",C)}var B6={kernelName:bd,backendName:"webgpu",kernelFunc:M1e};function F1e(r){let{inputs:t,backend:e,attrs:n}=r,{value:o}=t,{axis:s}=n;s<0&&(s+=o.shape.length);let i=o,a=i.shape.length,u=o.shape[s],l=new Array(a-1),c=0;for(let m=0;m<a;m++)m!==s&&(l[c++]=i.shape[m]);let p=[],d=new Array(a).fill(0),f=i.shape.slice();f[s]=1;let h=new Array(u);for(let m=0;m<h.length;m++){d[s]=m;let g=tu({inputs:{x:i},backend:e,attrs:{begin:d,size:f}}),y=Ee({inputs:{x:g},backend:e,attrs:{shape:l}});h[m]=y,p.push(g)}return p.forEach(m=>e.disposeData(m.dataId)),h}var V6={kernelName:Sl,backendName:"webgpu",kernelFunc:F1e};var L_=class{constructor(t,e,n){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.dispatchLayout=pe(t),this.dispatch=se(this.dispatchLayout,t,this.workgroupSize),n!=="float32"&&n!=="int32")throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${n} type.`);this.type=n,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`
    ${oe("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${Ts("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `}};function $1e(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,segmentIds:s}=t,{numSegments:i}=n,a=o.shape.length,u=[],l=0,c=T.getAxesPermutation([l],a),p=o;c!=null&&(p=Io({inputs:{x:o},backend:e,attrs:{perm:c}}),u.push(p),l=T.getInnerMostAxes(1,a)[0]);let d=T.segment_util.computeOutShape(p.shape,l,i),f=b.sizeFromShape([p.shape[l]]),h=Ee({inputs:{x:p},backend:e,attrs:{shape:[-1,f]}});u.push(h);let m=o.dtype,g=[h.shape[0],i],y=jr({backend:e,attrs:{shape:g,value:0,dtype:m}}),x=new L_(h.shape,g,m),w=[{type:"int32",data:[i]},{type:"int32",data:[b.sizeFromShape(h.shape)]}],C=e.runWebGPUProgram(x,[h,s],m,w,y),I=Ee({inputs:{x:C},backend:e,attrs:{shape:d}});u.push(C);let N=I;if(c!=null){u.push(I);let A=T.getUndoAxesPermutation(c);N=Io({inputs:{x:N},backend:e,attrs:{perm:A}})}return u.forEach(A=>e.disposeData(A.dataId)),N}var U6={kernelName:Il,backendName:"webgpu",kernelFunc:$1e};var P1e=[vj,VH,UH,GH,WH,jH,qH,KH,XH,YH,ZH,QH,JH,eq,tq,oq,sq,iq,aq,uq,cq,pq,dq,gq,yq,xq,wj,bq,Cq,Sq,Iq,Tq,_q,Eq,kq,Nq,Dq,Aq,Mq,Fq,$q,Pq,zq,Bq,Lq,Vq,Uq,Gq,Wq,jq,Kq,Xq,Yq,Zq,Qq,Jq,eK,tK,rK,yj,nK,iK,oK,sK,aK,uK,lK,cK,pK,dK,fK,bj,hK,wq,mK,gK,yK,xK,vK,bK,wK,SK,CK,IK,TK,_K,kK,NK,rq,DK,AK,MK,RK,OK,FK,nq,$K,PK,LK,zK,VK,Hq,UK,GK,WK,fq,jK,KK,XK,YK,ZK,QK,JK,e6,hq,t6,r6,n6,o6,xj,s6,i6,a6,u6,l6,c6,p6,d6,f6,h6,m6,g6,y6,x6,v6,b6,lq,A6,R6,O6,BK,w6,C6,S6,I6,_6,E6,k6,N6,D6,M6,qq,F6,$6,P6,T6,z6,B6,HH,V6,U6,HK];for(let r of P1e)Sg(r);var b8=function(r,t){return(b8=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])})(r,t)};function w8(r,t){if(typeof t!="function"&&t!==null)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function e(){this.constructor=r}b8(r,t),r.prototype=t===null?Object.create(t):(e.prototype=t.prototype,new e)}var Fr=function(){return(Fr=Object.assign||function(r){for(var t,e=1,n=arguments.length;e<n;e++)for(var o in t=arguments[e])Object.prototype.hasOwnProperty.call(t,o)&&(r[o]=t[o]);return r}).apply(this,arguments)};function Kt(r,t,e,n){return new(e||(e=Promise))(function(o,s){function i(l){try{u(n.next(l))}catch(c){s(c)}}function a(l){try{u(n.throw(l))}catch(c){s(c)}}function u(l){var c;l.done?o(l.value):(c=l.value,c instanceof e?c:new e(function(p){p(c)})).then(i,a)}u((n=n.apply(r,t||[])).next())})}function Xt(r,t){var e,n,o,s,i={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return s={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(s[Symbol.iterator]=function(){return this}),s;function a(u){return function(l){return function(c){if(e)throw new TypeError("Generator is already executing.");for(;i;)try{if(e=1,n&&(o=2&c[0]?n.return:c[0]?n.throw||((o=n.return)&&o.call(n),0):n.next)&&!(o=o.call(n,c[1])).done)return o;switch(n=0,o&&(c=[2&c[0],o.value]),c[0]){case 0:case 1:o=c;break;case 4:return i.label++,{value:c[1],done:!1};case 5:i.label++,n=c[1],c=[0];continue;case 7:c=i.ops.pop(),i.trys.pop();continue;default:if(o=i.trys,!((o=o.length>0&&o[o.length-1])||c[0]!==6&&c[0]!==2)){i=0;continue}if(c[0]===3&&(!o||c[1]>o[0]&&c[1]<o[3])){i.label=c[1];break}if(c[0]===6&&i.label<o[1]){i.label=o[1],o=c;break}if(o&&i.label<o[2]){i.label=o[2],i.ops.push(c);break}o[2]&&i.ops.pop(),i.trys.pop();continue}c=t.call(r,i)}catch(p){c=[6,p],n=0}finally{e=o=0}if(5&c[0])throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}([u,l])}}}function $h(r,t,e){if(e||arguments.length===2)for(var n,o=0,s=t.length;o<s;o++)!n&&o in t||(n||(n=Array.prototype.slice.call(t,0,o)),n[o]=t[o]);return r.concat(n||Array.prototype.slice.call(t))}var Vl=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],Eb=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],L1e={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},z1e={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},B1e=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],V1e=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]];function z_(r){return r instanceof SVGAnimatedLength?r.baseVal.value:r}function C8(r){return Kt(this,void 0,void 0,function(){var t,e;return Xt(this,function(n){switch(n.label){case 0:return t=document.createElement("canvas"),r instanceof ct?[4,Mc.toPixels(r,t)]:[3,2];case 1:return n.sent(),[3,3];case 2:t.width=z_(r.width),t.height=z_(r.height),e=t.getContext("2d"),r instanceof ImageData?e.putImageData(r,0,0):e.drawImage(r,0,0),n.label=3;case 3:return[2,t]}})})}function S8(r){return Kt(this,void 0,void 0,function(){var t,e,n,o,s,i;return Xt(this,function(a){switch(a.label){case 0:return r instanceof ct?(t=r.shape.slice(0,2),e=t[0],n=t[1],o=ImageData.bind,[4,Mc.toPixels(r)]):[3,2];case 1:return[2,new(o.apply(ImageData,[void 0,a.sent(),n,e]))];case 2:return s=document.createElement("canvas"),i=s.getContext("2d"),s.width=z_(r.width),s.height=z_(r.height),i.drawImage(r,0,0),[2,i.getImageData(0,0,s.width,s.height)]}})})}function U1e(r){return Kt(this,void 0,void 0,function(){var t,e;return Xt(this,function(n){switch(n.label){case 0:return r instanceof SVGImageElement||r instanceof OffscreenCanvas?[4,C8(r)]:[3,2];case 1:return e=n.sent(),[3,3];case 2:e=r,n.label=3;case 3:return t=e,[2,Mc.fromPixels(t,4)]}})})}function I8(r){if(r<0||r>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(r));if(!Number.isInteger(r))throw new Error("Mask value must be an integer but got ".concat(r))}var _b={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},G1e=function(){function r(t){this.mask=t}return r.prototype.toCanvasImageSource=function(){return Kt(this,void 0,void 0,function(){return Xt(this,function(t){return[2,this.mask]})})},r.prototype.toImageData=function(){return Kt(this,void 0,void 0,function(){return Xt(this,function(t){return[2,S8(this.mask)]})})},r.prototype.toTensor=function(){return Kt(this,void 0,void 0,function(){return Xt(this,function(t){return[2,U1e(this.mask)]})})},r.prototype.getUnderlyingType=function(){return"canvasimagesource"},r}();function W1e(r){return I8(r),"person"}var j1e=function(){function r(t){var e,n=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new v8.Pose({locateFile:function(o,s){if(t.solutionPath){var i=t.solutionPath.replace(/\/+$/,"");return"".concat(i,"/").concat(o)}return"".concat(s,"/").concat(o)}}),t.modelType){case"lite":e=0;break;case"heavy":e=2;break;case"full":default:e=1}this.poseSolution.setOptions({modelComplexity:e,smoothLandmarks:t.enableSmoothing,enableSegmentation:t.enableSegmentation,smoothSegmentation:t.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(o){if(n.height=o.image.height,n.width=o.image.width,o.poseLandmarks==null)n.poses=[];else{var s=n.translateOutput(o.poseLandmarks,o.poseWorldLandmarks);o.segmentationMask&&(s.segmentation={maskValueToLabel:W1e,mask:new G1e(o.segmentationMask)}),n.poses=[s]}})}return r.prototype.translateOutput=function(t,e){var n=this,o={keypoints:t.map(function(s,i){return{x:s.x*n.width,y:s.y*n.height,z:s.z,score:s.visibility,name:Eb[i]}})};return e!=null&&(o.keypoints3D=e.map(function(s,i){return{x:s.x,y:s.y,z:s.z,score:s.visibility,name:Eb[i]}})),o},r.prototype.estimatePoses=function(t,e,n){return Kt(this,void 0,void 0,function(){var o,s;return Xt(this,function(i){switch(i.label){case 0:return e&&e.flipHorizontal&&e.flipHorizontal!==this.selfieMode&&(this.selfieMode=e.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),t instanceof ct?(s=ImageData.bind,[4,Mc.toPixels(t)]):[3,2];case 1:return o=new(s.apply(ImageData,[void 0,i.sent(),t.shape[1],t.shape[0]])),[3,3];case 2:o=t,i.label=3;case 3:return t=o,[4,this.poseSolution.send({image:t},n)];case 4:return i.sent(),[2,this.poses]}})})},r.prototype.dispose=function(){this.poseSolution.close()},r.prototype.reset=function(){this.poseSolution.reset()},r.prototype.initialize=function(){return this.poseSolution.initialize()},r}();function H1e(r){return Kt(this,void 0,void 0,function(){var t,e;return Xt(this,function(n){switch(n.label){case 0:return t=function(o){if(o==null)return Fr({},_b);var s=Fr({},o);return s.runtime="mediapipe",s.enableSegmentation==null&&(s.enableSegmentation=_b.enableSegmentation),s.enableSmoothing==null&&(s.enableSmoothing=_b.enableSmoothing),s.smoothSegmentation==null&&(s.smoothSegmentation=_b.smoothSegmentation),s.modelType==null&&(s.modelType=_b.modelType),s}(r),[4,(e=new j1e(t)).initialize()];case 1:return n.sent(),[2,e]}})})}function Ry(r){return r instanceof ct?{height:r.shape[0],width:r.shape[1]}:{height:r.height,width:r.width}}function T8(r){return r-2*Math.PI*Math.floor((r+Math.PI)/(2*Math.PI))}function WM(r){return r instanceof ct?r:Mc.fromPixels(r)}function _8(r,t,e){return BM(e,"inputResolution"),[1/e.width*r[0][0]*t.width,1/e.height*r[0][1]*t.width,r[0][3]*t.width,1/e.width*r[1][0]*t.height,1/e.height*r[1][1]*t.height,r[1][3]*t.height,0,0]}function BM(r,t){b.assert(r.width!==0,function(){return"".concat(t," width cannot be 0.")}),b.assert(r.height!==0,function(){return"".concat(t," height cannot be 0.")})}function AM(r,t,e){var n=e.rotationVectorStartKeypointIndex,o=e.rotationVectorEndKeypointIndex,s=r.locationData,i=s.relativeKeypoints[n].x*t.width,a=s.relativeKeypoints[n].y*t.height,u=s.relativeKeypoints[o].x*t.width,l=s.relativeKeypoints[o].y*t.height,c=2*Math.sqrt((u-i)*(u-i)+(l-a)*(l-a)),p=function(d,f,h){var m,g=d.locationData,y=h.rotationVectorStartKeypointIndex,x=h.rotationVectorEndKeypointIndex;m=h.rotationVectorTargetAngle?h.rotationVectorTargetAngle:Math.PI*h.rotationVectorTargetAngleDegree/180;var w=g.relativeKeypoints[y].x*f.width,C=g.relativeKeypoints[y].y*f.height,I=g.relativeKeypoints[x].x*f.width,N=g.relativeKeypoints[x].y*f.height;return T8(m-Math.atan2(-(N-C),I-w))}(r,t,e);return{xCenter:i/t.width,yCenter:a/t.height,width:c/t.width,height:c/t.height,rotation:p}}function E8(r){if(r.length!==16)throw new Error("Array length must be 16 but got ".concat(r.length));return[[r[0],r[1],r[2],r[3]],[r[4],r[5],r[6],r[7]],[r[8],r[9],r[10],r[11]],[r[12],r[13],r[14],r[15]]]}function RM(r,t,e,n,o,s,i){return r[t][o]*(r[e][s]*r[n][i]-r[e][i]*r[n][s])}function Lo(r,t,e){var n=(t+1)%4,o=(t+2)%4,s=(t+3)%4,i=(e+1)%4,a=(e+2)%4,u=(e+3)%4;return RM(r,n,o,s,i,a,u)+RM(r,o,s,n,i,a,u)+RM(r,s,n,o,i,a,u)}function G6(r,t,e){e===void 0&&(e={ignoreRotation:!1});for(var n=[],o=0,s=r;o<s.length;o++){var i=s[o],a=i.x-.5,u=i.y-.5,l=e.ignoreRotation?0:t.rotation,c=Math.cos(l)*a-Math.sin(l)*u,p=Math.sin(l)*a+Math.cos(l)*u;c=c*t.width+t.xCenter,p=p*t.height+t.yCenter;var d=i.z*t.width,f=Fr({},i);f.x=c,f.y=p,f.z=d,n.push(f)}return n}function k8(r,t){var e=function(n,o,s,i){var a=o-n,u=i-s;if(a===0)throw new Error("Original min and max are both ".concat(n,", range cannot be 0."));var l=u/a;return{scale:l,offset:s-n*l}}(0,255,t[0],t[1]);return X(function(){return re(B(r,e.scale),e.offset)})}function VM(r,t,e){var n,o,s,i,a,u,l,c,p,d,f,h,m,g,y=t.outputTensorSize,x=t.keepAspectRatio,w=t.borderMode,C=t.outputTensorFloatRange,I=Ry(r),N=function($,z){return z?{xCenter:z.xCenter*$.width,yCenter:z.yCenter*$.height,width:z.width*$.width,height:z.height*$.height,rotation:z.rotation}:{xCenter:.5*$.width,yCenter:.5*$.height,width:$.width,height:$.height,rotation:0}}(I,e),A=function($,z,G){if(G===void 0&&(G=!1),!G)return{top:0,left:0,right:0,bottom:0};var K=z.height,Z=z.width;BM(z,"targetSize"),BM($,"roi");var Q,J,te=K/Z,ie=$.height/$.width,ne=0,ae=0;return te>ie?(Q=$.width,J=$.width*te,ae=(1-ie/te)/2):(Q=$.height/te,J=$.height,ne=(1-te/ie)/2),$.width=Q,$.height=J,{top:ae,left:ne,right:ne,bottom:ae}}(N,y,x),O=(n=N,o=I.width,s=I.height,i=!1,a=n.width,u=n.height,l=i?-1:1,c=Math.cos(n.rotation),p=Math.sin(n.rotation),d=n.xCenter,f=n.yCenter,h=1/o,m=1/s,(g=new Array(16))[0]=a*c*l*h,g[1]=-u*p*h,g[2]=0,g[3]=(-.5*a*c*l+.5*u*p+d)*h,g[4]=a*p*l*m,g[5]=u*c*m,g[6]=0,g[7]=(-.5*u*c-.5*a*p*l+f)*m,g[8]=0,g[9]=0,g[10]=a*h,g[11]=0,g[12]=0,g[13]=0,g[14]=0,g[15]=1,E8(g));return{imageTensor:X(function(){var $=WM(r),z=So(_8(O,I,y),[1,8]),G=w==="zero"?"constant":"nearest",K=yn.transform(Sr(le($,"float32")),z,"bilinear",G,0,[y.height,y.width]);return C!=null?k8(K,C):K}),padding:A,transformationMatrix:O}}function W6(r,t,e,n){return n===1?.5*(r+t):r+(t-r)*e/(n-1)}function q1e(r){return X(function(){var t=function(o){return X(function(){return[Ue(o,[0,0,0],[1,-1,1]),Ue(o,[0,0,1],[1,-1,-1])]})}(r),e=t[0],n=t[1];return{boxes:Rt(n),logits:Rt(e)}})}function N8(r){return r!=null&&r.currentTime!=null}function j6(r){for(var t={locationData:{relativeKeypoints:[]}},e=Number.MAX_SAFE_INTEGER,n=Number.MIN_SAFE_INTEGER,o=Number.MAX_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER,i=0;i<r.length;++i){var a=r[i];e=Math.min(e,a.x),n=Math.max(n,a.x),o=Math.min(o,a.y),s=Math.max(s,a.y),t.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return t.locationData.relativeBoundingBox={xMin:e,yMin:o,xMax:n,yMax:s,width:n-e,height:s-o},t}function K1e(r,t,e,n){return Kt(this,void 0,void 0,function(){var o,s,i,a,u;return Xt(this,function(l){switch(l.label){case 0:return r.sort(function(c,p){return Math.max.apply(Math,p.score)-Math.max.apply(Math,c.score)}),o=So(r.map(function(c){return[c.locationData.relativeBoundingBox.yMin,c.locationData.relativeBoundingBox.xMin,c.locationData.relativeBoundingBox.yMax,c.locationData.relativeBoundingBox.xMax]})),s=cr(r.map(function(c){return c.score[0]})),[4,yn.nonMaxSuppressionAsync(o,s,t,e)];case 1:return[4,(i=l.sent()).array()];case 2:return a=l.sent(),u=r.filter(function(c,p){return a.indexOf(p)>-1}),$e([o,s,i]),[2,u]}})})}function D8(r,t){return r.map(function(e){var n=Fr(Fr({},e),{x:e.x*t.width,y:e.y*t.height});return e.z!=null&&(n.z=e.z*t.width),n})}function X1e(r,t,e){return Kt(this,void 0,void 0,function(){var n,o,s,i,a,u,l,c,p,d,f,h,m,g,y,x,w,C,I,N,A,O,$,z;return Xt(this,function(G){switch(G.label){case 0:if(n=Rt(t,[0]),o=n.shape,s=o[0],i=o[1],a=o[2],r.length!==a)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(r.length,", heatmap length: ").concat(a));return u=[],[4,n.buffer()];case 1:for(l=G.sent(),c=0;c<r.length;c++)if(p=r[c],d=Fr({},p),u.push(d),f=Math.trunc(d.x*i),h=Math.trunc(d.y*s),!(f<0||f>=i||h<0||f>=s)){for(m=Math.trunc((e.kernelSize-1)/2),g=Math.max(0,f-m),y=Math.min(i,f+m+1),x=Math.max(0,h-m),w=Math.min(s,h+m+1),C=0,I=0,N=0,A=0,O=x;O<w;++O)for($=g;$<y;++$)z=l.get(O,$,c),C+=z,A=Math.max(A,z),I+=$*z,N+=O*z;A>=e.minConfidenceToRefine&&C>0&&(d.x=I/i/C,d.y=N/s/C)}return n.dispose(),[2,u]}})})}function H6(r,t){var e=t.left,n=t.top,o=t.left+t.right,s=t.top+t.bottom;return r.map(function(i){return Fr(Fr({},i),{x:(i.x-e)/(1-o),y:(i.y-n)/(1-s),z:i.z/(1-o)})})}function Y1e(r,t,e){return El()==="webgl"?function(n,o,s){var i=s.combineWithPreviousRatio.toFixed(2),a={variableNames:["prevMask","newMask"],outputShape:n.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `.concat(i,`);

      setOutput(outputValue);
    }
`)},u=kl();return X(function(){var l=u.compileAndRun(a,[n,o]);return Pn().makeTensorFromDataId(l.dataId,l.shape,l.dtype)})}(r,t,e):X(function(){var n=xe(t,.5),o=at(n),s=xe(1,rs(1,B(o,re(5.68842,B(o,re(-.748699,B(o,re(-57.8051,B(o,re(291.309,B(o,-624.717)))))))))));return re(t,B(xe(r,t),B(s,e.combineWithPreviousRatio)))})}function Z1e(r,t,e){return Kt(this,void 0,void 0,function(){var n,o,s,i,a;return Xt(this,function(u){switch(u.label){case 0:return n=r[0],o=r[1],s=function(l,c,p){return X(function(){var d,f,h,m;p.reverseOutputOrder?(f=Rt(Ue(l,[0,p.boxCoordOffset+0],[-1,1])),d=Rt(Ue(l,[0,p.boxCoordOffset+1],[-1,1])),m=Rt(Ue(l,[0,p.boxCoordOffset+2],[-1,1])),h=Rt(Ue(l,[0,p.boxCoordOffset+3],[-1,1]))):(d=Rt(Ue(l,[0,p.boxCoordOffset+0],[-1,1])),f=Rt(Ue(l,[0,p.boxCoordOffset+1],[-1,1])),h=Rt(Ue(l,[0,p.boxCoordOffset+2],[-1,1])),m=Rt(Ue(l,[0,p.boxCoordOffset+3],[-1,1]))),f=re(B(me(f,p.xScale),c.w),c.x),d=re(B(me(d,p.yScale),c.h),c.y),p.applyExponentialOnBoxSize?(h=B(Rr(me(h,p.hScale)),c.h),m=B(Rr(me(m,p.wScale)),c.w)):(h=B(me(h,p.hScale),c.h),m=B(me(m,p.wScale),c.h));var g=xe(d,me(h,2)),y=xe(f,me(m,2)),x=re(d,me(h,2)),w=re(f,me(m,2)),C=Dt([V(g,[p.numBoxes,1]),V(y,[p.numBoxes,1]),V(x,[p.numBoxes,1]),V(w,[p.numBoxes,1])],1);if(p.numKeypoints)for(var I=0;I<p.numKeypoints;++I){var N=p.keypointCoordOffset+I*p.numValuesPerKeypoint,A=void 0,O=void 0;p.reverseOutputOrder?(A=Rt(Ue(l,[0,N],[-1,1])),O=Rt(Ue(l,[0,N+1],[-1,1]))):(O=Rt(Ue(l,[0,N],[-1,1])),A=Rt(Ue(l,[0,N+1],[-1,1])));var $=re(B(me(A,p.xScale),c.w),c.x),z=re(B(me(O,p.yScale),c.h),c.y);C=Dt([C,V($,[p.numBoxes,1]),V(z,[p.numBoxes,1])],1)}return C})}(o,t,e),i=X(function(){var l=n;return e.sigmoidScore?(e.scoreClippingThresh!=null&&(l=Sn(n,-e.scoreClippingThresh,e.scoreClippingThresh)),l=Rn(l)):l}),[4,Q1e(s,i,e)];case 1:return a=u.sent(),$e([s,i]),[2,a]}})})}function Q1e(r,t,e){return Kt(this,void 0,void 0,function(){var n,o,s,i,a,u,l,c,p,d,f,h;return Xt(this,function(m){switch(m.label){case 0:return n=[],[4,r.data()];case 1:return o=m.sent(),[4,t.data()];case 2:for(s=m.sent(),i=0;i<e.numBoxes;++i)if(!(e.minScoreThresh!=null&&s[i]<e.minScoreThresh||(a=i*e.numCoords,u=J1e(o[a+0],o[a+1],o[a+2],o[a+3],s[i],e.flipVertically,i),(l=u.locationData.relativeBoundingBox).width<0||l.height<0))){if(e.numKeypoints>0)for((c=u.locationData).relativeKeypoints=[],p=e.numKeypoints*e.numValuesPerKeypoint,d=0;d<p;d+=e.numValuesPerKeypoint)f=a+e.keypointCoordOffset+d,h={x:o[f+0],y:e.flipVertically?1-o[f+1]:o[f+1]},c.relativeKeypoints.push(h);n.push(u)}return[2,n]}})})}function J1e(r,t,e,n,o,s,i){return{score:[o],ind:i,locationData:{relativeBoundingBox:{xMin:t,yMin:s?1-e:r,xMax:n,yMax:s?1-r:e,width:n-t,height:e-r}}}}function eEe(r,t){return r==="none"?t:function(e){return 1/(1+Math.exp(-e))}(t)}function q6(r,t,e,n){return Kt(this,void 0,void 0,function(){var o,s,i,a,u,l,c,p;return Xt(this,function(d){switch(d.label){case 0:return e=e||t.flipHorizontally||!1,n=n||t.flipVertically||!1,o=r.size,s=o/t.numLandmarks,[4,r.data()];case 1:for(i=d.sent(),a=[],u=0;u<t.numLandmarks;++u)l=u*s,(p={x:0,y:0}).x=e?t.inputImageWidth-i[l]:i[l],s>1&&(p.y=n?t.inputImageHeight-i[l+1]:i[l+1]),s>2&&(p.z=i[l+2]),s>3&&(p.score=eEe(t.visibilityActivation,i[l+3])),a.push(p);for(c=0;c<a.length;++c)(p=a[c]).x=p.x/t.inputImageWidth,p.y=p.y/t.inputImageHeight,p.z=p.z/t.inputImageWidth/(t.normalizeZ||1);return[2,a]}})})}function K6(r,t,e){var n=r.width,o=r.height,s=r.rotation;if(e.rotation==null&&e.rotationDegree==null||(s=function(c,p){return p.rotation!=null?c+=p.rotation:p.rotationDegree!=null&&(c+=Math.PI*p.rotationDegree/180),T8(c)}(s,e)),s===0)r.xCenter=r.xCenter+n*e.shiftX,r.yCenter=r.yCenter+o*e.shiftY;else{var i=(t.width*n*e.shiftX*Math.cos(s)-t.height*o*e.shiftY*Math.sin(s))/t.width,a=(t.width*n*e.shiftX*Math.sin(s)+t.height*o*e.shiftY*Math.cos(s))/t.height;r.xCenter=r.xCenter+i,r.yCenter=r.yCenter+a}if(e.squareLong){var u=Math.max(n*t.width,o*t.height);n=u/t.width,o=u/t.height}else if(e.squareShort){var l=Math.min(n*t.width,o*t.height);n=l/t.width,o=l/t.height}return r.width=n*e.scaleX,r.height=o*e.scaleY,r}function tEe(r,t){return r.map(function(e){var n=Fr(Fr({},e),{x:e.x/t.width,y:e.y/t.height});return e.z!=null&&(e.z=e.z/t.width),n})}var Yd=function(){function r(t){this.alpha=t,this.initialized=!1}return r.prototype.apply=function(t,e){var n;return this.initialized?n=e==null?this.storedValue+this.alpha*(t-this.storedValue):this.storedValue+this.alpha*e*Math.asinh((t-this.storedValue)/e):(n=t,this.initialized=!0),this.rawValue=t,this.storedValue=n,n},r.prototype.applyWithAlpha=function(t,e,n){return this.alpha=e,this.apply(t,n)},r.prototype.hasLastRawValue=function(){return this.initialized},r.prototype.lastRawValue=function(){return this.rawValue},r.prototype.reset=function(){this.initialized=!1},r}(),OM=function(){function r(t){this.frequency=t.frequency,this.minCutOff=t.minCutOff,this.beta=t.beta,this.thresholdCutOff=t.thresholdCutOff,this.thresholdBeta=t.thresholdBeta,this.derivateCutOff=t.derivateCutOff,this.x=new Yd(this.getAlpha(this.minCutOff)),this.dx=new Yd(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return r.prototype.apply=function(t,e,n){if(t==null)return t;var o=Math.trunc(e);if(this.lastTimestamp>=o)return t;this.lastTimestamp!==0&&o!==0&&(this.frequency=1/(1e-6*(o-this.lastTimestamp))),this.lastTimestamp=o;var s=this.x.hasLastRawValue()?(t-this.x.lastRawValue())*n*this.frequency:0,i=this.dx.applyWithAlpha(s,this.getAlpha(this.derivateCutOff)),a=this.minCutOff+this.beta*Math.abs(i),u=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(i):null;return this.x.applyWithAlpha(t,this.getAlpha(a),u)},r.prototype.getAlpha=function(t){return 1/(1+this.frequency/(2*Math.PI*t))},r}(),UM=function(){function r(t){this.config=t}return r.prototype.apply=function(t,e,n){var o=this;if(t==null)return this.reset(),null;this.initializeFiltersIfEmpty(t);var s=1;if(!this.config.disableValueScaling){if(n<this.config.minAllowedObjectScale)return $h([],t,!0);s=1/n}return t.map(function(i,a){var u=Fr(Fr({},i),{x:o.xFilters[a].apply(i.x,e,s),y:o.yFilters[a].apply(i.y,e,s)});return i.z!=null&&(u.z=o.zFilters[a].apply(i.z,e,s)),u})},r.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},r.prototype.initializeFiltersIfEmpty=function(t){var e=this;this.xFilters!=null&&this.xFilters.length===t.length||(this.xFilters=t.map(function(n){return new OM(e.config)}),this.yFilters=t.map(function(n){return new OM(e.config)}),this.zFilters=t.map(function(n){return new OM(e.config)}))},r}(),MM=function(){function r(t){this.config=t,this.window=[],this.lowPassFilter=new Yd(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return r.prototype.apply=function(t,e,n){if(t==null)return t;var o,s=Math.trunc(e);if(this.lastTimestamp>=s)return t;if(this.lastTimestamp===-1)o=1;else{for(var i=t*n-this.lastValue*this.lastValueScale,a=s-this.lastTimestamp,u=i,l=a,c=(1+this.window.length)*(1e6/30),p=0,d=this.window;p<d.length;p++){var f=d[p];if(l+f.duration>c)break;u+=f.distance,l+=f.duration}var h=u/(1e-6*l);o=1-1/(1+this.config.velocityScale*Math.abs(h)),this.window.unshift({distance:i,duration:a}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=t,this.lastValueScale=n,this.lastTimestamp=s,this.lowPassFilter.applyWithAlpha(t,o)},r}(),rEe=function(){function r(t){this.config=t}return r.prototype.apply=function(t,e,n){var o=this;if(t==null)return this.reset(),null;var s=1;if(!this.config.disableValueScaling){if(n<this.config.minAllowedObjectScale)return $h([],t,!0);s=1/n}return this.initializeFiltersIfEmpty(t),t.map(function(i,a){var u=Fr(Fr({},i),{x:o.xFilters[a].apply(i.x,e,s),y:o.yFilters[a].apply(i.y,e,s)});return i.z!=null&&(u.z=o.zFilters[a].apply(i.z,e,s)),u})},r.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},r.prototype.initializeFiltersIfEmpty=function(t){var e=this;this.xFilters!=null&&this.xFilters.length===t.length||(this.xFilters=t.map(function(n){return new MM(e.config)}),this.yFilters=t.map(function(n){return new MM(e.config)}),this.zFilters=t.map(function(n){return new MM(e.config)}))},r}(),FM=function(){function r(t){if(t.velocityFilter!=null)this.keypointsFilter=new rEe(t.velocityFilter);else{if(t.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(t,"."));this.keypointsFilter=new UM(t.oneEuroFilter)}}return r.prototype.apply=function(t,e,n,o,s){if(o===void 0&&(o=!1),t==null)return this.keypointsFilter.reset(),null;var i=s!=null?function(l,c){return(l.width*c.width+l.height*c.height)/2}(s,n):1,a=o?D8(t,n):t,u=this.keypointsFilter.apply(a,e,i);return o?tEe(u,n):u},r}(),X6=function(){function r(t){this.alpha=t.alpha}return r.prototype.apply=function(t){var e=this;if(t==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===t.length||(this.visibilityFilters=t.map(function(a){return new Yd(e.alpha)}));for(var n=[],o=0;o<t.length;++o){var s=t[o],i=Fr({},s);i.score=this.visibilityFilters[o].apply(s.score),n.push(i)}return n},r}(),nEe={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},Ay={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},oEe={maxPoses:1,flipHorizontal:!1},sEe={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},iEe=.3,Y6={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},aEe={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},uEe={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},lEe={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},cEe={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},pEe={kernelSize:7,minConfidenceToRefine:.5},Z6={alpha:.1},dEe={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},fEe={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},hEe={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},mEe={activation:"none"},gEe={combineWithPreviousRatio:.7},yEe=function(){function r(t){this.mask=t}return r.prototype.toCanvasImageSource=function(){return Kt(this,void 0,void 0,function(){return Xt(this,function(t){return[2,C8(this.mask)]})})},r.prototype.toImageData=function(){return Kt(this,void 0,void 0,function(){return Xt(this,function(t){return[2,S8(this.mask)]})})},r.prototype.toTensor=function(){return Kt(this,void 0,void 0,function(){return Xt(this,function(t){return[2,this.mask]})})},r.prototype.getUnderlyingType=function(){return"tensor"},r}();function xEe(r){return I8(r),"person"}var vEe=function(){function r(t,e,n,o,s,i){this.detectorModel=t,this.landmarkModel=e,this.enableSmoothing=n,this.enableSegmentation=o,this.smoothSegmentation=s,this.modelType=i,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(p){p.reduceBoxesInLowestLayer==null&&(p.reduceBoxesInLowestLayer=!1),p.interpolatedScaleAspectRatio==null&&(p.interpolatedScaleAspectRatio=1),p.fixedAnchorSize==null&&(p.fixedAnchorSize=!1);for(var d=[],f=0;f<p.numLayers;){for(var h=[],m=[],g=[],y=[],x=f;x<p.strides.length&&p.strides[x]===p.strides[f];){var w=W6(p.minScale,p.maxScale,x,p.strides.length);if(x===0&&p.reduceBoxesInLowestLayer)g.push(1),g.push(2),g.push(.5),y.push(.1),y.push(w),y.push(w);else{for(var C=0;C<p.aspectRatios.length;++C)g.push(p.aspectRatios[C]),y.push(w);if(p.interpolatedScaleAspectRatio>0){var I=x===p.strides.length-1?1:W6(p.minScale,p.maxScale,x+1,p.strides.length);y.push(Math.sqrt(w*I)),g.push(p.interpolatedScaleAspectRatio)}}x++}for(var N=0;N<g.length;++N){var A=Math.sqrt(g[N]);h.push(y[N]/A),m.push(y[N]*A)}var O=0,$=0;if(p.featureMapHeight.length>0)O=p.featureMapHeight[f],$=p.featureMapWidth[f];else{var z=p.strides[f];O=Math.ceil(p.inputSizeHeight/z),$=Math.ceil(p.inputSizeWidth/z)}for(var G=0;G<O;++G)for(var K=0;K<$;++K)for(var Z=0;Z<h.length;++Z){var Q={xCenter:(K+p.anchorOffsetX)/$,yCenter:(G+p.anchorOffsetY)/O,width:0,height:0};p.fixedAnchorSize?(Q.width=1,Q.height=1):(Q.width=m[Z],Q.height=h[Z]),d.push(Q)}f=x}return d}(nEe);var a=cr(this.anchors.map(function(p){return p.width})),u=cr(this.anchors.map(function(p){return p.height})),l=cr(this.anchors.map(function(p){return p.xCenter})),c=cr(this.anchors.map(function(p){return p.yCenter}));this.anchorTensor={x:l,y:c,w:a,h:u},this.prevFilteredSegmentationMask=this.enableSegmentation?So([],[0,0]):null}return r.prototype.estimatePoses=function(t,e,n){return Kt(this,void 0,void 0,function(){var o,s,i,a,u,l,c,p,d,f,h,m,g,y,x,w,C,I,N,A,O,$,z;return Xt(this,function(G){switch(G.label){case 0:return o=function(K){var Z;if((Z=K==null?oEe:Fr({},K)).maxPoses==null&&(Z.maxPoses=1),Z.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(Z.maxPoses,". Should be > 0."));if(Z.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return Z}(e),t==null?(this.reset(),[2,[]]):(this.maxPoses=o.maxPoses,this.timestamp=n!=null?1e3*n:N8(t)?1e6*t.currentTime:null,s=Ry(t),i=X(function(){return le(WM(t),"float32")}),(a=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(i)]);case 1:if((u=G.sent()).length===0)return this.reset(),i.dispose(),[2,[]];l=u[0],a=this.poseDetectionToRoi(l,s),G.label=2;case 2:return[4,this.poseLandmarksByRoi(a,i)];case 3:return c=G.sent(),i.dispose(),c==null?(this.reset(),[2,[]]):(p=c.landmarks,d=c.auxiliaryLandmarks,f=c.poseScore,h=c.worldLandmarks,m=c.segmentationMask,g=this.poseLandmarkFiltering(p,d,h,s),y=g.actualLandmarksFiltered,x=g.auxiliaryLandmarksFiltered,w=g.actualWorldLandmarksFiltered,C=this.poseLandmarksToRoi(x,s),this.regionOfInterest=C,I=this.smoothSegmentation&&m!=null?this.poseSegmentationFiltering(m):m,(N=y!=null?D8(y,s):null)!=null&&N.forEach(function(K,Z){K.name=Eb[Z]}),(A=w)!=null&&A.forEach(function(K,Z){K.name=Eb[Z]}),O={score:f,keypoints:N,keypoints3D:A},I!==null&&($=X(function(){var K=Sr(I,2),Z=Vn(K,[[0,0],[0,0],[0,1]]);return Hg(Z,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||$e(I),z={maskValueToLabel:xEe,mask:new yEe($)},O.segmentation=z),[2,[O]])}})})},r.prototype.poseSegmentationFiltering=function(t){var e=this.prevFilteredSegmentationMask;return e.size===0?this.prevFilteredSegmentationMask=t:(this.prevFilteredSegmentationMask=Y1e(e,t,gEe),$e(t)),$e(e),this.prevFilteredSegmentationMask},r.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),$e([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},r.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&($e(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=So([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},r.prototype.detectPose=function(t){return Kt(this,void 0,void 0,function(){var e,n,o,s,i,a,u,l,c,p;return Xt(this,function(d){switch(d.label){case 0:return e=VM(t,aEe),n=e.imageTensor,o=e.padding,s=this.detectorModel.predict(n),i=q1e(s),a=i.boxes,[4,Z1e([u=i.logits,a],this.anchorTensor,sEe)];case 1:return(l=d.sent()).length===0?($e([n,s,u,a]),[2,l]):[4,K1e(l,this.maxPoses,iEe)];case 2:return c=d.sent(),p=function(f,h){f===void 0&&(f=[]);for(var m=h.left,g=h.top,y=h.left+h.right,x=h.top+h.bottom,w=0;w<f.length;w++){var C=f[w],I=C.locationData.relativeBoundingBox,N=(I.xMin-m)/(1-y),A=(I.yMin-g)/(1-x),O=I.width/(1-y),$=I.height/(1-x);I.xMin=N,I.yMin=A,I.width=O,I.height=$,I.xMax=N+O,I.yMax=A+$;var z=C.locationData.relativeKeypoints;z&&z.forEach(function(G){var K=(G.x-m)/(1-y),Z=(G.y-g)/(1-x);G.x=K,G.y=Z})}return f}(c,o),$e([n,s,u,a]),[2,p]}})})},r.prototype.poseDetectionToRoi=function(t,e){return K6(AM(t,e,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),e,Y6)},r.prototype.poseLandmarksByRoi=function(t,e){return Kt(this,void 0,void 0,function(){var n,o,s,i,a,u,l,c,p,d,f,h,m,g;return Xt(this,function(y){switch(y.label){case 0:if(n=Ry(e),o=VM(e,uEe,t),s=o.imageTensor,i=o.padding,a=o.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return u=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&u.push("activation_segmentation"),l=this.landmarkModel.execute(s,u),[4,this.tensorsToPoseLandmarksAndSegmentation(l)];case 1:return(c=y.sent())==null?($e(l),$e(s),[2,null]):(p=c.landmarks,d=c.auxiliaryLandmarks,f=c.poseScore,h=c.worldLandmarks,m=c.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(n,t,i,a,p,d,h,m)]);case 2:return g=y.sent(),$e(l),$e(s),[2,Fr({poseScore:f},g)]}})})},r.prototype.poseLandmarksAndSegmentationInverseProjection=function(t,e,n,o,s,i,a,u){return Kt(this,void 0,void 0,function(){var l,c,p,d,f,h;return Xt(this,function(m){return l=H6(s,n),c=H6(i,n),p=G6(l,e),d=G6(c,e),f=function(g,y){for(var x=[],w=0,C=g;w<C.length;w++){var I=C[w],N=I.x,A=I.y,O=y.rotation,$=Math.cos(O)*N-Math.sin(O)*A,z=Math.sin(O)*N+Math.cos(O)*A,G=Fr({},I);G.x=$,G.y=z,x.push(G)}return x}(a,e),h=null,this.enableSegmentation&&(h=X(function(){var g=u.shape,y=g[0],x=g[1],w=function(N){var A=E8(new Array(16).fill(0));A[0][0]=Lo(N,0,0),A[1][0]=-Lo(N,0,1),A[2][0]=Lo(N,0,2),A[3][0]=-Lo(N,0,3),A[0][2]=Lo(N,2,0),A[1][2]=-Lo(N,2,1),A[2][2]=Lo(N,2,2),A[3][2]=-Lo(N,2,3),A[0][1]=-Lo(N,1,0),A[1][1]=Lo(N,1,1),A[2][1]=-Lo(N,1,2),A[3][1]=Lo(N,1,3),A[0][3]=-Lo(N,3,0),A[1][3]=Lo(N,3,1),A[2][3]=-Lo(N,3,2),A[3][3]=Lo(N,3,3);for(var O=N[0][0]*A[0][0]+N[1][0]*A[0][1]+N[2][0]*A[0][2]+N[3][0]*A[0][3],$=0;$<A.length;$++)for(var z=0;z<A.length;z++)A[$][z]/=O;return A}(o),C=So(_8(w,{width:x,height:y},t),[1,8]),I=[1,y,x,1];return Rt(yn.transform(V(u,I),C,"bilinear","constant",0,[t.height,t.width]),[0,3])}),$e(u)),[2,{landmarks:p,auxiliaryLandmarks:d,worldLandmarks:f,segmentationMask:h}]})})},r.prototype.tensorsToPoseLandmarksAndSegmentation=function(t){return Kt(this,void 0,void 0,function(){var e,n,o,s,i,a,u,l,c,p,d,f,h;return Xt(this,function(m){switch(m.label){case 0:return e=t[0],n=t[1],o=t[2],s=t[3],i=this.enableSegmentation?t[4]:null,[4,n.data()];case 1:return(a=m.sent()[0])<.5?[2,null]:[4,q6(e,lEe)];case 2:return[4,X1e(m.sent(),o,pEe)];case 3:return u=m.sent(),l=u.slice(0,33),c=u.slice(33,35),[4,q6(s,cEe)];case 4:return p=m.sent(),d=p.slice(0,33),f=function(g,y,x){x===void 0&&(x=!0);for(var w=[],C=0;C<g.length;C++){var I=Fr({},y[C]);x&&(I.score=g[C].score),w.push(I)}return w}(l,d,!0),h=this.enableSegmentation?function(g,y,x){return X(function(){var w=Rt(g,[0]),C=w.shape[2];if(C===1){var I=w;switch(y.activation){case"none":break;case"sigmoid":I=Rn(I);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(y.activation,")"))}var N=x?yn.resizeBilinear(I,[x.height,x.width]):I;return Rt(N,[2])}throw new Error("Unsupported number of tensor channels ".concat(C))})}(i,mEe):null,[2,{landmarks:l,auxiliaryLandmarks:c,poseScore:a,worldLandmarks:f,segmentationMask:h}]}})})},r.prototype.poseLandmarksToRoi=function(t,e){return K6(AM(j6(t),e,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),e,Y6)},r.prototype.poseLandmarkFiltering=function(t,e,n,o){var s,i,a;if(this.timestamp!=null&&this.enableSmoothing){var u=AM(j6(e),o,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new X6(Z6)),s=this.visibilitySmoothingFilterActual.apply(t),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new X6(Z6)),i=this.visibilitySmoothingFilterAuxiliary.apply(e),a=this.visibilitySmoothingFilterActual.apply(n),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new FM(dEe)),s=this.landmarksSmoothingFilterActual.apply(s,this.timestamp,o,!0,u),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new FM(fEe)),i=this.landmarksSmoothingFilterAuxiliary.apply(i,this.timestamp,o,!0,u),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new FM(hEe)),a=this.worldLandmarksSmoothingFilterActual.apply(n,this.timestamp)}else s=t,i=e,a=n;return{actualLandmarksFiltered:s,auxiliaryLandmarksFiltered:i,actualWorldLandmarksFiltered:a}},r}();function bEe(r){return Kt(this,void 0,void 0,function(){var t,e,n,o,s,i;return Xt(this,function(a){switch(a.label){case 0:return t=function(u){var l=Fr({},u??Ay);if(l.enableSmoothing==null&&(l.enableSmoothing=Ay.enableSmoothing),l.enableSegmentation==null&&(l.enableSegmentation=Ay.enableSegmentation),l.smoothSegmentation==null&&(l.smoothSegmentation=Ay.smoothSegmentation),l.modelType==null&&(l.modelType=Ay.modelType),l.detectorModelUrl==null&&(l.detectorModelUrl=Ay.detectorModelUrl),l.landmarkModelUrl==null)switch(l.modelType){case"lite":l.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":l.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:l.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return l}(r),e=typeof t.detectorModelUrl=="string"&&t.detectorModelUrl.indexOf("https://tfhub.dev")>-1,n=typeof t.landmarkModelUrl=="string"&&t.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([jd(t.detectorModelUrl,{fromTFHub:e}),jd(t.landmarkModelUrl,{fromTFHub:n})])];case 1:return o=a.sent(),s=o[0],i=o[1],[2,new vEe(s,i,t.enableSmoothing,t.enableSegmentation,t.smoothSegmentation,t.modelType)]}})})}var Ph,To,A8=function(){function r(t){(function(e){if(e.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(e.maxTracks));if(e.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(e.maxAge));if(e.keypointTrackerParams!==void 0){if(e.keypointTrackerParams.keypointConfidenceThreshold<0||e.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(e.keypointTrackerParams.keypointConfidenceThreshold));if(e.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(e.keypointTrackerParams.minNumberOfKeypoints));for(var n=0,o=e.keypointTrackerParams.keypointFalloff;n<o.length;n++){var s=o[n];if(s<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(s))}}})(t),this.tracks=[],this.maxTracks=t.maxTracks,this.maxAge=1e3*t.maxAge,this.minSimilarity=t.minSimilarity,this.nextID=1}return r.prototype.apply=function(t,e){this.filterOldTracks(e);var n=this.computeSimilarity(t);return this.assignTracks(t,n,e),this.updateTracks(e),t},r.prototype.getTracks=function(){return this.tracks.slice()},r.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(t){return t.id}))},r.prototype.filterOldTracks=function(t){var e=this;this.tracks=this.tracks.filter(function(n){return t-n.lastTimestamp<=e.maxAge})},r.prototype.assignTracks=function(t,e,n){for(var o=Array.from(Array(e[0].length).keys()),s=[],i=0,a=Array.from(Array(t.length).keys());i<a.length;i++){var u=a[i];if(o.length!==0){for(var l=-1,c=-1,p=0,d=o;p<d.length;p++){var f=d[p],h=e[u][f];h>=this.minSimilarity&&h>c&&(l=f,c=h)}if(l>=0){var m=this.tracks[l];m=Object.assign(m,this.createTrack(t[u],n,m.id)),t[u].id=m.id;var g=o.indexOf(l);o.splice(g,1)}else s.push(u)}else s.push(u)}for(var y=0,x=s;y<x.length;y++){u=x[y];var w=this.createTrack(t[u],n);this.tracks.push(w),t[u].id=w.id}},r.prototype.updateTracks=function(t){this.tracks.sort(function(e,n){return n.lastTimestamp-e.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},r.prototype.createTrack=function(t,e,n){var o={id:n||this.nextTrackID(),lastTimestamp:e,keypoints:$h([],t.keypoints,!0).map(function(s){return Fr({},s)})};return t.box!==void 0&&(o.box=Fr({},t.box)),o},r.prototype.nextTrackID=function(){var t=this.nextID;return this.nextID+=1,t},r.prototype.remove=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];this.tracks=this.tracks.filter(function(n){return!t.includes(n.id)})},r.prototype.reset=function(){this.tracks=[]},r}(),wEe=function(r){function t(e){return r.call(this,e)||this}return w8(t,r),t.prototype.computeSimilarity=function(e){var n=this;return e.length===0||this.tracks.length===0?[[]]:e.map(function(o){return n.tracks.map(function(s){return n.iou(o,s)})})},t.prototype.iou=function(e,n){var o=Math.max(e.box.xMin,n.box.xMin),s=Math.max(e.box.yMin,n.box.yMin),i=Math.min(e.box.xMax,n.box.xMax),a=Math.min(e.box.yMax,n.box.yMax);if(o>=i||s>=a)return 0;var u=(i-o)*(a-s);return u/(e.box.width*e.box.height+n.box.width*n.box.height-u)},t}(A8),CEe=function(r){function t(e){var n=r.call(this,e)||this;return n.keypointThreshold=e.keypointTrackerParams.keypointConfidenceThreshold,n.keypointFalloff=e.keypointTrackerParams.keypointFalloff,n.minNumKeyoints=e.keypointTrackerParams.minNumberOfKeypoints,n}return w8(t,r),t.prototype.computeSimilarity=function(e){if(e.length===0||this.tracks.length===0)return[[]];for(var n=[],o=0,s=e;o<s.length;o++){for(var i=s[o],a=[],u=0,l=this.tracks;u<l.length;u++){var c=l[u];a.push(this.oks(i,c))}n.push(a)}return n},t.prototype.oks=function(e,n){for(var o=this.area(n.keypoints)+1e-6,s=0,i=0,a=0;a<e.keypoints.length;++a){var u=e.keypoints[a],l=n.keypoints[a];if(!(u.score<this.keypointThreshold||l.score<this.keypointThreshold)){i+=1;var c=Math.pow(u.x-l.x,2)+Math.pow(u.y-l.y,2),p=2*this.keypointFalloff[a];s+=Math.exp(-1*c/(2*o*Math.pow(p,2)))}}return i<this.minNumKeyoints?0:s/i},t.prototype.area=function(e){var n=this,o=e.filter(function(u){return u.score>n.keypointThreshold}),s=Math.min.apply(Math,$h([1],o.map(function(u){return u.x}),!1)),i=Math.max.apply(Math,$h([0],o.map(function(u){return u.x}),!1)),a=Math.min.apply(Math,$h([1],o.map(function(u){return u.y}),!1));return(i-s)*(Math.max.apply(Math,$h([0],o.map(function(u){return u.y}),!1))-a)},t}(A8);function R8(r){switch(r){case To.BlazePose:return Eb.reduce(function(t,e,n){return t[e]=n,t},{});case To.PoseNet:case To.MoveNet:return Vl.reduce(function(t,e,n){return t[e]=n,t},{});default:throw new Error("Model ".concat(r," is not supported."))}}(function(r){r.Keypoint="keypoint",r.BoundingBox="boundingBox"})(Ph||(Ph={})),function(r){r.MoveNet="MoveNet",r.BlazePose="BlazePose",r.PoseNet="PoseNet"}(To||(To={}));var _Kt=Object.freeze({__proto__:null,getKeypointIndexBySide:function(r){switch(r){case To.BlazePose:return L1e;case To.PoseNet:case To.MoveNet:return z1e;default:throw new Error("Model ".concat(r," is not supported."))}},getAdjacentPairs:function(r){switch(r){case To.BlazePose:return V1e;case To.PoseNet:case To.MoveNet:return B1e;default:throw new Error("Model ".concat(r," is not supported."))}},getKeypointIndexByName:R8}),Q6=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],O8={modelType:"SinglePose.Lightning",enableSmoothing:!0},J6={},e8={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},$M={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},t8={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function SEe(r,t,e,n){for(var o={},s=0,i=Vl;s<i.length;s++){var a=i[s];o[a]=[t[e[a]].y*n.height,t[e[a]].x*n.width]}if(function(x,w){return(x[w.left_hip].score>.2||x[w.right_hip].score>.2)&&(x[w.left_shoulder].score>.2||x[w.right_shoulder].score>.2)}(t,e)){var u=(o.left_hip[0]+o.right_hip[0])/2,l=(o.left_hip[1]+o.right_hip[1])/2,c=function(x,w,C,I,N){for(var A=["left_shoulder","right_shoulder","left_hip","right_hip"],O=0,$=0,z=0;z<A.length;z++)(J=Math.abs(I-C[A[z]][0]))>O&&(O=J),(te=Math.abs(N-C[A[z]][1]))>$&&($=te);for(var G=0,K=0,Z=0,Q=Object.keys(C);Z<Q.length;Z++){var J,te,ie=Q[Z];x[w[ie]].score<.2||((J=Math.abs(I-C[ie][0]))>G&&(G=J),(te=Math.abs(N-C[ie][1]))>K&&(K=te))}return[O,$,G,K]}(t,e,o,u,l),p=c[0],d=c[1],f=c[2],h=c[3],m=Math.max(1.9*d,1.9*p,1.2*f,1.2*h),g=[u-(m=Math.min(m,Math.max(l,n.width-l,u,n.height-u))),l-m];if(m>Math.max(n.width,n.height)/2)return GM(r==null,n);var y=2*m;return{yMin:g[0]/n.height,xMin:g[1]/n.width,yMax:(g[0]+y)/n.height,xMax:(g[1]+y)/n.width,height:(g[0]+y)/n.height-g[0]/n.height,width:(g[1]+y)/n.width-g[1]/n.width}}return GM(r==null,n)}function GM(r,t){var e,n,o,s;return r?t.width>t.height?(e=1,n=t.height/t.width,o=0,s=(t.width/2-t.height/2)/t.width):(e=t.width/t.height,n=1,o=(t.height/2-t.width/2)/t.height,s=0):t.width>t.height?(e=t.width/t.height,n=1,o=(t.height/2-t.width/2)/t.height,s=0):(e=1,n=t.height/t.width,o=0,s=(t.width/2-t.height/2)/t.width),{yMin:o,xMin:s,yMax:o+e,xMax:s+n,height:e,width:n}}function IEe(r){var t,e=r==null?O8:Fr({},r);if(e.modelType==null)e.modelType="SinglePose.Lightning";else if(Q6.indexOf(e.modelType)<0)throw new Error("Invalid architecture ".concat(e.modelType,". ")+"Should be one of ".concat(Q6));if(e.enableSmoothing==null&&(e.enableSmoothing=!0),e.minPoseScore!=null&&(e.minPoseScore<0||e.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(e.multiPoseMaxDimension!=null&&(e.multiPoseMaxDimension%32!=0||e.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(e.modelType==="MultiPose.Lightning"&&e.enableTracking==null&&(e.enableTracking=!0),e.modelType==="MultiPose.Lightning"&&e.enableTracking===!0)if(e.trackerType==null&&(e.trackerType=Ph.BoundingBox),e.trackerType===Ph.Keypoint)e.trackerConfig!=null?e.trackerConfig=function(n){var o=r8($M,n);return o.keypointTrackerParams=Fr({},$M.keypointTrackerParams),n.keypointTrackerParams!=null&&(n.keypointTrackerParams.keypointConfidenceThreshold!=null&&(o.keypointTrackerParams.keypointConfidenceThreshold=n.keypointTrackerParams.keypointConfidenceThreshold),n.keypointTrackerParams.keypointFalloff!=null&&(o.keypointTrackerParams.keypointFalloff=n.keypointTrackerParams.keypointFalloff),n.keypointTrackerParams.minNumberOfKeypoints!=null&&(o.keypointTrackerParams.minNumberOfKeypoints=n.keypointTrackerParams.minNumberOfKeypoints)),o}(e.trackerConfig):e.trackerConfig=$M;else{if(e.trackerType!==Ph.BoundingBox)throw new Error("Tracker type not supported by MoveNet");e.trackerConfig!=null?e.trackerConfig=(t=e.trackerConfig,r8(t8,t)):e.trackerConfig=t8}return e}function r8(r,t){var e={maxTracks:r.maxTracks,maxAge:r.maxAge,minSimilarity:r.minSimilarity};return t.maxTracks!=null&&(e.maxTracks=t.maxTracks),t.maxAge!=null&&(e.maxAge=t.maxAge),t.minSimilarity!=null&&(e.minSimilarity=t.minSimilarity),e}var TEe=function(){function r(t,e){this.moveNetModel=t,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=R8(To.MoveNet),e.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):e.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=e.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new UM(e8),this.cropRegionFilterYMin=new Yd(.9),this.cropRegionFilterXMin=new Yd(.9),this.cropRegionFilterYMax=new Yd(.9),this.cropRegionFilterXMax=new Yd(.9)),this.enableSmoothing=e.enableSmoothing,e.minPoseScore?this.minPoseScore=e.minPoseScore:this.minPoseScore=.25,e.multiPoseMaxDimension?this.multiPoseMaxDimension=e.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=e.enableTracking,this.multiPoseModel&&this.enableTracking&&(e.trackerType===Ph.Keypoint?this.tracker=new CEe(e.trackerConfig):e.trackerType===Ph.BoundingBox&&(this.tracker=new wEe(e.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return r.prototype.runSinglePersonPoseModel=function(t){return Kt(this,void 0,void 0,function(){var e,n,o,s,i;return Xt(this,function(a){switch(a.label){case 0:if((e=this.moveNetModel.execute(t)).shape.length!==4||e.shape[0]!==1||e.shape[1]!==1||e.shape[2]!==17||e.shape[3]!==3)throw e.dispose(),new Error("Unexpected output shape from model: [".concat(e.shape,"]"));return El()==="webgpu"?[3,1]:(n=e.dataSync(),[3,3]);case 1:return[4,e.data()];case 2:n=a.sent(),a.label=3;case 3:for(e.dispose(),o={keypoints:[],score:0},s=0,i=0;i<17;++i)o.keypoints[i]={y:n[3*i],x:n[3*i+1],score:n[3*i+2]},o.keypoints[i].score>.2&&(++s,o.score+=o.keypoints[i].score);return s>0&&(o.score/=s),[2,o]}})})},r.prototype.runMultiPersonPoseModel=function(t){return Kt(this,void 0,void 0,function(){var e,n,o,s,i,a,u,l;return Xt(this,function(c){switch(c.label){case 0:if((e=this.moveNetModel.execute(t)).shape.length!==3||e.shape[0]!==1||e.shape[2]!==56)throw e.dispose(),new Error("Unexpected output shape from model: [".concat(e.shape,"]"));return El()==="webgpu"?[3,1]:(n=e.dataSync(),[3,3]);case 1:return[4,e.data()];case 2:n=c.sent(),c.label=3;case 3:for(e.dispose(),o=[],s=n.length/56,i=0;i<s;++i)for(o[i]={keypoints:[]},a=56*i+51,o[i].box={yMin:n[a],xMin:n[a+1],yMax:n[a+2],xMax:n[a+3],width:n[a+3]-n[a+1],height:n[a+2]-n[a]},u=56*i+55,o[i].score=n[u],o[i].keypoints=[],l=0;l<17;++l)o[i].keypoints[l]={y:n[56*i+3*l],x:n[56*i+3*l+1],score:n[56*i+3*l+2]};return[2,o]}})})},r.prototype.estimatePoses=function(t,e,n){return e===void 0&&(e=J6),Kt(this,void 0,void 0,function(){var o,s,i,a,u,l;return Xt(this,function(c){switch(c.label){case 0:return e=function(p){return p==null?J6:Fr({},p)}(e),t==null?(this.reset(),[2,[]]):(n==null?N8(t)&&(n=1e6*t.currentTime):n*=1e3,o=WM(t),s=Ry(o),i=Sr(o,0),t instanceof ct||o.dispose(),a=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(i,s,n)]);case 1:return a=c.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(i,s,n)];case 3:a=c.sent(),c.label=4;case 4:for(u=0;u<a.length;++u)for(l=0;l<a[u].keypoints.length;++l)a[u].keypoints[l].name=Vl[l],a[u].keypoints[l].y*=s.height,a[u].keypoints[l].x*=s.width;return[2,a]}})})},r.prototype.estimateSinglePose=function(t,e,n){return Kt(this,void 0,void 0,function(){var o,s,i,a,u=this;return Xt(this,function(l){switch(l.label){case 0:return this.cropRegion||(this.cropRegion=GM(this.cropRegion==null,e)),o=X(function(){var c=So([[u.cropRegion.yMin,u.cropRegion.xMin,u.cropRegion.yMax,u.cropRegion.xMax]]),p=er([1],"int32"),d=[u.modelInputResolution.height,u.modelInputResolution.width];return le(yn.cropAndResize(t,c,p,d,"bilinear",0),"int32")}),t.dispose(),[4,this.runSinglePersonPoseModel(o)];case 1:if(s=l.sent(),o.dispose(),s.score<this.minPoseScore)return this.reset(),[2,[]];for(i=0;i<s.keypoints.length;++i)s.keypoints[i].y=this.cropRegion.yMin+s.keypoints[i].y*this.cropRegion.height,s.keypoints[i].x=this.cropRegion.xMin+s.keypoints[i].x*this.cropRegion.width;return n!=null&&this.enableSmoothing&&(s.keypoints=this.keypointFilter.apply(s.keypoints,n,1)),a=SEe(this.cropRegion,s.keypoints,this.keypointIndexByName,e),this.cropRegion=this.filterCropRegion(a),[2,[s]]}})})},r.prototype.estimateMultiplePoses=function(t,e,n){return Kt(this,void 0,void 0,function(){var o,s,i,a,u,l,c,p,d,f,h,m=this;return Xt(this,function(g){switch(g.label){case 0:return e.width>e.height?(s=this.multiPoseMaxDimension,i=Math.round(this.multiPoseMaxDimension*e.height/e.width),o=yn.resizeBilinear(t,[i,s]),u=s,l=32*Math.ceil(i/32),a=Vn(o,[[0,0],[0,l-i],[0,0],[0,0]])):(s=Math.round(this.multiPoseMaxDimension*e.width/e.height),i=this.multiPoseMaxDimension,o=yn.resizeBilinear(t,[i,s]),u=32*Math.ceil(s/32),l=i,a=Vn(o,[[0,0],[0,0],[0,u-s],[0,0]])),o.dispose(),t.dispose(),c=le(a,"int32"),a.dispose(),[4,this.runMultiPersonPoseModel(c)];case 1:for(p=g.sent(),c.dispose(),p=p.filter(function(y){return y.score>=m.minPoseScore}),f=0;f<p.length;++f)for(d=0;d<p[f].keypoints.length;++d)p[f].keypoints[d].y*=l/i,p[f].keypoints[d].x*=u/s;if(this.enableTracking&&(this.tracker.apply(p,n),this.enableSmoothing)){for(f=0;f<p.length;++f)this.keypointFilterMap.has(p[f].id)||this.keypointFilterMap.set(p[f].id,new UM(e8)),p[f].keypoints=this.keypointFilterMap.get(p[f].id).apply(p[f].keypoints,n,1);h=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(y,x){h.has(x)||m.keypointFilterMap.delete(x)})}return[2,p]}})})},r.prototype.filterCropRegion=function(t){if(t){var e=this.cropRegionFilterYMin.apply(t.yMin),n=this.cropRegionFilterXMin.apply(t.xMin),o=this.cropRegionFilterYMax.apply(t.yMax),s=this.cropRegionFilterXMax.apply(t.xMax);return{yMin:e,xMin:n,yMax:o,xMax:s,height:o-e,width:s-n}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},r.prototype.dispose=function(){this.moveNetModel.dispose()},r.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},r.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},r}();function _Ee(r){return r===void 0&&(r=O8),Kt(this,void 0,void 0,function(){var t,e,n,o;return Xt(this,function(s){switch(s.label){case 0:return t=IEe(r),n=!0,t.modelUrl?(n=typeof t.modelUrl=="string"&&t.modelUrl.indexOf("https://tfhub.dev")>-1,[4,jd(t.modelUrl,{fromTFHub:n})]):[3,2];case 1:return e=s.sent(),[3,4];case 2:return o=void 0,t.modelType==="SinglePose.Lightning"?o="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":t.modelType==="SinglePose.Thunder"?o="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":t.modelType==="MultiPose.Lightning"&&(o="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,jd(o,{fromTFHub:n})];case 3:e=s.sent(),s.label=4;case 4:return El()==="webgl"&&j().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new TEe(e,t)]}})})}var n8={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},o8=["MobileNetV1","ResNet50"],s8={MobileNetV1:[8,16],ResNet50:[16]},EEe=[8,16,32],i8={MobileNetV1:[.5,.75,1],ResNet50:[1]},a8=[1,2,4],u8={maxPoses:1,flipHorizontal:!1},kEe={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},NEe=[-123.15,-115.9,-103.06];function PM(r){return Math.floor(r/2)}var DEe=function(){function r(t,e){this.priorityQueue=new Array(t),this.numberOfElements=-1,this.getElementValue=e}return r.prototype.enqueue=function(t){this.priorityQueue[++this.numberOfElements]=t,this.swim(this.numberOfElements)},r.prototype.dequeue=function(){var t=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,t},r.prototype.empty=function(){return this.numberOfElements===-1},r.prototype.size=function(){return this.numberOfElements+1},r.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},r.prototype.max=function(){return this.priorityQueue[0]},r.prototype.swim=function(t){for(;t>0&&this.less(PM(t),t);)this.exchange(t,PM(t)),t=PM(t)},r.prototype.sink=function(t){for(;2*t<=this.numberOfElements;){var e=2*t;if(e<this.numberOfElements&&this.less(e,e+1)&&e++,!this.less(t,e))break;this.exchange(t,e),t=e}},r.prototype.getValueAt=function(t){return this.getElementValue(this.priorityQueue[t])},r.prototype.less=function(t,e){return this.getValueAt(t)<this.getValueAt(e)},r.prototype.exchange=function(t,e){var n=this.priorityQueue[t];this.priorityQueue[t]=this.priorityQueue[e],this.priorityQueue[e]=n},r}();function AEe(r,t,e,n,o,s){for(var i=s.shape,a=i[0],u=i[1],l=!0,c=Math.max(e-o,0),p=Math.min(e+o+1,a),d=c;d<p;++d){for(var f=Math.max(n-o,0),h=Math.min(n+o+1,u),m=f;m<h;++m)if(s.get(d,m,r)>t){l=!1;break}if(!l)break}return l}function REe(r){return Kt(this,void 0,void 0,function(){return Xt(this,function(t){return[2,Promise.all(r.map(function(e){return e.buffer()}))]})})}function M8(r,t,e,n){return{y:n.get(r,t,e),x:n.get(r,t,e+17)}}function F8(r,t,e){var n=M8(r.heatmapY,r.heatmapX,r.id,e),o=n.y,s=n.x;return{x:r.heatmapX*t+s,y:r.heatmapY*t+o}}function $8(r,t,e,n){var o=e.x,s=e.y;return r.some(function(i){var a,u,l,c,p,d,f=i.keypoints;return a=s,u=o,l=f[n].y,c=f[n].x,(p=l-a)*p+(d=c-u)*d<=t})}var l8=Vl.reduce(function(r,t,e){return r[t]=e,r},{}),P8=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(r){var t=r[0],e=r[1];return[l8[t],l8[e]]}),LM=P8.map(function(r){return r[1]}),c8=P8.map(function(r){return r[0]});function p8(r,t,e){return r<t?t:r>e?e:r}function zM(r,t,e,n){return{y:p8(Math.round(r.y/t),0,e-1),x:p8(Math.round(r.x/t),0,n-1)}}function d8(r,t){return{x:r.x+t.x,y:r.y+t.y}}function f8(r,t,e,n,o,s,i,a){a===void 0&&(a=2);for(var u=n.shape,l=u[0],c=u[1],p={y:t.y,x:t.x},d=d8(p,function(x,w,C){var I=C.shape[2]/2;return{y:C.get(w.y,w.x,x),x:C.get(w.y,w.x,I+x)}}(r,zM(p,s,l,c),i)),f=0;f<a;f++){var h=zM(d,s,l,c),m=M8(h.y,h.x,e,o);d=d8({x:h.x*s,y:h.y*s},{x:m.x,y:m.y})}var g=zM(d,s,l,c),y=n.get(g.y,g.x,e);return{y:d.y,x:d.x,name:Vl[e],score:y}}function OEe(r,t,e,n,o,s){var i=t.shape[2],a=LM.length,u=new Array(i),l=r.part,c=r.score,p=F8(l,n,e);u[l.id]={score:c,name:Vl[l.id],y:p.y,x:p.x};for(var d=a-1;d>=0;--d){var f=LM[d],h=c8[d];u[f]&&!u[h]&&(u[h]=f8(d,u[f],h,t,e,n,s))}for(d=0;d<a;++d)f=c8[d],h=LM[d],u[f]&&!u[h]&&(u[h]=f8(d,u[f],h,t,e,n,o));return u}function MEe(r,t,e){return e.reduce(function(n,o,s){var i=o.y,a=o.x,u=o.score;return $8(r,t,{y:i,x:a},s)||(n+=u),n},0)/e.length}function FEe(r,t,e,n,o,s,i,a){return i===void 0&&(i=.5),a===void 0&&(a=20),Kt(this,void 0,void 0,function(){var u,l,c,p,d,f,h,m,g,y,x,w;return Xt(this,function(C){switch(C.label){case 0:return[4,REe([r,t,e,n])];case 1:for(u=C.sent(),l=u[0],c=u[1],p=u[2],d=u[3],f=[],h=function(I,N,A){for(var O=A.shape,$=O[0],z=O[1],G=O[2],K=new DEe($*z*G,function(ie){return ie.score}),Z=0;Z<$;++Z)for(var Q=0;Q<z;++Q)for(var J=0;J<G;++J){var te=A.get(Z,Q,J);te<I||AEe(J,te,Z,Q,N,A)&&K.enqueue({score:te,part:{heatmapY:Z,heatmapX:Q,id:J}})}return K}(i,1,l),m=a*a;f.length<s&&!h.empty();)g=h.dequeue(),y=F8(g.part,o,c),$8(f,m,y,g.part.id)||(x=OEe(g,l,c,o,p,d),w=MEe(f,m,x),f.push({keypoints:x,score:w}));return[2,f]}})})}function L8(){for(var r,t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];switch(t.length){case 0:r="fn main() ";break;case 1:r="fn main(".concat(t[0]," : i32)");break;default:throw Error("Unreachable")}return r}var $Ee=function(){function r(t){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[t[0],1],this.dispatchLayout=Kd.flatDispatchLayout(this.outputShape),this.dispatch=Kd.computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return r.prototype.getUserCode=function(){return`
        `.concat(L8("index"),` {
          if (index < uniforms.size) {
            let y = B[index * 2];
            let x = B[index * 2 + 1];
            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;
            result[index] = A[outIndex];
          }
        }
        `)},r}();function PEe(r,t){if(kl()instanceof gy)return function(e,n){var o=kl(),s=new $Ee(n.shape),i=o.runWebGPUProgram(s,[e,n],"float32");return Pn().makeTensorFromTensorInfo(i)}(r,t);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}var LEe=function(){function r(t){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,t.length!==2||t[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(t));this.workgroupSize=[32,1,1],this.outputShape=t;var e=[t[0],1];this.dispatchLayout=Kd.flatDispatchLayout(e),this.dispatch=Kd.computeDispatch(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return r.prototype.getUserCode=function(){return`
    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {
      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;
      let outIndexX = outIndexY + uniforms.bShape.z;
      let outY = i32(B[outIndexY]);
      let outX = i32(B[outIndexX]);
      return vec2<i32>(outY, outX);
    }

    `.concat(L8("index"),` {
      if (index < uniforms.size) {
        let indexY = index * `).concat(this.supportedLastDimension,`;
        let indexX = indexY + 1;
        let heatmapY = A[indexY];
        let heatmapX = A[indexX];
        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);
        result[indexY] = f32(out[0]);
        result[indexX] = f32(out[1]);
      }
    }
    `)},r}();function zEe(r,t){if(kl()instanceof gy)return function(e,n){var o=kl(),s=new LEe(e.shape),i=o.runWebGPUProgram(s,[e,n],"float32");return Pn().makeTensorFromTensorInfo(i)}(r,t);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}function z8(r){var t=r.shape,e=t[0],n=t[1],o=t[2];return X(function(){var s,i,a=V(r,[e*n,o]),u=vi(a,0),l=Sr(me(u,we(n,"int32")),1),c=Sr((s=u,i=n,X(function(){var p=me(s,we(i,"int32"));return xe(s,B(p,we(i,"int32")))})),1);return Dt([l,c],1)})}function BEe(r,t,e){return X(function(){var n=function(o,s){for(var i=[],a=0;a<Vl.length;a++){var u=o.get(a,0).valueOf(),l=o.get(a,1).valueOf(),c=VEe(u,l,a,s),p=c.x,d=c.y;i.push(d),i.push(p)}return So(i,[Vl.length,2])}(r,e);return re(le(B(r.toTensor(),we(t,"int32")),"float32"),n)})}function VEe(r,t,e,n){return{y:n.get(r,t,e),x:n.get(r,t,e+Vl.length)}}function UEe(r,t,e){return Kt(this,void 0,void 0,function(){var n,o,s,i,a,u,l,c,p,d;return Xt(this,function(f){switch(f.label){case 0:return n=0,o=z8(r),[4,Promise.all([r.buffer(),t.buffer(),o.buffer()])];case 1:return s=f.sent(),i=s[0],a=s[1],u=s[2],[4,(l=BEe(u,e,a)).buffer()];case 2:return c=f.sent(),p=Array.from(function(h,m){for(var g=m.shape[0],y=new Float32Array(g),x=0;x<g;x++){var w=m.get(x,0),C=m.get(x,1);y[x]=h.get(w,C,x)}return y}(i,u)),d=p.map(function(h,m){return n+=h,{y:c.get(m,0),x:c.get(m,1),score:h,name:Vl[m]}}),o.dispose(),l.dispose(),[2,{keypoints:d,score:n/d.length}]}})})}function GEe(r,t,e){return Kt(this,void 0,void 0,function(){var n,o,s;return Xt(this,function(i){return n=z8(r),o=function(a,u,l){return X(function(){var c=zEe(a,l);return re(le(B(a,we(u,"int32")),"float32"),c)})}(n,e,t),s=PEe(r,n),[2,[o,s]]})})}function h8(r,t){return(r-1)%t==0}var m8="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",g8="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function y8(r,t){return function(e,n){return(e-1)%n==0}(r,t)?r:Math.floor(r/t)*t+1}var x8=function(){function r(t,e){this.posenetModel=t;var n=this.posenetModel.inputs[0].shape;b.assert(n[1]===-1&&n[2]===-1,function(){return"Input shape [".concat(n[1],", ").concat(n[2],"] ")+"must both be equal to or -1"});var o,s,i=(o=e.inputResolution,s=e.outputStride,{height:y8(o.height,s),width:y8(o.width,s)});(function(a){b.assert(EEe.indexOf(a)>=0,function(){return"outputStride of ".concat(a," is invalid. ")+"It must be either 8 or 16."})})(e.outputStride),function(a,u){b.assert(h8(a.height,u),function(){return"height of ".concat(a.height," is invalid for output stride ")+"".concat(u,".")}),b.assert(h8(a.width,u),function(){return"width of ".concat(a.width," is invalid for output stride ")+"".concat(u,".")})}(i,e.outputStride),this.inputResolution=i,this.outputStride=e.outputStride,this.architecture=e.architecture}return r.prototype.estimatePoses=function(t,e){return e===void 0&&(e=u8),Kt(this,void 0,void 0,function(){return Xt(this,function(n){return[2,this.estimatePosesGPU(t,e,!1)]})})},r.prototype.estimatePosesGPU=function(t,e,n){return e===void 0&&(e=u8),n===void 0&&(n=!1),Kt(this,void 0,void 0,function(){var o,s,i,a,u,l,c,p,d,f,h,m,g,y,x,w,C,I;return Xt(this,function(N){switch(N.label){case 0:return o=function(A){var O=A;if(O.maxPoses==null&&(O.maxPoses=1),O.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(O.maxPoses,". Should be > 0."));if(O.maxPoses>1){if((O=Fr(Fr({},kEe),O)).scoreThreshold<0||O.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(O.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(O.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(O.nmsRadius,"."))}return O}(e),t==null?[2,n?[[],[]]:[]]:(this.maxPoses=o.maxPoses,s=VM(t,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),i=s.imageTensor,a=s.padding,u=this.architecture==="ResNet50"?re(i,NEe):k8(i,[-1,1]),l=this.posenetModel.predict(u),this.architecture==="ResNet50"?(c=Rt(l[2],[0]),p=Rt(l[3],[0]),d=Rt(l[0],[0]),f=Rt(l[1],[0])):(c=Rt(l[0],[0]),p=Rt(l[1],[0]),d=Rt(l[2],[0]),f=Rt(l[3],[0])),h=Rn(p),this.maxPoses!==1?[3,5]:n?[4,GEe(h,c,this.outputStride)]:[3,2]);case 1:return g=N.sent(),x=g[0],y=g[1],m=[x,y],[3,4];case 2:return[4,UEe(h,c,this.outputStride)];case 3:x=N.sent(),m=[x],N.label=4;case 4:return[3,7];case 5:if(n)throw new Error("GPU renderer only supports single pose!");return[4,FEe(h,c,d,f,this.outputStride,this.maxPoses,o.scoreThreshold,o.nmsRadius)];case 6:m=N.sent(),N.label=7;case 7:if(n){if(o.flipHorizontal===!0)throw new Error("flipHorizontal is not supported!");w=this.getCanvasInfo(Ry(t),this.inputResolution,a)}else I=Ry(t),C=function(A,O,$,z){var G=O.height,K=O.width,Z=G/($.height*(1-z.top-z.bottom)),Q=K/($.width*(1-z.left-z.right)),J=-z.top*$.height,te=-z.left*$.width;if(Q===1&&Z===1&&J===0&&te===0)return A;for(var ie=0,ne=A;ie<ne.length;ie++)for(var ae=0,ye=ne[ie].keypoints;ae<ye.length;ae++){var ge=ye[ae];ge.x=(ge.x+te)*Q,ge.y=(ge.y+J)*Z}return A}(m,I,this.inputResolution,a),o.flipHorizontal&&(C=function(A,O){for(var $=0,z=A;$<z.length;$++)for(var G=0,K=z[$].keypoints;G<K.length;G++){var Z=K[G];Z.x=O.width-1-Z.x}return A}(C,I));return i.dispose(),u.dispose(),$e(l),c.dispose(),p.dispose(),d.dispose(),f.dispose(),h.dispose(),[2,n?[m,w]:C]}})})},r.prototype.getCanvasInfo=function(t,e,n){var o=t.height,s=t.width,i=o/(e.height*(1-n.top-n.bottom)),a=s/(e.width*(1-n.left-n.right)),u=-n.top*e.height;return[-n.left*e.width,u,a,i,t.width,t.height]},r.prototype.dispose=function(){this.posenetModel.dispose()},r.prototype.reset=function(){},r}();function WEe(r){return r===void 0&&(r=n8),Kt(this,void 0,void 0,function(){var t,e,n,o,s;return Xt(this,function(i){switch(i.label){case 0:return(t=function(c){var p=c||n8;if(p.architecture==null&&(p.architecture="MobileNetV1"),o8.indexOf(p.architecture)<0)throw new Error("Invalid architecture ".concat(p.architecture,". ")+"Should be one of ".concat(o8));if(p.inputResolution==null&&(p.inputResolution={height:257,width:257}),p.outputStride==null&&(p.outputStride=16),s8[p.architecture].indexOf(p.outputStride)<0)throw new Error("Invalid outputStride ".concat(p.outputStride,". ")+"Should be one of ".concat(s8[p.architecture]," ")+"for architecture ".concat(p.architecture,"."));if(p.multiplier==null&&(p.multiplier=1),i8[p.architecture].indexOf(p.multiplier)<0)throw new Error("Invalid multiplier ".concat(p.multiplier,". ")+"Should be one of ".concat(i8[p.architecture]," ")+"for architecture ".concat(p.architecture,"."));if(p.quantBytes==null&&(p.quantBytes=4),a8.indexOf(p.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(p.quantBytes,". ")+"Should be one of ".concat(a8," ")+"for architecture ".concat(p.architecture,"."));if(p.architecture==="MobileNetV1"&&p.outputStride===32&&p.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return p}(r)).architecture!=="ResNet50"?[3,2]:(a=t.outputStride,u=t.quantBytes,l="model-stride".concat(a,".json"),e=u===4?g8+"float/"+l:g8+"quant".concat(u,"/")+l,[4,jd(t.modelUrl||e)]);case 1:return n=i.sent(),[2,new x8(n,t)];case 2:return o=function(c,p,d){var f={1:"100",.75:"075",.5:"050"},h="model-stride".concat(c,".json");return d===4?m8+"float/".concat(f[p],"/")+h:m8+"quant".concat(d,"/").concat(f[p],"/")+h}(t.outputStride,t.multiplier,t.quantBytes),[4,jd(t.modelUrl||o)];case 3:return s=i.sent(),[2,new x8(s,t)]}var a,u,l})})}function B8(r,t){return Kt(this,void 0,void 0,function(){var e,n;return Xt(this,function(o){switch(r){case To.PoseNet:return[2,WEe(t)];case To.BlazePose:if(n=void 0,(e=t)!=null){if(e.runtime==="tfjs")return[2,bEe(t)];if(e.runtime==="mediapipe")return[2,H1e(t)];n=e.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(n));case To.MoveNet:return[2,_Ee(t)];default:throw new Error("".concat(r," is not a supported model name."))}})})}var B_={kernelName:Ou,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>B(r,Ci(le(e,"float32"),-1))}}};var V8={kernelName:Qi,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=at(le(e,"float32")),o=lr(xe(we(1),n));return yt(me(r,o))}}}};var U8={kernelName:Ji,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=lr(xe(at(le(e,"float32")),1));return me(r,n)}}}};var G8={kernelName:js,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=st(e.shape,n.shape);return{a:()=>{let a=r,u=gr(e.shape,o);return u.length>0&&(a=Ie(a,u)),V(a,e.shape)},b:()=>{let a=r,u=gr(n.shape,o);return u.length>0&&(a=Ie(a,u)),V(a,n.shape)}}}};var W8={kernelName:Mu,saveAllInputs:!0,gradFunc:(r,t)=>{let e={};return t.forEach((n,o)=>{e[o]=()=>r.clone()}),e}};var j8={kernelName:Fu,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>je(e)}}};var H8={kernelName:$u,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>je(e)}}};var q8={kernelName:ea,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>me(r,lr(xe(we(1),at(le(e,"float32")))))}}};var K8={kernelName:ta,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=lr(re(we(1),at(le(e,"float32"))));return me(r,n)}}}};var X8={kernelName:oa,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=st(e.shape,n.shape);return{a:()=>{let a=re(at(e),at(n)),u=B(r,me(n,a)),l=gr(e.shape,o);return l.length>0&&(u=Ie(u,l)),V(u,e.shape)},b:()=>{let a=re(at(e),at(n)),u=yt(B(r,me(e,a))),l=gr(n.shape,o);return l.length>0&&(u=Ie(u,l)),V(u,n.shape)}}}};var Y8={kernelName:ra,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>me(r,re(at(le(e,"float32")),1))}}};var Z8={kernelName:na,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>me(r,xe(we(1),at(le(e,"float32"))))}}};function HEe(r,t,e,n,o,s){let i=E(r,"dy","avgPool3dGrad"),a=E(t,"input","avgPool3dGrad"),u=i,l=a,c=!1;a.rank===4&&(c=!0,u=V(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),l=V(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),F(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),F(l.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`),wr("avgPool3dGrad",o,s);let p={dy:u,input:l},d={filterSize:e,strides:n,pad:o,dimRoundingMode:s},f=R.runKernel(Dp,p,d);return c?V(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}var Q8=D({avgPool3dGrad_:HEe});var J8={kernelName:Lu,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:a}=e;return{x:()=>Q8(r,n,o,s,i,a)}}};function qEe(r,t,e,n,o){let s=E(r,"dy","avgPoolGrad"),i=E(t,"input","avgPoolGrad");F(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let a=i,u=s,l=!1;i.rank===3&&(l=!0,a=V(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=V(s,[1,s.shape[0],s.shape[1],s.shape[2]])),F(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),F(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);let c={dy:u,input:a},p={filterSize:e,strides:n,pad:o},d=R.runKernel(Np,c,p);return l?V(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var e5=D({avgPoolGrad_:qEe});var t5={kernelName:Pu,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{filterSize:o,strides:s,pad:i}=e;return{x:()=>e5(r,n,o,s,i)}}};var r5={kernelName:zu,inputsToSave:["a","b"],gradFunc:(r,t,e)=>{let[n,o]=t,{transposeA:s,transposeB:i}=e;return!s&&!i?{a:()=>dt(r,o,!1,!0),b:()=>dt(n,r,!0,!1)}:!s&&i?{a:()=>dt(r,o,!1,!1),b:()=>dt(r,n,!0,!1)}:s&&!i?{a:()=>dt(o,r,!1,!0),b:()=>dt(n,r,!1,!1)}:{a:()=>dt(o,r,!0,!0),b:()=>dt(r,n,!0,!0)}}};var n5={kernelName:Bu,gradFunc:(r,t,e)=>{let{blockShape:n,crops:o}=e;return{x:()=>Pd(r,n,o)}}};var o5={kernelName:oU,gradFunc:(r,t,e)=>{let n=e,o=n.inputShape,s=n.shape,i=Array.from(s);for(let u=o.length-1;u>=0;u--)if(o[u]===s[u])i[u]=1;else if(o[u]!==1)throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${s}].`);let a=[];for(let u=0;u<i.length;u++)i[u]>1&&a.push(u);return{x:()=>Ie(r,a,!0)}}};var s5={kernelName:di,gradFunc:r=>({x:()=>r.clone()})};var i5={kernelName:sa,gradFunc:r=>({x:()=>je(r)})};var a5={kernelName:ia,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{clipValueMin:o,clipValueMax:s}=e;return{x:()=>Cr(ao($o(n,o),ws(n,s)),r,je(r))}}};var u5={kernelName:Vu,inputsToSave:["x"],gradFunc:B_.gradFunc};var l5={kernelName:Uu,saveAllInputs:!0,gradFunc:(r,t,e)=>{let n=t.map(u=>u.shape),{axis:o}=e,s=Cn(o,t[0].shape)[0],i=n.map(u=>u[s]);return Tn(r,i,s).map(u=>()=>u)}};var c5={kernelName:Gu,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let[n,o]=t,{dilations:s,strides:i,pad:a,dataFormat:u}=e;return F(Hs(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>zg(n.shape,r,o,i,a,u),filter:()=>iy(n,r,o.shape,i,a,u)}}};var p5={kernelName:Wu,inputsToSave:["dy","filter"],gradFunc:(r,t,e)=>{let[n,o]=t,{strides:s,pad:i,dataFormat:a,dimRoundingMode:u}=e;return{dy:()=>Jo(r,o,s,i,a,1,u),filter:()=>iy(r,n,o.shape,s,i,a,u)}}};function KEe(r,t,e,n,o){let s=r;r.rank===4&&(s=V(r,[1,r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));let i=t;i.rank===4&&(i=V(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),F(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),F(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),F(e.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),F(s.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${e[3]}.`),F(i.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${e[4]}).`);let a={x:s,dy:i},u={strides:n,pad:o,filterShape:e};return R.runKernel(Fp,a,u)}var d5=D({conv3DBackpropFilter_:KEe});var f5={kernelName:ju,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let{dilations:n,strides:o,pad:s}=e;F(Hs(n),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${n}'`);let[i,a]=t;return{x:()=>OS(i.shape,r,a,o,s),filter:()=>d5(i,r,a.shape,o,s)}}};var h5={kernelName:aa,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>B(yt(Qg(le(e,"float32"))),r)}}};var m5={kernelName:ua,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>B(Jg(le(e,"float32")),r)}}};var g5={kernelName:Hu,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{axis:o,exclusive:s,reverse:i}=e;return{x:()=>{let a=U2([o],n.rank),u=Ug(r,o,s,!i);return a!=null&&(u=ft(u,a)),u}}}};var y5={kernelName:qu,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let{dilations:n,strides:o,pad:s,dimRoundingMode:i}=e,a=n??[1,1];F(Hs(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);let[u,l]=t;return F(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),F(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`),F(u.shape[3]===l.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),F(Jn(o,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${o} and dilations '${a}'.`),wr("depthwiseConv2d",s,i),{x:()=>fI(u.shape,r,l,o,s,a,i),filter:()=>dI(u,r,l.shape,o,s,a,i)}}};var x5={kernelName:Ku,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let[n,o]=t,s={x:n,filter:o,dy:r},i={x:n,filter:o,dy:r};return{x:()=>R.runKernel(Jf,s,e),filter:()=>R.runKernel(eh,i,e)}}};var v5={kernelName:ca,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t,n={dy:r,y:e};return{x:()=>R.runKernel(jp,n)}}};var b5={kernelName:pa,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t,n=B(Rr(yt(at(e))),2/Math.sqrt(Math.PI));return{x:()=>B(r,n)}}};var w5={kernelName:da,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t;return{x:()=>B(r,e)}}};var C5={kernelName:Xu,inputsToSave:["input"],gradFunc:(r,t)=>{let[e]=t;return{input:()=>V(r,e.shape)}}};var S5={kernelName:fa,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>B(r,Rr(e))}}};var I5={kernelName:ha,gradFunc:r=>({x:()=>je(r)})};var T5={kernelName:ma,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=st(e.shape,n.shape);return{a:()=>{let a=me(r,le(n,"float32")),u=gr(e.shape,o);return u.length>0?V(Ie(a,u),e.shape):a},b:()=>{let a=B(r,le(e,"float32")),u=gr(n.shape,o);u.length>0&&(a=V(Ie(a,u),n.shape));let l=at(n);return yt(me(a,le(l,"float32")))}}}};var _5={kernelName:Yu,inputsToSave:["x","mean","variance","scale"],gradFunc:(r,t,e)=>{let{varianceEpsilon:n}=e,[o,s,i,a]=t,u=a??we(1),l=gr(s.shape,o.shape),c=[];if(s.rank===1){for(let C=0;C<o.shape.length-1;++C)c.push(o.shape[C]);c.push(1)}let p=xe(o,s),d=B(r,u),f=Xg(re(i,we(n))),h=B(B(B(f,f),f),we(-.5));return{x:()=>s.rank===1?V(B(B(r,eo(V(f,[1,1,1,s.shape[0]]),c)),u),o.shape):V(B(B(r,f),u),o.shape),mean:()=>{let C=B(B(f,we(-1)),d);return s.rank===1&&(C=Ie(C,l)),V(C,s.shape)},variance:()=>{let C=B(B(h,p),d);return s.rank===1&&(C=Ie(C,l)),V(C,s.shape)},scale:()=>{let C=B(p,f),I=B(r,C);return s.rank===1&&(I=Ie(I,l)),V(I,s.shape)},offset:()=>{let C=r;return s.rank===1&&(C=Ie(C,l)),V(C,s.shape)}}}};var N5={kernelName:Zu,inputsToSave:["x","indices"],gradFunc:(r,t,e)=>{let[n,o]=t,{axis:s,batchDims:i}=e,a=Cn(s,n.shape)[0],u=(l,c,p)=>()=>{let d=l.shape,f=c.size,h=d.slice(0,a),m=h.length,g=d.slice(s,d.length).slice(1),y=g.length,x=E5(0,m),w=E5(m+1,m+1+y),C=k5([h,[f],g]),I=V(p,C),N=V(c,[f]),A=k5([[m],x,w]),O=ft(I,A),$=sy(O,N,l.shape[a]),z=Qv(A);return $=ft($,z),$};if(i===1){let l=n.shape[0],c=n.split(l,0);return{x:()=>Wr(c.map((f,h)=>u(f,o.slice(h,1),r.slice(h,1))())).reshape(n.shape),indices:()=>o}}else return{x:u(n,o,r),indices:()=>o}}};function E5(r,t){let e=[];for(let n=r;n<t;++n)e.push(n);return e}function k5(r){let t=[];for(let e=0;e<r.length;++e)for(let n=0;n<r[e].length;++n)t.push(r[e][n]);return t}var D5={kernelName:ga,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t;return{a:()=>je(e),b:()=>je(n)}}};var A5={kernelName:fi,gradFunc:r=>({x:()=>le(r,"float32")})};var R5={kernelName:ya,gradFunc:r=>({x:()=>je(r)})};var O5={kernelName:xa,gradFunc:r=>({x:()=>je(r)})};var M5={kernelName:va,gradFunc:r=>({x:()=>je(r)})};var F5={kernelName:Qu,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{alpha:o}=e,s=Gr(n,0);return{x:()=>Cr(s,r,B(r,o))}}};var $5={kernelName:wa,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>me(r,re(e,1))}}};var P5={kernelName:ba,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>me(r,le(e,"float32"))}}};var L5={kernelName:sU,inputsToSave:[],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n]=t,{axis:o}=e;return{logits:()=>{let i=Rr(n);return xe(r,B(Ie(r,o,!0),i))}}}};function XEe(r,t,e,n=5,o=1,s=1,i=.5){let a={x:r,y:t,dy:e},u={depthRadius:n,bias:o,alpha:s,beta:i};return R.runKernel(Jp,a,u)}var z5=D({localResponseNormalizationBackprop_:XEe});var B5={kernelName:Ju,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n,o]=t,{depthRadius:s,bias:i,alpha:a,beta:u}=e;return{x:()=>z5(n,o,r,s,i,a,u)}}};function V_(r,t,e,n){return t.rank<e.rank&&(t=V(t,wi(t.shape,n))),r.rank<e.rank&&(r=V(r,wi(r.shape,n))),{x:()=>B(r,le(Co(e,t),r.dtype))}}var jM={kernelName:el,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let n=e,{reductionIndices:o}=n,s=t[0],i=t[1],a=Cn(o,s.shape),u=V_(r,i,s,a);return{x:()=>u.x()}}};var V5={kernelName:Ca,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t;return{a:()=>B(r,le($o(e,n),"float32")),b:()=>B(r,le(Ac(e,n),"float32"))}}};function YEe(r,t,e,n,o,s,i){let a=E(r,"dy","maxPool3dGrad"),u=E(t,"input","maxPool3dGrad"),l=E(e,"output","maxPool3dGrad"),c=a,p=u,d=l,f=!1;u.rank===4&&(f=!0,c=V(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),p=V(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),d=V(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),F(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),F(p.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),F(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),wr("maxPool3dGrad",s,i);let h={dy:c,input:p,output:d},m={filterSize:n,strides:o,pad:s,dimRoundingMode:i},g=R.runKernel(td,h,m);return f?V(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var U5=D({maxPool3dGrad_:YEe});var G5={kernelName:rl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n,o]=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=e;return{x:()=>U5(r,n,o,s,i,a,u)}}};function ZEe(r,t,e,n,o,s,i){let a=E(r,"dy","maxPoolGrad"),u=E(t,"input","maxPoolGrad"),l=E(e,"output","maxPoolGrad");F(u.rank===a.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${a.rank})`),F(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),F(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),wr("maxPoolGrad",s,i);let c={dy:a,input:u,output:l},p={filterSize:n,strides:o,pad:s,dimRoundingMode:i};return R.runKernel(ed,c,p)}var W5=D({maxPoolGrad_:ZEe});var j5={kernelName:tl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n,o]=t,{filterSize:s,strides:i,pad:a}=e;return{x:()=>W5(r,n,o,s,i,a)}}};var H5={kernelName:nl,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{axis:o}=e,s=Cn(o,n.shape),a=V2(n.shape,s)[1],u=bt(a);return{x:()=>{let c=n.shape.slice();s.forEach(f=>{c[f]=1});let p=V(r,c);return me(B(p,hn(n.shape,"float32")),u)}}}};var q5={kernelName:ol,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let n=e,{axis:o}=n,[s,i]=t,a=Cn(o,s.shape),u=V_(r,i,s,a);return{x:()=>u.x()}}};var K5={kernelName:Sa,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t;return{a:()=>B(r,le(ws(e,n),"float32")),b:()=>B(r,le(Gr(e,n),"float32"))}}};var X5={kernelName:sl,inputsToSave:["x"],gradFunc:(r,t,e)=>{let n=t[0],{paddings:o}=e,s=o.map(i=>i[0]);return{x:()=>Ue(r,s,n.shape)}}};var Y5={kernelName:Ia,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=st(e.shape,n.shape);return{a:()=>{let a=gr(e.shape,o);return a.length>0?V(Ie(r,a),e.shape):r},b:()=>{let a=B(r,yt(Fl(me(e,n)))),u=gr(n.shape,o);return u.length>0?V(Ie(a,u),n.shape):a}}}};var Z5={kernelName:Ta,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=st(e.shape,n.shape);return{a:()=>{let a=B(r,le(n,"float32")),u=gr(e.shape,o);return u.length>0?V(Ie(a,u),e.shape):a},b:()=>{let a=B(r,le(e,"float32")),u=gr(n.shape,o);return u.length>0?V(Ie(a,u),n.shape):a}}}};var Q5={kernelName:il,gradFunc:r=>({x:()=>yt(r)})};var J5={kernelName:ul,inputsToSave:["indices"],gradFunc:(r,t)=>{let e=t[0];return{indices:()=>er(e.shape,"float32")}}};var eX={kernelName:al,gradFunc:r=>({x:()=>je(r)})};var tX={kernelName:ll,saveAllInputs:!0,gradFunc:(r,t,e)=>{let{axis:n}=e;return _n(r,n).map(s=>()=>s)}};var HM={kernelName:cl,inputsToSave:["x"],gradFunc:(r,t,e)=>{let n=t[0],{paddings:o}=e,s=o.map(i=>i[0]);return{x:()=>Ue(r,s,n.shape)}}};var rX={kernelName:_a,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(r,t)=>{let[e,n,o]=t,s=e,i=n,a=st(s.shape,i.shape);return{a:()=>{let c=le(i,"float32"),p=B(r,B(c,io(s,xe(c,we(1))))),d=gr(s.shape,a);return d.length>0&&(p=Ie(p,d)),V(p,s.shape)},b:()=>{let c=Gr(s,0),p=Cr(c,Bn(s),je(s)),d=B(r,B(o,p)),f=gr(i.shape,a);return f.length>0&&(d=Ie(d,f)),V(d,i.shape)}}}};var nX={kernelName:pl,inputsToSave:["x","alpha"],gradFunc:(r,t)=>{let[e,n]=t,o=Gr(e,0);return{x:()=>Cr(o,r,B(r,n)),alpha:()=>{let s=Cr(o,je(r),B(r,e)),i=gr(n.shape,r.shape);return i.length>0&&(s=Ie(s,i)),V(s,n.shape)}}}};function QEe(r,t,e){let n=r.shape.slice();n[e]=1;let o=V(t,n),s=gh(r,e,!0,!1),i=gh(r,e,!0,!0),a=B(s,i);return B(o,a)}function JEe(r,t,e){let n=r.shape.length,o=n-e.length,s=T.getAxesPermutation(e,n),i=r;s!=null&&(i=ft(r,s));let a=i.shape.slice(),l=a.splice(n-e.length,e.length).reduce((d,f)=>d*f,1);a.push(l);let c=i.reshape(a),p=QEe(c,t,o);if(p=p.reshape(i.shape),s!=null){let d=T.getUndoAxesPermutation(s);p=ft(p,d)}return p}var oX={kernelName:dl,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{axis:o}=e,s=[];return o==null?s=n.shape.map((i,a)=>a):typeof o=="number"?s=[o]:s=o,{x:()=>JEe(n,r,s)}}};var sX={kernelName:la,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=st(e.shape,n.shape);return{a:()=>{let a=me(r,le(n,"float32")),u=gr(e.shape,o);return u.length>0?V(Ie(a,u),e.shape):a},b:()=>{let a=B(r,le(e,"float32")),u=gr(n.shape,o);u.length>0&&(a=V(Ie(a,u),n.shape));let l=at(n);return yt(me(a,le(l,"float32")))}}}};var iX={kernelName:Ea,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>me(r,yt(at(e)))}}};var aX={kernelName:Na,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t,n=B(ws(e,6),Ci(e));return{x:()=>B(r,le(n,"float32"))}}};var uX={kernelName:ka,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>B(r,le(Ci(e),"float32"))}}};var lX={kernelName:fl,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>V(r,e.shape)}}};var cX={kernelName:ml,inputsToSave:["images"],gradFunc:(r,t,e)=>{let[n]=t,o={dy:r,images:n};return{images:()=>R.runKernel(ld,o,e)}}};var pX={kernelName:hl,inputsToSave:["images"],gradFunc:(r,t,e)=>{let[n]=t,o={dy:r,images:n};return{images:()=>R.runKernel(ud,o,e)}}};var dX={kernelName:gl,gradFunc:(r,t,e)=>{let{dims:n}=e,o=Cn(n,r.shape);return{x:()=>In(r,o)}}};var fX={kernelName:Da,gradFunc:r=>({x:()=>je(r)})};var hX={kernelName:Aa,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>yt(me(r,B(io(e,1.5),2)))}}};var mX={kernelName:yl,inputsToSave:["condition"],gradFunc:(r,t)=>{let[e]=t;return{condition:()=>le(je(e),"float32"),t:()=>B(r,le(e,r.dtype)),e:()=>B(r,le(Fd(e),r.dtype))}}};var gX={kernelName:Ra,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=Gr(e,we(0)),o=we(dO),s=we(fO),i=B(r,s),a=B(B(r,o),Rr(le(e,"float32")));return Cr(n,i,a)}}}};var yX={kernelName:$a,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t;return{x:()=>B(r,B(e,xe(we(1),e)))}}};var xX={kernelName:Fa,gradFunc:r=>({x:()=>je(r)})};var vX={kernelName:Oa,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>B(Nd(le(e,"float32")),r)}}};var bX={kernelName:Ma,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>B(Vg(le(e,"float32")),r)}}};var wX={kernelName:xl,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{begin:o,size:s}=e,i=n.shape,[a,u]=pO(n,o,s),l=[];for(let c=0;c<r.rank;c++)l.push([a[c],i[c]-a[c]-u[c]]);return{x:()=>Vn(r,l)}}};var CX={kernelName:Cl,outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n]=t,{dim:o}=e,s=!0,i=B(r,n);return{logits:()=>xe(i,B(Ie(i,[o],s),n))}}};var SX={kernelName:Pa,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>B(r,Rn(e))}}};var qM={kernelName:bl,gradFunc:(r,t,e)=>{let{blockShape:n,paddings:o}=e;return{x:()=>kd(r,n,o)}}};var KM={kernelName:wl,gradFunc:(r,t,e)=>{let{axis:n}=e;return{x:()=>Dt(r,n)}}};var IX={kernelName:La,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>me(r,B(lr(le(e,"float32")),2))}}};var TX={kernelName:gd,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>B(r,B(le(e,"float32"),2))}}};var _X={kernelName:za,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=we(2);return{a:()=>B(r,B(o,xe(e,n))),b:()=>B(r,B(o,xe(n,e)))}}};var EX={kernelName:Ga,gradFunc:r=>({x:()=>je(r)})};var kX={kernelName:Ba,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=st(e.shape,n.shape);return{a:()=>{let a=r,u=gr(e.shape,o);return u.length>0&&(a=Ie(a,u)),V(a,e.shape)},b:()=>{let a=r,u=gr(n.shape,o);return u.length>0&&(a=Ie(a,u)),V(yt(a),n.shape)}}}};var NX={kernelName:vl,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,o=n.shape.slice(),{axis:s}=e;Cn(s,n.shape).forEach(l=>{o[l]=1});let a=V(r,o),u=B(a,hn(n.shape,"float32"));return{x:()=>u}}};var DX={kernelName:Va,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>me(r,at(Nd(e)))}}};var AX={kernelName:Ua,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t;return{x:()=>B(xe(we(1),at(e)),r)}}};var RX={kernelName:hi,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{reps:o}=e;return{x:()=>{let i=je(n);if(n.rank===1)for(let a=0;a<o[0];++a)i=re(i,Ue(r,[a*n.shape[0]],[n.shape[0]]));else if(n.rank===2)for(let a=0;a<o[0];++a)for(let u=0;u<o[1];++u)i=re(i,Ue(r,[a*n.shape[0],u*n.shape[1]],[n.shape[0],n.shape[1]]));else if(n.rank===3)for(let a=0;a<o[0];++a)for(let u=0;u<o[1];++u)for(let l=0;l<o[2];++l)i=re(i,Ue(r,[a*n.shape[0],u*n.shape[1],l*n.shape[2]],[n.shape[0],n.shape[1],n.shape[2]]));else if(n.rank===4)for(let a=0;a<o[0];++a)for(let u=0;u<o[1];++u)for(let l=0;l<o[2];++l)for(let c=0;c<o[3];++c)i=re(i,Ue(r,[a*n.shape[0],u*n.shape[1],l*n.shape[2],c*n.shape[3]],[n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${n.rank} tensors yet.`);return i}}}};var OX={kernelName:mi,gradFunc:(r,t,e)=>{let n=e,{perm:o}=n,s=Qv(o);return{x:()=>ft(r,s)}}};var MX={kernelName:Sl,gradFunc:(r,t,e)=>{let n=e,{axis:o}=n;return{value:()=>Wr(r,o)}}};var FX={kernelName:Il,inputsToSave:["segmentIds"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>eke(r,e)}}};function eke(r,t){let e=ts(t,je(t)),n=$l(r,e),o=$o(t,we(0,"int32")),s=n.rank-o.rank;for(let a=0;a<s;++a)o=Sr(o,a+1);o=ao(o,hn(n.shape,"bool"));let i=je(n);return Cr(o,n,i)}var $X={kernelName:Tl,gradFunc:r=>({x:()=>je(r)})};var tke=[B_,V8,U8,G8,W8,j8,H8,q8,K8,X8,Y8,Z8,J8,t5,r5,n5,o5,s5,i5,a5,u5,l5,p5,c5,f5,h5,m5,g5,y5,x5,sX,v5,b5,w5,C5,S5,T5,I5,_5,N5,D5,A5,R5,O5,M5,F5,$5,P5,L5,B5,jM,jM,V5,G5,j5,H5,q5,K5,X5,Y5,Z5,Q5,J5,eX,tX,HM,HM,rX,nX,oX,iX,aX,uX,lX,cX,pX,dX,fX,hX,mX,gX,yX,xX,vX,bX,wX,CX,SX,qM,qM,KM,KM,IX,_X,TX,EX,kX,NX,DX,AX,RX,OX,MX,FX,$X];for(let r of tke)aU(r);U().prototype.abs=function(){return this.throwIfDisposed(),Nr(this)};U().prototype.acos=function(){return this.throwIfDisposed(),hS(this)};U().prototype.acosh=function(){return this.throwIfDisposed(),mS(this)};U().prototype.add=function(r){return this.throwIfDisposed(),re(this,r)};U().prototype.all=function(r,t){return this.throwIfDisposed(),$g(this,r,t)};U().prototype.any=function(r,t){return this.throwIfDisposed(),hh(this,r,t)};U().prototype.argMax=function(r){return this.throwIfDisposed(),vi(this,r)};U().prototype.argMin=function(r){return this.throwIfDisposed(),gS(this,r)};U().prototype.asScalar=function(){return this.throwIfDisposed(),F(this.size===1,()=>"The array must have only 1 element."),V(this,[])};U().prototype.asType=function(r){return this.throwIfDisposed(),le(this,r)};U().prototype.as1D=function(){return this.throwIfDisposed(),V(this,[this.size])};U().prototype.as2D=function(r,t){return this.throwIfDisposed(),V(this,[r,t])};U().prototype.as3D=function(r,t,e){return this.throwIfDisposed(),V(this,[r,t,e])};U().prototype.as4D=function(r,t,e,n){return this.throwIfDisposed(),V(this,[r,t,e,n])};U().prototype.as5D=function(r,t,e,n,o){return this.throwIfDisposed(),V(this,[r,t,e,n,o])};U().prototype.asin=function(){return this.throwIfDisposed(),yS(this)};U().prototype.asinh=function(){return this.throwIfDisposed(),xS(this)};U().prototype.atan=function(){return this.throwIfDisposed(),vS(this)};U().prototype.atan2=function(r){return this.throwIfDisposed(),bS(this,r)};U().prototype.atanh=function(){return this.throwIfDisposed(),wS(this)};U().prototype.avgPool=function(r,t,e,n){return this.throwIfDisposed(),Ed(this,r,t,e,n)};U().prototype.batchToSpaceND=function(r,t){return this.throwIfDisposed(),kd(this,r,t)};U().prototype.batchNorm=function(r,t,e,n,o){return this.throwIfDisposed(),Al(this,r,t,e,n,o)};U().prototype.broadcastTo=function(r){return this.throwIfDisposed(),Rl(this,r)};U().prototype.cast=function(r){return this.throwIfDisposed(),le(this,r)};U().prototype.ceil=function(){return this.throwIfDisposed(),ES(this)};U().prototype.clipByValue=function(r,t){return this.throwIfDisposed(),Sn(this,r,t)};U().prototype.concat=function(r,t){return this.throwIfDisposed(),r instanceof ct&&(r=[r]),Dt([this,...r],t)};U().prototype.conv1d=function(r,t,e,n,o,s){return this.throwIfDisposed(),Lg(this,r,t,e,n,o,s)};U().prototype.conv2dTranspose=function(r,t,e,n,o){return this.throwIfDisposed(),Bg(this,r,t,e,n,o)};U().prototype.conv2d=function(r,t,e,n,o,s){return this.throwIfDisposed(),Jo(this,r,t,e,n,o,s)};U().prototype.cos=function(){return this.throwIfDisposed(),Nd(this)};U().prototype.cosh=function(){return this.throwIfDisposed(),Vg(this)};U().prototype.cumprod=function(r,t,e){return this.throwIfDisposed(),gh(this,r,t,e)};U().prototype.cumsum=function(r,t,e){return this.throwIfDisposed(),Ug(this,r,t,e)};U().prototype.depthToSpace=function(r,t){return this.throwIfDisposed(),FS(this,r,t)};U().prototype.depthwiseConv2d=function(r,t,e,n,o,s){return this.throwIfDisposed(),Ol(this,r,t,e,n,o,s)};U().prototype.dilation2d=function(r,t,e,n,o){return this.throwIfDisposed(),$S(this,r,t,e,n,o)};U().prototype.divNoNan=function(r){return this.throwIfDisposed(),PS(this,r)};U().prototype.div=function(r){return this.throwIfDisposed(),me(this,r)};U().prototype.dot=function(r){return this.throwIfDisposed(),LS(this,r)};U().prototype.elu=function(){return this.throwIfDisposed(),Ml(this)};U().prototype.equal=function(r){return this.throwIfDisposed(),Co(this,r)};U().prototype.erf=function(){return this.throwIfDisposed(),Gg(this)};U().prototype.euclideanNorm=function(r,t){return this.throwIfDisposed(),zS(this,r,t)};U().prototype.exp=function(){return this.throwIfDisposed(),Rr(this)};U().prototype.expandDims=function(r){return this.throwIfDisposed(),Sr(this,r)};U().prototype.expm1=function(){return this.throwIfDisposed(),BS(this)};U().prototype.fft=function(){return this.throwIfDisposed(),Bd(this)};U().prototype.flatten=function(){return this.throwIfDisposed(),V(this,[this.size])};U().prototype.floor=function(){return this.throwIfDisposed(),Fl(this)};U().prototype.floorDiv=function(r){return this.throwIfDisposed(),Fg(this,r)};U().prototype.gather=function(r,t,e){return this.throwIfDisposed(),$l(this,r,t,e)};U().prototype.greaterEqual=function(r){return this.throwIfDisposed(),$o(this,r)};U().prototype.greater=function(r){return this.throwIfDisposed(),Gr(this,r)};U().prototype.ifft=function(){return this.throwIfDisposed(),Oc(this)};U().prototype.irfft=function(){return this.throwIfDisposed(),ry(this)};U().prototype.isFinite=function(){return this.throwIfDisposed(),VS(this)};U().prototype.isInf=function(){return this.throwIfDisposed(),US(this)};U().prototype.isNaN=function(){return this.throwIfDisposed(),GS(this)};U().prototype.leakyRelu=function(r){return this.throwIfDisposed(),Rd(this,r)};U().prototype.lessEqual=function(r){return this.throwIfDisposed(),ws(this,r)};U().prototype.less=function(r){return this.throwIfDisposed(),Ac(this,r)};U().prototype.localResponseNormalization=function(r,t,e,n){return this.throwIfDisposed(),WS(this,r,t,e,n)};U().prototype.logSigmoid=function(){return this.throwIfDisposed(),jS(this)};U().prototype.logSoftmax=function(r){return this.throwIfDisposed(),Wg(this,r)};U().prototype.logSumExp=function(r,t){return this.throwIfDisposed(),Md(this,r,t)};U().prototype.log=function(){return this.throwIfDisposed(),Bn(this)};U().prototype.log1p=function(){return this.throwIfDisposed(),Od(this)};U().prototype.logicalAnd=function(r){return this.throwIfDisposed(),ao(this,r)};U().prototype.logicalNot=function(){return this.throwIfDisposed(),Fd(this)};U().prototype.logicalOr=function(r){return this.throwIfDisposed(),jg(this,r)};U().prototype.logicalXor=function(r){return this.throwIfDisposed(),HS(this,r)};U().prototype.matMul=function(r,t,e){return this.throwIfDisposed(),dt(this,r,t,e)};U().prototype.maxPool=function(r,t,e,n){return this.throwIfDisposed(),$d(this,r,t,e,n)};U().prototype.max=function(r,t){return this.throwIfDisposed(),zn(this,r,t)};U().prototype.maximum=function(r){return this.throwIfDisposed(),ts(this,r)};U().prototype.mean=function(r,t){return this.throwIfDisposed(),Ir(this,r,t)};U().prototype.min=function(r,t){return this.throwIfDisposed(),Nc(this,r,t)};U().prototype.minimum=function(r){return this.throwIfDisposed(),rs(this,r)};U().prototype.mirrorPad=function(r,t){return this.throwIfDisposed(),Hg(this,r,t)};U().prototype.mod=function(r){return this.throwIfDisposed(),XS(this,r)};U().prototype.mul=function(r){return this.throwIfDisposed(),B(this,r)};U().prototype.neg=function(){return this.throwIfDisposed(),yt(this)};U().prototype.norm=function(r,t,e){return this.throwIfDisposed(),Dc(this,r,t,e)};U().prototype.notEqual=function(r){return this.throwIfDisposed(),Xa(this,r)};U().prototype.oneHot=function(r,t=1,e=0){return this.throwIfDisposed(),vh(this,r,t,e)};U().prototype.onesLike=function(){return this.throwIfDisposed(),On(this)};U().prototype.pad=function(r,t){return this.throwIfDisposed(),Vn(this,r,t)};U().prototype.pool=function(r,t,e,n,o,s){return this.throwIfDisposed(),YS(this,r,t,e,n,o,s)};U().prototype.pow=function(r){return this.throwIfDisposed(),io(this,r)};U().prototype.prelu=function(r){return this.throwIfDisposed(),Ld(this,r)};U().prototype.prod=function(r,t){return this.throwIfDisposed(),ZS(this,r,t)};U().prototype.reciprocal=function(){return this.throwIfDisposed(),rI(this)};U().prototype.relu=function(){return this.throwIfDisposed(),to(this)};U().prototype.relu6=function(){return this.throwIfDisposed(),qg(this)};U().prototype.reshapeAs=function(r){return this.throwIfDisposed(),V(this,r.shape)};U().prototype.reshape=function(r){return this.throwIfDisposed(),V(this,r)};U().prototype.resizeBilinear=function(r,t,e){return this.throwIfDisposed(),vI(this,r,t,e)};U().prototype.resizeNearestNeighbor=function(r,t,e){return this.throwIfDisposed(),bI(this,r,t,e)};U().prototype.reverse=function(r){return this.throwIfDisposed(),In(this,r)};U().prototype.rfft=function(){return this.throwIfDisposed(),Vd(this)};U().prototype.round=function(){return this.throwIfDisposed(),Kg(this)};U().prototype.rsqrt=function(){return this.throwIfDisposed(),Xg(this)};U().prototype.selu=function(){return this.throwIfDisposed(),Yg(this)};U().prototype.separableConv2d=function(r,t,e,n,o,s){return this.throwIfDisposed(),Zg(this,r,t,e,n,o,s)};U().prototype.sigmoid=function(){return this.throwIfDisposed(),Rn(this)};U().prototype.sign=function(){return this.throwIfDisposed(),nI(this)};U().prototype.sin=function(){return this.throwIfDisposed(),Qg(this)};U().prototype.sinh=function(){return this.throwIfDisposed(),Jg(this)};U().prototype.slice=function(r,t){return this.throwIfDisposed(),Ue(this,r,t)};U().prototype.softmax=function(r){return this.throwIfDisposed(),zd(this,r)};U().prototype.softplus=function(){return this.throwIfDisposed(),Ka(this)};U().prototype.spaceToBatchND=function(r,t){return this.throwIfDisposed(),Pd(this,r,t)};U().prototype.split=function(r,t){return this.throwIfDisposed(),Tn(this,r,t)};U().prototype.sqrt=function(){return this.throwIfDisposed(),lr(this)};U().prototype.square=function(){return this.throwIfDisposed(),at(this)};U().prototype.squaredDifference=function(r){return this.throwIfDisposed(),ny(this,r)};U().prototype.squeeze=function(r){return this.throwIfDisposed(),Rt(this,r)};U().prototype.stack=function(r,t){this.throwIfDisposed();let e=r instanceof ct?[this,r]:[this,...r];return Wr(e,t)};U().prototype.step=function(r){return this.throwIfDisposed(),Ci(this,r)};U().prototype.stridedSlice=function(r,t,e,n,o,s,i,a){return this.throwIfDisposed(),oI(this,r,t,e,n,o,s,i,a)};U().prototype.sub=function(r){return this.throwIfDisposed(),xe(this,r)};U().prototype.sum=function(r,t){return this.throwIfDisposed(),Ie(this,r,t)};U().prototype.tan=function(){return this.throwIfDisposed(),sI(this)};U().prototype.tanh=function(){return this.throwIfDisposed(),qa(this)};U().prototype.tile=function(r){return this.throwIfDisposed(),eo(this,r)};U().prototype.toBool=function(){return this.throwIfDisposed(),le(this,"bool")};U().prototype.toFloat=function(){return this.throwIfDisposed(),le(this,"float32")};U().prototype.toInt=function(){return this.throwIfDisposed(),le(this,"int32")};U().prototype.topk=function(r,t){return this.throwIfDisposed(),aI(this,r,t)};U().prototype.transpose=function(r){return this.throwIfDisposed(),ft(this,r)};U().prototype.unique=function(r){return this.throwIfDisposed(),uI(this,r)};U().prototype.unsortedSegmentSum=function(r,t){return this.throwIfDisposed(),sy(this,r,t)};U().prototype.unstack=function(r){return this.throwIfDisposed(),_n(this,r)};U().prototype.where=function(r,t){return this.throwIfDisposed(),Cr(r,this,t)};U().prototype.zerosLike=function(){return this.throwIfDisposed(),je(this)};var Ys=class r extends Error{constructor(t){super(t),Object.setPrototypeOf(this,r.prototype)}},zo=class r extends Error{constructor(t){super(t),Object.setPrototypeOf(this,r.prototype)}},Y=class r extends Error{constructor(t){super(t),Object.setPrototypeOf(this,r.prototype)}},Xe=class r extends Error{constructor(t){super(t),Object.setPrototypeOf(this,r.prototype)}},U_=class r extends Error{constructor(t){super(t),Object.setPrototypeOf(this,r.prototype)}};var kb=class{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=t}};function Di(r,t){if(Array.isArray(r)){let e=[];for(let n=0;n<t;n++)e=e.concat(r);return e}else{let e=new Array(t);return e.fill(r),e}}function Zs(r,t){if(!r)throw new U_(t)}function YM(r,t){let e=0;for(let n of r)n===t&&e++;return e}function Gn(r){return r.length===1?r[0]:r}function Yt(r){return Array.isArray(r)?r:[r]}function Ai(r){let e=r.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function zc(r){return r.length<=1||r.indexOf("_")===-1?r:r.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}var Ni={};function Oy(r){if(r==null)return null;let t={};return t.className=r.getClassName(),t.config=r.getConfig(),t}function XM(r){if(!(r==null||typeof r!="object"))if(Array.isArray(r))r.forEach(t=>XM(t));else{let t=Object.keys(r);for(let e of t){let n=r[e];n!=null&&typeof n=="object"&&(!Array.isArray(n)&&n.type==="ndarray"&&typeof n.value=="number"?r[e]=n.value:XM(n))}}}function Ul(r,t={},e={},n="object",o=!1){if(typeof r=="string"){let s=r,i;if(s in e)i=e[s];else if(s in Ni)i=Ni[s];else if(i=t[s],i==null)throw new Y(`Unknown ${n}: ${r}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let s=r;if(s.className==null||s.config==null)throw new Y(`${n}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let i=s.className,a,u;if(i in e?[a,u]=e[i]:i in Ni?[a,u]=Ni.className:i in t&&([a,u]=t[i]),a==null)throw new Y(`Unknown ${n}: ${i}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){let l={};for(let f of Object.keys(Ni))l[f]=Ni[f];for(let f of Object.keys(e))l[f]=e[f];let c=s.config;c.customObjects=l;let p=Object.assign({},Ni);for(let f of Object.keys(e))Ni[f]=e[f];XM(s.config);let d=u(a,s.config,e,o);return Ni=Object.assign({},p),d}else{let l=Object.assign({},Ni);for(let p of Object.keys(e))Ni[p]=e[p];let c=new a(s.config);return Ni=Object.assign({},l),c}}}function rke(r,t){return r<t?-1:r>t?1:0}function Nb(r,t){return-1*rke(r,t)}function Ri(r){if(r==null)return r;let t=[];for(let e of r)t.indexOf(e)===-1&&t.push(e);return t}function PX(r){if(r==null)throw new Y(`Invalid value in obj: ${JSON.stringify(r)}`);for(let t in r)if(r.hasOwnProperty(t))return!1;return!0}function Gl(r,t,e){if(e!=null&&r.indexOf(e)<0)throw new Y(`${e} is not a valid ${t}.  Valid values are ${r} or null/undefined.`)}function G_(r,t,e=0,n=1/0){return Zs(e>=0),Zs(n>=e),Array.isArray(r)&&r.length>=e&&r.length<=n&&r.every(o=>typeof o===t)}function an(r,t){Array.isArray(r)?(b.assert(r.length>0,()=>`${t} is unexpectedly an empty array.`),r.forEach((e,n)=>an(e,`element ${n+1} of ${t}`))):b.assert(Number.isInteger(r)&&r>0,()=>`Expected ${t} to be a positive integer, but got ${LX(r)}.`)}function LX(r){return r===null?"null":Array.isArray(r)?"["+r.map(t=>LX(t)).join(",")+"]":typeof r=="string"?`"${r}"`:`${r}`}function zX(r,t,e){let n=e!=null?e():b.now(),o;return(...i)=>{let a=e!=null?e():b.now();return a-n<t||(n=a,o=r(...i)),o}}function W_(r){return r==="relu"?"relu":r==="linear"?"linear":r==="elu"?"elu":null}var nke=0;function H_(){return nke++}var j_={};function Zd(r=""){return r in j_||(j_[r]=0),j_[r]+=1,r+j_[r].toString()}var BX=["channelsFirst","channelsLast"],VX=["nearest","bilinear"],UX=["valid","same","causal"],GX=["max","avg"],WX=["sum","mul","concat","ave"];var My=new Map;function $r(r){Gl(BX,"DataFormat",r)}function HX(r){Gl(VX,"InterpolationFormat",r)}function Bo(r){Gl(UX,"PaddingMode",r)}function ZM(r){Gl(GX,"PoolMode",r)}var Db=[],jX="/";function nu(r,t){Db.push(r);try{let e=t();return Db.pop(),e}catch(e){throw Db.pop(),e}}function oke(){return Db.length===0?"":Db.join(jX)+jX}function q_(r){if(!qX(r))throw new Error("Not a valid tensor name: '"+r+"'");return oke()+r}function K_(r){if(!qX(r))throw new Error("Not a valid tensor name: '"+r+"'");My.has(r)||My.set(r,0);let t=My.get(r);if(My.set(r,My.get(r)+1),t>0){let e=`${r}_${t}`;return My.set(e,1),e}else return r}var ske=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function qX(r){return!!r.match(ske)}function KX(r){return r===parseInt(r.toString(),10)}function Oi(r,t,e){t==null&&(t=0),e==null&&(e=r.length);let n=1;for(let o=t;o<e;++o)n*=r[o];return n}function Lh(r){if(r.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<r.length;e++){let n=r[e];n<t&&(t=n)}return t}function ou(r){if(r.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<r.length;e++){let n=r[e];n>t&&(t=n)}return t}function Vo(r,t){if(t<r)throw new Y(`end (${t}) < begin (${r}) is forbidden.`);let e=[];for(let n=r;n<t;++n)e.push(n);return e}var QM;function vn(){return QM==null&&(QM=kl().epsilon()),QM}function Uo(){return"channelsLast"}function _o(r,t){return le(r,t)}function Vc(r,t=-1){let e=r.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),V(r,e)}function XX(r,t){return X(()=>{if(r.shape.length!==2)throw new Y(`repeat() expects a rank-2 tensor, but received a rank-${r.shape.length} tensor.`);let e=Vc(r,1);return Y_(e,[1,t,1])})}function YX(r){let t=[Oi(r.shape)];return V(r,t)}function ZX(r){if(r.rank<=1)throw new Y(`batchFlatten requires a minimum rank of 2. Got rank: ${r.rank}.`);let t=[r.shape[0],Oi(r.shape,1)];return V(r,t)}function Bc(r,t,e){return X(()=>{switch(r.rank){case 1:return ey(r,t,e);case 2:return tb(r,[t,0],[e,r.shape[1]]);case 3:return ty(r,[t,0,0],[e,r.shape[1],r.shape[2]]);case 4:return Sh(r,[t,0,0,0],[e,r.shape[1],r.shape[2],r.shape[3]]);case 5:return Ue(r,[t,0,0,0,0],[e,r.shape[1],r.shape[2],r.shape[3],r.shape[4]]);case 6:return Ue(r,[t,0,0,0,0,0],[e,r.shape[1],r.shape[2],r.shape[3],r.shape[4],r.shape[5]]);default:throw new Y(`sliceAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}})}function JM(r,t,e){return X(()=>{switch(r.rank){case 1:return ey(r,t,e);case 2:return tb(r,[0,t],[r.shape[0],e]);case 3:return ty(r,[0,0,t],[r.shape[0],r.shape[1],e]);case 4:return Sh(r,[0,0,0,t],[r.shape[0],r.shape[1],r.shape[2],e]);default:throw new Y(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function Ab(r,t,e,n){return X(()=>{switch(r.rank){case 1:return ey(r,t,e);case 2:switch(n){case 1:return Bc(r,t,e);case 2:return JM(r,t,e);default:throw new Y(`The axis is not within the rank of the tensor ${n}`)}case 3:switch(n){case 1:return Bc(r,t,e);case 2:return ty(r,[0,t,0],[r.shape[0],e,r.shape[2]]);case 3:return JM(r,t,e);default:throw new Y(`The axis is not within the rank of the tensor ${n}`)}case 4:switch(n){case 1:return Bc(r,t,e);case 2:return Sh(r,[0,t,0,0],[r.shape[0],e,r.shape[2],r.shape[3]]);case 3:return Sh(r,[0,0,t,0],[r.shape[0],r.shape[1],e,r.shape[3]]);case 4:return JM(r,t,e);default:throw new Y(`The axis is not within the rank of the tensor ${n}`)}default:throw new Y(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function Fy(r,t=-1){let e;return t<0&&(e=r[0].rank,e!==0?t=e:t=0),t===r[0].rank&&(t=-1),Dt(r,t)}function tF(r,t){switch(r.rank){case 1:return kS([r,t]);case 2:return NS([r,t],0);case 3:return DS([r,t],0);case 4:return AS([r,t],0);default:throw new Y(`concatAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}}function Y_(r,t){if(Array.isArray(t)||(t=[t]),r.rank!==t.length)throw new Y(`The length of input n (${t.length}) does not match the number of dimensions in input x (${r.rank})`);return eo(r,t)}function $y(r,t=0,e=1,n,o){return Ch(r,t,e,n,o)}function Mi(r,t,e,n){if(r.rank<2||t.rank<2)throw new Xe(`dot requires both inputs to be rank >= 2 but got x shape = ${r.shape} and y shape = ${t.shape}`);if(t.rank>=3){let o=r.shape.slice(-1)[0],s=t.shape.slice(-2)[0];if(o!==s)throw new Xe(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${r.shape} and  y shape = ${t.shape}`)}if(r.rank===2&&t.rank===2)return Ud.matMul({a:r,b:t,transposeA:!1,transposeB:!1,bias:n?eF(r.rank,n,Uo()):null,activation:e});{let o=r.shape.slice(),s=o.pop();r=V(r,[-1,s]);let i=t.shape.slice(),a=i.pop(),u=i.pop(),l=[...i,a],c=Array.from({length:t.rank},(h,m)=>m===0?t.rank-2:m<=t.rank-2?m-1:m);t=V(ft(t,c),[u,-1]);let p=[...o,...l];return V(Ud.matMul({a:r,b:t,transposeA:!1,transposeB:!1,bias:n?eF(r.rank,n,Uo()):null,activation:e}),p)}}function Z_(r,t,e){return X(()=>(Array.isArray(t)?t=cr(t,"int32"):t=le(t,"int32"),$l(r,t,e)))}function zh(r){return B(r,r)}function eF(r,t,e){let n=t.shape;if(t.rank!==1&&t.rank!==r)throw new Y(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${r}`);if(r===5){if(e==="channelsFirst")return n.length===1?V(t,[1,n[0],1,1,1]):V(t,[1,n[3],n[0],n[1],n[2]]);if(e==="channelsLast")return n.length===1?V(t,[1,1,1,1,n[0]]):V(t,[1].concat(n))}else if(r===4){if(e==="channelsFirst")return n.length===1?V(t,[1,n[0],1,1]):V(t,[1,n[2],n[0],n[1]]);if(e==="channelsLast")return n.length===1?V(t,[1,1,1,n[0]]):V(t,[1].concat(n))}else if(r===3){if(e==="channelsFirst")return n.length===1?V(t,[1,n[0],1]):V(t,[1,n[1],n[0]]);if(e==="channelsLast")return n.length===1?V(t,[1,1,n[0]]):V(t,[1].concat(n))}else if(r<3)return t;throw new Y(`Unsupported input rank by biasAdd: ${t.rank}`)}function Go(r,t,e){return X(()=>(e==null&&(e=Uo()),$r(e),re(r,eF(r.rank,t,e))))}function QX(r,t=1){if(t!==1)throw new Xe(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Ml(r)}function JX(r){return X(()=>me(r,re(Nr(r),1)))}function Q_(r,t,e,n){return X(()=>Z2(r,t,e,n))}function eY(r){return X(()=>{let t=re(.5,B(.2,r));return Sn(t,0,1)})}function Qd(r,t,e=!1){return e?r():t()}var tY=["fanIn","fanOut","fanAvg"],rY=["normal","uniform","truncatedNormal"];function ike(r){Gl(tY,"FanMode",r)}function ake(r){Gl(rY,"Distribution",r)}var Wo=class extends ce.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},sY=(()=>{class r extends Wo{apply(e,n){return er(e,n)}}return r.className="Zeros",r})();ce.registerClass(sY);var J_=(()=>{class r extends Wo{apply(e,n){return hn(e,n)}}return r.className="Ones",r})();ce.registerClass(J_);var iY=(()=>{class r extends Wo{constructor(e){if(super(),typeof e!="object")throw new Y(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new Y(`config must have value set but got ${e}`);this.value=e.value}apply(e,n){return X(()=>B(we(this.value),hn(e,n)))}getConfig(){return{value:this.value}}}return r.className="Constant",r})();ce.registerClass(iY);var aY=(()=>{class r extends Wo{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,n){return Cs(e,this.minval,this.maxval,n,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return r.className="RandomUniform",r})();ce.registerClass(aY);var uY=(()=>{class r extends Wo{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new Xe(`randomNormal does not support dType ${n}.`);return $y(e,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return r.className="RandomNormal",r})();ce.registerClass(uY);var lY=(()=>{class r extends Wo{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new Xe(`truncatedNormal does not support dType ${n}.`);return oy(e,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return r.className="TruncatedNormal",r})();ce.registerClass(lY);var cY=(()=>{class r extends Wo{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,n){return X(()=>{if(e.length!==2||e[0]!==e[1])throw new Y("Identity matrix initializer can only be used for 2D square matrices.");return B(this.gain,yh(e[0]))})}getConfig(){return{gain:this.gain}}}return r.className="Identity",r})();ce.registerClass(cY);function uke(r,t="channelsLast"){let e,n;if($r(t),r.length===2)e=r[0],n=r[1];else if([3,4,5].indexOf(r.length)!==-1){if(t==="channelsFirst"){let o=Oi(r,2);e=r[1]*o,n=r[0]*o}else if(t==="channelsLast"){let o=Oi(r,0,r.length-2);e=r[r.length-2]*o,n=r[r.length-1]*o}}else{let o=Oi(r);e=Math.sqrt(o),n=Math.sqrt(o)}return[e,n]}var Ns=(()=>{class r extends Wo{constructor(e){if(super(),e.scale<0)throw new Y(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,ike(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,ake(this.distribution),this.seed=e.seed}apply(e,n){let o=uke(e),s=o[0],i=o[1],a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,s):this.mode==="fanOut"?a/=Math.max(1,i):a/=Math.max(1,(s+i)/2),this.distribution==="normal"){let u=Math.sqrt(a);if(n=n||"float32",n!=="float32"&&n!=="int32")throw new Xe(`${this.getClassName()} does not support dType ${n}.`);return oy(e,0,u,n,this.seed)}else{let u=Math.sqrt(3*a);return Cs(e,-u,u,n,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return r.className="VarianceScaling",r})();ce.registerClass(Ns);var rF=(()=>{class r extends Ns{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Ns.className}}return r.className="GlorotUniform",r})();ce.registerClass(rF);var nF=(()=>{class r extends Ns{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Ns.className}}return r.className="GlorotNormal",r})();ce.registerClass(nF);var oF=(()=>{class r extends Ns{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Ns.className}}return r.className="HeNormal",r})();ce.registerClass(oF);var sF=(()=>{class r extends Ns{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Ns.className}}return r.className="HeUniform",r})();ce.registerClass(sF);var iF=(()=>{class r extends Ns{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Ns.className}}return r.className="LeCunNormal",r})();ce.registerClass(iF);var aF=(()=>{class r extends Ns{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Ns.className}}return r.className="LeCunUniform",r})();ce.registerClass(aF);var pY=(()=>{class r extends Wo{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,n){return X(()=>{if(e.length<2)throw new Xe("Shape must be at least 2D.");if(n!=="int32"&&n!=="float32"&&n!==void 0)throw new TypeError(`Unsupported data type ${n}.`);n=n;let o=b.sizeFromShape(e.slice(0,-1)),s=e[e.length-1],i=o*s;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);let a=[Math.max(s,o),Math.min(s,o)],u=$y(a,0,1,n,this.seed),l=eO.qr(u,!1),c=l[0],d=l[1].flatten().stridedSlice([0],[Math.min(s,o)*Math.min(s,o)],[Math.min(s,o)+1]);return c=B(c,d.sign()),o<s&&(c=c.transpose()),B(we(this.gain),c.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}return r.className="Orthogonal",r})();ce.registerClass(pY);var nY={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function oY(r,t={}){return Ul(r,ce.SerializationMap.getMap().classNameMap,t,"initializer")}function Tr(r){return Oy(r)}function pr(r){if(typeof r=="string"){let t=r in nY?nY[r]:r;if(t==="GlorotNormal")return new nF;if(t==="GlorotUniform")return new rF;if(t==="HeNormal")return new oF;if(t==="HeUniform")return new sF;if(t==="LeCunNormal")return new iF;if(t==="LeCunUniform")return new aF;{let e={};return e.className=t,e.config={},oY(e)}}else return r instanceof Wo?r:oY(r)}function e1(r){return Array.isArray(r)&&Array.isArray(r[0])}function Py(r){return r.length===0?[]:Array.isArray(r[0])?r:[r]}function He(r){let t;if(Array.isArray(r)){if(r.length!==1)throw new Y(`Expected Tensor length to be 1; got ${r.length}`);t=r[0]}else t=r;return t}function pt(r){if(Array.isArray(r)&&Array.isArray(r[0])){if(r.length===1)return r=r,r[0];throw new Y(`Expected exactly 1 Shape; got ${r.length}`)}else return r}function Ly(r){let t=0;for(let e of r)e.shape.length===0?t+=1:t+=e.shape.reduce((n,o)=>n*o);return t}var fY="Variable",Rb=class{constructor(t,e="float32",n=fY,o=!0,s=null){this.dtype=e??"float32",this.shape=t.shape,this.id=H_(),n=n??fY,this.originalName=q_(n),this.name=K_(this.originalName),this.trainable_=o,this.constraint=s,this.val=lI(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),cke(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}};function cke(r,t){if(r.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(r.shape)+" vs. "+JSON.stringify(t.shape))}function Ob(r){return r.map(t=>t.read())}function zy(r){r.forEach(t=>{t[0].write(t[1])})}var yr=class{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}},Eo=class{constructor(t,e,n,o,s,i,a){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=o,this.callArgs=s,this.outputTensorIndex=a,this.id=H_(),i!=null&&(this.originalName=q_(i),this.name=K_(this.originalName)),this.rank=e.length}},pke=0,Uc=class{constructor(t,e){this.callArgs=e,this.id=pke++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(let n of t.inboundLayers)n?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){let t=[];for(let e of this.inboundLayers)e!=null?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},dke=0,Ye=class extends ce.Serializable{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=dke++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){let n=this.getClassName();e=Ai(n)+"_"+Zd(n)}if(this.name=e,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let n;if(t.batchInputShape!=null)n=t.batchInputShape;else if(t.inputShape!=null){let s=null;t.batchSize!=null&&(s=t.batchSize),n=[s].concat(t.inputShape)}this.batchInputShape=n;let o=t.dtype;o==null&&(o=t.inputDType),o==null&&(o="float32"),this.dtype=o}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(this.inboundNodes.length===0)throw new zo(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new Y(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return Gn(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return Gn(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Ys(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Ys(`Layer ${this.name} is not connected, no input to return.`);return Gn(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Ys(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Ys(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Gn(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){let e=Yt(t);if(this.inputSpec==null||this.inputSpec.length===0)return;let n=Yt(this.inputSpec);if(e.length!==n.length)throw new Y(`Layer ${this.name} expects ${n.length} inputs, but it received ${e.length} input tensors. Input received: ${t}`);for(let o=0;o<e.length;o++){let s=e[o],i=n[o];if(i==null)continue;let a=s.rank;if(i.ndim!=null&&a!==i.ndim)throw new Y(`Input ${o} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${a}`);if(i.maxNDim!=null&&a>i.maxNDim)throw new Y(`Input ${o} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${a}`);if(i.minNDim!=null&&a<i.minNDim)throw new Y(`Input ${o} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${a}.`);if(i.dtype!=null&&s.dtype!==i.dtype)throw new Y(`Input ${o} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${s.dtype}.`);if(i.axes){let u=s.shape;for(let l in i.axes){let c=Number(l),p=i.axes[l],d=c>=0?u[c]:u[u.length+c];if(p!=null&&[p,null].indexOf(d)===-1)throw new Y(`Input ${o} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${p} but got shape ${u}.`)}}if(i.shape!=null)for(let u=0;u<i.shape.length;++u){let l=i.shape[u],c=s.shape[u];if(l!=null&&c!=null&&l!==c)throw new Y(`Input ${o} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${s.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){this._callHook!=null&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();let n=Yt(t),o=mke(t),s=gke(t);if(o===s)throw new Y("Arguments to apply() must be all SymbolicTensors or all Tensors");return nu(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);let i=[];for(let a of Yt(t))i.push(a.shape);this.build(Gn(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(t),s){let i=this.call(t,e);this.supportsMasking&&this.setMaskMetadata(t,i);let a=Yt(i),u=[];for(let l of a)n.indexOf(l)!==-1&&(l=l.clone()),u.push(l);if(i=Gn(u),this.activityRegularizer!=null)throw new Xe("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{let i=fke(t),a=this.computeOutputShape(i),u,l=hke(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?i[0]:i),a!=null&&a.length>0&&Array.isArray(a[0])?u=a.map((c,p)=>new Eo(l,c,this,Yt(t),e,this.name,p)):u=new Eo(l,a,this,Yt(t),e,this.name),this.addInboundNode(t,u,null,null,i,a,e),this._refCount++,this.activityRegularizer!=null)throw new Xe("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((n,o)=>{n!=null&&t[o]!=null&&t[o]!==n&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Ys(`The layer ${this.name} has never been called and thus has no defined output shape.`);let t=[];for(let e of this.inboundNodes){let n=JSON.stringify(e.outputShapes);t.indexOf(n)===-1&&t.push(n)}if(t.length===1){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new Ys(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new zo(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Ly(this.weights)}build(t){this.built=!0}getWeights(t=!1){return Ob(t?this.trainableWeights:this.weights)}setWeights(t){X(()=>{let e=this.weights;if(e.length!==t.length)throw new Y(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(e.length===0)return;let n=[],o=Ob(e);for(let s=0;s<o.length;++s){let i=o[s],a=e[s],u=t[s];if(!b.arraysEqual(i.shape,u.shape))throw new Y(`Layer weight shape ${i.shape} not compatible with provided weight shape ${u.shape}`);n.push([a,u])}zy(n)})}addWeight(t,e,n,o,s,i,a,u){if(this._addedWeightNames.indexOf(t)!==-1)throw new Y(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(o=u!=null?u():pr("zeros"));let l=o.apply(e,n),c=new Rb(l,n,t,i,a);return l.dispose(),s!=null&&this.addLoss(()=>s.apply(c.read())),i==null&&(i=!0),i?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=Yt(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(e!=null)if(Array.isArray(e))e.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return e}setMaskMetadata(t,e,n){if(!this.supportsMasking)return;let o=this.computeMask(t,n),s=Yt(e),i=Yt(o);if(s.length!==i.length)throw new Error(`${this.name} outputs ${s.length} tensors but ${s.length} masks for those tensors`);for(let a=0;a<s.length;a++)s[a].kerasMask=i[a]}addInboundNode(t,e,n,o,s,i,a=null){let u=Yt(t);e=Yt(e),n=Yt(n),o=Yt(o),s=Py(s),i=Py(i);let l=[],c=[],p=[];for(let d of u)l.push(d.sourceLayer),c.push(d.nodeIndex),p.push(d.tensorIndex);new Uc({outboundLayer:this,inboundLayers:l,nodeIndices:c,tensorIndices:p,inputTensors:u,outputTensors:e,inputMasks:n,outputMasks:o,inputShapes:s,outputShapes:i},a);for(let d=0;d<e.length;d++)e[d].sourceLayer=this,e[d].nodeIndex=this.inboundNodes.length-1,e[d].tensorIndex=d}getConfig(){let t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}};function fke(r){r=Yt(r);let t=[];for(let e of r)t.push(e.shape);return Gn(t)}function hke(r){return"float32"}function uF(r,t,e){if((t==null||e!=null&&e>0)&&(t=r.sourceLayer,e=r.nodeIndex),t.inboundNodes.length===0)return[r];{let n=t.inboundNodes[e];if(n.inboundLayers.length===0)return n.inputTensors;{let o=[];for(let s=0;s<n.inboundLayers.length;s++){let i=n.inputTensors[s],a=n.inboundLayers[s],u=n.nodeIndices[s],l=uF(i,a,u);for(let c of l)o.indexOf(c)===-1&&o.push(c)}return o}}}function mke(r){let t=!0;for(let e of Yt(r))if(!(e instanceof Eo)){t=!1;break}return t}function gke(r){let t=!0;for(let e of Yt(r))if(e instanceof Eo){t=!1;break}return t}var Bh=(()=>{class r extends Ye{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:Zd("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new Y("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let n=e.batchInputShape;if(n==null){if(e.inputShape==null)throw new Y("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");n=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new Y("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let o=e.dtype||"float32";this.batchInputShape=n,this.dtype=o,this.inputSpec=[{shape:n}];let s=new Eo(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new Uc({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[n],outputShapes:[n]})}apply(e,n){throw new Y(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return r.className="InputLayer",r})();ce.registerClass(Bh);function lF(r){if(r.batchShape==null&&r.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(r.batchShape!=null&&r.shape!=null)throw new Y("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=r.batchShape;r.shape!=null&&t==null&&(t=[null].concat(r.shape));let e=r.dtype;return e==null&&(e="float32"),new Bh({batchInputShape:t,name:r.name,dtype:e,sparse:r.sparse}).inboundNodes[0].outputTensors[0]}function yke(r,t){if(r.dtype==null||r.dtype===t.dtype)return t;try{return le(t,r.dtype)}catch{throw new Y(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${r.name}' (${r.dtype}).`)}}var Wl=class r{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof r)for(let e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(t==null)return;for(let e of t)this.add(e.key,e.value)}}add(t,e,n){if(this.id2Value[t.id]==null)this.id2Value[t.id]=yke(t,e),this.name2Id[t.name]=t.id,n!=null&&(this.id2Mask[t.id]=n);else throw new Y(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof Eo){if(this.id2Value[t.id]==null)throw new Y(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let e=this.name2Id[t];if(e==null)throw new Y(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof Eo){if(this.id2Value[t.id]==null)throw new Y(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let e=this.name2Id[t];if(e==null)throw new Y(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){this.id2Mask!=null&&$e(this.id2Mask)}},t1=new kb,r1=new kb;function mY(r){t1?.setMaxEntries(r),r1?.setMaxEntries(r)}function Vh(r,t,e,n){let o=e==null?!1:e.training,s=Array.isArray(r),i=s?r:[r],a=i.map(h=>h.name),u=[],l=t.names();for(let h of a)l.indexOf(h)!==-1?u.push(t.getValue(h)):u.push(null);n!=null&&(n.maxNumTensors=-1/0,n.minNumTensors=1/0);let c=a.join(",")+"|"+t.names().sort().join(","),p=t1.get(c),d;if(p==null){let h=xke(i,t);p=h.sorted,d=h.recipientCounts,t1.put(c,p),r1.put(c,d)}d={},o||Object.assign(d,r1.get(c));let f=new Wl(t);for(let h=0;h<p.length;++h){if(n!=null){let $=qv().numTensors;$>n.maxNumTensors&&(n.maxNumTensors=$),$<n.minNumTensors&&(n.minNumTensors=$)}let m=p[h],g=m.sourceLayer;if(g instanceof Bh)continue;let y=[],x=[],w=[],C=!1;for(let $ of m.inputs){let z=f.getValue($),G=f.getMask($);y.push(z),x.push(G),G!=null&&(C=!0),o||(d[$.name]--,d[$.name]===0&&!t.hasKey($)&&a.indexOf($.name)===-1&&!z.isDisposed&&$.sourceLayer.stateful!==!0&&w.push(z))}C&&(e=e||{},e.mask=x[0]);let I=Yt(g.apply(y,e)),N=null;g.supportsMasking&&(N=g.computeMask(y,x));let A=bke(m),O=Array.isArray(A)?A:[A];for(let $=0;$<O.length;++$){f.hasKey(O[$])||f.add(O[$],I[$],Array.isArray(N)?N[0]:N);let z=a.indexOf(O[$].name);z!==-1&&(u[z]=I[$])}o||$e(w)}return f.disposeMasks(),s?u:u[0]}function xke(r,t){b.assert(r!=null&&r.length>0,()=>"Expected at least one fetch, got none");let e=[],n={};if(r.length===1){let o=hY(r[0],t);e=o.sorted,n=o.recipientMap}else{let o=new Set;for(let s of r){let{sorted:i,recipientMap:a}=hY(s,t);for(let u of i)o.has(u.name)||(e.push(u),o.add(u.name));for(let u in a)n[u]==null&&(n[u]=new Set),a[u].forEach(l=>n[u].add(l))}}return{sorted:e,recipientCounts:vke(n)}}function vke(r){let t={};for(let e in r)t[e]=r[e].size;return t}function hY(r,t){let e=new Set,n=[],o={};for(let a of t.names())e.add(a);let s=[],i=[];for(s.push(r);s.length>0;){let a=s[s.length-1];if(e.has(a.name)){s.pop();continue}let u=i[i.length-1]===s.length-1;if(a.inputs.length===0||u)s.pop(),n.push(a),e.add(a.name),u&&i.pop();else{i.push(s.length-1);for(let l of a.inputs)o[l.name]==null&&(o[l.name]=new Set),o[l.name].add(a.name),!e.has(l.name)&&s.push(l)}}return{sorted:n,recipientMap:o}}function bke(r){let t;if(r.sourceLayer.inboundNodes.length===1)t=r.sourceLayer.output;else{let e=null;for(let n=0;n<r.sourceLayer.inboundNodes.length;++n)for(let o of r.sourceLayer.inboundNodes[n].outputTensors)if(o.id===r.id){e=n;break}t=r.sourceLayer.getOutputAt(e)}return t}var wke=j();wke.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,mY);function cF(r,t){return X(()=>lr(Ie(B(r,r),t,!0)))}var Uh=class extends ce.Serializable{getConfig(){return{}}},xY=(()=>{class r extends Uh{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return X(()=>{let n=cF(e,this.axis),o=Sn(n,0,this.maxValue);return B(e,me(o,re(vn(),n)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return r.className="MaxNorm",r})();ce.registerClass(xY);var vY=(()=>{class r extends Uh{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return X(()=>me(e,re(vn(),cF(e,this.axis))))}getConfig(){return{axis:this.axis}}}return r.className="UnitNorm",r})();ce.registerClass(vY);var bY=(()=>{class r extends Uh{apply(e){return to(e)}}return r.className="NonNeg",r})();ce.registerClass(bY);var wY=(()=>{class r extends Uh{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return X(()=>{let n=cF(e,this.axis),o=re(B(this.rate,Sn(n,this.minValue,this.maxValue)),B(1-this.rate,n));return B(e,me(o,re(vn(),n)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return r.className="MinMaxNorm",r})();ce.registerClass(wY);var gY={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function qr(r){return Oy(r)}function yY(r,t={}){return Ul(r,ce.SerializationMap.getMap().classNameMap,t,"constraint")}function Kr(r){if(r==null)return null;if(typeof r=="string"){let e={className:r in gY?gY[r]:r,config:{}};return yY(e)}else return r instanceof Uh?r:yY(r)}function Gc(r){return L(this,null,function*(){if(r==null)return;let t=[],e=[],n=[];for(let o in r){let s=r[o];if(typeof s!="number"){let i=s;t.push(i.data()),e.push(o),n.push(i)}}if(t.length>0){let o=yield Promise.all(t);for(let s=0;s<o.length;++s)r[e[s]]=o[s][0];$e(n)}})}function n1(r){if(r!=null)for(let t in r){let e=r[t];typeof e!="number"&&e.dispose()}}var Ike=125,Jd=class{constructor(){this.validationData=null}setParams(t){this.params=t}onEpochBegin(t,e){return L(this,null,function*(){})}onEpochEnd(t,e){return L(this,null,function*(){})}onBatchBegin(t,e){return L(this,null,function*(){})}onBatchEnd(t,e){return L(this,null,function*(){})}onTrainBegin(t){return L(this,null,function*(){})}onTrainEnd(t){return L(this,null,function*(){})}setModel(t){}},o1=class{constructor(t,e=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(let e of this.callbacks)e.setParams(t)}setModel(t){for(let e of this.callbacks)e.setModel(t)}onEpochBegin(t,e){return L(this,null,function*(){e==null&&(e={});for(let n of this.callbacks)yield n.onEpochBegin(t,e)})}onEpochEnd(t,e){return L(this,null,function*(){e==null&&(e={});for(let n of this.callbacks)yield n.onEpochEnd(t,e)})}onBatchBegin(t,e){return L(this,null,function*(){e==null&&(e={});for(let n of this.callbacks)yield n.onBatchBegin(t,e)})}onBatchEnd(t,e){return L(this,null,function*(){e==null&&(e={});for(let n of this.callbacks)yield n.onBatchEnd(t,e)})}onTrainBegin(t){return L(this,null,function*(){t==null&&(t={});for(let e of this.callbacks)yield e.onTrainBegin(t)})}onTrainEnd(t){return L(this,null,function*(){t==null&&(t={});for(let e of this.callbacks)yield e.onTrainEnd(t)})}},pF=class extends Jd{constructor(){super()}onEpochBegin(t){return L(this,null,function*(){this.seen=0,this.totals={}})}onBatchEnd(t,e){return L(this,null,function*(){e==null&&(e={});let n=e.size==null?0:e.size;this.seen+=n;for(let o in e){let s=e[o];if(typeof s=="number")this.totals.hasOwnProperty(o)||(this.totals[o]=0),this.totals[o]=this.totals[o]+s*n;else{let i;o in this.totals?i=this.totals[o]:this.totals[o]=0;let a=X(()=>re(this.totals[o],B(s,n)));this.totals[o]=a,i?.dispose()}}})}onEpochEnd(t,e){return L(this,null,function*(){if(e!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?e[n]=this.totals[n]/this.seen:X(()=>{let o=B(me(1,this.seen),this.totals[n]);e[n]=o,this.totals[n].dispose(),Ar(e[n])}))})}},s1=class extends Jd{onTrainBegin(t){return L(this,null,function*(){this.epoch=[],this.history={}})}onEpochEnd(t,e){return L(this,null,function*(){e==null&&(e={}),this.epoch.push(t);for(let n in e)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(e[n])})}syncData(){return L(this,null,function*(){let t=[],e=[],n=[];for(let s in this.history){let i=this.history[s];for(let a=0;a<i.length;++a)if(typeof i[a]!="number"){let u=i[a];t.push(u.data()),e.push(s),n.push(a)}}let o=yield Promise.all(t);for(let s=0;s<o.length;++s)this.history[e[s]][n[s]].dispose(),this.history[e[s]][n[s]]=o[s][0]})}},i1=class extends Jd{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||ib,this.yieldEvery=e||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=Ike),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");b.isNumber(this.yieldEvery)&&(this.maybeWait=zX(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}maybeWait(t,e,n){return L(this,null,function*(){let o=[];this.yield!=null&&(yield Gc(n),o.push(this.yield(t,e,n))),o.push(this.nextFrameFunc()),yield Promise.all(o)})}onEpochBegin(t,e){return L(this,null,function*(){this.currentEpoch=t,this.epochBegin!=null&&(yield Gc(e),yield this.epochBegin(t,e))})}onEpochEnd(t,e){return L(this,null,function*(){let n=[];this.epochEnd!=null&&(yield Gc(e),n.push(this.epochEnd(t,e))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),yield Promise.all(n)})}onBatchBegin(t,e){return L(this,null,function*(){this.batchBegin!=null&&(yield Gc(e),yield this.batchBegin(t,e))})}onBatchEnd(t,e){return L(this,null,function*(){let n=[];this.batchEnd!=null&&(yield Gc(e),n.push(this.batchEnd(t,e))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):b.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,t,e)),yield Promise.all(n)})}onTrainBegin(t){return L(this,null,function*(){this.trainBegin!=null&&(yield Gc(t),yield this.trainBegin(t))})}onTrainEnd(t){return L(this,null,function*(){this.trainEnd!=null&&(yield Gc(t),yield this.trainEnd(t))})}};function a1(r,t){return r==null&&(r={}),r instanceof Jd?[r]:Array.isArray(r)&&r[0]instanceof Jd?r:Yt(r).map(n=>new i1(n,t))}var CY=(()=>{class r{constructor(){}static registerCallbackConstructor(e,n){b.assert(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),r.checkForDuplicate(n),r.constructors[e]==null&&(r.constructors[e]=[]),r.constructors[e].push(n)}static checkForDuplicate(e){for(let n in r.constructors)r.constructors[+n].forEach(s=>{if(s===e)throw new Y("Duplicate callback constructor.")})}static clear(){r.constructors={}}static createCallbacks(e){let n=[];for(let o in r.constructors){let s=+o;e>=s&&n.push(...r.constructors[s])}return n.map(o=>new o)}}return r.constructors={},r})();function u1(r,t,e,n,o,s,i,a,u){let l=new s1,c=[new pF,...CY.createCallbacks(t)];r!=null&&c.push(...r),c.push(l);let p=new o1(c);return p.setParams({epochs:e,initialEpoch:n,samples:o,steps:s,batchSize:i,verbose:t,doValidation:a,metrics:u}),{callbackList:p,history:l}}function Ds(r,t={},e=!1){return Ul(r,ce.SerializationMap.getMap().classNameMap,t,"layer",e)}function Mb(r,t){return X(()=>{r.dtype!=="float32"&&(r=le(r,"float32"));let e=Ie(zh(r),t,!0),n=bi(e.shape,vn()),o=lr(ts(e,n));return me(r,o)})}function Gh(r,t){return X(()=>Ir(zh(xe(t,r)),-1))}function $b(r,t){return X(()=>Ir(Nr(xe(t,r)),-1))}function Pb(r,t){return X(()=>{let e=xe(r,t),n=Sn(Nr(r),vn(),Number.MAX_VALUE),o=Nr(me(e,n));return B(100,Ir(o,-1))})}function Tke(r,t){return X(()=>{let e=Sn(t,vn(),Number.MAX_VALUE),n=Bn(re(1,e)),o=Sn(r,vn(),Number.MAX_VALUE),s=Bn(re(1,o));return Ir(zh(xe(n,s)),-1)})}function _ke(r,t){return X(()=>{let e=ts(0,xe(1,B(r,t)));return Ir(zh(e),-1)})}function Eke(r,t){return X(()=>{let e=ts(0,xe(1,B(r,t)));return Ir(e,-1)})}function kke(r,t){return X(()=>{let e=Ie(B(r,t),-1),n=zn(B(xe(1,r),t),-1);return ts(0,re(1,xe(n,e)))})}function Nke(r,t){return X(()=>{let e=Math.log(2),n=xe(t,r),o=xe(re(n,Ka(B(-2,n))),e);return Ir(o,-1)})}function Wh(r,t,e=!1){return X(()=>{if(e)t=zd(t);else{let n=Ie(t,t.shape.length-1,!0);t=me(t,n)}return t=Sn(t,vn(),1-vn()),yt(Ie(B(le(r,"float32"),Bn(t)),t.shape.length-1))})}function By(r,t,e=!1){return X(()=>{let n=le(Fl(YX(r)),"int32");t=Sn(t,vn(),1-vn());let o=t.shape,s=V(vh(n,o[o.length-1]),o);return Wh(s,t,e)})}function Dke(r,t){if(!b.arraysEqual(r.shape,t.shape))throw new Y(`logits and labels must have the same shape, but got shapes ${JSON.stringify(r.shape)} and ${JSON.stringify(t.shape)}`);return X(()=>{let e=to(t),n=yt(Nr(t));return re(xe(e,B(t,r)),Od(Rr(n)))})}function Vy(r,t){return X(()=>{let e;return e=Sn(t,vn(),1-vn()),e=Bn(me(e,xe(1,e))),Ir(Dke(r,e),-1)})}function Ake(r,t){return X(()=>{let e=Sn(r,vn(),1),n=Sn(t,vn(),1);return Ie(B(r,Bn(me(e,n))),-1)})}function Rke(r,t){return X(()=>{let e=Bn(re(vn(),t));return Ir(xe(t,B(r,e)),-1)})}function l1(r,t){return X(()=>{let e=Mb(r,-1),n=Mb(t,-1),o=B(e,n);return yt(Ie(o,-1))})}var Fb={meanSquaredError:Gh,meanAbsoluteError:$b,meanAbsolutePercentageError:Pb,meanSquaredLogarithmicError:Tke,squaredHinge:_ke,hinge:Eke,categoricalHinge:kke,logcosh:Nke,categoricalCrossentropy:Wh,sparseCategoricalCrossentropy:By,binaryCrossentropy:Vy,kullbackLeiblerDivergence:Ake,poisson:Rke,cosineProximity:l1};function c1(r){if(typeof r=="string"){if(r in Fb)return Fb[r];let t=`Unknown loss ${r}`;throw r.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${r}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new Y(t)}else return r}function d1(r,t){return X(()=>{let e=B(.5,On(t)),n=_o(Gr(t,e),r.dtype);return Ir(Co(r,n),-1)})}function f1(r,t){return X(()=>_o(Co(vi(r,-1),vi(t,-1)),"float32"))}function Oke(r,t){return X(()=>le(Ie(ao(Co(r,1),Co(t,1))),"float32"))}function Mke(r,t){return X(()=>le(Ie(ao(Co(r,0),Co(t,1))),"float32"))}function IY(r,t){return X(()=>{let e=Oke(r,t),n=Mke(r,t),o=re(e,n);return le(Cr(Gr(o,0),me(e,o),0),"float32")})}function dF(r,t){return Vy(r,t)}function fF(r,t){return r.rank===t.rank&&(r=Rt(r,[r.rank-1])),t=vi(t,-1),t.dtype!==r.dtype&&(t=le(t,r.dtype)),le(Co(r,t),"float32")}var Fke=Gh,$ke=Gh,Pke=$b,Lke=$b,zke=Pb,Bke=Pb,h1=Wh,Vke=l1,hF=By,p1={binaryAccuracy:d1,categoricalAccuracy:f1,precision:IY,categoricalCrossentropy:h1,sparseCategoricalCrossentropy:hF,mse:Fke,MSE:$ke,mae:Pke,MAE:Lke,mape:zke,MAPE:Bke,cosine:Vke};function TY(r){if(typeof r=="string"&&r in p1)return p1[r];if(typeof r!="string"&&r!=null)return r;throw new Y(`Unknown metric ${r}`)}function Lb(r){if(Zs(r!==null,`Unknown LossOrMetricFn ${r}`),typeof r=="string")return r;{let t;for(let e of Object.keys(Fb))if(Fb[e]===r){t=e;break}if(t!==void 0)return t;for(let e of Object.keys(p1))if(p1[e]===r){t=e;break}return t!==void 0?t:r.name}}function EY(r){let t={Adagrad:()=>Nh.adagrad(.01),Adadelta:()=>Nh.adadelta(1,.95,vn()),Adam:()=>Nh.adam(.001,.9,.999,vn()),Adamax:()=>Nh.adamax(.002,.9,.999,vn(),0),RMSProp:()=>Nh.rmsprop(.001,.9,0,vn()),SGD:()=>Nh.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,r in t)return t[r]();throw new Y(`Unknown Optimizer ${r}`)}function gF(r,t,e=!1){if(r==null||typeof r!="object"||Object.getPrototypeOf(r)!==Object.prototype||!mF(r))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){let n=JSON.stringify(r);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function mF(r){if(r===null)return!0;if(typeof r=="object")if(Object.getPrototypeOf(r)===Object.prototype){let t=Object.keys(r);for(let e of t)if(typeof e!="string"||!mF(r[e]))return!1;return!0}else if(Array.isArray(r)){for(let t of r)if(!mF(t))return!1;return!0}else return!1;else{let t=typeof r;return t==="string"||t==="number"||t==="boolean"}}function kY(r,t,e,n=console.log){let o=Wke(r),s=["Layer (type)","Input Shape","Output shape","Param #"];o?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(c=>Math.floor(t*c)));let i;if(!o){s.push("Receives inputs"),i=[];for(let c in r.nodesByDepth)i.push(...r.nodesByDepth[c])}n("_".repeat(t)),m1(s,e,n),n("=".repeat(t));let a=r.layers;for(let c=0;c<a.length;++c)o?jke(a[c],e,n):Hke(a[c],e,i,n),n((c===a.length-1?"=":"_").repeat(t));r.checkTrainableWeightsConsistency();let u=Gke(r),l=Ly(r.nonTrainableWeights);n(`Total params: ${u+l}`),n(`Trainable params: ${u}`),n(`Non-trainable params: ${l}`),n("_".repeat(t))}function Gke(r){let t;return r.collectedTrainableWeights!=null?t=Ly(r.collectedTrainableWeights):t=Ly(r.trainableWeights),t}function Wke(r){let t=!0,e=[],n=[];for(let o in r.nodesByDepth)e.push(r.nodesByDepth[o]);for(let o of e){if(o.length>1||o.length===1&&o[0].inboundLayers.length>1){t=!1;break}n.push(...o)}if(t)for(let o of r.layers){let s=!1;for(let i of o.inboundNodes)if(n.indexOf(i)!==-1)if(s){t=!1;break}else s=!0;if(!t)break}return t}function m1(r,t,e=console.log){let n="";for(let o=0;o<r.length;++o)o>0&&(n=n.slice(0,n.length-1)+" "),n+=r[o],n=n.slice(0,t[o]),n+=" ".repeat(t[o]-n.length);e(n)}function jke(r,t,e){let n,o;try{o=r.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{o="multiple"}try{n=JSON.stringify(r.outputShape)}catch{n="multiple"}let s=r.name,i=r.getClassName(),a=[`${s} (${i})`,o,n,r.countParams().toString()];m1(a,t,e)}function Hke(r,t,e,n){let o,s;try{s=r.inboundNodes.map(p=>JSON.stringify(p.inputShapes)).join(",")}catch{s="multiple"}try{o=JSON.stringify(r.outputShape)}catch{o="multiple"}let i=[];for(let p of r.inboundNodes)if(!(e!=null&&e.length>0&&e.indexOf(p)===-1))for(let d=0;d<p.inboundLayers.length;++d){let f=p.inboundLayers[d].name,h=p.nodeIndices[d],m=p.tensorIndices[d];i.push(`${f}[${h}][${m}]`)}let a=r.name,u=r.getClassName(),l=i.length===0?"":i[0],c=[`${a} (${u})`,s,o,r.countParams().toString(),l];m1(c,t,n);for(let p=1;p<i.length;++p)m1(["","","","",i[p]],t,n)}function NY(r,t,e){return(r==="inboundNodes"||r==="outputLayers"||r==="inputLayers")&&t===0&&typeof e=="string"}function zb(r,t){if(r===null)return null;if(typeof r=="string")return zc(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let e=[],n=r.length;for(let o=0;o<n;++o){let s=r[o];NY(t,o,s)?e.push(s):e.push(zb(s,t))}return e}else{let e={};for(let n of Object.keys(r)){let o=r[n];if(n==="name"&&typeof o=="string")e[n]=o;else{let s=zc(n);e[s]=zb(o,s)}}return e}}function g1(r,t){if(r==null)return null;if(typeof r=="string")return Ai(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let e=[],n=r.length;for(let o=0;o<n;++o){let s=r[o];NY(t,o,s)?e.push(s):e.push(g1(s,t))}return e}else{let e={};for(let n of Object.keys(r)){let o=r[n],s=Ai(n);(n==="name"||n==="className")&&typeof o=="string"?e[s]=o:e[s]=g1(o,n)}return e}}var Uy="4.20.0";var qke=r=>{let t=Object.keys(r);if(t.length===0)return!1;let e=t[0].split("/");return!isNaN(parseInt(e[e.length-1],10))},y1=class r extends Ye{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){let x=this.getClassName().toLowerCase();this.name=Zd(x)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],Ri(this.inputs).length!==this.inputs.length)throw new Y(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(x=>x.name)}`);Ri(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(x=>x.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let x of this.outputs){let w=x.sourceLayer,C=x.nodeIndex,I=x.tensorIndex;this.outputLayers.push(w),this.outputLayersNodeIndices.push(C),this.outputLayersTensorIndices.push(I)}for(let x of this.inputs){let w=x.sourceLayer,C=x.nodeIndex,I=x.tensorIndex;Zs(C===0,"input layer has >1 nodes"),Zs(I===0,"input layer has >1 tensors"),this.inputLayers.push(w),this.inputLayersNodeIndices.push(C),this.inputLayersTensorIndices.push(I)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let x=0;x<this.inputLayers.length;x++){let w=this.inputLayers[x];if(!(w instanceof Bh))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${x} (0-based) originates from layer type ${w.getClassName()}.`);this.inputNames.push(w.name),this.feedInputShapes.push(w.batchInputShape),this.feedInputNames.push(w.name)}for(let x of this.outputLayers)this.outputNames.push(x.name);this.internalInputShapes=this.inputs.map(x=>x.shape),this.internalOutputShapes=this.outputs.map(x=>x.shape);let e={},n={},o={},s={},i={},a=[],u=(x,w,C,I,N,A)=>{(I==null||N==null||A==null)&&(I=x.sourceLayer,N=x.nodeIndex,A=x.tensorIndex);let O=I.inboundNodes[N];if(C.indexOf(O)!==-1)throw new zo(`The tensor ${x.name} at layer "${I.name}" is part of a cycle.`);if(w.indexOf(O)!==-1)return;this.containerNodes.add(r.nodeKey(I,N)),I.id in i||(i[I.id]=Object.keys(i).length),C.indexOf(O)===-1&&C.push(O);let $=O.inboundLayers.length;for(let z=0;z<$;z++){let G=O.inputTensors[z],K=O.inboundLayers[z],Z=O.nodeIndices[z],Q=O.tensorIndices[z];u(G,w,C,K,Z,Q)}for(w.push(O);C.indexOf(O)>=0;)C.splice(C.indexOf(O),1);a.push(O)},l=[],c=[];for(let x of this.outputs)u(x,l,c);let p=a.slice().reverse();for(let x of p){n[x.id]=x,x.id in e||(e[x.id]=0);let w=e[x.id],C=o[x.outboundLayer.id]==null?0:o[x.outboundLayer.id];w=Math.max(w,C),o[x.outboundLayer.id]=w,s[x.outboundLayer.id]=x.outboundLayer,e[x.id]=w;for(let I=0;I<x.inboundLayers.length;I++){let N=x.inboundLayers[I],A=x.nodeIndices[I],O=N.inboundNodes[A],$=e[O.id]==null?0:e[O.id];e[O.id]=Math.max(w+1,$),n[O.id]=O}}let d={};for(let x in e){let w=e[x];w in d||(d[w]=[]),d[w].push(n[x])}let f={};for(let x in o){let w=o[x];w in f||(f[w]=[]),f[w].push(s[x])}let h=Object.keys(f).map(x=>parseInt(x,10)).sort(Nb);this.layers=[];for(let x of h){let w=f[x];w.sort((C,I)=>{let N=i[C.id],A=i[I.id];return N<A?-1:N>A?1:0});for(let C of w)C instanceof r&&this.internalContainerRefs.push(C),this.layers.push(C)}this.layersByDepth=f,h=Object.keys(d).map(x=>parseInt(x,10)).sort(Nb);let m=this.inputs.slice(),g=[];for(let x of h)for(let w of d[x]){let C=w.outboundLayer;if(C!=null){for(let I of w.inputTensors)if(m.indexOf(I)===-1)throw new zo(`Graph disconnected: cannot obtain value for tensor ${I} at layer "${C.name}". The following previous layers were accessed without issue: ${g}`);for(let I of w.outputTensors)m.push(I);g.push(C.name)}}this.nodesByDepth=d;let y=this.layers.map(x=>x.name);for(let x of y){let w=y.filter(C=>C===x).length;if(w!==1)throw new zo(`The name "${x}" is used ${w} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new Uc({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(x=>null),outputMasks:this.outputs.map(x=>null),inputShapes:this.inputs.map(x=>x.shape),outputShapes:this.outputs.map(x=>x.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(let e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(n=>n.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new Y("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){let e=[];for(let n of this.layers)e.push(...n.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){let n={},o=0,s=qke(t);s&&this.parseWeights(t);for(let a of this.layers)for(let[u,l]of a.weights.entries()){let c=s?`${l.name.split("/").slice(0,-1).join("/")+"/"}${u}`:l.originalName;if(n[c]!=null)throw new Y(`Duplicate weight name: ${c}`);n[c]=l,o++}let i=[];for(let a in t){let u=a;if(n[a]==null){let l=a.split("/");u=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(n[u]!=null)i.push([n[u],t[a]]);else if(e)throw new Y(`Provided weight data has no target variable: ${a}`);delete n[u]}if(e){let a=[];for(let u in n)a.push(u);if(a.length>0)throw new Y(`${a.length} of ${o} weights are not set: ${a}`)}zy(i)}parseWeights(t){for(let e in Object.keys(t)){let n=e.split("/"),o=["vars","layer_checkpoint_dependencies"],s=n.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!o.includes(i)).join("/");s!==e&&(t[s]=t[e],delete t[e])}}updatedConfig(){let t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${Uy}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){let n=g1(this.updatedConfig());return e?JSON.stringify(n):n}call(t,e){return X(()=>{t=Yt(t);let n=new Wl;for(let o=0;o<this.inputs.length;++o)n.add(this.inputs[o],t[o]);return Vh(this.outputs,n,e)})}computeMask(t,e){return X(()=>{t=Yt(t);let n;return e==null?n=Di(null,t.length):n=Yt(e),this.runInternalGraph(t,n)[1]})}computeOutputShape(t){let e=Py(t);if(e.length!==this.inputLayers.length)throw new Y(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let a=0;a<e.length;a++){let u=this.inputLayers[a],l=e[a],c=u.name+"_0_0";n[c]=l}let o=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(Nb);if(o.length>1)for(let a of o){let u=this.nodesByDepth[a];for(let l of u){let c=l.outboundLayer;if(this.inputLayers.map(m=>m.id).indexOf(c.id)!==-1)continue;let p=[];for(let m=0;m<l.inboundLayers.length;m++){let g=l.inboundLayers[m],y=l.nodeIndices[m],x=l.tensorIndices[m],w=`${g.name}_${y}_${x}`,C=n[w];p.push(C)}let d=c.computeOutputShape(Gn(p)),f=Py(d),h=c.inboundNodes.indexOf(l);for(let m=0;m<f.length;m++){let g=`${c.name}_${h}_${m}`;n[g]=f[m]}}}let s=[],i=[];for(let a=0;a<this.outputLayers.length;a++){let u=this.outputLayers[a],l=this.outputLayersNodeIndices[a],c=this.outputLayersTensorIndices[a],p=`${u.name}_${l}_${c}`;i.push(p)}for(let a=0;a<i.length;a++){let u=i[a];Zs(u in n),s.push(n[u])}return Gn(s)}runInternalGraph(t,e){e==null&&(e=Di(null,t.length));let n={};for(let u=0;u<this.inputs.length;++u){let l=this.inputs[u],c=t[u],p=e[u];n[l.id]=[c,p]}let o=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(Nb);for(let u of o){let l=this.nodesByDepth[u];for(let c of l){let p=c.outboundLayer,d=c.inputTensors,f=c.outputTensors,h=new Array;for(let m of d)m.id in n&&h.push(n[m.id]);if(h.length===d.length){let m={},g,y,x,w;if(c.callArgs!=null&&(m=c.callArgs),h.length===1){let[C,I]=h[0];m.mask==null&&(m.mask=I),x=Yt(p.call(C,m)),w=Yt(p.computeMask(C,I)),g=[C],y=[I]}else g=h.map(C=>C[0]),y=h.map(C=>C[1]),m.mask==null&&(m.mask=y),x=Yt(p.call(g,m)),w=Yt(p.computeMask(g,y));if(p.activityRegularizer)throw new Xe("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let C=0;C<f.length;++C){let I=f[C],N=x[C],A=w[C];n[I.id]=[N,A]}}}}let s=[],i=[],a=[];for(let u of this.outputs){Zs(u.id in n,`Could not compute output ${u.name} : ${u.id}`);let[l,c]=n[u.id];a.push(l.shape),s.push(l),i.push(c)}return[s,i,a]}buildNodeConversionMap(t){let e={},n;for(let o of this.layers){n=o instanceof r?1:0;for(let s=0;s<o.inboundNodes.length;s++){let i=r.nodeKey(o,s);this.containerNodes.has(i)&&(e[i]=n,n+=1)}}return e}getLayer(t,e){if(e!=null)return this.findLayer(e);if(t==null)throw new Y("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(let n of this.layers)if(n.name===t)return n;throw new Y(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new Y(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return X(()=>{let t=[];for(let e of this.layers)for(let n=0;n<e.inboundNodes.length;++n){let o=r.nodeKey(e,n);this.containerNodes.has(o)&&t.push(...e.calculateLosses())}return t})}getConfig(){let t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[];for(let i of this.layers){let a=i.getClassName(),u=i.getConfig(),l=[];for(let p=0;p<i.inboundNodes.length;p++){let d=i.inboundNodes[p],f=r.nodeKey(i,p),h={};if(this.containerNodes.has(f)){if(d.callArgs)try{JSON.stringify(d.callArgs),h=d.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),h={}}if(d.inboundLayers.length>0){let m=[];for(let g=0;g<d.inboundLayers.length;g++){let y=d.inboundLayers[g],x=d.nodeIndices[g],w=d.tensorIndices[g],C=r.nodeKey(y,x),I=e[C];I==null&&(I=0),m.push([y.name,I,w,h])}l.push(m)}}}let c={};c.name=i.name,c.className=a,c.config=u,c.inboundNodes=l,n.push(c)}t.layers=n;let o=[];for(let i=0;i<this.inputLayers.length;i++){let a=this.inputLayers[i],u=this.inputLayersNodeIndices[i],l=r.nodeKey(a,u);if(!this.containerNodes.has(l))continue;let c=e[l];c==null&&(c=0);let p=this.inputLayersTensorIndices[i];o.push([a.name,c,p])}t.inputLayers=o;let s=[];for(let i=0;i<this.outputLayers.length;i++){let a=this.outputLayers[i],u=this.outputLayersNodeIndices[i],l=r.nodeKey(a,u);if(!this.containerNodes.has(l))continue;let c=e[l];c==null&&(c=0);let p=this.outputLayersTensorIndices[i];s.push([a.name,c,p])}return t.outputLayers=s,t}static fromConfig(t,e,n={},o=!1){let s={},i={};function a(g,y){g.name in i?i[g.name].push(y):i[g.name]=[y]}function u(g,y){let x=[],w;for(let C of y){let I=C[0],N=C[1],A=C[2];if(w=C[3]==null?{}:C[3],!(I in s)){a(g,y);return}let O=s[I];if(O.inboundNodes.length<=N){a(g,y);return}let $=O.inboundNodes[N];x.push($.outputTensors[A])}x.length>0&&g.apply(Gn(x),w)}function l(g){let y=g.name,x=Ds(g,e.customObjects!=null?e.customObjects:{});x.setFastWeightInitDuringBuild(o),s[y]=x,g.inboundNodes.forEach(C=>{if(!(C instanceof Array))throw new Y(`Corrupted configuration, expected array for nodeData: ${C}`);a(x,C)})}let c=e.name,p=e.layers;for(let g of p)l(g);for(;!PX(i);)for(let g of p){let y=s[g.name];if(y.name in i){let x=i[y.name];delete i[y.name];for(let w of x)u(y,w)}}let d=[],f=[],h=e.inputLayers;for(let g of h){let y=g[0],x=g[1],w=g[2];Zs(y in s);let I=s[y].inboundNodes[x].outputTensors;d.push(I[w])}let m=e.outputLayers;for(let g of m){let y=g[0],x=g[1],w=g[2];Zs(y in s);let I=s[y].inboundNodes[x].outputTensors;f.push(I[w])}return new t({inputs:d,outputs:f,name:c})}get stateful(){if(this._stateful)throw new Y("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){X(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function Kke(r,t,e){let n=t.length;if(r==null||Array.isArray(r)&&r.length===0)return t.map(o=>null);if(n===1)return Array.isArray(r)&&r.length===1?r:typeof r=="object"&&t[0]in r?[r[t[0]]]:[r];if(Array.isArray(r)){if(r.length!==n)throw new Error(`Provided ${e} is an array of ${r.length} element(s), but the model has ${n} outputs. Make sure a set of weights is provided for each model output.`);return r}else if(typeof r=="object"&&Object.keys(r).length>0&&typeof r[Object.keys(r)[0]]=="object"){let o=[];return t.forEach(s=>{s in r?o.push(r[s]):o.push(null)}),o}else throw new Error(`The model has multiple (${n}) outputs, so ${e} must be either an array with ${n} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(r)}`)}function x1(r,t){return Kke(r,t,"classWeight")}function v1(r,t,e,n){return L(this,null,function*(){if(t!=null||n!=null)throw new Error("Support sampleWeight is not implemented yet");if(e!=null){let o=X(()=>{if(r.shape.length===1)return Mo(r);if(r.shape.length===2){if(r.shape[1]>1)return vi(r,1);if(r.shape[1]===1)return V(r,[r.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${r.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${r.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(yield o.data());$e(o);let i=[];return s.forEach(a=>{if(e[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);i.push(e[a])}),cr(i,"float32")}else return null})}function DY(r,t){return B(r,t)}var Xke=32;function OY(r,t){let e,n,o=t;e=o.xs,n=o.ys,b.assert(e!=null&&n!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let s=AY("input",r.inputNames,e),i=AY("output",r.outputNames,n),a=s[0].shape[0];b.assert(s.length===r.inputs.length,()=>`LayersModel has ${r.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(r.inputNames)})`),b.assert(i.length===r.outputs.length,()=>`LayersModel has ${r.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(r.outputNames)})`);for(let u=0;u<s.length;u++)b.assert(s[u].shape[0]===a,()=>`Batch size mismatch: input ${r.inputNames[u]} has ${s[u].shape[0]}; expected  ${a} based on input ${r.inputNames[0]}.`);for(let u=0;u<i.length;u++)b.assert(i[u].shape[0]===a,()=>`Batch size mismatch: output ${r.outputNames[u]} has ${i[u].shape[0]}; expected  ${a} based on input ${r.inputNames[0]}.`);return{xs:s,ys:i}}function AY(r,t,e){if(e instanceof ct)return[e];if(Array.isArray(e))return b.assert(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${r} keys ${t}.`),e;{let n=[];for(let o of t){if(e[o]==null)throw new Y(`The feature data generated by the dataset lacks the required ${r} key '${o}'.`);n.push(e[o])}return n}}function Yke(r){if(r.length===3)throw new Xe("Validation with sample weights is not implemented yet.");return{xs:r[0],ys:r[1]}}function MY(r,t,e){return L(this,null,function*(){let n=e.batchesPerEpoch!=null;if(b.assert(r.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),b.assert(e!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),b.assert(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),b.assert(!n||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),b.assert(e.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");r.isTraining=!0;try{let o=e.validationData!=null,s,i;if(o)if(RY(e.validationData))b.assert(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{let g=Yke(e.validationData);s=g.xs,i=g.ys}let a=r.makeTrainFunction(),u=r.getDedupedMetricsNames(),l;o?l=u.slice().concat(u.map(g=>"val_"+g)):l=u.slice();let c=a1(e.callbacks,e.yieldEvery),p=e.verbose==null?1:e.verbose,{callbackList:d,history:f}=u1(c,p,e.epochs,null,null,Zke(t,e),null,o,l);d.setModel(r),r.history=f,yield d.onTrainBegin(),r.stopTraining_=!1;let h=e.initialEpoch==null?0:e.initialEpoch,m=yield t.iterator();for(;h<e.epochs;){let g={};yield d.onEpochBegin(h);let y=0,x=0;for(n||(m=yield t.iterator());!n||y<e.batchesPerEpoch;){let w=yield m.next();if(n&&w.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(w.value!=null){let{xs:C,ys:I}=OY(r,w.value),N={};N.batch=x,N.size=C[0].shape[0],yield d.onBatchBegin(x,N);let A=[];if(e.classWeight!=null){let z=x1(e.classWeight,r.outputNames);for(let G=0;G<z.length;++G)A.push(yield v1(I[G],null,z[G]))}let O=C.concat(I).concat(A),$=a(O);$e(O);for(let z=0;z<u.length;++z){let G=u[z],K=$[z];N[G]=K,Ar(K)}yield d.onBatchEnd(x,N),n1(N),x++,y++}if(n?y>=e.batchesPerEpoch:w.done){if(o){let C;RY(e.validationData)?C=Yt(yield r.evaluateDataset(e.validationData,{batches:e.validationBatches})):C=Yt(r.evaluate(s,i,{batchSize:e.validationBatchSize==null?Xke:e.validationBatchSize,verbose:0}));for(let I=0;I<r.metricsNames.length;++I)g[`val_${r.metricsNames[I]}`]=C[I]}break}if(r.stopTraining_)break}if(yield d.onEpochEnd(h,g),h++,r.stopTraining_)break}return yield d.onTrainEnd(),yield r.history.syncData(),r.history}finally{r.isTraining=!1}})}function Zke(r,t){let e=null;return t.batchesPerEpoch!=null?e=t.batchesPerEpoch:Number.isFinite(r.size)&&(e=r.size),e}function RY(r){return typeof r.iterator=="function"}function Qke(r){return typeof r.next=="function"}function FY(r,t,e){return L(this,null,function*(){e=e||{};let n=e.batches!=null,o=r.testFunction,s=[];if(e.verbose>0)throw new Xe("Verbose mode is not implemented yet.");b.assert(!n||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);let i=Qke(t)?t:yield t.iterator(),a=0,u=0;for(;!n||u<e.batches;){let l=yield i.next();if(s=X(()=>{if(l.value){let{xs:c,ys:p}=OY(r,l.value),d=c.concat(p),f=X(()=>o(d));if($e(d),u===0)for(let m=0;m<f.length;++m)s.push(we(0));let h=d[0].shape[0];for(let m=0;m<f.length;++m){let g=f[m],y=s[m];s[m]=X(()=>re(s[m],B(h,g))),u>0&&$e(y)}$e(f),a+=h,++u}return s}),l.done){n&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let l=0;l<s.length;++l){let c=s[l];s[l]=me(s[l],a),$e(c)}return Gn(s)})}function b1(r){b.assert(r>0&&Number.isInteger(r),()=>`batchSize is required to be a positive integer, but got ${r}`)}function Gy(r,t,e){return r==null?[null]:Array.isArray(r)?r.map(n=>Bc(n,t,e-t)):Bc(r,t,e-t)}function w1(r,t){return X(()=>r==null?null:Array.isArray(r)?r.map(e=>w1(e,t)):Z_(r,t.dtype==="int32"?t:le(t,"int32")))}function C1(r,t){let e=[],n=0,o=null;for(;n<r;)o=n+t,o>=r&&(o=r),e.push([n,o]),n=o;return e}function yF(r){let t=[];r instanceof ct&&(r=[r]);for(let e=0;e<r.length;++e){let n=r[e];if(n.rank===1)t.push(Vc(n,1));else{if(n.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(n)}}return t}function Fi(r,t){if(r==null)return;let e=[];if(t instanceof ct)e.push(t.id);else if(Array.isArray(t))t.forEach(o=>e.push(o.id));else if(t!=null)for(let o in t){let s=t[o];e.push(s.id)}let n=[];if(r instanceof ct)e.indexOf(r.id)===-1&&n.push(r);else if(Array.isArray(r))r.forEach(o=>{e.indexOf(o.id)===-1&&n.push(o)});else if(r!=null)for(let o in r){let s=r[o];e.indexOf(s.id)===-1&&n.push(s)}n.forEach(o=>{o.isDisposed||o.dispose()})}function Jke(r){return r instanceof ct}function xF(r){return Array.isArray(r)}function $Y(r){return!Jke(r)&&!xF(r)}function PY(r,t,e,n=!0,o=""){if(t==null||t.length===0){if(r!=null){let i=!1;if(xF(r)&&r.length>0)i=!0;else if($Y(r)){for(let a in r)if(r.hasOwnProperty(a)){i=!0;break}}else i=!0;if(i)throw new Y(`Error when checking model ${o} expected no data, but got ${r}`)}return[]}if(r==null)return t.map(i=>null);let s;if($Y(r)){r=r,s=[];for(let i of t){if(r[i]==null)throw new Y(`No data provided for "${i}". Need data for each key in: ${t}`);s.push(r[i])}}else if(xF(r)){if(r=r,r.length!==t.length)throw new Y(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${r}`);s=r}else{if(r=r,t.length>1)throw new Y(`The model ${o} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${r.shape}`);s=[r]}if(s=yF(s),e!=null)for(let i=0;i<t.length;++i){if(e[i]==null)continue;let a=s[i];if(a.shape.length!==e[i].length)throw new Y(`Error when checking ${o}: expected ${t[i]} to have ${e[i].length} dimension(s). but got array with shape ${a.shape}`);for(let u=0;u<e[i].length;++u){if(u===0&&!n)continue;let l=a.shape[u],c=e[i][u];if(c!=null&&c>=0&&l!==c)throw new Y(`${o} expected a batch of elements where each example has shape [${e[i].slice(1,e[i].length)}] (i.e.,tensor shape [*,${e[i].slice(1,e[i].length)}]) but the ${o} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return s}function eNe(r,t,e){let n=Ri(r.map(s=>s.shape[0]));n.sort();let o=Ri(t.map(s=>s.shape[0]));if(o.sort(),n.length>1)throw new Y(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(r.map(s=>s.shape))}`);if(o.length>1)throw new Y(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(n.length>0&&o.length>0&&!b.arraysEqual(n,o))throw new Y(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${o[0]} target sample(s).`)}function tNe(r,t,e){let n=[Gh,Vy,Wh];for(let o=0;o<r.length;++o){let s=r[o],i=t[o],a=e[o];if(i!=null){if(i===Wh&&s.shape[s.shape.length-1]===1)throw new Y(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(n.indexOf(i)!==-1){let u=s.shape.slice(1),l=a.slice(1);for(let c=0;c<u.length;++c){let p=u[c],d=l[c];if(d!=null&&p!==d)throw new Y(`A target Tensor with shape ${s.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function LY(r,t,e,n=!0,o=""){let s;if(Array.isArray(r)){if(r.length!==t.length)throw new Y(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${r.length} Tensors(s).`);s=r}else{if(t.length>1)throw new Y(`The model expects ${t.length} ${o} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(r.shape)}.`);s=[r]}if(e!=null)for(let i=0;i<t.length;++i){if(e[i]==null)continue;let a=s[i];if(a.shape.length!==e[i].length)throw new Y(`Error when checking ${o}: expected ${t[i]} to have ${e[i].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let u=0;u<e[i].length;++u){if(u===0&&!n)continue;let l=a.shape[u],c=e[i][u];if(c!=null&&c!==l)throw new Y(`Error when checking ${o}: expected ${t[i]} to have shape ${JSON.stringify(e[i])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function rNe(r,t){if(r==null||Array.isArray(r)&&r.length===0)return t.map(n=>[]);let e;if(typeof r=="string"||typeof r=="function")e=[r];else if(Array.isArray(r)||typeof r=="object")e=r;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${r}`);if(Array.isArray(e))return t.map(n=>e);{let n=[];for(let o of t){let s=e.hasOwnProperty(o)?e[o]:[];Array.isArray(s)||(s=[s]),n.push(s)}return n}}var nNe="layers-model",Wc=(()=>{class r extends y1{constructor(e){super(e),this.isTraining=!1}summary(e,n,o=console.log){if(!this.built)throw new Y("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");kY(this,e,n,o)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=EY(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof lo))throw new Y("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let n=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let a in e.loss)if(this.outputNames.indexOf(a)===-1)throw new Y(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(let a of this.outputNames)e.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),n.push(c1(e.loss[a]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new Y(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);n=e.loss.map(u=>c1(u))}else{let a=c1(e.loss);this.outputs.forEach(u=>{n.push(a)})}this.lossFunctions=n,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){let u=this.internalOutputShapes[a],l=this.outputNames[a];this.feedOutputNames.push(l),this.feedOutputShapes.push(u),this.feedLossFns.push(this.lossFunctions[a])}let o=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],nu("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(o.indexOf(a)!==-1)continue;let u=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([u,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});let s=rNe(e.metrics,this.outputNames),i=(a,u,l)=>{this.outputNames.length>1&&(u=this.outputNames[a]+"_"+u),this.metricsNames.push(u),this.metricsTensors.push([l,a])};nu("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(o.indexOf(a)!==-1)continue;let u=s[a];(c=>{let p="",d,f,h;for(let m of c){if(typeof m=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(m)!==-1){let y=this.internalOutputShapes[a];y[y.length-1]===1||this.lossFunctions[a]===Vy?["accuracy","acc"].indexOf(m)!==-1?f=d1:["crossentropy","ce"].indexOf(m)!==-1&&(f=dF):this.lossFunctions[a]===By?["accuracy","acc"].indexOf(m)!==-1?f=fF:["crossentropy","ce"].indexOf(m)!==-1&&(f=hF):["accuracy","acc"].indexOf(m)!==-1?f=f1:["crossentropy","ce"].indexOf(m)!==-1&&(f=h1);let x;["accuracy","acc"].indexOf(m)!==-1?x="acc":["crossentropy","ce"].indexOf(m)!==-1&&(x="ce"),h=f,d=p+x}else h=TY(m),d=p+Lb(m);let g;nu(d,()=>{g=h}),i(a,d,g)}})(u)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,n,o={}){let s=o.batchSize==null?32:o.batchSize;b1(s);let a=this.standardizeUserDataXY(e,n,!0,s);try{let u=a[0].concat(a[1]);this.makeTestFunction();let l=this.testFunction,c=this.testLoop(l,u,s,o.verbose,o.steps);return Gn(c)}finally{Fi(a[0],e),Fi(a[1],n)}}evaluateDataset(e,n){return L(this,null,function*(){return this.makeTestFunction(),FY(this,e,n)})}checkNumSamples(e,n,o,s="steps"){let i;if(o!=null){if(i=null,n!=null)throw new Y(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${n}`)}else if(e!=null)Array.isArray(e)?i=e[0].shape[0]:i=e.shape[0];else throw new Y(`Either the input data should have a defined shape, or ${s} shoud be specified.`);return i}execute(e,n){if(Array.isArray(n)&&n.length===0)throw new Y("`outputs` is an empty Array, which is not allowed.");let o=Array.isArray(n),s=o?n:[n],i=this.retrieveSymbolicTensors(s),a=new Wl;if(e instanceof ct&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new Y(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)a.add(this.inputs[l],e[l])}else for(let l of this.inputs){let c=e[l.name];if(c==null)throw new Y(`No value is provided for the model's input ${l.name}`);a.add(l,c)}let u=Vh(i,a);return o?u:u[0]}retrieveSymbolicTensors(e){let n=Di(null,e.length),o=e.length;for(let s of this.layers){let i=Array.isArray(s.output)?s.output:[s.output],a=i.map(u=>u.name);for(let u=0;u<e.length;++u){let l=a.indexOf(e[u]);if(l!==-1&&(n[u]=i[l],o--),o===0)break}if(o===0)break}if(o>0){let s=[];throw n.forEach((i,a)=>{i==null&&s.push(e[a])}),new Y(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s)}`)}return n}predictLoop(e,n=32,o=!1){return X(()=>{let s=this.checkNumSamples(e);if(o)throw new Xe("Verbose predictLoop() is not implemented yet.");let i=C1(s,n),a=this.outputs.map(u=>[]);for(let u=0;u<i.length;++u)X(()=>{let c=i[u][0],p=i[u][1],d=Gy(e,c,p),f=[];if(Array.isArray(d))for(let m=0;m<d.length;++m)f.push({key:this.inputs[m],value:d[m]});else f.push({key:this.inputs[0],value:d});let h=new Wl(f);return Vh(this.outputs,h)}).forEach((c,p)=>a[p].push(c));return Gn(a.map(u=>Dt(u,0)))})}predict(e,n={}){let o=yF(e);LY(o,this.inputNames,this.feedInputShapes,!1);try{let s=n.batchSize==null?32:n.batchSize;return b1(s),this.predictLoop(o,s)}finally{Fi(o,e)}}predictOnBatch(e){LY(e,this.inputNames,this.feedInputShapes,!0);let n=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,n)}standardizeUserDataXY(e,n,o=!0,s){if(this.optimizer_==null)throw new zo("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let i=[];for(let a=0;a<this.feedOutputShapes.length;++a){let u=this.feedOutputShapes[a];this.feedLossFns[a]===By?i.push(u.slice(0,u.length-1).concat([1])):i.push(u)}if(e=PY(e,this.feedInputNames,this.feedInputShapes,!1,"input"),n=PY(n,this.feedOutputNames,i,!1,"target"),eNe(e,n,null),tNe(n,this.feedLossFns,this.feedOutputShapes),this.stateful&&s!=null&&s>0&&e[0].shape[0]%s!==0)throw new Y(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${e[0].shape[0]} sample(s).`);return[e,n]}standardizeUserData(e,n,o,s,i=!0,a){return L(this,null,function*(){let[u,l]=this.standardizeUserDataXY(e,n,i,a);if(o!=null)throw new Error("sample weight is not supported yet.");let c=null;if(s!=null){let p=x1(s,this.outputNames);c=[];for(let d=0;d<p.length;++d)c.push(yield v1(l[d],null,p[d]))}return[u,l,c]})}testLoop(e,n,o,s=0,i){return X(()=>{let a=this.checkNumSamples(n,o,i,"steps"),u=[];if(s>0)throw new Xe("Verbose mode is not implemented yet.");if(i!=null)throw new Xe("steps mode in testLoop() is not implemented yet");{let l=C1(a,o),c=cr(Vo(0,a));for(let p=0;p<l.length;++p){let d=l[p][0],f=l[p][1],h=Bc(c,d,f-d),m=w1(n,h),g=e(m);if(p===0)for(let y=0;y<g.length;++y)u.push(we(0));for(let y=0;y<g.length;++y){let x=g[y];u[y]=re(u[y],B(f-d,x))}}for(let p=0;p<u.length;++p)u[p]=me(u[p],a)}return u})}getDedupedMetricsNames(){let e=this.metricsNames,n=[];for(let o=0;o<e.length;++o){let s=e[o],i=s;if(YM(e,s)>1){let a=YM(e.slice(0,o),s);i+=`_${a}`}n.push(i)}return n}makeTrainFunction(){return e=>{let n=[],o=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],u=()=>{let d=[];for(let g=0;g<this.inputs.length;++g)d.push({key:this.inputs[g],value:o[g]});let f=new Wl(d),h=Vh(this.outputs,f,{training:!0}),m;for(let g=0;g<this.lossFunctions.length;++g){let y=this.lossFunctions[g],x=y(s[g],h[g]);i[g]!=null&&(x=DY(x,i[g]));let w=Ir(x);n.push(w),g===0?m=x:m=re(m,x)}for(let g=0;g<this.metricsTensors.length;++g){let y;if(this.outputs.length>1&&g<this.outputs.length)y=n[g];else{let x=this.metricsTensors[g][0],w=this.metricsTensors[g][1];y=Ir(x(s[w],h[w]))}Ar(y),a.push(y)}return m=Ir(m),this.calculateLosses().forEach(g=>{m=re(m,g)}),m},l=this.collectedTrainableWeights.map(d=>d.read());return[this.optimizer_.minimize(u,!0,l)].concat(a)}}makeTestFunction(){this.testFunction=e=>X(()=>{let n=[],o,s=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let c=0;c<this.inputs.length;++c)a.push({key:this.inputs[c],value:s[c]});let u=new Wl(a),l=Vh(this.outputs,u);for(let c=0;c<this.lossFunctions.length;++c){let p=this.lossFunctions[c],d=Ir(p(i[c],l[c]));c===0?o=d:o=re(o,d),n.push(o)}for(let c=0;c<this.metricsTensors.length;++c){let p=this.metricsTensors[c][0],d=this.metricsTensors[c][1],f=Ir(p(i[d],l[d]));n.push(f)}return n})}fit(s,i){return L(this,arguments,function*(e,n,o={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let a,u,l,c,p,d,f,h,m;try{let g=o.batchSize==null?32:o.batchSize;b1(g);let x=yield this.standardizeUserData(e,n,o.sampleWeight,o.classWeight,!1,g);a=x[0],u=x[1],m=x[2];let w=!1,C;if(o.validationData!=null&&o.validationData.length>0){if(w=!0,o.validationData.length===2)p=o.validationData[0],d=o.validationData[1];else throw o.validationData.length===3?new Xe("validationData including sample weights is not supported yet."):new Y(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${o.validationData} is invalid.`);let Z=yield this.standardizeUserData(p,d,null,null,!0,g);f=Z[0],h=Z[1],C=f.concat(h)}else if(o.validationSplit!=null&&o.validationSplit>0&&o.validationSplit<1){w=!0;let K=Math.floor(a[0].shape[0]*(1-o.validationSplit)),Z=a[0].shape[0];f=Gy(a,K,Z),l=a,a=Gy(a,0,K),h=Gy(u,K,Z),c=u,u=Gy(u,0,K),C=f.concat(h)}else o.validationSteps!=null&&(w=!0);let I=a.concat(u).concat(m);this.checkTrainableWeightsConsistency();let N=this.makeTrainFunction(),A=this.getDedupedMetricsNames(),O,$;w?(this.makeTestFunction(),O=this.testFunction,$=A.slice().concat(A.map(K=>"val_"+K))):(O=null,C=[],$=A.slice());let z=a1(o.callbacks,o.yieldEvery);return yield this.fitLoop(N,I,A,g,o.epochs,o.verbose,z,O,C,o.shuffle,$,o.initialEpoch,null,null)}finally{this.isTraining=!1,Fi(a,e),Fi(u,n),Fi(l,e),Fi(c,n),Fi(f,p),Fi(h,d),m!=null&&$e(m)}})}fitLoop(e,n,o,s,i,a,u,l,c,p,d,f,h,m){return L(this,null,function*(){s==null&&(s=32),i==null&&(i=1),p==null&&(p=!0),f==null&&(f=0);let g=!1;if(l!=null&&c!=null&&(g=!0),m!=null&&(g=!0,h==null))throw new Y("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let y=this.checkNumSamples(n,s,h,"steps_per_epoch"),x;y!=null&&(x=Vo(0,y)),a==null&&(a=1);let{callbackList:w,history:C}=u1(u,a,i,f,y,h,s,g,d);w.setModel(this),this.history=C,yield w.onTrainBegin(),this.stopTraining_=!1;for(let I=f;I<i;++I){yield w.onEpochBegin(I);let N={};if(h!=null)throw new Xe("stepsPerEpoch mode is not implemented yet.");{if(p==="batch")throw new Xe("batch shuffling is not implemneted yet");p&&b.shuffle(x);let A=cr(x),O=C1(y,s);for(let $=0;$<O.length;++$){let z={};if(yield w.onBatchBegin($,z),X(()=>{let G=O[$][0],K=O[$][1],Z=Bc(A,G,K-G);z.batch=$,z.size=K-G;let Q=w1(n,Z),J=e(Q);for(let te=0;te<o.length;++te){let ie=o[te],ne=J[te];z[ie]=ne,Ar(ne)}if($===O.length-1&&g){let te=this.testLoop(l,c,s);for(let ie=0;ie<o.length;++ie){let ne=o[ie],ae=te[ie];Ar(ae),N["val_"+ne]=ae}}}),yield w.onBatchEnd($,z),n1(z),this.stopTraining_)break}A.dispose()}if(yield w.onEpochEnd(I,N),this.stopTraining_)break}return yield w.onTrainEnd(),yield this.history.syncData(),this.history})}fitDataset(e,n){return L(this,null,function*(){return MY(this,e,n)})}trainOnBatch(e,n){return L(this,null,function*(){let o=yield this.standardizeUserData(e,n),s=o[0],i=o[1],u=this.makeTrainFunction()(s.concat(i)),l=[];for(let c of u){let p=yield c.data();l.push(p[0])}return $e(u),Fi(o[0],e),Fi(o[1],n),Gn(l)})}getNamedWeights(e){let n=[],o=e!=null&&e.trainableOnly,s=o?this.trainableWeights:this.weights,i=this.getWeights(o);for(let a=0;a<s.length;++a)o&&!s[a].trainable||n.push({name:s[a].originalName,tensor:i[a]});return n}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let n=qv().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=n-qv().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Ai(this.loss);else if(Array.isArray(this.loss)){for(let n of this.loss)if(typeof n!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(n=>Ai(n))}else{let n=Object.keys(this.loss);e={};let o=this.loss;for(let s of n)if(typeof o[s]=="string")e[s]=Ai(o[s]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Ai(Lb(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Ai(Lb(e)));{let e={};for(let n in this.metrics)e[n]=Ai(Lb(this.metrics[n]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let n=zb(e.optimizer_config),o=Ds(n),s;if(typeof e.loss=="string")s=zc(e.loss);else if(Array.isArray(e.loss))s=e.loss.map(a=>zc(a));else if(e.loss!=null){s={};for(let a in e.loss)s[a]=zc(e.loss[a])}let i;if(Array.isArray(e.metrics))i=e.metrics.map(a=>zc(a));else if(e.metrics!=null){i={};for(let a in e.metrics)i[a]=zc(e.metrics[a])}this.compile({loss:s,metrics:i,optimizer:o})}save(e,n){return L(this,null,function*(){if(typeof e=="string"){let c=Ya.getSaveHandlers(e);if(c.length===0)throw new Y(`Cannot find any save handlers for URL '${e}'`);if(c.length>1)throw new Y(`Found more than one (${c.length}) save handlers for URL '${e}'`);e=c[0]}if(e.save==null)throw new Y("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let o=yield Ya.encodeWeights(this.getNamedWeights(n)),u={modelTopology:this.toJSON(null,!1),format:nNe,generatedBy:`TensorFlow.js tfjs-layers v${Uy}`,convertedBy:null};if((n==null?!1:n.includeOptimizer)&&this.optimizer!=null){u.trainingConfig=this.getTrainingConfig();let c="optimizer",{data:p,specs:d}=yield Ya.encodeWeights(yield this.optimizer.getWeights(),c);o.specs.push(...d),o.data=Ya.concatenateArrayBuffers([o.data,p])}return this.userDefinedMetadata!=null&&(gF(this.userDefinedMetadata,this.name,!0),u.userDefinedMetadata=this.userDefinedMetadata),u.weightData=o.data,u.weightSpecs=o.specs,e.save(u)})}setUserDefinedMetadata(e){gF(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}return r.className="Model",r})();ce.registerClass(Wc);var oNe=(()=>{class r extends Wc{}return r.className="Functional",r})();ce.registerClass(oNe);var vF=(()=>{class r extends Wc{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:Zd("sequential_"),e.layers!=null)for(let n of e.layers)this.add(n)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(o=>o<0))throw new Y(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){let n=e instanceof r||e instanceof Wc,o;if(n){if(o=e,o.outputs.length!==1)throw new Y("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(o.inputs.length!==1)throw new Y("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new Y("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let s=lF({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(s)}if(n)this.outputs=o.outputs,this.inputs=o.inputs;else{if(e.inboundNodes.length!==1)throw new Y(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new Y("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=uF(this.outputs[0])}this.inboundNodes=[],new Uc({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Di(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{let s=e.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,n){return this.model==null&&this.build(),this.model.call(e,n)}build(e){if(pt(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Wc({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,n,o=console.log){this.built||this.build(),super.summary(e,n,o)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,n,o={}){if(!this.built)throw new zo("The model needs to be compiled before being used.");return this.model.evaluate(e,n,o)}evaluateDataset(e,n){return L(this,null,function*(){if(!this.built)throw new zo("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,n)})}predict(e,n={}){return this.model==null&&this.build(),this.model.predict(e,n)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(s,i){return L(this,arguments,function*(e,n,o={}){if(!this.built)throw new zo("The model needs to be compiled before being used.");return this.model.fit(e,n,o)})}fitDataset(e,n){return L(this,null,function*(){if(!this.built)throw new zo("The model needs to be compiled before being used.");return this.model.fitDataset(e,n)})}trainOnBatch(e,n){return L(this,null,function*(){return this.model.trainOnBatch(e,n)})}static fromConfig(e,n,o={},s=!1){let i,a={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new Y("Legacy serialization format not supported yet.");i=n}else b.assert(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=n.layers,delete n.layers,a=n;let u=new e(a);if(!(u instanceof r))throw new Xe(`Sequential.fromConfig called on non-Sequential input: ${u}`);for(let l of i){let p=Ds(l,void 0,s);s&&p.setFastWeightInitDuringBuild(!0),u.add(p)}return u}set stopTraining(e){if(this.model==null)throw new Y("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new Y("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let n of this.layers){let o={};o.className=n.getClassName(),o.config=n.getConfig(),e.push(o)}return{name:this.name,layers:e}}}return r.className="Sequential",r})();ce.registerClass(vF);var ro=class extends ce.Serializable{getConfig(){return{}}},iNe=(()=>{class r extends ro{apply(e,n=1){return QX(e,n)}}return r.className="elu",r})();ce.registerClass(iNe);var aNe=(()=>{class r extends ro{apply(e){return Yg(e)}}return r.className="selu",r})();ce.registerClass(aNe);var uNe=(()=>{class r extends ro{apply(e){return to(e)}}return r.className="relu",r})();ce.registerClass(uNe);var lNe=(()=>{class r extends ro{apply(e){return X(()=>rs(6,to(e)))}}return r.className="relu6",r})();ce.registerClass(lNe);var cNe=(()=>{class r extends ro{apply(e){return e}}return r.className="linear",r})();ce.registerClass(cNe);var pNe=(()=>{class r extends ro{apply(e){return Rn(e)}}return r.className="sigmoid",r})();ce.registerClass(pNe);var dNe=(()=>{class r extends ro{apply(e){return eY(e)}}return r.className="hardSigmoid",r})();ce.registerClass(dNe);var fNe=(()=>{class r extends ro{apply(e){return Ka(e)}}return r.className="softplus",r})();ce.registerClass(fNe);var hNe=(()=>{class r extends ro{apply(e){return JX(e)}}return r.className="softsign",r})();ce.registerClass(hNe);var mNe=(()=>{class r extends ro{apply(e){return qa(e)}}return r.className="tanh",r})();ce.registerClass(mNe);var wF=(()=>{class r extends ro{apply(e,n=-1){return zd(e,n)}}return r.className="softmax",r})();ce.registerClass(wF);var gNe=(()=>{class r extends ro{apply(e,n=-1){return Wg(e,n)}}return r.className="logSoftmax",r})();ce.registerClass(gNe);var yNe=(()=>{class r extends ro{apply(e){return X(()=>X(()=>{let n=Math.sqrt(2),o=B(.5,re(1,Gg(me(e,n))));return B(e,o)}))}}return r.className="gelu",r})();ce.registerClass(yNe);var xNe=(()=>{class r extends ro{apply(e){return X(()=>B(.5,B(e,re(1,qa(B(lr(me(2,Math.PI)),re(e,B(.044715,io(e,3)))))))))}}return r.className="gelu_new",r})();ce.registerClass(xNe);var vNe=(()=>{class r extends ro{apply(e){return X(()=>B(e,qa(Ka(e))))}}return r.className="mish",r})();ce.registerClass(vNe);var bNe=(()=>{class r extends ro{apply(e,n=1){return X(()=>B(Rn(B(e,n)),e))}}return r.className="swish",r})();ce.registerClass(bNe);function su(r){return r.getClassName()}function bF(r,t={}){return Ul(r,ce.SerializationMap.getMap().classNameMap,t,"activation")}function iu(r){if(r==null){let t={};return t.className="linear",t.config={},bF(t)}if(typeof r=="string"){let t={};return t.className=r,t.config={},bF(t)}else return r instanceof ro?r:bF(r)}function wNe(r){if(r!=null&&typeof r!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${r}`)}var S1=class extends ce.Serializable{},VY=(()=>{class r extends S1{constructor(e){super(),wNe(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return X(()=>{let n=er([1]);return this.hasL1&&(n=re(n,Ie(B(this.l1,Nr(e))))),this.hasL2&&(n=re(n,Ie(B(this.l2,zh(e))))),V(n,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,n){return new e({l1:n.l1,l2:n.l2})}}return r.className="L1L2",r})();ce.registerClass(VY);var zY={l1l2:"L1L2"};function tr(r){return Oy(r)}function BY(r,t={}){return Ul(r,ce.SerializationMap.getMap().classNameMap,t,"regularizer")}function xr(r){if(r==null)return null;if(typeof r=="string"){let e={className:r in zY?zY[r]:r,config:{}};return BY(e)}else return r instanceof S1?r:BY(r)}var UY=(()=>{class r extends Ye{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,n){e=He(e);let o=to(e);return this.maxValue!=null&&(o=Sn(o,0,this.maxValue)),o}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},n=super.getConfig();return Object.assign(e,n),e}}return r.className="ReLU",r})();ce.registerClass(UY);var GY=(()=>{class r extends Ye{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,n){let o=He(e);return Rd(o,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},n=super.getConfig();return Object.assign(e,n),e}}return r.className="LeakyReLU",r})();ce.registerClass(GY);var WY=(()=>{class r extends Ye{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=pr(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=xr(e.alphaRegularizer),this.alphaConstraint=Kr(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new Y(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=pt(e);let n=e.slice(1);if(this.sharedAxes!=null)for(let s of this.sharedAxes)n[s-1]=1;this.alpha=this.addWeight("alpha",n,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let o={};if(this.sharedAxes!=null)for(let s=1;s<e.length;++s)o[s]=e[s];this.inputSpec=[new yr({ndim:e.length,axes:o})],this.built=!0}call(e,n){return e=He(e),Ld(e,this.alpha.read())}getConfig(){let e={alphaInitializer:Tr(this.alphaInitializer),alphaRegularizer:tr(this.alphaRegularizer),alphaConstraint:qr(this.alphaConstraint),sharedAxes:this.sharedAxes},n=super.getConfig();return Object.assign(e,n),e}}return r.className="PReLU",r})();ce.registerClass(WY);var jY=(()=>{class r extends Ye{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Xe(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,n){let o=He(e);return Ml(o)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},n=super.getConfig();return Object.assign(e,n),e}}return r.className="ELU",r})();ce.registerClass(jY);var HY=(()=>{class r extends Ye{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,n){let o=He(e);return B(o,le(Gr(o,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},n=super.getConfig();return Object.assign(e,n),e}}return r.className="ThresholdedReLU",r})();ce.registerClass(HY);var qY=(()=>{class r extends Ye{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new wF().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,n){return X(()=>{let o=He(e),s=n.mask;if(s!=null){let i=B(xe(hn(o.shape),le(s,o.dtype)),we(-1e9));o=re(o,i)}return this.axis instanceof Array?this.axis.length>1?Rr(xe(o,Md(o,this.axis,!0))):this.softmax(o,this.axis[0]):this.softmax(o,this.axis)})}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},n=super.getConfig();return Object.assign(e,n),e}}return r.className="Softmax",r})();ce.registerClass(qY);function ef(r,t,e){if(typeof r=="number")return Di(r,t);if(r.length!==t)throw new Y(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${r.length} elements.`);for(let n=0;n<t;++n){let o=r[n];if(!KX(o))throw new Y(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(r)} including a non-integer number ${o}`)}return r}function os(r,t,e,n,o=1){if(r==null)return r;let s=t+(t-1)*(o-1),i;return e==="same"?i=r:i=r-s+1,Math.floor((i+n-1)/n)}function au(r,t,e,n){if(r==null)return null;if(n==="valid")r=r*t+ou([e-t,0]);else if(n==="same")r=r*t;else throw new Y(`Unsupport padding mode: ${n}.`);return r}function Vb(r,t){return X(()=>($r(t),t==="channelsFirst"?ft(r,[0,2,3,1]):r))}function CF(r,t){return X(()=>($r(t),t==="channelsFirst"?ft(r,[0,2,3,4,1]):r))}function SNe(r,t,e,n=1,o="valid",s,i=1){return X(()=>{if(s==null&&(s=Uo()),$r(s),r.shape.length!==3)throw new Y(`The input of a conv1dWithBias operation should be 3, but is ${r.shape.length} instead.`);if(t.shape.length!==3)throw new Y(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(e!=null&&e.shape.length!==1)throw new Y(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(s==="channelsFirst"&&(r=ft(r,[0,2,1])),o==="causal")throw new Xe("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=Lg(r,t,n,o==="same"?"same":"valid","NWC",i);return e!=null&&(a=Go(a,e)),a})}function KY(r,t,e,n=[1,1],o="valid",s,i,a=null){return X(()=>{if(s==null&&(s=Uo()),$r(s),r.rank!==3&&r.rank!==4)throw new Y(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${r.rank}.`);if(t.rank!==3&&t.rank!==4)throw new Y(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${r.rank}.`);let u=Vb(r,s);if(o==="causal")throw new Xe("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=Ud.conv2d({x:u,filter:t,strides:n,pad:o==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:e,activation:a}),s==="channelsFirst"&&(u=ft(u,[0,3,1,2])),u})}function INe(r,t,e,n=[1,1,1],o="valid",s,i){return X(()=>{if(s==null&&(s=Uo()),$r(s),r.rank!==4&&r.rank!==5)throw new Y(`conv3dWithBias expects input to be of rank 4 or 5, but received ${r.rank}.`);if(t.rank!==4&&t.rank!==5)throw new Y(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${r.rank}.`);let a=CF(r,s);if(o==="causal")throw new Xe("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=RS(a,t,n,o==="same"?"same":"valid","NDHWC",i),e!=null&&(a=Go(a,e)),s==="channelsFirst"&&(a=ft(a,[0,4,1,2,3])),a})}var Bb=class r extends Ye{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",r.verifyArgs(e),this.rank=t,an(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Xe(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=ef(e.kernelSize,t,"kernelSize"),this.strides=ef(e.strides==null?1:e.strides,t,"strides"),this.padding=e.padding==null?"valid":e.padding,Bo(this.padding),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,$r(this.dataFormat),this.activation=iu(e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.biasInitializer=pr(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Kr(e.biasConstraint),this.biasRegularizer=xr(e.biasRegularizer),this.activityRegularizer=xr(e.activityRegularizer),this.dilationRate=ef(e.dilationRate==null?1:e.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new Y(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new Y(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new Y(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(Zs("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!G_(t.kernelSize,"number",1,3))throw new Y(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:su(this.activation),useBias:this.useBias,biasInitializer:Tr(this.biasInitializer),biasRegularizer:tr(this.biasRegularizer),activityRegularizer:tr(this.activityRegularizer),biasConstraint:qr(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}},Wy=class r extends Bb{constructor(t,e){super(t,e),this.kernel=null,r.verifyArgs(e),this.filters=e.filters,an(this.filters,"filters"),this.kernelInitializer=pr(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Kr(e.kernelConstraint),this.kernelRegularizer=xr(e.kernelRegularizer)}build(t){t=pt(t);let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new Y(`The channel dimension of the input should be defined. Found ${t[e]}`);let n=t[e],o=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:n}}],this.built=!0}call(t,e){return X(()=>{t=He(t);let n,o=this.bias==null?null:this.bias.read(),s=W_(this.activation.getClassName());if(s!=null&&this.rank===2)n=KY(t,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)n=SNe(t,this.kernel.read(),o,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)n=KY(t,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)n=INe(t,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Xe("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(n=this.activation.apply(n))}return n})}computeOutputShape(t){t=pt(t);let e=[],n=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let s=0;s<n.length;++s){let i=os(n[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);e.push(i)}let o=[t[0]];return this.dataFormat==="channelsLast"?(o=o.concat(e),o.push(this.filters)):(o.push(this.filters),o=o.concat(e)),o}getConfig(){let t={filters:this.filters,kernelInitializer:Tr(this.kernelInitializer),kernelRegularizer:tr(this.kernelRegularizer),kernelConstraint:qr(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new Y(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},SF=(()=>{class r extends Wy{constructor(e){super(2,e),r.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!G_(e.kernelSize,"number",1,2))throw new Y(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}return r.className="Conv2D",r})();ce.registerClass(SF);var IF=(()=>{class r extends Wy{constructor(e){super(3,e),r.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new Y(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}return r.className="Conv3D",r})();ce.registerClass(IF);var XY=(()=>{class r extends SF{constructor(e){if(super(e),this.inputSpec=[new yr({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new Y(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=pt(e),e.length!==4)throw new Y("Input should have rank 4; Received input shape: "+JSON.stringify(e));let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new Y("The channel dimension of the inputs should be defined. Found `None`.");let o=e[n],s=this.kernelSize.concat([this.filters,o]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new yr({ndim:4,axes:{[n]:o}})],this.built=!0}call(e,n){return X(()=>{let o=He(e);if(o.shape.length!==4)throw new Y(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${o.shape.length}`);let s=o.shape,i=s[0],a,u;this.dataFormat==="channelsFirst"?(a=2,u=3):(a=1,u=2);let l=s[a],c=s[u],p=this.kernelSize[0],d=this.kernelSize[1],f=this.strides[0],h=this.strides[1],m=au(l,f,p,this.padding),g=au(c,h,d,this.padding),y=[i,m,g,this.filters];this.dataFormat!=="channelsLast"&&(o=ft(o,[0,2,3,1]));let x=Bg(o,this.kernel.read(),y,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(x=ft(x,[0,3,1,2])),this.bias!=null&&(x=Go(x,this.bias.read(),this.dataFormat)),this.activation!=null&&(x=this.activation.apply(x)),x})}computeOutputShape(e){e=pt(e);let n=e.slice(),o,s,i;this.dataFormat==="channelsFirst"?(o=1,s=2,i=3):(o=3,s=1,i=2);let a=this.kernelSize[0],u=this.kernelSize[1],l=this.strides[0],c=this.strides[1];return n[o]=this.filters,n[s]=au(n[s],l,a,this.padding),n[i]=au(n[i],c,u,this.padding),n}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}}return r.className="Conv2DTranspose",r})();ce.registerClass(XY);var YY=(()=>{class r extends IF{constructor(e){if(super(e),this.inputSpec=[new yr({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new Y(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=pt(e),e.length!==5)throw new Y("Input should have rank 5; Received input shape: "+JSON.stringify(e));let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new Y("The channel dimension of the inputs should be defined. Found `None`.");let o=e[n],s=this.kernelSize.concat([this.filters,o]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new yr({ndim:5,axes:{[n]:o}})],this.built=!0}call(e,n){return X(()=>{let o=He(e);if(o.shape.length!==5)throw new Y(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${o.shape.length}`);let s=o.shape,i=s[0],a,u,l;this.dataFormat==="channelsFirst"?(l=2,a=3,u=4):(l=1,a=2,u=3);let c=s[l],p=s[a],d=s[u],f=this.kernelSize[0],h=this.kernelSize[1],m=this.kernelSize[2],g=this.strides[0],y=this.strides[1],x=this.strides[2],w=au(c,g,f,this.padding),C=au(p,y,h,this.padding),I=au(d,x,m,this.padding),N=[i,w,C,I,this.filters];this.dataFormat!=="channelsLast"&&(o=ft(o,[0,2,3,4,1]));let A=MS(o,this.kernel.read(),N,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(A=ft(A,[0,4,1,2,3])),this.bias!==null&&(A=Go(A,this.bias.read(),this.dataFormat)),this.activation!==null&&(A=this.activation.apply(A)),A})}computeOutputShape(e){e=pt(e);let n=e.slice(),o,s,i,a;this.dataFormat==="channelsFirst"?(o=1,s=2,i=3,a=4):(o=4,s=1,i=2,a=3);let u=this.kernelSize[0],l=this.kernelSize[1],c=this.kernelSize[2],p=this.strides[0],d=this.strides[1],f=this.strides[2];return n[o]=this.filters,n[s]=au(n[s],p,u,this.padding),n[i]=au(n[i],d,l,this.padding),n[a]=au(n[a],f,c,this.padding),n}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}}return r.className="Conv3DTranspose",r})();ce.registerClass(YY);var TNe=(()=>{class r extends Wy{constructor(e,n){if(super(e,n),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,n.filters==null)throw new Y("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(n.kernelInitializer!=null||n.kernelRegularizer!=null||n.kernelConstraint!=null)throw new Y("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(n.padding!=null&&n.padding!=="same"&&n.padding!=="valid")throw new Y(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(n.padding)}`);this.depthMultiplier=n.depthMultiplier==null?1:n.depthMultiplier,this.depthwiseInitializer=pr(n.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=xr(n.depthwiseRegularizer),this.depthwiseConstraint=Kr(n.depthwiseConstraint),this.pointwiseInitializer=pr(n.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=xr(n.pointwiseRegularizer),this.pointwiseConstraint=Kr(n.pointwiseConstraint)}build(e){if(e=pt(e),e.length<this.rank+2)throw new Y(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null||e[n]<0)throw new Y(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[n])}`);let o=e[n],s=this.kernelSize.concat([o,this.depthMultiplier]),i=[];for(let u=0;u<this.rank;++u)i.push(1);i.push(o*this.depthMultiplier,this.filters);let a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new yr({ndim:this.rank+2,axes:{[n]:o}})],this.built=!0}call(e,n){return X(()=>{e=He(e);let o;if(this.rank===1)throw new Xe("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=ft(e,[0,2,3,1])),o=Zg(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(o=Go(o,this.bias.read(),this.dataFormat)),this.activation!=null&&(o=this.activation.apply(o)),this.dataFormat==="channelsFirst"&&(o=ft(o,[0,3,1,2])),o})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Tr(this.depthwiseInitializer),e.pointwiseInitializer=Tr(this.pointwiseInitializer),e.depthwiseRegularizer=tr(this.depthwiseRegularizer),e.pointwiseRegularizer=tr(this.pointwiseRegularizer),e.depthwiseConstraint=qr(this.depthwiseConstraint),e.pointwiseConstraint=qr(this.pointwiseConstraint),e}}return r.className="SeparableConv",r})();var ZY=(()=>{class r extends TNe{constructor(e){super(2,e)}}return r.className="SeparableConv2D",r})();ce.registerClass(ZY);var QY=(()=>{class r extends Wy{constructor(e){super(1,e),r.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!G_(e.kernelSize,"number",1,1))throw new Y(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}return r.className="Conv1D",r})();ce.registerClass(QY);var JY=(()=>{class r extends Ye{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,n){return X(()=>{if(e=He(e),this.dataFormat==="channelsLast"){let o=Ab(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Ab(o,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let o=Ab(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Ab(o,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}return r.className="Cropping2D",r})();ce.registerClass(JY);var e9=(()=>{class r extends Ye{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,$r(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,HX(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let n=e[2]==null?null:this.size[0]*e[2],o=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],n,o]}else{let n=e[1]==null?null:this.size[0]*e[1],o=e[2]==null?null:this.size[1]*e[2];return[e[0],n,o,e[3]]}}call(e,n){return X(()=>{let o=He(e),s=o.shape;if(this.dataFormat==="channelsFirst"){o=ft(o,[0,2,3,1]);let i=this.size[0]*s[2],a=this.size[1]*s[3],u=this.interpolation==="nearest"?yn.resizeNearestNeighbor(o,[i,a]):yn.resizeBilinear(o,[i,a]);return ft(u,[0,3,1,2])}else{let i=this.size[0]*s[1],a=this.size[1]*s[2];return this.interpolation==="nearest"?yn.resizeNearestNeighbor(o,[i,a]):yn.resizeBilinear(o,[i,a])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},n=super.getConfig();return Object.assign(e,n),e}}return r.className="UpSampling2D",r})();ce.registerClass(e9);function _Ne(r,t,e=[1,1],n="valid",o,s){return X(()=>{o==null&&(o=Uo()),$r(o);let i=Vb(r,o);if(r.rank!==4)throw new Y(`Input for depthwiseConv2d is required to be 4-D, but is instead ${r.rank}-D`);if(t.rank!==4)throw new Y(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=Ol(i,t,e,n==="same"?"same":"valid","NHWC",s),o==="channelsFirst"&&(i=ft(i,[0,3,1,2])),i})}var t9=(()=>{class r extends Bb{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=pr(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Kr(e.depthwiseConstraint),this.depthwiseRegularizer=xr(e.depthwiseRegularizer)}build(e){if(e=pt(e),e.length<4)throw new Y(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let n=this.dataFormat==="channelsFirst"?1:3;if(e[n]==null||e[n]<0)throw new Y(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[n]}).`);let o=e[n],s=[this.kernelSize[0],this.kernelSize[1],o,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",s,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[o*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return X(()=>{e=He(e);let o=_Ne(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(o=Go(o,this.bias.read(),this.dataFormat)),this.activation!=null&&(o=this.activation.apply(o)),o})}computeOutputShape(e){e=pt(e);let n=this.dataFormat==="channelsFirst"?e[2]:e[1],o=this.dataFormat==="channelsFirst"?e[3]:e[2],s=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=os(n,this.kernelSize[0],this.padding,this.strides[0]),a=os(o,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],s,i,a]:[e[0],i,a,s]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Tr(this.depthwiseInitializer),e.depthwiseRegularizer=tr(this.depthwiseRegularizer),e.depthwiseConstraint=qr(this.depthwiseRegularizer),e}}return r.className="DepthwiseConv2D",r})();ce.registerClass(t9);function TF(r,t,e,n){if(Array.isArray(r)){if(t!=null||e!=null)throw new Y("When inputs is an array, neither initialState or constants should be provided");n!=null&&(e=r.slice(r.length-n,r.length),r=r.slice(0,r.length-n)),r.length>1&&(t=r.slice(1,r.length)),r=r[0]}function o(s){return s==null||Array.isArray(s)?s:[s]}return t=o(t),e=o(e),{inputs:r,initialState:t,constants:e}}function _F(r,t,e,n=!1,o,s,i=!1,a=!1){return X(()=>{let u=t.shape.length;if(u<3)throw new Y(`Input should be at least 3D, but is ${u}D.`);let l=[1,0].concat(Vo(2,u));if(t=ft(t,l),s!=null)throw new Xe("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),o!=null&&(o=le(le(o,"bool"),"float32"),o.rank===u-1&&(o=Sr(o,-1)),o=ft(o,l)),n&&(t=In(t,0),o!=null&&(o=In(o,0)));let c=[],p,d=e,f=t.shape[0],h=_n(t),m;o!=null&&(m=_n(o));for(let y=0;y<f;++y){let x=h[y],w=X(()=>r(x,d));if(o==null)p=w[0],d=w[1];else{let C=X(()=>{let I=m[y],N=xe(On(I),I),A=re(B(w[0],I),B(d[0],N)),O=d.map(($,z)=>re(B(w[1][z],I),B($,N)));return{output:A,newStates:O}});p=C.output,d=C.newStates}a&&c.push(p)}let g;return a&&(g=Wr(c,1)),[p,g,d]})}var rf=(()=>{class r extends Ye{constructor(e){super(e);let n;if(e.cell==null)throw new Y("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?n=new NF({cells:e.cell}):n=e.cell,n.stateSize==null)throw new Y("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new yr({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Vo(0,e).map(n=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){e1(e)&&(e=e[0]),e=e;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);let o=n[0],s;if(this.returnSequences?s=[e[0],e[1],o]:s=[e[0],o],this.returnState){let i=[];for(let a of n)i.push([e[0],a]);return[s].concat(i)}else return s}computeMask(e,n){return X(()=>{Array.isArray(n)&&(n=n[0]);let o=this.returnSequences?n:null;if(this.returnState){let s=this.states.map(i=>null);return[o].concat(s)}else return o})}get states(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let o=0;o<e;++o)n.push(null);return n}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Xe("Constants support is not implemented in RNN yet.");e1(e)&&(e=e[0]),e=e;let o=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new yr({shape:[o,null,...s]});let i=[e[0]].concat(e.slice(2));this.cell.build(i);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!b.arraysEqual(this.stateSpec.map(u=>u.shape[u.shape.length-1]),a))throw new Y(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(u=>new yr({shape:[null,u]}));this.stateful&&this.resetStates()}resetStates(e,n=!1){X(()=>{if(!this.stateful)throw new Ys("Cannot call resetStates() on an RNN Layer that is not stateful.");let o=this.inputSpec[0].shape[0];if(o==null)throw new Y("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>er([o,s])):this.states_=[er([o,this.cell.stateSize])];else if(e==null)$e(this.states_),this.keptStates!=null&&($e(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>er([o,s])):this.states_[0]=er([o,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Y(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);n===!0?this.keptStates.push(this.states_.slice()):$e(this.states_);for(let s=0;s<this.states_.length;++s){let i=e[s],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,u=[o,a];if(!b.arraysEqual(i.shape,u))throw new Y(`State ${s} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${i.shape}`);this.states_[s]=i}}this.states_=this.states_.map(s=>Ar(s.clone()))})}apply(e,n){let o=n==null?null:n.initialState,s=n==null?null:n.constants;n==null&&(n={});let i=TF(e,o,s,this.numConstants);e=i.inputs,o=i.initialState,s=i.constants;let a=[],u=[];if(o!=null){n.initialState=o,a=a.concat(o),this.stateSpec=[];for(let c of o)this.stateSpec.push(new yr({shape:c.shape}));u=u.concat(this.stateSpec)}if(s!=null&&(n.constants=s,a=a.concat(s),this.numConstants=s.length),a[0]instanceof Eo){let c=[e].concat(a),p=this.inputSpec.concat(u),d=this.inputSpec;this.inputSpec=p;let f=super.apply(c,n);return this.inputSpec=d,f}else return super.apply(e,n)}call(e,n){return X(()=>{let o=n==null?null:n.mask,s=n==null?null:n.training,i=n==null?null:n.initialState;e=He(e),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(e));let a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==a)throw new Y(`RNN Layer has ${a} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let u={training:s},c=_F((m,g)=>{let y=this.cell.call([m].concat(g),u);return[y[0],y.slice(1)]},e,i,this.goBackwards,o,null,this.unroll,this.returnSequences),p=c[0],d=c[1],f=c[2];this.stateful&&this.resetStates(f,s);let h=this.returnSequences?d:p;return this.returnState?[h].concat(f):h})}getInitialState(e){return X(()=>{let n=er(e.shape);return n=Ie(n,[1,2]),n=Vc(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(o=>o>1?Y_(n,[1,o]):n):this.cell.stateSize>1?[Y_(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let e=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);let o=this.cell.getConfig();return this.getClassName()===r.className&&(n.cell={className:this.cell.getClassName(),config:o}),Object.assign(Object.assign(Object.assign({},o),e),n)}static fromConfig(e,n,o={}){let s=n.cell,i=Ds(s,o);return new e(Object.assign(n,{cell:i}))}}return r.className="RNN",r})();ce.registerClass(rf);var tf=class extends Ye{},EF=(()=>{class r extends tf{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,an(this.units,"units"),this.activation=iu(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=pr(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=pr(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=pr(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=xr(e.kernelRegularizer),this.recurrentRegularizer=xr(e.recurrentRegularizer),this.biasRegularizer=xr(e.biasRegularizer),this.kernelConstraint=Kr(e.kernelConstraint),this.recurrentConstraint=Kr(e.recurrentConstraint),this.biasConstraint=Kr(e.biasConstraint),this.dropout=Lh([1,ou([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Lh([1,ou([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=pt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return X(()=>{if(e=e,e.length!==2)throw new Y(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let o=e[1];e=e[0];let s=n.training==null?!1:n.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=jc({ones:()=>On(e),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=jc({ones:()=>On(o),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc}));let i,a=this.dropoutMask,u=this.recurrentDropoutMask;a!=null?i=Mi(B(e,a),this.kernel.read()):i=Mi(e,this.kernel.read()),this.bias!=null&&(i=Go(i,this.bias.read())),u!=null&&(o=B(o,u));let l=re(i,Mi(o,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){let e=super.getConfig(),n={units:this.units,activation:su(this.activation),useBias:this.useBias,kernelInitializer:Tr(this.kernelInitializer),recurrentInitializer:Tr(this.recurrentInitializer),biasInitializer:Tr(this.biasInitializer),kernelRegularizer:tr(this.kernelRegularizer),recurrentRegularizer:tr(this.recurrentRegularizer),biasRegularizer:tr(this.biasRegularizer),activityRegularizer:tr(this.activityRegularizer),kernelConstraint:qr(this.kernelConstraint),recurrentConstraint:qr(this.recurrentConstraint),biasConstraint:qr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),n)}}return r.className="SimpleRNNCell",r})();ce.registerClass(EF);var r9=(()=>{class r extends rf{constructor(e){e.cell=new EF(e),super(e)}call(e,n){return X(()=>{this.cell.dropoutMask!=null&&($e(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&($e(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let o=n==null?null:n.mask,s=n==null?null:n.training,i=n==null?null:n.initialState;return super.call(e,{mask:o,training:s,initialState:i})})}static fromConfig(e,n){return new e(n)}}return r.className="SimpleRNN",r})();ce.registerClass(r9);var kF=(()=>{class r extends tf{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new Y("GRUCell does not support reset_after parameter set to true.");this.units=e.units,an(this.units,"units"),this.activation=iu(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=iu(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=pr(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=pr(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=pr(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=xr(e.kernelRegularizer),this.recurrentRegularizer=xr(e.recurrentRegularizer),this.biasRegularizer=xr(e.biasRegularizer),this.kernelConstraint=Kr(e.kernelConstraint),this.recurrentConstraint=Kr(e.recurrentConstraint),this.biasConstraint=Kr(e.biasConstraint),this.dropout=Lh([1,ou([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Lh([1,ou([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=pt(e);let n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return X(()=>{if(e=e,e.length!==2)throw new Y(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let o=n.training==null?!1:n.training,s=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=jc({ones:()=>On(e),rate:this.dropout,training:o,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=jc({ones:()=>On(s),rate:this.recurrentDropout,training:o,count:3,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,a=this.recurrentDropoutMask,u,l,c;0<this.dropout&&this.dropout<1&&(e=B(e,i[0]));let p=Mi(e,this.kernel.read());this.useBias&&(p=Go(p,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=B(s,a[0]));let d=this.recurrentKernel.read(),[f,h]=Tn(d,[2*this.units,this.units],d.rank-1),m=Mi(s,f),[g,y,x]=Tn(p,3,p.rank-1),[w,C]=Tn(m,2,m.rank-1);u=this.recurrentActivation.apply(re(g,w)),l=this.recurrentActivation.apply(re(y,C));let I=Mi(B(l,s),h);c=this.activation.apply(re(x,I));let N=re(B(u,s),B(re(1,yt(u)),c));return[N,N]})}getConfig(){let e=super.getConfig(),n={units:this.units,activation:su(this.activation),recurrentActivation:su(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Tr(this.kernelInitializer),recurrentInitializer:Tr(this.recurrentInitializer),biasInitializer:Tr(this.biasInitializer),kernelRegularizer:tr(this.kernelRegularizer),recurrentRegularizer:tr(this.recurrentRegularizer),biasRegularizer:tr(this.biasRegularizer),activityRegularizer:tr(this.activityRegularizer),kernelConstraint:qr(this.kernelConstraint),recurrentConstraint:qr(this.recurrentConstraint),biasConstraint:qr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),n)}}return r.className="GRUCell",r})();ce.registerClass(kF);var n9=(()=>{class r extends rf{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new kF(e),super(e)}call(e,n){return X(()=>{this.cell.dropoutMask!=null&&($e(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&($e(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let o=n==null?null:n.mask,s=n==null?null:n.training,i=n==null?null:n.initialState;return super.call(e,{mask:o,training:s,initialState:i})})}static fromConfig(e,n){return n.implmentation===0&&(n.implementation=1),new e(n)}}return r.className="GRU",r})();ce.registerClass(n9);var Ub=(()=>{class r extends tf{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,an(this.units,"units"),this.activation=iu(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=iu(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=pr(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=pr(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=pr(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=xr(e.kernelRegularizer),this.recurrentRegularizer=xr(e.recurrentRegularizer),this.biasRegularizer=xr(e.biasRegularizer),this.kernelConstraint=Kr(e.kernelConstraint),this.recurrentConstraint=Kr(e.recurrentConstraint),this.biasConstraint=Kr(e.biasConstraint),this.dropout=Lh([1,ou([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Lh([1,ou([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var n;e=pt(e);let o=e[e.length-1];this.kernel=this.addWeight("kernel",[o,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let s;if(this.useBias){if(this.unitForgetBias){let i=this.biasInitializer,a=this.units;s=new(n=class extends Wo{apply(l,c){let p=i.apply([a]),d=new J_().apply([a]),f=i.apply([a*2]);return tF(tF(p,d),f)}},n.className="CustomInit",n)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,n){return X(()=>{let o=n.training==null?!1:n.training;if(e=e,e.length!==3)throw new Y(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let s=e[1],i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=jc({ones:()=>On(e),rate:this.dropout,training:o,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=jc({ones:()=>On(s),rate:this.recurrentDropout,training:o,count:4,dropoutFunc:this.dropoutFunc}));let a=this.dropoutMask,u=this.recurrentDropoutMask,l,c,p,d;0<this.dropout&&this.dropout<1&&(e=B(e,a[0]));let f=Mi(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=B(s,u[0])),f=re(f,Mi(s,this.recurrentKernel.read())),this.useBias&&(f=Go(f,this.bias.read()));let[h,m,g,y]=Tn(f,4,f.rank-1);l=this.recurrentActivation.apply(h),c=this.recurrentActivation.apply(m),p=re(B(c,i),B(l,this.activation.apply(g))),d=this.recurrentActivation.apply(y);let x=B(d,this.activation.apply(p));return[x,x,p]})}getConfig(){let e=super.getConfig(),n={units:this.units,activation:su(this.activation),recurrentActivation:su(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Tr(this.kernelInitializer),recurrentInitializer:Tr(this.recurrentInitializer),biasInitializer:Tr(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:tr(this.kernelRegularizer),recurrentRegularizer:tr(this.recurrentRegularizer),biasRegularizer:tr(this.biasRegularizer),activityRegularizer:tr(this.activityRegularizer),kernelConstraint:qr(this.kernelConstraint),recurrentConstraint:qr(this.recurrentConstraint),biasConstraint:qr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),n)}}return r.className="LSTMCell",r})();ce.registerClass(Ub);var o9=(()=>{class r extends rf{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Ub(e),super(e)}call(e,n){return X(()=>{this.cell.dropoutMask!=null&&($e(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&($e(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let o=n==null?null:n.mask,s=n==null?null:n.training,i=n==null?null:n.initialState;return super.call(e,{mask:o,training:s,initialState:i})})}static fromConfig(e,n){return n.implmentation===0&&(n.implementation=1),new e(n)}}return r.className="LSTM",r})();ce.registerClass(o9);var NF=(()=>{class r extends tf{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let n of this.cells.slice().reverse())Array.isArray(n.stateSize)?e.push(...n.stateSize):e.push(n.stateSize);return e}call(e,n){return X(()=>{e=e;let o=e.slice(1),s=[];for(let u of this.cells.slice().reverse())Array.isArray(u.stateSize)?s.push(o.splice(0,u.stateSize.length)):s.push(o.splice(0,1));s.reverse();let i=[],a;for(let u=0;u<this.cells.length;++u){let l=this.cells[u];o=s[u],u===0?a=[e[0]].concat(o):a=[a[0]].concat(o),a=l.call(a,n),i.push(a.slice(1))}o=[];for(let u of i.slice().reverse())o.push(...u);return[a[0]].concat(o)})}build(e){e1(e)&&(e=e[0]),e=e;let n;this.cells.forEach((o,s)=>{nu(`RNNCell_${s}`,()=>{o.build(e),Array.isArray(o.stateSize)?n=o.stateSize[0]:n=o.stateSize,e=[e[0],n]})}),this.built=!0}getConfig(){let e=super.getConfig(),n=i=>({className:i.getClassName(),config:i.getConfig()}),s={cells:this.cells.map(n)};return Object.assign(Object.assign({},e),s)}static fromConfig(e,n,o={}){let s=[];for(let i of n.cells)s.push(Ds(i,o));return new e({cells:s})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let n of this.cells)e.push(...n.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let n of this.cells)e.push(...n.nonTrainableWeights);if(!this.trainable){let n=[];for(let o of this.cells)n.push(...o.trainableWeights);return n.concat(e)}return e}getWeights(){let e=[];for(let n of this.cells)e.push(...n.weights);return Ob(e)}setWeights(e){let n=[];for(let o of this.cells){let s=o.weights.length,i=e.splice(s);for(let a=0;a<o.weights.length;++a)n.push([o.weights[a],i[a]])}zy(n)}}return r.className="StackedRNNCells",r})();ce.registerClass(NF);function jc(r){let{ones:t,rate:e,training:n=!1,count:o=1,dropoutFunc:s}=r,i=()=>s!=null?s(t(),e):Q_(t(),e),a=()=>Qd(i,t,n);return!o||o<=1?Ar(a().clone()):Array(o).fill(void 0).map(a).map(l=>Ar(l.clone()))}var ENe=function(r,t){var e={};for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&t.indexOf(n)<0&&(e[n]=r[n]);if(r!=null&&typeof Object.getOwnPropertySymbols=="function")for(var o=0,n=Object.getOwnPropertySymbols(r);o<n.length;o++)t.indexOf(n[o])<0&&Object.prototype.propertyIsEnumerable.call(r,n[o])&&(e[n[o]]=r[n[o]]);return e};var kNe=(()=>{class r extends rf{constructor(e){if(e.unroll)throw new Xe("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Xe("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new yr({ndim:5})]}call(e,n){return X(()=>{if(this.cell.dropoutMask!=null&&($e(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&($e(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),n&&n.constants)throw new Y("ConvRNN2D cell does not support constants");let o=n==null?null:n.mask,s=n==null?null:n.training,i=n==null?null:n.initialState;return super.call(e,{mask:o,training:s,initialState:i})})}computeOutputShape(e){let n=this.computeSingleOutputShape(e);return this.returnSequences||(n=[n[0],...n.slice(2)]),this.returnState&&(n=[n,...Array(2).fill([e[0],...n.slice(-3)])]),n}getInitialState(e){return X(()=>{let{stateSize:n}=this.cell,o=e.shape,s=this.computeSingleOutputShape(o),i=[s[0],...s.slice(2)],a=er(i);return Array.isArray(n)?Array(n.length).fill(a):[a]})}resetStates(e,n=!1){X(()=>{if(!this.stateful)throw new Ys("Cannot call resetStates() on an RNN Layer that is not stateful.");let o=this.inputSpec[0].shape,s=this.computeSingleOutputShape(o),i=[s[0],...s.slice(2)];if(o[0]==null)throw new Y("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>er(i)):this.states_=[er(i)];else if(e==null)$e(this.states_),this.keptStates!=null&&($e(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>er(i)):this.states_[0]=er(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Y(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);n?this.keptStates.push(this.states_.slice()):$e(this.states_);for(let u=0;u<this.states_.length;++u){let l=e[u],c=i;if(!b.arraysEqual(l.shape,c))throw new Y(`State ${u} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${l.shape}`);this.states_[u]=l}}this.states_=this.states_.map(u=>Ar(u.clone()))})}computeSingleOutputShape(e){let{dataFormat:n,filters:o,kernelSize:s,padding:i,strides:a,dilationRate:u}=this.cell,l=n==="channelsFirst",c=e[l?3:2],p=e[l?4:3],d=os(c,s[0],i,a[0],u[0]),f=os(p,s[1],i,a[1],u[1]);return[...e.slice(0,2),...l?[o,d,f]:[d,f,o]]}}return r.className="ConvRNN2D",r})(),DF=(()=>{class r extends Ub{constructor(e){let{filters:n,kernelSize:o,strides:s,padding:i,dataFormat:a,dilationRate:u}=e;super(Object.assign(Object.assign({},e),{units:n})),this.filters=n,an(this.filters,"filters"),this.kernelSize=ef(o,2,"kernelSize"),this.kernelSize.forEach(l=>an(l,"kernelSize")),this.strides=ef(s||1,2,"strides"),this.strides.forEach(l=>an(l,"strides")),this.padding=i||"valid",Bo(this.padding),this.dataFormat=a||"channelsLast",$r(this.dataFormat),this.dilationRate=ef(u||1,2,"dilationRate"),this.dilationRate.forEach(l=>an(l,"dilationRate"))}build(e){var n;e=pt(e);let o=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[o]==null)throw new Y(`The channel dimension of the input should be defined. Found ${e[o]}`);let s=e[o],i=4,a=this.kernelSize.concat([s,this.filters*i]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let u=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",u,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){let c=this.biasInitializer,p=this.filters;l=new(n=class extends Wo{apply(f,h){let m=c.apply([p]),g=hn([p]),y=c.apply([p*2]);return Fy([m,g,y])}},n.className="CustomInit",n)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,n){return X(()=>{if(e.length!==3)throw new Y(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let o=n.training||!1,s=e[0],i=e[1],a=e[2],u=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=jc({ones:()=>On(s),rate:this.dropout,training:o,count:u,dropoutFunc:this.dropoutFunc}));let l=this.dropoutMask,c=(ge,Se,be)=>!Se||!Se[be]?ge:B(Se[be],ge),p=c(s,l,0),d=c(s,l,1),f=c(s,l,2),h=c(s,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=jc({ones:()=>On(i),rate:this.recurrentDropout,training:o,count:u,dropoutFunc:this.dropoutFunc}));let m=this.recurrentDropoutMask,g=c(i,m,0),y=c(i,m,1),x=c(i,m,2),w=c(i,m,3),C=3,[I,N,A,O]=Tn(this.kernel.read(),u,C),[$,z,G,K]=this.useBias?Tn(this.bias.read(),u):[null,null,null,null];p=this.inputConv(p,I,$,this.padding),d=this.inputConv(d,N,z,this.padding),f=this.inputConv(f,A,G,this.padding),h=this.inputConv(h,O,K,this.padding);let[Z,Q,J,te]=Tn(this.recurrentKernel.read(),u,C);g=this.recurrentConv(g,Z),y=this.recurrentConv(y,Q),x=this.recurrentConv(x,J),w=this.recurrentConv(w,te);let ie=this.recurrentActivation.apply(re(p,g)),ne=this.recurrentActivation.apply(re(d,y)),ae=re(B(ne,a),B(ie,this.activation.apply(re(f,x)))),ye=B(this.recurrentActivation.apply(re(h,w)),this.activation.apply(ae));return[ye,ye,ae]})}getConfig(){let e=super.getConfig(),{units:n}=e,o=ENe(e,["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},o),s)}inputConv(e,n,o,s){let i=Jo(e,n,this.strides,s||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return o?Go(i,o,this.dataFormat):i}recurrentConv(e,n){return Jo(e,n,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}return r.className="ConvLSTM2DCell",r})();ce.registerClass(DF);var s9=(()=>{class r extends kNe{constructor(e){let n=new DF(e);super(Object.assign(Object.assign({},e),{cell:n}))}static fromConfig(e,n){return new e(n)}}return r.className="ConvLSTM2D",r})();ce.registerClass(s9);var AF=(()=>{class r extends Ye{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let n=e.shape,o=[];for(let s=0;s<this.noiseShape.length;++s)o.push(this.noiseShape[s]==null?n[s]:this.noiseShape[s]);return o}call(e,n){return X(()=>{this.invokeCallHook(e,n);let o=He(e);if(0<this.rate&&this.rate<1){let s=n.training==null?!1:n.training,i=this.getNoiseShape(o);return Qd(()=>Q_(o,this.rate,i,this.seed),()=>o,s)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},n=super.getConfig();return Object.assign(e,n),e}dispose(){return super.dispose()}}return r.className="Dropout",r})();ce.registerClass(AF);var i9=(()=>{class r extends AF{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let n=e.shape;return[n[0],1,n[2]]}}return r.className="SpatialDropout1D",r})();ce.registerClass(i9);var a9=(()=>{class r extends Ye{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let n=null;e.batchSize!=null&&(n=e.batchSize),this.batchInputShape=[n,e.inputDim]}this.units=e.units,an(this.units,"units"),this.activation=iu(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=pr(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=pr(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Kr(e.kernelConstraint),this.biasConstraint=Kr(e.biasConstraint),this.kernelRegularizer=xr(e.kernelRegularizer),this.biasRegularizer=xr(e.biasRegularizer),this.activityRegularizer=xr(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=pt(e);let n=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:n}}],this.built=!0}computeOutputShape(e){e=pt(e);let n=e.slice();return n[n.length-1]=this.units,n}call(e,n){return X(()=>{this.invokeCallHook(e,n);let o=He(e),s=W_(this.activation.getClassName()),i;return s!=null?i=Mi(o,this.kernel.read(),s,this.bias?this.bias.read():null):(i=Mi(o,this.kernel.read()),this.bias!=null&&(i=Go(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){let e={units:this.units,activation:su(this.activation),useBias:this.useBias,kernelInitializer:Tr(this.kernelInitializer),biasInitializer:Tr(this.biasInitializer),kernelRegularizer:tr(this.kernelRegularizer),biasRegularizer:tr(this.biasRegularizer),activityRegularizer:tr(this.activityRegularizer),kernelConstraint:qr(this.kernelConstraint),biasConstraint:qr(this.biasConstraint)},n=super.getConfig();return Object.assign(e,n),e}}return r.className="Dense",r})();ce.registerClass(a9);var u9=(()=>{class r extends Ye{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=pt(e);for(let n of e.slice(1))if(n==null)throw new Y(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Oi(e,1)]}call(e,n){return X(()=>{this.invokeCallHook(e,n);let o=He(e);if(this.dataFormat==="channelsFirst"&&o.rank>1){let s=[0];for(let i=2;i<o.rank;++i)s.push(i);s.push(1),o=ft(o,s)}return ZX(o)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let n=super.getConfig();return Object.assign(e,n),e}}return r.className="Flatten",r})();ce.registerClass(u9);var l9=(()=>{class r extends Ye{constructor(e){super(e),this.supportsMasking=!0,this.activation=iu(e.activation)}call(e,n){return X(()=>{this.invokeCallHook(e,n);let o=He(e);return this.activation.apply(o)})}getConfig(){let e={activation:su(this.activation)},n=super.getConfig();return Object.assign(e,n),e}}return r.className="Activation",r})();ce.registerClass(l9);var c9=(()=>{class r extends Ye{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,n){return X(()=>(e=He(e),XX(e,this.n)))}getConfig(){let e={n:this.n},n=super.getConfig();return Object.assign(e,n),e}}return r.className="RepeatVector",r})();ce.registerClass(c9);var p9=(()=>{class r extends Ye{constructor(e){super(e),this.targetShape=e.targetShape;for(let n=0;n<this.targetShape.length;++n)this.isUnknown(this.targetShape[n])&&(this.targetShape[n]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,n){let o="Total size of new array must be unchanged.",s=n.slice(),i=1,a=null;for(let l=0;l<s.length;++l){let c=s[l];if(this.isUnknown(c))if(a===null)a=l;else throw new Y("Can only specifiy one unknown dimension.");else i*=c}let u=Oi(e);if(a!==null){if(i===0||u%i!==0)throw new Y(o);s[a]=u/i}else if(u!==i)throw new Y(o);return s}computeOutputShape(e){let n=!1;for(let o=0;o<e.length;++o)if(this.isUnknown(e[o])){n=!0;break}return n?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,n){return X(()=>{this.invokeCallHook(e,n);let o=He(e),s=o.shape,i=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return V(o,i)})}getConfig(){let e={targetShape:this.targetShape},n=super.getConfig();return Object.assign(e,n),e}}return r.className="Reshape",r})();ce.registerClass(p9);var d9=(()=>{class r extends Ye{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let n=Vo(1,e.dims.length+1);if(!b.arraysEqual(e.dims.slice().sort(),n))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new yr({ndim:this.dims.length+1})]}computeOutputShape(e){e=pt(e);let n=e.slice();return this.dims.forEach((o,s)=>{n[s+1]=e[o]}),n}call(e,n){return ft(He(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},n=super.getConfig();return Object.assign(e,n),e}}return r.className="Permute",r})();ce.registerClass(d9);var f9=(()=>{class r extends Ye{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),n={maskValue:this.maskValue};return Object.assign(n,e),n}computeMask(e,n){let o=He(e);return hh(Xa(o,this.maskValue),-1)}call(e,n){return X(()=>{this.invokeCallHook(e,n);let o=He(e),a=hh(Xa(o,this.maskValue),-1,!0);return B(o,le(a,o.dtype))})}}return r.className="Masking",r})();ce.registerClass(f9);var h9=(()=>{class r extends Ye{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let n=null;e.batchSize!=null&&(n=e.batchSize),e.inputLength==null?this.batchInputShape=[n,null]:this.batchInputShape=[n].concat(Yt(e.inputLength))}this.inputDim=e.inputDim,an(this.inputDim,"inputDim"),this.outputDim=e.outputDim,an(this.outputDim,"outputDim"),this.embeddingsInitializer=pr(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=xr(e.embeddingsRegularizer),this.activityRegularizer=xr(e.activityRegularizer),this.embeddingsConstraint=Kr(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,n){return X(()=>this.maskZero?(e=He(e),Xa(e,je(e))):null)}computeOutputShape(e){if(e=pt(e),this.inputLength==null)return[...e,this.outputDim];let n=Yt(this.inputLength);if(n.length!==e.length-1)throw new Y(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let o=0;for(let s=0;s<n.length;++s){let i=n[s],a=e[s+1];if(i!=null&&a!=null&&i!==a)throw new Y(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);i==null&&(n[o]=a),o++}}return[e[0],...n,this.outputDim]}call(e,n){return X(()=>{this.invokeCallHook(e,n);let o=He(e);o.dtype!=="int32"&&(o=_o(o,"int32"));let s=Z_(this.embeddings.read(),V(o,[o.size]));return V(s,pt(this.computeOutputShape(o.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Tr(this.embeddingsInitializer),embeddingsRegularizer:tr(this.embeddingsRegularizer),activityRegularizer:tr(this.activityRegularizer),embeddingsConstraint:qr(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},n=super.getConfig();return Object.assign(e,n),e}}return r.className="Embedding",r})();ce.registerClass(h9);var Hc=class extends Ye{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new Xe}computeElementwiseOpOutputShape(t,e){if(t==null||e==null)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(e.length===0)return t;let n=t.slice(0,t.length-e.length);for(let o=0;o<e.length;++o){let s=t[t.length-e.length+o],i=e[o];if(s==null||i==null||s<0||i<0)n.push(null);else if(s===1)n.push(i);else if(i===1)n.push(s);else{if(s!==i)throw new Y("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(s)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[pt(t)]),t=t,t.length<2)throw new Y(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(let s of t)s!=null&&s[0]!==null&&e.push(s[0]);if(e=Ri(e),e.length>1)throw new Y(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let n=t[0]==null?null:t[0].slice(1);for(let s=1;s<t.length;++s){let i=t[s]==null?null:t[s].slice(1);n=this.computeElementwiseOpOutputShape(n,i)}let o=t.map(s=>s.length);t.indexOf(null)===-1&&Ri(o).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return X(()=>{if(t=t,this.reshapeRequired){let n=[],o=t.map(s=>s.rank);if(o.indexOf(null)===-1){let s=ou(o);for(let i of t){let a=i.rank;for(let u=0;u<s-a;++u)i=Vc(i,1);n.push(i)}return this.mergeFunction(n)}else{let s=!1;for(let u of t){let l=u.rank;if(l==null){let c=u.shape,p=c[0],d=c.slice(1).concat([p]),f=V(u,[p].concat(Oi(c.slice(1))));f=ft(f,[1,0]),f=V(f,d),n.push(f),s=!0}else if(l>1){let c=Vo(1,l).concat([0]);n.push(ft(u,c)),s=!0}else n.push(u)}let i=this.mergeFunction(n),a=i.rank;if(s){if(a==null){let u=i.shape,l=u.length,c=u[l-1],p=[c].concat(u.slice(0,u.length-1));i=V(ft(V(i,[-1,c]),[1,0]),p)}else if(a>1){let u=[a-1].concat(Vo(0,a-1));i=ft(i,u)}}return i}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let e;t[0]==null?e=null:e=t[0].slice(1);for(let o=1;o<t.length;++o){let s=t[o]==null?null:t[o].slice(1);e=this.computeElementwiseOpOutputShape(e,s)}let n=[];for(let o of t)o!=null&&o[0]!==null&&n.push(o[0]);return n=Ri(n),n.length===1?e=n.concat(e):e=[null].concat(e),e}computeMask(t,e){return X(()=>{if(e==null)return null;if(!Array.isArray(e))throw new Y("`mask` should be an Array");if(!Array.isArray(t))throw new Y("`inputs` should be an Array");if(e.length!==t.length)throw new Y(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(o=>o==null))return null;e=e.map(o=>o==null?o:Sr(o,0));let n=e[0];for(let o=1;o<e.length-1;++o)n=ao(n,e[o]);return n})}},m9=(()=>{class r extends Hc{constructor(e){super(e)}mergeFunction(e){return X(()=>{let n=e[0].clone();for(let o=1;o<e.length;++o)n=re(n,e[o]);return n})}}return r.className="Add",r})();ce.registerClass(m9);var g9=(()=>{class r extends Hc{constructor(e){super(e)}mergeFunction(e){return X(()=>{let n=e[0].clone();for(let o=1;o<e.length;++o)n=B(n,e[o]);return n})}}return r.className="Multiply",r})();ce.registerClass(g9);var y9=(()=>{class r extends Hc{constructor(e){super(e)}mergeFunction(e){return X(()=>{let n=e[0].clone();for(let o=1;o<e.length;++o)n=re(n,e[o]);return B(1/e.length,n)})}}return r.className="Average",r})();ce.registerClass(y9);var x9=(()=>{class r extends Hc{constructor(e){super(e)}mergeFunction(e){return X(()=>{let n=e[0];for(let o=1;o<e.length;++o)n=ts(n,e[o]);return n})}}return r.className="Maximum",r})();ce.registerClass(x9);var v9=(()=>{class r extends Hc{constructor(e){super(e)}mergeFunction(e){return X(()=>{let n=e[0];for(let o=1;o<e.length;++o)n=rs(n,e[o]);return n})}}return r.className="Minimum",r})();ce.registerClass(v9);var b9=(()=>{class r extends Hc{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new Y("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let n=!0;for(let s of e)if(s!=null){n=!1;break}if(n)return;let o=[];for(let s=0;s<e.length;++s){let i=e[s].slice();i.splice(this.axis,1);let a=!1;for(let u of o)if(b.arraysEqual(u,i)){a=!0;break}a||o.push(i)}if(o.length>1)throw new Y("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return X(()=>Fy(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new Y("A `Concatenate` layer should be called on a list of inputs.");let n=e,o=n[0].slice(),s=this.axis<0?o.length+this.axis:this.axis;for(let i of n.slice(1)){if(o[s]==null||i[s]==null){o[s]=null;break}o[s]+=i[s]}return o}computeMask(e,n){if(n==null)return null;if(!Array.isArray(n))throw new Y("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new Y("`inputs` should be an array for Concatenate");if(n.length!==e.length)throw new Y(`Mismatch in the length of mask (${n.length}) and the legnth of inputs (${e.length})`);return X(()=>{let o=!0;if(n.forEach(a=>{if(a!=null){o=!1;return}}),o)return null;let s=[];for(let a=0;a<e.length;++a)n[a]==null?s.push(le(On(e[a]),"bool")):n[a].rank<e[a].rank?s.push(Sr(n[a],-1)):s.push(n[a]);let i=Dt(s,this.axis);return $g(i,-1,!1)})}getConfig(){let e={axis:this.axis},n=super.getConfig();return Object.assign(e,n),e}}return r.className="Concatenate",r})();ce.registerClass(b9);function Gb(r,t){for(;r<0;)r+=t;return r}function NNe(r,t,e){if(r.shape.length>3||t.shape.length>3)throw new Xe("batchDot is not implemented for tensors of 4D or higher rank yet");if(b.assert(r.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${r.shape.length}`),b.assert(r.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof e=="number"&&(e=[e,e]),r.dtype==="complex64"||t.dtype==="complex64")throw new Xe("batchDot is not implemented for complex64-type Tensors yet.");let n=r.shape.length,o=t.shape.length;e==null&&(e=[n-1,o-2]);let s=e;return X(()=>{let i;if(n>o){i=n-o;let u=[];for(let l=0;l<i;++l)u.push(1);t=V(t,t.shape.concat(u))}else if(o>n){i=o-n;let u=[];for(let l=0;l<i;++l)u.push(1);r=V(r,r.shape.concat(u))}else i=0;let a;if(r.shape.length===2&&t.shape.length===2)s[0]===s[1]?a=Ie(B(r,t),s[0]):a=Ie(B(ft(r,[1,0]),t),s[1]);else{let u=s[0]!==r.shape.length-1,l=s[1]===t.shape.length-1;a=dt(r,t,u,l)}if(i>0){let u;n>o?u=n+o-3:u=n-1;let l=[];for(let c=u;c<u+i;++c)l.push(c);a=Rt(a,l)}return a.shape.length===1&&(a=Sr(a,1)),a})}var w9=(()=>{class r extends Hc{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){b.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let n=e[0],o=e[1];if(n.length>3||o.length>3)throw new Xe("Dot layer does not support tensors of 4D or higher rank yet.");let s=this.interpretAxes(n,o);if(n[s[0]]!==o[s[1]])throw new Y(`Dimension incompatibility: ${n[s[0]]} !== ${o[s[1]]}`)}mergeFunction(e){if(e.length!==2)throw new Y(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let n=e[0],o=e[1],s;return Array.isArray(this.axes)?s=this.axes.map((i,a)=>Gb(i,e[a].shape.length)):s=[Gb(this.axes,n.shape.length),Gb(this.axes,o.shape.length)],this.normalize&&(n=Mb(n,s[0]),o=Mb(o,s[1])),NNe(n,o,s)}interpretAxes(e,n){let o;return Array.isArray(this.axes)?o=this.axes:o=[Gb(this.axes,e.length),Gb(this.axes,n.length)],o}computeOutputShape(e){b.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let n=e[0].slice(),o=e[1].slice();if(n.length>3||o.length>3)throw new Xe("Dot layer does not support tensors of 4D or higher rank yet.");let s=this.interpretAxes(n,o);n.splice(s[0],1),o.splice(s[1],1),o.splice(0,1);let i=n.concat(o);return i.length===1&&i.push(1),i}computeMask(e,n){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},n=super.getConfig();return Object.assign(e,n),e}}return r.className="Dot",r})();ce.registerClass(w9);var C9=(()=>{class r extends Ye{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),n={stddev:this.stddev};return Object.assign(n,e),n}call(e,n){return X(()=>{this.invokeCallHook(e,n);let o=He(e);return Qd(()=>re($y(o.shape,0,this.stddev),o),()=>o,n.training||!1)})}}return r.className="GaussianNoise",r})();ce.registerClass(C9);var S9=(()=>{class r extends Ye{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),n={rate:this.rate};return Object.assign(n,e),n}call(e,n){return X(()=>{this.invokeCallHook(e,n);let o=He(e);return this.rate>0&&this.rate<1?Qd(()=>{let i=Math.sqrt(this.rate/(1-this.rate));return B(o,$y(o.shape,1,i))},()=>o,n.training||!1):o})}}return r.className="GaussianDropout",r})();ce.registerClass(S9);var I9=(()=>{class r extends Ye{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||He(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),n={rate:this.rate};return Object.assign(n,e),n}call(e,n){return X(()=>{if(this.rate<1&&this.rate>0){let o=this._getNoiseShape(e);return Qd(()=>{let i=He(e),l=-1.6732632423543772*1.0507009873554805,c=$o(Cs(o),this.rate);c=_o(c,"float32");let p=((1-this.rate)*(1+this.rate*l**2))**-.5,d=-p*l*this.rate,f=re(B(i,c),B(re(c,-1),l));return re(B(f,p),d)},()=>He(e),n.training||!1)}return e})}}return r.className="AlphaDropout",r})();ce.registerClass(I9);function Wb(r,t,e,n,o,s=.001){let i;if(r.rank===2)i=SS(r,t,e,n,o,s);else if(r.rank===3)i=IS(r,t,e,n,o,s);else if(r.rank===4)i=TS(r,t,e,n,o,s);else throw new Xe(`batchNormalization is not implemented for array of rank ${r.rank} yet`);return i}function DNe(r,t,e,n,o=.001){return X(()=>{let s=xh(r,n),i=s.mean,a=s.variance;return[Wb(r,i,a,e,t,o),i,a]})}function ANe(r,t,e,n,o=.001){return X(()=>{let s=xh(r,n),i=s.mean,a=s.variance,u=[];for(let h of Vo(0,r.rank))n.indexOf(h)!==-1?u.push(1):u.push(r.shape[h]);let l=V(i,u),c=V(a,u),p=t==null?null:V(t,u),d=e==null?null:V(e,u);return[Wb(r,l,c,d,p,o),i,a]})}function RNe(r,t,e,n,o=.001){return b.arraysEqual(n.slice().sort(),Vo(0,r.rank-1))?DNe(r,t,e,n,o):ANe(r,t,e,n,o)}var T9=(()=>{class r extends Ye{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=pr(e.betaInitializer||"zeros"),this.gammaInitializer=pr(e.gammaInitializer||"ones"),this.movingMeanInitializer=pr(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=pr(e.movingVarianceInitializer||"ones"),this.betaConstraint=Kr(e.betaConstraint),this.gammaConstraint=Kr(e.gammaConstraint),this.betaRegularizer=xr(e.betaRegularizer),this.gammaRegularizer=xr(e.gammaRegularizer)}build(e){e=pt(e);let n=this.axis>=0?this.axis:this.axis+e.length,o=e[n];if(o==null)throw new Y(`Axis ${n} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new yr({ndim:e.length,axes:{[n]:o}})];let s=[o];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,n){return X(()=>{let o=n.training==null?!1:n.training,s=He(e),i=s.shape,a=i.length,u=Vo(0,a),l=this.axis>=0?this.axis:this.axis+a;u.splice(l,1);let c=Di(1,a);c[l]=i[l];let p=u.slice();p.sort();let d=!b.arraysEqual(p,Vo(0,a).slice(0,a-1)),f=()=>{if(d){let w=V(this.movingMean.read(),c),C=V(this.movingVariance.read(),c),I=this.center?V(this.beta.read(),c):null,N=this.scale?V(this.gamma.read(),c):null;return Wb(s,w,C,I,N,this.epsilon)}else return Wb(s,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!o)return f();let[h,m,g]=RNe(s,this.gamma.read(),this.beta.read(),u,this.epsilon),y=(w,C,I)=>{X(()=>{let N=1-I,A=w.read(),O=B(xe(A,C),N);w.write(xe(A,O))})};return(()=>{y(this.movingMean,m,this.momentum),y(this.movingVariance,g,this.momentum)})(),h})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Tr(this.betaInitializer),gammaInitializer:Tr(this.gammaInitializer),movingMeanInitializer:Tr(this.movingMeanInitializer),movingVarianceInitializer:Tr(this.movingVarianceInitializer),betaRegularizer:tr(this.betaRegularizer),gammaRegularizer:tr(this.gammaRegularizer),betaConstraint:qr(this.betaConstraint),gammaConstraint:qr(this.gammaConstraint)},n=super.getConfig();return Object.assign(e,n),e}}return r.className="BatchNormalization",r})();ce.registerClass(T9);var _9=(()=>{class r extends Ye{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let n of this.axis)if(!Number.isInteger(n))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=pr(e.betaInitializer||"zeros"),this.gammaInitializer=pr(e.gammaInitializer||"ones"),this.betaRegularizer=xr(e.betaRegularizer),this.gammaRegularizer=xr(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=pt(e);let n=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=n);for(let i of this.axis)if(i<0||i>=n)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==Ri(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let o=this.axis.map(i=>e[i]),s=!0;this.scale?this.gamma=this.addWeight("gamma",o,"float32",this.gammaInitializer,this.gammaRegularizer,s):this.gamma=null,this.center?this.beta=this.addWeight("beta",o,"float32",this.betaInitializer,this.betaRegularizer,s):this.beta=null,this.built=!0}call(e,n){let o=He(e),s=o.shape,i=s.length;return X(()=>{let{mean:u,variance:l}=xh(o,this.axis,!0),c=Di(1,i);for(let g of this.axis)c[g]=s[g];let p=g=>g!=null&&g.shape.length!==i?V(g,c):g,d=this.scale?p(this.gamma.read()):null,f=this.center?p(this.beta.read()):null,h=[],m=[];for(let g=0;g<i;++g)this.axis.indexOf(g)!==-1?(h.push(s[g]),m.push(1)):(h.push(1),m.push(s[g]));return u=eo(u,h),l=eo(l,h),d!=null&&(d=eo(d,m)),f!=null&&(f=eo(f,m)),Wb(o,u,l,f,d,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Tr(this.betaInitializer),gammaInitializer:Tr(this.gammaInitializer),betaRegularizer:tr(this.betaRegularizer),gammaRegularizer:tr(this.gammaRegularizer)},n=super.getConfig();return Object.assign(e,n),e}}return r.className="LayerNormalization",r})();ce.registerClass(_9);function ONe(r,t,e){return X(()=>{if(r.rank!==4)throw new Y(`temporalPadding expects input tensor to be 4-D, but received a ${r.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new Y("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(e==null&&(e=Uo()),e!=="channelsLast"&&e!=="channelsFirst")throw new Y(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let n;return e==="channelsFirst"?n=[[0,0],[0,0],t[0],t[1]]:n=[[0,0],t[0],t[1],[0,0]],Vn(r,n)})}var E9=(()=>{class r extends Ye{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Uo():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new Y(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let n,o;if(typeof e.padding[0]=="number")n=[e.padding[0],e.padding[0]],o=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new Y(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(n=e.padding[0],e.padding[1].length!==2)throw new Y(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);o=e.padding[1]}this.padding=[n,o]}this.inputSpec=[new yr({ndim:4})]}computeOutputShape(e){e=pt(e);let n,o;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?n=e[2]+this.padding[0][0]+this.padding[0][1]:n=null,e[3]!=null&&e[3]>=0?o=e[3]+this.padding[1][0]+this.padding[1][1]:o=null,[e[0],e[1],n,o]):(e[1]!=null&&e[1]>=0?n=e[1]+this.padding[0][0]+this.padding[0][1]:n=null,e[2]!=null&&e[2]>=0?o=e[2]+this.padding[1][0]+this.padding[1][1]:o=null,[e[0],n,o,e[3]])}call(e,n){return X(()=>ONe(He(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}return r.className="ZeroPadding2D",r})();ce.registerClass(E9);function N1(r,t,e,n,o,s){return X(()=>{$r(o),ZM(s),Bo(n),e==null&&(e=[1,1]),n==null&&(n="valid"),o==null&&(o=Uo()),s==null&&(s="max"),r=Vb(r,o);let i,a=n==="same"?"same":"valid";return s==="max"?i=$d(r,t,e,a):i=Ed(r,t,e,a),o==="channelsFirst"&&(i=ft(i,[0,3,1,2])),i})}function k9(r,t,e,n,o,s){return X(()=>{$r(o),ZM(s),Bo(n),e==null&&(e=[1,1,1]),n==null&&(n="valid"),o==null&&(o=Uo()),s==null&&(s="max"),r=CF(r,o);let i,a=n==="same"?"same":"valid";return s==="max"?i=KS(r,t,e,a):i=CS(r,t,e,a),o==="channelsFirst"&&(i=ft(i,[0,4,1,2,3])),i})}var I1=class extends Ye{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new Y(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(an(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new Y(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);an(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,Bo(this.padding),this.inputSpec=[new yr({ndim:3})]}computeOutputShape(t){t=pt(t);let e=os(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return X(()=>{this.invokeCallHook(t,e),t=Vc(He(t),2);let n=this.poolingFunction(He(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Rt(n,[2])})}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}},N9=(()=>{class r extends I1{constructor(e){super(e)}poolingFunction(e,n,o,s,i){return $r(i),Bo(s),N1(e,n,o,s,i,"max")}}return r.className="MaxPooling1D",r})();ce.registerClass(N9);var D9=(()=>{class r extends I1{constructor(e){super(e)}poolingFunction(e,n,o,s,i){return $r(i),Bo(s),N1(e,n,o,s,i,"avg")}}return r.className="AveragePooling1D",r})();ce.registerClass(D9);var T1=class extends Ye{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new Y(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];an(this.poolSize,"poolSize"),an(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,$r(this.dataFormat),Bo(this.padding),this.inputSpec=[new yr({ndim:4})]}computeOutputShape(t){t=pt(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2];return e=os(e,this.poolSize[0],this.padding,this.strides[0]),n=os(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return X(()=>(this.invokeCallHook(t,e),this.poolingFunction(He(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},A9=(()=>{class r extends T1{constructor(e){super(e)}poolingFunction(e,n,o,s,i){return $r(i),Bo(s),N1(e,n,o,s,i,"max")}}return r.className="MaxPooling2D",r})();ce.registerClass(A9);var R9=(()=>{class r extends T1{constructor(e){super(e)}poolingFunction(e,n,o,s,i){return $r(i),Bo(s),N1(e,n,o,s,i,"avg")}}return r.className="AveragePooling2D",r})();ce.registerClass(R9);var _1=class extends Ye{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new Y(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];an(this.poolSize,"poolSize"),an(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,$r(this.dataFormat),Bo(this.padding),this.inputSpec=[new yr({ndim:5})]}computeOutputShape(t){t=pt(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2],o=this.dataFormat==="channelsFirst"?t[4]:t[3];return e=os(e,this.poolSize[0],this.padding,this.strides[0]),n=os(n,this.poolSize[1],this.padding,this.strides[1]),o=os(o,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,n,o]:[t[0],e,n,o,t[4]]}call(t,e){return X(()=>(this.invokeCallHook(t,e),this.poolingFunction(He(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},O9=(()=>{class r extends _1{constructor(e){super(e)}poolingFunction(e,n,o,s,i){return $r(i),Bo(s),k9(e,n,o,s,i,"max")}}return r.className="MaxPooling3D",r})();ce.registerClass(O9);var M9=(()=>{class r extends _1{constructor(e){super(e)}poolingFunction(e,n,o,s,i){return $r(i),Bo(s),k9(e,n,o,s,i,"avg")}}return r.className="AveragePooling3D",r})();ce.registerClass(M9);var E1=class extends Ye{constructor(t){super(t),this.inputSpec=[new yr({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new Xe}},F9=(()=>{class r extends E1{constructor(e){super(e||{})}call(e,n){return X(()=>{let o=He(e);return Ir(o,1)})}}return r.className="GlobalAveragePooling1D",r})();ce.registerClass(F9);var $9=(()=>{class r extends E1{constructor(e){super(e||{})}call(e,n){return X(()=>{let o=He(e);return zn(o,1)})}}return r.className="GlobalMaxPooling1D",r})();ce.registerClass($9);var k1=class extends Ye{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,$r(this.dataFormat),this.inputSpec=[new yr({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new Xe}getConfig(){let t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},P9=(()=>{class r extends k1{call(e,n){return X(()=>{let o=He(e);return this.dataFormat==="channelsLast"?Ir(o,[1,2]):Ir(o,[2,3])})}}return r.className="GlobalAveragePooling2D",r})();ce.registerClass(P9);var L9=(()=>{class r extends k1{call(e,n){return X(()=>{let o=He(e);return this.dataFormat==="channelsLast"?zn(o,[1,2]):zn(o,[2,3])})}}return r.className="GlobalMaxPooling2D",r})();ce.registerClass(L9);var D1=class extends Ye{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){let t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,n={}){let o=e.layer,s=Ds(o,n);delete e.layer;let i={layer:s};return Object.assign(i,e),new t(i)}},z9=(()=>{class r extends D1{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=pt(e),e.length<3)throw new Y(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let n=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(n),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=pt(e);let n=[e[0]].concat(e.slice(2)),o=this.layer.computeOutputShape(n),s=e[1];return[o[0],s].concat(o.slice(1))}call(e,n){return X(()=>(e=He(e),_F((a,u)=>[He(this.layer.call(a,n)),[]],e,[],!1,null,null,!1,!0)[1]))}}return r.className="TimeDistributed",r})();ce.registerClass(z9);function MNe(r){Gl(WX,"BidirectionalMergeMode",r)}var FNe="concat",B9=(()=>{class r extends D1{constructor(e){super(e);let n=e.layer.getConfig(),o={};o.className=e.layer.getClassName(),o.config=n,this.forwardLayer=Ds(o),n.goBackwards=n.goBackwards!==!0;let s={};if(s.className=e.layer.getClassName(),s.config=n,this.backwardLayer=Ds(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?FNe:e.mergeMode,MNe(this.mergeMode),e.weights)throw new Xe("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let n=e.length,o=Math.floor(n/2);this.forwardLayer.setWeights(e.slice(0,o)),this.backwardLayer.setWeights(e.slice(o))}computeOutputShape(e){let n=this.forwardLayer.computeOutputShape(e);Array.isArray(n)&&Array.isArray(n[0])||(n=[n]),n=n;let o,s,i;return this.returnState&&(i=n.slice(1)),o=n[0],o=o,this.mergeMode==="concat"?(o[o.length-1]*=2,s=[o]):this.mergeMode==null?s=[o,o.slice()]:s=[o],this.returnState?this.mergeMode==null?s.concat(i).concat(i.slice()):[o].concat(i).concat(i.slice()):Gn(s)}apply(e,n){let o=n==null?null:n.initialState,s=n==null?null:n.constants;n==null&&(n={});let i=TF(e,o,s,this.numConstants);if(e=i.inputs,o=i.initialState,s=i.constants,Array.isArray(e)&&(o=e.slice(1),e=e[0]),(o==null||o.length===0)&&s==null)return super.apply(e,n);let a=[],u=[];if(o!=null){let c=o.length;if(c%2>0)throw new Y("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");n.initialState=o,a.push(...o);let p=o.map(d=>new yr({shape:d.shape}));this.forwardLayer.stateSpec=p.slice(0,c/2),this.backwardLayer.stateSpec=p.slice(c/2),u.push(...p)}if(s!=null)throw new Xe("Support for constants in Bidirectional layers is not implemented yet.");let l=a[0]instanceof Eo;for(let c of a)if(c instanceof Eo!==l)throw new Y("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){let c=[e].concat(a),p=this.inputSpec.concat(u),d=this.inputSpec;this.inputSpec=p;let f=super.apply(c,n);return this.inputSpec=d,f}else return super.apply(e,n)}call(e,n){return X(()=>{let o=n.initialState,s,i;if(o==null)s=this.forwardLayer.call(e,n),i=this.backwardLayer.call(e,n);else{let l=o.slice(0,o.length/2),c=o.slice(o.length/2);s=this.forwardLayer.call(e,Object.assign(n,{initialState:l})),i=this.backwardLayer.call(e,Object.assign(n,{initialState:c}))}let a;this.returnState&&(Array.isArray(s)&&(a=s.slice(1).concat(i.slice(1))),s=s[0],i=i[0]),this.returnSequences&&(i=In(i,1));let u;return this.mergeMode==="concat"?u=Fy([s,i]):this.mergeMode==="sum"?u=re(s,i):this.mergeMode==="ave"?u=B(.5,re(s,i)):this.mergeMode==="mul"?u=B(s,i):this.mergeMode==null&&(u=[s,i]),this.returnState?this.mergeMode==null?u.concat(a):[u].concat(a):u})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){nu(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),nu(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,n){Array.isArray(n)&&(n=n[0]);let o;if(this.returnSequences?this.mergeMode==null?o=[n,n]:o=n:this.mergeMode==null?o=[null,null]:o=null,this.returnState){let i=this.forwardLayer.states.map(a=>null);return Array.isArray(o)?o.concat(i).concat(i):[o].concat(i).concat(i)}else return o}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},n=super.getConfig();return Object.assign(e,n),e}static fromConfig(e,n){let o=Ds(n.layer);if(delete n.layer,n.numConstants!=null)throw new Xe("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let s=n;return s.layer=o,new e(s)}}return r.className="Bidirectional",r})();ce.registerClass(B9);var V9=(()=>{class r extends Ye{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},n=super.getConfig();return Object.assign(e,n),e}call(e,n){return X(()=>(e=He(e),e.dtype!=="float32"&&(e=_o(e,"float32")),re(B(e,this.scale),this.offset)))}}return r.className="Rescaling",r})();ce.registerClass(V9);var{resizeBilinear:$Ne,cropAndResize:PNe}=yn,U9=(()=>{class r extends Ye{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,n,o,s,i,a,u,l){return X(()=>{let c,p=!1,d=n/a,f=o/u,h=(s+n)/a,m=(i+o)/u,g=[d,f,h,m],y=[];e.rank===3?(p=!0,c=Wr([e])):c=e;for(let N=0;N<c.shape[0];N++)y.push(g);let x=$n(y,[y.length,4]),w=Pl(0,y.length,1,"int32"),I=PNe(c,x,w,[s,i],"nearest");return p?_o(He(_n(I)),l):_o(I,l)})}upsize(e,n,o,s){return X(()=>{let i=$Ne(e,[n,o]);return _o(i,s)})}call(e,n){return X(()=>{let o=He(e),s=o.dtype,i=o.shape,a=i[i.length-3],u=i[i.length-2],l=0;a!==this.height&&(l=Math.floor((a-this.height)/2));let c=0;return u!==this.width&&(c=Math.floor((u-this.width)/2),c===0&&(c=1)),l>=0&&c>=0?this.centerCrop(o,l,c,this.height,this.width,a,u,s):this.upsize(e,this.height,this.width,s)})}getConfig(){let e={height:this.height,width:this.width},n=super.getConfig();return Object.assign(e,n),e}computeOutputShape(e){e=pt(e);let n=e.length-3,o=e.length-2;return e[n]=this.height,e[o]=this.width,e}}return r.className="CenterCrop",r})();ce.registerClass(U9);function G9(r,t,e,n){let o=He(r);if(o.dtype!=="int32"&&(o=_o(o,"int32")),t==="int")return o;let s=o.shape;if(o.rank===0&&(o=Sr(o,-1)),t==="oneHot"&&o.shape[o.shape.length-1]!==1&&(o=Sr(o,-1)),o.rank>2)throw new Y(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${o.rank}.`);let i=["multiHot","oneHot"].includes(t),a=o,u;if(typeof n<"u"&&t==="count"?u=Zv(a,n,e,i):u=Zv(a,[],e,i),t!=="tfIdf")return u;if(n)return B(u,n);throw new Y("When outputMode is 'tfIdf', weights must be provided.")}var W9=(()=>{class r extends Ye{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},n=super.getConfig();return Object.assign(e,n),e}computeOutputShape(e){return e=pt(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,n){return X(()=>{e=He(e),e.dtype!=="int32"&&(e=_o(e,"int32"));let o;if(typeof n.countWeights<"u"){if(this.outputMode!=="count")throw new Y(`countWeights is not used when outputMode !== count.
              Received countWeights=${n.countWeights}`);o=He(n.countWeights)}let s=zn(e),i=Nc(e),a=Gr(this.numTokens,s).bufferSync().get(0),u=$o(i,0).bufferSync().get(0);if(!(a&&u))throw new Y(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return G9(e,this.outputMode,this.numTokens,o)})}}return r.className="CategoryEncoding",r})();ce.registerClass(W9);var zNe=["bilinear","nearest"],j9=new Set(zNe),H9=(()=>{class r extends Ye{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(j9.has(e.interpolation))this.interpolation=e.interpolation;else throw new Y(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=pt(e);let n=e[2];return[this.height,this.width,n]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},n=super.getConfig();return Object.assign(e,n),e}call(e,n){return X(()=>{let o=[this.height,this.width];if(this.interpolation==="bilinear")return yn.resizeBilinear(e,o,!this.cropToAspectRatio);if(this.interpolation==="nearest")return yn.resizeNearestNeighbor(e,o,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...j9]} are supported`)})}}return r.className="Resizing",r})();ce.registerClass(H9);var q9=(()=>{class r{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}return r.className="RandomSeed",r})();var K9=(()=>{class r extends Ye{constructor(e){super(e),this.randomGenerator=new q9(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},n=super.getConfig();return Object.assign(e,n),e}}return r.className="BaseRandomLayer",r})();var BNe=["bilinear","nearest"],X9=new Set(BNe),Y9=(()=>{class r extends K9{constructor(e){super(e);let{factor:n,interpolation:o="bilinear"}=e;if(this.factor=n,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new Y(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new Y(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new Y(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(o)if(X9.has(o))this.interpolation=o;else throw new Y(`Invalid interpolation parameter: ${o} is not implemented`)}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},n=super.getConfig();return Object.assign(e,n),e}computeOutputShape(e){e=pt(e);let n=e[2];return[this.imgHeight,-1,n]}call(e,n){return X(()=>{let o=He(e);this.imgHeight=o.shape[o.shape.length-3];let s=o.shape[o.shape.length-2];this.widthFactor=Cs([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*s;i=Math.round(i);let a=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return yn.resizeBilinear(e,a);case"nearest":return yn.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...X9]} are supported`)}})}}return r.className="RandomWidth",r})();ce.registerClass(Y9);var ZNe=If(eb());var XNe=If(eb());var agr=Symbol("out"),ugr=Symbol("field"),lgr=Symbol("quote"),cgr=Symbol("quoteafterquote"),pgr=Symbol("quoteinquote");var uDe=En.whereImpl,Q9=(()=>{class r extends Zi{nextDataId(){return r.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new dc(this,Pn())}write(e,n,o){this.firstUse&&(this.firstUse=!1,j().get("IS_NODE")&&T.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let s={id:this.nextDataId()};return this.data.set(s,{values:e,dtype:o,refCount:1}),s}makeTensorInfo(e,n,o){let s;if(n==="string"&&o!=null&&o.length>0&&b.isString(o[0])){let i=o.map(a=>b.encodeString(a));s=this.write(i,e,n)}else s=this.write(o,e,n);return{dataId:s,shape:e,dtype:n}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){let n=this.data.get(e);n.refCount++}decRef(e){if(this.data.has(e)){let n=this.data.get(e);n.refCount--}}move(e,n,o,s,i){this.data.set(e,{values:n,dtype:s,refCount:i})}numDataIds(){return this.data.numDataIds()}read(e){return L(this,null,function*(){return this.readSync(e)})}readSync(e){let{dtype:n,complexTensorInfos:o}=this.data.get(e);if(n==="complex64"){let s=this.readSync(o.real.dataId),i=this.readSync(o.imag.dataId);return T.mergeRealAndImagArrays(s,i)}return b.convertBackendValuesAndArrayBuffer(this.data.get(e).values,n)}bufferSync(e){let n=this.readSync(e.dataId);if(e.dtype==="string")try{let o=n.map(s=>b.decodeString(s));return Ne(e.shape,e.dtype,o)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ne(e.shape,e.dtype,n)}makeOutput(e,n,o){return Pn().makeTensorFromTensorInfo(this.makeTensorInfo(n,o,e),this)}disposeData(e,n=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!n&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:o}=this.data.get(e);o!=null&&(this.disposeData(o.real.dataId,!0),this.disposeData(o.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return L(this,null,function*(){let n=b.now();return e(),{kernelMs:b.now()-n}})}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){de([e],"where");let n=this.readSync(e.dataId);return uDe(e.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return r.nextDataId=0,r})();Dg("cpu",()=>new Q9,1);var OF=Je(ca,r=>r>=0?r:Math.exp(r)-1),J9={kernelName:ca,backendName:"cpu",kernelFunc:OF};function MF(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{alpha:s}=n;de([o],"leakyRelu");let i=b.sizeFromShape(o.shape),a=e.data.get(o.dataId).values,u=b.getTypedArrayFromDType("float32",i);for(let l=0;l<a.length;l++)u[l]=a[l]<0?s*a[l]:a[l];return e.makeTensorInfo(o.shape,"float32",u)}var e7={kernelName:Qu,backendName:"cpu",kernelFunc:MF};var lDe=It((r,t)=>r<0?t*r:r);function FF(r){let{inputs:t,backend:e}=r,{x:n,alpha:o}=t;de([n,o],"prelu");let s=e.data.get(n.dataId).values,i=e.data.get(o.dataId).values,[a,u]=lDe(n.shape,o.shape,s,i,"float32");return e.makeTensorInfo(u,"float32",a)}var t7={kernelName:pl,backendName:"cpu",kernelFunc:FF};var $F=Je(ka,r=>Math.max(0,r)),r7={kernelName:ka,backendName:"cpu",kernelFunc:$F};var PF=Je(Na,r=>Math.min(Math.max(0,r),6)),n7={kernelName:Na,backendName:"cpu",kernelFunc:PF};function jh(r,t,e,n,o){if(e==="linear")return po({inputs:{x:t},backend:r});if(e==="relu")return $F({inputs:{x:t},backend:r});if(e==="elu")return OF({inputs:{x:t},backend:r});if(e==="relu6")return PF({inputs:{x:t},backend:r});if(e==="prelu")return FF({inputs:{x:t,alpha:n},backend:r});if(e==="leakyrelu")return MF({inputs:{x:t},backend:r,attrs:{alpha:o}});if(e==="sigmoid")return dM({inputs:{x:t},backend:r});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function Tt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{shape:s}=n,i=b.sizeFromShape(o.shape),a=b.inferFromImplicitShape(s,i),u=b.sizeFromShape(a);b.assert(i===u,()=>`The new shape (${a}) has ${u} elements and the old shape (${o.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),e.incRef(o.dataId);let l=e.data.get(o.dataId);if(l.complexTensorInfos!=null){let c=l.complexTensorInfos.real,p=l.complexTensorInfos.imag;c.shape=a,p.shape=a}return{dataId:o.dataId,shape:a,dtype:o.dtype}}var o7={kernelName:fl,backendName:"cpu",kernelFunc:Tt};function LF(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s}=t,{transposeA:i,transposeB:a}=n;de([o,s],"matMul");let u=o.shape.length,l=s.shape.length,c=i?o.shape[u-2]:o.shape[u-1],p=a?s.shape[l-1]:s.shape[l-2],d=i?o.shape[u-1]:o.shape[u-2],f=a?s.shape[l-2]:s.shape[l-1],h=o.shape.slice(0,-2),m=s.shape.slice(0,-2),g=b.sizeFromShape(h),y=b.sizeFromShape(m),w=Fo.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,f]);b.assert(c===p,()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${i} and transposeB=${a} must match.`);let C=i?[g,c,d]:[g,d,c],I=a?[y,f,p]:[y,p,f],N=Tt({inputs:{x:o},backend:e,attrs:{shape:C}}),A=Tt({inputs:{x:s},backend:e,attrs:{shape:I}}),O=i?N.shape[1]:N.shape[2],$=i?N.shape[2]:N.shape[1],z=a?A.shape[1]:A.shape[2],G=Math.max(g,y),K=e.data.get(N.dataId).values,Z=e.data.get(A.dataId).values,Q=b.computeStrides(N.shape),J=b.computeStrides(A.shape),[te,ie,ne]=i?[Q[0],1,Q[1]]:[Q[0],Q[1],1],[ae,ye,ge]=a?[1,J[1],J[0]]:[J[1],1,J[0]],Se=$*z,be=Ne([G,$,z],N.dtype),ke=be.values,Te=e.blockSize;for(let Oe=0;Oe<G;Oe++){let Ge=Oe%g,Ke=Oe%y;for(let Ze=0;Ze<$;Ze+=Te){let lt=Math.min(Ze+Te,$);for(let _e=0;_e<z;_e+=Te){let Ct=Math.min(_e+Te,z);for(let ze=0;ze<O;ze+=Te){let nt=Math.min(ze+Te,O);for(let Lt=Ze;Lt<lt;Lt++)for(let tt=_e;tt<Ct;tt++){let vr=0;for(let Or=ze;Or<nt;Or++){let ei=K[Ge*te+Lt*ie+Or*ne],Dn=Z[Or*ae+tt*ye+Ke*ge];vr+=ei*Dn}ke[Oe*Se+(Lt*z+tt)]+=vr}}}}}return e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo(A),e.makeTensorInfo(w,be.dtype,be.values)}var s7={kernelName:zu,backendName:"cpu",kernelFunc:LF};function cDe(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s,bias:i,preluActivationWeights:a}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:p}=n,d,f,h,m=[];d=LF({inputs:{a:o,b:s},attrs:{transposeA:u,transposeB:l},backend:e}),i&&(f=Ll({inputs:{a:d,b:i},backend:e}),m.push(d),d=f),c&&(h=jh(e,d,c,a,p),m.push(d),d=h);for(let y of m)e.disposeIntermediateTensorInfo(y);return d}var i7={kernelName:Cc,backendName:"cpu",kernelFunc:cDe};var pDe=Je(Qi,r=>Math.acos(r)),a7={kernelName:Qi,backendName:"cpu",kernelFunc:pDe};var dDe=Je(Ji,r=>Math.acosh(r)),u7={kernelName:Ji,backendName:"cpu",kernelFunc:dDe};function fDe(r){let{inputs:t,backend:e}=r,n=t;de(t,"addN");let o=n.map(a=>e.data.get(a.dataId).values),s=Ne(n[0].shape,n[0].dtype),i=s.values;for(let a=0;a<n.length;a++){let u=o[a];for(let l=0;l<i.length;l++)i[l]+=u[l]}return e.makeTensorInfo(s.shape,s.dtype,s.values)}var l7={kernelName:Mu,backendName:"cpu",kernelFunc:fDe};function hDe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;de(o,"all");let a=b.parseAxisParam(s,o.shape),u=a,l=T.getAxesPermutation(u,o.shape.length),c=o;l!=null&&(c=Hr({inputs:{x:o},backend:e,attrs:{perm:l}}),u=T.getInnerMostAxes(u.length,o.shape.length)),T.assertAxesAreInnerMostDims("all",u,c.shape.length);let[p,d]=T.computeOutAndReduceShapes(c.shape,u),f=b.sizeFromShape(d),h=b.makeZerosTypedArray(b.sizeFromShape(p),c.dtype),m=e.data.get(c.dataId).values;for(let y=0;y<h.length;++y){let x=y*f,w=m[x];for(let C=0;C<f;++C){let I=m[x+C];w=w&&I}h[y]=w}l!=null&&e.disposeIntermediateTensorInfo(c);let g=e.makeTensorInfo(p,c.dtype,h);if(i){let y=T.expandShapeToKeepDim(p,a),x=Tt({inputs:{x:g},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(g),x}return g}var c7={kernelName:Ep,backendName:"cpu",kernelFunc:hDe};function mDe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;de(o,"any");let a=b.parseAxisParam(s,o.shape),u=a,l=T.getAxesPermutation(u,o.shape.length),c=o;l!=null&&(c=Hr({inputs:{x:o},backend:e,attrs:{perm:l}}),u=T.getInnerMostAxes(u.length,o.shape.length)),T.assertAxesAreInnerMostDims("any",u,c.shape.length);let[p,d]=T.computeOutAndReduceShapes(c.shape,u),f=b.sizeFromShape(d),h=b.makeZerosTypedArray(b.sizeFromShape(p),c.dtype),m=e.data.get(c.dataId).values;for(let y=0;y<h.length;++y){let x=y*f,w=m[x];for(let C=0;C<f;++C){let I=m[x+C];w=w||I}h[y]=w}l!=null&&e.disposeIntermediateTensorInfo(c);let g=e.makeTensorInfo(p,c.dtype,h);if(i){let y=T.expandShapeToKeepDim(p,a),x=Tt({inputs:{x:g},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(g),x}return g}var p7={kernelName:kp,backendName:"cpu",kernelFunc:mDe};function gDe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n;de(o,"argMax");let i=b.parseAxisParam(s,o.shape),a=T.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=Hr({inputs:{x:o},backend:e,attrs:{perm:a}}),l.push(u),i=T.getInnerMostAxes(i.length,u.shape.length)),i=[i[0]],T.assertAxesAreInnerMostDims("argMax",i,u.shape.length);let[c,p]=T.computeOutAndReduceShapes(u.shape,i),d=b.sizeFromShape(c),f=b.makeZerosTypedArray(d,"int32"),h=b.sizeFromShape(p),m=e.data.get(u.dataId).values;for(let g=0;g<f.length;++g){let y=g*h,x=m[y],w=0;for(let C=0;C<h;++C){let I=m[y+C];I>x&&(x=I,w=C)}f[g]=w}return l.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(c,"int32",f)}var d7={kernelName:Fu,backendName:"cpu",kernelFunc:gDe};function yDe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n;de(o,"argMin");let i=b.parseAxisParam(s,o.shape),a=T.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=Hr({inputs:{x:o},backend:e,attrs:{perm:a}}),l.push(u),i=T.getInnerMostAxes(i.length,u.shape.length)),i=[i[0]],T.assertAxesAreInnerMostDims("argMin",i,u.shape.length);let[c,p]=T.computeOutAndReduceShapes(u.shape,i),d=b.sizeFromShape(c),f=b.makeZerosTypedArray(d,"int32"),h=b.sizeFromShape(p),m=e.data.get(u.dataId).values;for(let g=0;g<f.length;++g){let y=g*h,x=m[y],w=0;for(let C=0;C<h;++C){let I=m[y+C];I<x&&(x=I,w=C)}f[g]=w}return l.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(c,"int32",f)}var f7={kernelName:$u,backendName:"cpu",kernelFunc:yDe};var xDe=Je(ea,r=>Math.asin(r)),h7={kernelName:ea,backendName:"cpu",kernelFunc:xDe};var vDe=Je(ta,r=>Math.asinh(r)),m7={kernelName:ta,backendName:"cpu",kernelFunc:vDe};var bDe=Je(ra,r=>Math.atan(r)),g7={kernelName:ra,backendName:"cpu",kernelFunc:bDe};var wDe=It((r,t)=>Math.atan2(r,t)),CDe=Mt(oa,wDe),y7={kernelName:oa,backendName:"cpu",kernelFunc:CDe};var SDe=Je(na,r=>Math.atanh(r)),x7={kernelName:na,backendName:"cpu",kernelFunc:SDe};function jy(r,t,e,n,o,s){let i=o.strideHeight,a=o.strideWidth,u=o.dilationHeight,l=o.dilationWidth,c=o.effectiveFilterHeight,p=o.effectiveFilterWidth,d=o.padInfo.top,f=o.padInfo.left,h=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Ne(o.outShape,e),g=m.values,y=o.outShape[1]*o.outShape[2]*o.outShape[3],x=o.outShape[2]*o.outShape[3],w=o.outShape[3];for(let C=0;C<o.batchSize;++C){let I=C*y,N=C*n[0];for(let A=0;A<o.inChannels;++A)for(let O=0;O<o.outHeight;++O){let $=O*i-d,z=Math.max(0,$),G=Math.min(o.inHeight,c+$),K=I+O*x;for(let Z=0;Z<o.outWidth;++Z){let Q=Z*a-f,J=Math.max(0,Q),te=Math.min(o.inWidth,p+Q),ie=h,ne=0,ae=0;for(let ge=z;ge<G;ge+=u){let Se=N+ge*n[1];for(let be=J;be<te;be+=l){let ke=Se+be*n[2],Te=r[ke+A];s==="max"&&Te>ie?ie=Te:s==="avg"&&(ne+=Te,ae++)}if(isNaN(ie))break}let ye=K+Z*w+A;g[ye]=s==="avg"?ne/ae:ie}}}return m}function A1(r,t,e,n,o=!1,s=!1){let i=Ne(n.outShape,"int32"),a=n.strideHeight,u=n.strideWidth,l=n.dilationHeight,c=n.dilationWidth,p=n.effectiveFilterHeight,d=n.effectiveFilterWidth,f=n.padInfo.top,h=n.padInfo.left,m=Ne(t,e,r);for(let g=0;g<n.batchSize;++g)for(let y=0;y<n.inChannels;++y)for(let x=0;x<n.outHeight;++x){let w=x*a-f,C=w;for(;C<0;)C+=l;let I=Math.min(n.inHeight,p+w);for(let N=0;N<n.outWidth;++N){let A=N*u-h,O=A;for(;O<0;)O+=c;let $=Math.min(n.inWidth,d+A),z=Number.NEGATIVE_INFINITY,G=-1;for(let K=C;K<I;K+=l){let Z=K-w;for(let Q=O;Q<$;Q+=c){let J=Q-A,te=m.get(g,K,Q,y);te>z&&(z=te,o?G=s?((g*n.inHeight+K)*n.inWidth+Q)*n.inChannels+y:(K*n.inWidth+Q)*n.inChannels+y:G=Z*d+J)}}i.set(G,g,x,N,y)}}return i}function R1(r,t,e,n,o,s){let i=o.strideDepth,a=o.strideHeight,u=o.strideWidth,l=o.dilationDepth,c=o.dilationHeight,p=o.dilationWidth,d=o.effectiveFilterDepth,f=o.effectiveFilterHeight,h=o.effectiveFilterWidth,m=o.padInfo.front,g=o.padInfo.top,y=o.padInfo.left,x=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=Ne(o.outShape,e),C=w.values,I=o.outShape[1]*o.outShape[2]*o.outShape[3]*o.outShape[4],N=o.outShape[2]*o.outShape[3]*o.outShape[4],A=o.outShape[3]*o.outShape[4],O=o.outShape[4];for(let $=0;$<o.batchSize;++$){let z=$*I,G=$*n[0];for(let K=0;K<o.inChannels;++K)for(let Z=0;Z<o.outDepth;++Z){let Q=Z*i-m,J=Q;for(;J<0;)J+=l;let te=Math.min(o.inDepth,d+Q),ie=z+Z*N;for(let ne=0;ne<o.outHeight;++ne){let ae=ne*a-g,ye=ae;for(;ye<0;)ye+=c;let ge=Math.min(o.inHeight,f+ae),Se=ie+ne*A;for(let be=0;be<o.outWidth;++be){let ke=be*u-y,Te=ke;for(;Te<0;)Te+=p;let Oe=Math.min(o.inWidth,h+ke),Ge=Se+be*O,Ke=x,Ze=0,lt=0;for(let Ct=J;Ct<te;Ct+=l){let ze=G+Ct*n[1];for(let nt=ye;nt<ge;nt+=c){let Lt=ze+nt*n[2];for(let tt=Te;tt<Oe;tt+=p){let vr=Lt+tt*n[3],Or=r[vr+K];if(s==="max"&&Or>Ke?Ke=Or:s==="avg"&&(Ze+=Or,lt++),isNaN(Ke))break}if(isNaN(Ke))break}if(isNaN(Ke))break}let _e=Ge+K;C[_e]=s==="avg"?Ze/Math.max(lt,1):Ke}}}}return w}function v7(r,t){let e=Ne(t.outShape,"int32"),n=t.strideDepth,o=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,a=t.dilationHeight,u=t.dilationWidth,l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,p=t.effectiveFilterWidth,d=t.padInfo.front,f=t.padInfo.top,h=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){let x=y*n-d,w=x;for(;w<0;)w+=i;let C=Math.min(t.inDepth,l+x);for(let I=0;I<t.outHeight;++I){let N=I*o-f,A=N;for(;A<0;)A+=a;let O=Math.min(t.inHeight,c+N);for(let $=0;$<t.outWidth;++$){let z=$*s-h,G=z;for(;G<0;)G+=u;let K=Math.min(t.inWidth,p+z),Z=Number.NEGATIVE_INFINITY,Q=-1;for(let J=w;J<C;J+=i){let te=J-x;for(let ie=A;ie<O;ie+=a){let ne=ie-N;for(let ae=G;ae<K;ae+=u){let ye=ae-z,ge=r.get(m,J,ie,ae,g);ge>=Z&&(Z=ge,Q=te*c*p+ne*c+ye)}}}e.set(Q,m,y,I,$,g)}}}return e}function IDe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;de(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;b.assert(T.eitherStridesOrDilationsAreOne(i,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let c=T.computePool2DInfo(o.shape,s,i,l,a,u),p;if(c.filterWidth===1&&c.filterHeight===1&&b.arraysEqual(c.inShape,c.outShape))p=po({inputs:{x:o},backend:e});else{let d=e.data.get(o.dataId).values,f=b.computeStrides(o.shape),h=jy(d,o.shape,o.dtype,f,c,"avg");p=e.makeTensorInfo(c.outShape,o.dtype,h.values)}return p}var b7={kernelName:Pu,backendName:"cpu",kernelFunc:IDe};function TDe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=n;de(o,"avgPool3d");let c=T.computePool3DInfo(o.shape,s,i,1,a,u,l),p=e.data.get(o.dataId).values,d=R1(p,o.shape,o.dtype,b.computeStrides(o.shape),c,"avg");return e.makeTensorInfo(d.shape,"float32",d.values)}var w7={kernelName:Lu,backendName:"cpu",kernelFunc:TDe};function _De(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=n;de([o,s],"avgPool3DGrad");let c=T.computePool3DInfo(s.shape,i,a,1,u,l),p=c.strideDepth,d=c.strideHeight,f=c.strideWidth,h=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,x=c.dilationHeight,w=c.dilationWidth,C=c.effectiveFilterDepth,I=c.effectiveFilterHeight,N=c.effectiveFilterWidth,A=C-1-c.padInfo.front,O=N-1-c.padInfo.left,$=I-1-c.padInfo.top,z=Ne(s.shape,"float32"),G=1/(h*m*g),K=e.bufferSync(o);for(let Z=0;Z<c.batchSize;++Z)for(let Q=0;Q<c.inChannels;++Q)for(let J=0;J<c.inDepth;++J)for(let te=0;te<c.inHeight;++te)for(let ie=0;ie<c.inWidth;++ie){let ne=J-A,ae=te-$,ye=ie-O,ge=0;for(let Se=0;Se<C;Se+=y){let be=(ne+Se)/p;if(!(be<0||be>=c.outDepth||Math.floor(be)!==be))for(let ke=0;ke<I;ke+=x){let Te=(ae+ke)/d;if(!(Te<0||Te>=c.outHeight||Math.floor(Te)!==Te))for(let Oe=0;Oe<N;Oe+=w){let Ge=(ye+Oe)/f;if(Ge<0||Ge>=c.outWidth||Math.floor(Ge)!==Ge)continue;let Ke=K.get(Z,be,Te,Ge,Q);ge+=Ke}}}z.set(ge*G,Z,J,te,ie,Q)}return e.makeTensorInfo(z.shape,z.dtype,z.values)}var C7={kernelName:Dp,backendName:"cpu",kernelFunc:_De};function EDe(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,i=s;de([o,s],"avgPoolGrad");let{filterSize:a,strides:u,pad:l}=n,c=T.computePool2DInfo(i.shape,a,u,1,l),p=c.strideHeight,d=c.strideWidth,f=c.filterHeight,h=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,x=c.effectiveFilterWidth,w=x-1-c.padInfo.left,C=y-1-c.padInfo.top,I=Ne(i.shape,"float32"),N=1/(f*h),A=e.data.get(o.dataId).values,O=Ne(o.shape,"float32",A);for(let $=0;$<c.batchSize;++$)for(let z=0;z<c.inChannels;++z)for(let G=0;G<c.inHeight;++G)for(let K=0;K<c.inWidth;++K){let Z=G-C,Q=K-w,J=0;for(let te=0;te<y;te+=m){let ie=(Z+te)/p;if(!(ie<0||ie>=c.outHeight||Math.floor(ie)!==ie))for(let ne=0;ne<x;ne+=g){let ae=(Q+ne)/d;if(ae<0||ae>=c.outWidth||Math.floor(ae)!==ae)continue;let ye=O.get($,ie,ae,z);J+=ye}}I.set(J*N,$,G,K,z)}return e.makeTensorInfo(I.shape,I.dtype,I.values)}var S7={kernelName:Np,backendName:"cpu",kernelFunc:EDe};function kDe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,scale:s,offset:i,mean:a,variance:u}=t;b.assert(a.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),b.assert(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),b.assert(s==null||a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),de([o,a,u,s,i],"batchNorm");let{varianceEpsilon:l}=n;l==null&&(l=.001);let c=e.data.get(o.dataId).values,p=e.data.get(a.dataId).values,d=e.data.get(u.dataId).values,f=s?e.data.get(s.dataId).values:new Float32Array([1]),h=i?e.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=h.length,y=f.length,x=d.length,w=p.length,C=0,I=0,N=0,A=0;for(let O=0;O<c.length;++O)m[O]=h[C++]+(c[O]-p[I++])*f[N++]/Math.sqrt(d[A++]+l),C>=g&&(C=0),I>=w&&(I=0),N>=y&&(N=0),A>=x&&(A=0);return e.makeTensorInfo(o.shape,o.dtype,m)}var I7={kernelName:Yu,backendName:"cpu",kernelFunc:kDe};function NDe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,crops:i}=n;de([o],"batchToSpaceND");let a=s.reduce((y,x)=>y*x),u=T.getReshaped(o.shape,s,a),l=T.getPermuted(u.length,s.length),c=T.getReshapedPermuted(o.shape,s,a),p=T.getSliceBeginCoords(i,s.length),d=T.getSliceSize(c,i,s.length),f=Tt({inputs:{x:o},backend:e,attrs:{shape:u}}),h=Hr({inputs:{x:f},backend:e,attrs:{perm:l}}),m=Tt({inputs:{x:h},backend:e,attrs:{shape:c}}),g=ki({inputs:{x:m},backend:e,attrs:{begin:p,size:d}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(m),g}var T7={kernelName:Bu,backendName:"cpu",kernelFunc:NDe};function DDe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:i}=n,a=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,l=by(a,u,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,l)}var _7={kernelName:Ap,backendName:"cpu",kernelFunc:DDe};function ADe(r){let{inputs:t,backend:e}=r,{s0:n,s1:o}=t,s=e.data.get(n.dataId).values,i=e.data.get(o.dataId).values,a=T.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var E7={kernelName:Rp,backendName:"cpu",kernelFunc:ADe};var RDe=Je(ia,(r,t)=>{let e=t;return r>e.clipValueMax?e.clipValueMax:r<e.clipValueMin?e.clipValueMin:r}),k7={kernelName:ia,backendName:"cpu",kernelFunc:RDe};var ODe=r=>{let{x:t}=r.inputs,e=r.backend,n=new Float32Array(b.sizeFromShape(t.shape)),o=e.data.get(t.dataId),s=o.complexTensorInfos.real,i=o.complexTensorInfos.imag,a=e.data.get(s.dataId).values,u=e.data.get(i.dataId).values;for(let l=0;l<a.length;l++){let c=a[l],p=u[l];n[l]=Math.hypot(c,p)}return e.makeOutput(n,t.shape,"float32")},N7={kernelName:Vu,backendName:"cpu",kernelFunc:ODe};function jl(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.data.get(n.dataId).complexTensorInfos.imag,s=e.data.get(o.dataId).values;return e.makeTensorInfo(o.shape,o.dtype,s)}var D7={kernelName:Zp,backendName:"cpu",kernelFunc:jl};function nf(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n,s=b.parseAxisParam(o,t[0].shape)[0],i=t.map(m=>m.shape);T.assertParamsConsistent(i,s);let a=T.computeOutShape(t.map(m=>m.shape),s);if(b.sizeFromShape(a)===0)return e.makeTensorInfo(a,t[0].dtype,[]);let u=t.filter(m=>b.sizeFromShape(m.shape)>0);if(u.length===1)return po({inputs:{x:u[0]},backend:e});if(u[0].dtype==="complex64"){let m=u.map(C=>Ti({inputs:{input:C},backend:e})),g=u.map(C=>jl({inputs:{input:C},backend:e})),y=nf({inputs:m,backend:e,attrs:{axis:s}}),x=nf({inputs:g,backend:e,attrs:{axis:s}}),w=Mn({inputs:{real:y,imag:x},backend:e});return m.forEach(C=>e.disposeIntermediateTensorInfo(C)),g.forEach(C=>e.disposeIntermediateTensorInfo(C)),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(x),w}let l=u.map(m=>{let y=[-1,b.sizeFromShape(m.shape.slice(s))];return Tt({inputs:{x:m},backend:e,attrs:{shape:y}})}),c=l.map(m=>({vals:e.data.get(m.dataId).values,shape:m.shape}));a=T.computeOutShape(l.map(m=>m.shape),1);let p=l[0].shape[0]===1,d=rT(c,a,t[0].dtype,p),f=T.computeOutShape(u.map(m=>m.shape),s),h=e.makeTensorInfo(f,t[0].dtype,d);return l.forEach(m=>e.disposeIntermediateTensorInfo(m)),h}var A7={kernelName:Uu,backendName:"cpu",kernelFunc:nf};function zF(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=n;de([o,s],"conv2d");let p=T.convertConv2DDataFormat(u),d=T.computeConv2DInfo(o.shape,s.shape,i,l,a,c,!1,p),f=d.filterHeight,h=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,x=d.padInfo.top,w=d.dataFormat==="channelsLast",C=new jt(d.outShape,o.dtype),I=b.computeStrides(o.shape),N=b.computeStrides(s.shape),A=I[0],O=w?I[1]:I[2],$=w?I[2]:1,z=w?1:I[1],G=C.strides[0],K=w?C.strides[1]:C.strides[2],Z=w?C.strides[2]:1,Q=w?1:C.strides[1],J=e.data.get(o.dataId).values,te=e.data.get(s.dataId).values,ie=C.values;for(let ne=0;ne<d.batchSize;++ne){let ae=ne*A,ye=ne*G;for(let ge=0;ge<d.outHeight;++ge){let Se=ye+ge*K,be=ge*d.strideHeight-x;for(let ke=0;ke<f;++ke){let Te=be+ke*m;if(Te<0||Te>=d.inHeight)continue;let Oe=ke*N[0],Ge=ae+Te*O;for(let Ke=0;Ke<d.outWidth;++Ke){let Ze=Se+Ke*Z,lt=Ke*d.strideWidth-y;for(let _e=0;_e<h;++_e){let Ct=lt+_e*g;if(Ct<0||Ct>=d.inWidth)continue;let ze=Oe+_e*N[1],nt=Ge+Ct*$,Lt=ze;for(let tt=0;tt<d.inChannels;++tt){let vr=J[nt+tt*z];for(let Or=0;Or<d.outChannels;++Or)ie[Ze+Or*Q]+=vr*te[Lt+Or];Lt+=d.outChannels}}}}}}return e.makeTensorInfo(C.shape,C.dtype,ie)}var R7={kernelName:Gu,backendName:"cpu",kernelFunc:zF};function MDe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:c}=n;de([o,s],"conv2dBackpropFilter");let p=T.convertConv2DDataFormat(u),d=T.computeConv2DInfo(o.shape,c,i,1,a,l,!1,p),{strideHeight:f,strideWidth:h,filterHeight:m,filterWidth:g}=d,y=d.dataFormat==="channelsLast",x=new jt(d.filterShape,"float32"),w=d.padInfo.left,C=d.padInfo.top,I=e.data.get(o.dataId).values,N=e.data.get(s.dataId).values,A=new jt(o.shape,o.dtype,I),O=new jt(s.shape,s.dtype,N);for(let $=0;$<m;++$){let z=Math.max(0,Math.ceil((C-$)/f)),G=Math.min(d.outHeight,(d.inHeight+C-$)/f);for(let K=0;K<g;++K){let Z=Math.max(0,Math.ceil((w-K)/h)),Q=Math.min(d.outWidth,(d.inWidth+w-K)/h);for(let J=0;J<d.inChannels;++J)for(let te=0;te<d.outChannels;++te){let ie=0;for(let ne=0;ne<d.batchSize;++ne)for(let ae=z;ae<G;++ae){let ye=$+ae*f-C;for(let ge=Z;ge<Q;++ge){let Se=K+ge*h-w;y?ie+=A.get(ne,ye,Se,J)*O.get(ne,ae,ge,te):ie+=A.get(ne,J,ye,Se)*O.get(ne,te,ae,ge)}}x.set(ie,$,K,J,te)}}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}var O7={kernelName:Mp,backendName:"cpu",kernelFunc:MDe};function FDe(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{inputShape:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:c}=n;de([o,s],"conv2dBackpropInput");let p=b.computeStrides(s.shape),d=b.computeStrides(o.shape),f=T.convertConv2DDataFormat(l),h=T.computeConv2DInfo(i,s.shape,a,1,u,c,!1,f),m=new jt(h.inShape,"float32"),g=m.values,y=e.data.get(o.dataId).values,x=e.data.get(s.dataId).values,[w,C,I]=p,{batchSize:N,filterHeight:A,filterWidth:O,inChannels:$,inHeight:z,inWidth:G,outChannels:K,outHeight:Z,outWidth:Q,strideHeight:J,strideWidth:te}=h;f=h.dataFormat;let ie=A-1-h.padInfo.top,ne=O-1-h.padInfo.left,ae=f==="channelsLast",ye=m.strides[0],ge=ae?m.strides[1]:m.strides[2],Se=ae?m.strides[2]:1,be=ae?1:m.strides[1],ke=d[0],Te=ae?d[1]:d[2],Oe=ae?d[2]:1,Ge=ae?1:d[1];for(let Ke=0;Ke<N;++Ke)for(let Ze=0;Ze<$;++Ze)for(let lt=0;lt<z;++lt){let _e=lt-ie,Ct=Math.max(0,Math.ceil(_e/J)),ze=Math.min(Z,(A+_e)/J);for(let nt=0;nt<G;++nt){let Lt=nt-ne,tt=Math.max(0,Math.ceil(Lt/te)),vr=Math.min(Q,(O+Lt)/te),Or=0;for(let Dn=Ct;Dn<ze;++Dn){let zi=Dn*J-_e;for(let ho=tt;ho<vr;++ho){let gu=ho*te-Lt,Kn=ke*Ke+Te*Dn+Oe*ho,ti=w*(A-1-zi)+C*(O-1-gu)+I*Ze;for(let Ps=0;Ps<K;++Ps){let ri=y[Kn+Ge*Ps],yu=x[ti+Ps];Or+=ri*yu}}}let ei=ye*Ke+ge*lt+Se*nt+be*Ze;g[ei]=Or}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}var M7={kernelName:Wu,backendName:"cpu",kernelFunc:FDe};function $De(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u}=n;de([o,s],"conv3d");let l=T.computeConv3DInfo(o.shape,s.shape,i,u,a),{filterDepth:c,filterHeight:p,filterWidth:d,dilationDepth:f,dilationHeight:h,dilationWidth:m,padInfo:g}=l,y=g.front,x=g.left,w=g.top,C=new jt(l.outShape,o.dtype),I=e.data.get(o.dataId).values,N=e.data.get(s.dataId).values,A=C.values,O=b.computeStrides(o.shape),$=b.computeStrides(s.shape);for(let z=0;z<l.batchSize;++z){let G=z*O[0],K=z*C.strides[0];for(let Z=0;Z<l.outDepth;++Z){let Q=K+Z*C.strides[1],J=Z*l.strideDepth-y;for(let te=0;te<c;++te){let ie=J+te*f;if(ie<0||ie>=l.inDepth)continue;let ne=te*$[0],ae=G+ie*O[1];for(let ye=0;ye<l.outHeight;++ye){let ge=Q+ye*C.strides[2],Se=ye*l.strideHeight-w;for(let be=0;be<p;++be){let ke=Se+be*h;if(ke<0||ke>=l.inHeight)continue;let Te=ne+be*$[1],Oe=ae+ke*O[2];for(let Ge=0;Ge<l.outWidth;++Ge){let Ke=ge+Ge*l.outChannels,Ze=Ge*l.strideWidth-x;for(let lt=0;lt<d;++lt){let _e=Ze+lt*m;if(_e<0||_e>=l.inWidth)continue;let Ct=Te+lt*$[2],ze=Oe+_e*l.inChannels,nt=Ct;for(let Lt=0;Lt<l.inChannels;++Lt){let tt=I[ze+Lt];for(let vr=0;vr<l.outChannels;++vr)A[Ke+vr]+=tt*N[nt+vr];nt+=l.outChannels}}}}}}}}return e.makeTensorInfo(C.shape,C.dtype,C.values)}var F7={kernelName:ju,backendName:"cpu",kernelFunc:$De};function PDe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,pad:a,filterShape:u}=n;de([o,s],"conv3dBackpropFilterV2");let l=b.computeStrides(o.shape),c=b.computeStrides(s.shape),p=T.computeConv3DInfo(o.shape,u,i,1,a),d=p.strideDepth,f=p.strideHeight,h=p.strideWidth,m=p.filterDepth,g=p.filterHeight,y=p.filterWidth,x=new jt(p.filterShape,"float32"),w=x.values,[C,I,N,A]=x.strides,O=e.data.get(s.dataId).values,[$,z,G,K]=c,Z=e.data.get(o.dataId).values,[Q,J,te,ie]=l,ne=p.padInfo.front,ae=p.padInfo.left,ye=p.padInfo.top;for(let ge=0;ge<m;++ge){let Se=Math.max(0,Math.ceil((ne-ge)/d)),be=Math.min(p.outDepth,(p.inDepth+ne-ge)/d),ke=ge*C;for(let Te=0;Te<g;++Te){let Oe=Math.max(0,Math.ceil((ye-Te)/f)),Ge=Math.min(p.outHeight,(p.inHeight+ye-Te)/f),Ke=Te*I+ke;for(let Ze=0;Ze<y;++Ze){let lt=Math.max(0,Math.ceil((ae-Ze)/h)),_e=Math.min(p.outWidth,(p.inWidth+ae-Ze)/h),Ct=Ze*N+Ke;for(let ze=0;ze<p.inChannels;++ze){let nt=ze*A+Ct;for(let Lt=0;Lt<p.outChannels;++Lt){let tt=0;for(let vr=0;vr<p.batchSize;++vr){let Or=vr*Q,ei=vr*$;for(let Dn=Se;Dn<be;++Dn){let ho=(ge+Dn*d-ne)*J+Or,gu=Dn*z+ei;for(let Kn=Oe;Kn<Ge;++Kn){let Ps=(Te+Kn*f-ye)*te+ho,ri=Kn*G+gu;for(let yu=lt;yu<_e;++yu){let Lx=(Ze+yu*h-ae)*ie+Ps,ym=yu*K+ri;tt+=Z[Lx+ze]*O[ym+Lt]}}}}w[nt+Lt]=tt}}}}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}var $7={kernelName:Fp,backendName:"cpu",kernelFunc:PDe};function LDe(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{pad:i,strides:a,inputShape:u}=n;de([o],"conv3dBackpropInputV2");let l=b.computeStrides(o.shape),c=b.computeStrides(s.shape),p=T.computeConv3DInfo(u,s.shape,a,1,i),d=new jt(p.inShape,"float32"),f=d.values,[h,m,g,y]=d.strides,x=e.data.get(o.dataId).values,[w,C,I,N]=l,A=e.data.get(s.dataId).values,[O,$,z,G]=c,{batchSize:K,filterDepth:Z,filterHeight:Q,filterWidth:J,inChannels:te,inDepth:ie,inHeight:ne,inWidth:ae,outChannels:ye,outDepth:ge,outHeight:Se,outWidth:be,strideDepth:ke,strideHeight:Te,strideWidth:Oe}=p,Ge=Z-1-p.padInfo.front,Ke=Q-1-p.padInfo.top,Ze=J-1-p.padInfo.left;for(let lt=0;lt<K;++lt)for(let _e=0;_e<te;++_e)for(let Ct=0;Ct<ie;++Ct){let ze=Ct-Ge,nt=Math.max(0,Math.ceil(ze/ke)),Lt=Math.min(ge,(Z+ze)/ke);for(let tt=0;tt<ne;++tt){let vr=tt-Ke,Or=Math.max(0,Math.ceil(vr/Te)),ei=Math.min(Se,(Q+vr)/Te);for(let Dn=0;Dn<ae;++Dn){let zi=Dn-Ze,ho=Math.max(0,Math.ceil(zi/Oe)),gu=Math.min(be,(J+zi)/Oe),Kn=0;for(let ti=nt;ti<Lt;++ti){let Ps=ti*ke-ze;for(let ri=Or;ri<ei;++ri){let yu=ri*Te-vr;for(let op=ho;op<gu;++op){let Lx=op*Oe-zi,ym=w*lt+C*ti+I*ri+N*op,Gw=O*(Z-1-Ps)+$*(Q-1-yu)+z*(J-1-Lx)+G*_e;for(let xu=0;xu<ye;++xu){let zx=x[ym+xu],Ww=A[Gw+xu];Kn+=zx*Ww}}}}f[h*lt+m*Ct+g*tt+y*Dn+_e]=Kn}}}return e.makeTensorInfo(d.shape,d.dtype,d.values)}var P7={kernelName:$p,backendName:"cpu",kernelFunc:LDe};var zDe=Je(aa,r=>Math.cos(r)),L7={kernelName:aa,backendName:"cpu",kernelFunc:zDe};var BDe=Je(ua,r=>Math.cosh(r)),z7={kernelName:ua,backendName:"cpu",kernelFunc:BDe};function VDe(r){let{inputs:t,backend:e,attrs:n}=r,{image:o,boxes:s,boxInd:i}=t,{cropSize:a,method:u,extrapolationValue:l}=n,[c,p,d,f]=o.shape,h=s.shape[0],[m,g]=a,y=Ne([h,m,g,f],"float32"),x=e.data.get(s.dataId).values,w=e.data.get(i.dataId).values,C=e.data.get(o.dataId).values,I=b.computeStrides(o.shape),N=b.computeStrides(y.shape);for(let A=0;A<h;A++){let O=A*4,$=x[O],z=x[O+1],G=x[O+2],K=x[O+3],Z=w[A];if(Z>=c)continue;let Q=m>1?(G-$)*(p-1)/(m-1):0,J=g>1?(K-z)*(d-1)/(g-1):0;for(let te=0;te<m;te++){let ie=m>1?$*(p-1)+te*Q:.5*($+G)*(p-1);if(ie<0||ie>p-1){for(let ne=0;ne<g;ne++)for(let ae=0;ae<f;ae++){let ye=ae+ne*N[2]+te*N[1]+A*N[0];y.values[ye]=l}continue}if(u==="bilinear"){let ne=Math.floor(ie),ae=Math.ceil(ie),ye=ie-ne;for(let ge=0;ge<g;ge++){let Se=g>1?z*(d-1)+ge*J:.5*(z+K)*(d-1);if(Se<0||Se>d-1){for(let Oe=0;Oe<f;Oe++){let Ge=Oe+ge*N[2]+te*N[1]+A*N[0];y.values[Ge]=l}continue}let be=Math.floor(Se),ke=Math.ceil(Se),Te=Se-be;for(let Oe=0;Oe<f;Oe++){let Ge=Oe+be*I[2]+ne*I[1]+Z*I[0],Ke=C[Ge];Ge=Oe+ke*I[2]+ne*I[1]+Z*I[0];let Ze=C[Ge];Ge=Oe+be*I[2]+ae*I[1]+Z*I[0];let lt=C[Ge];Ge=Oe+ke*I[2]+ae*I[1]+Z*I[0];let _e=C[Ge],Ct=Ke+(Ze-Ke)*Te,ze=lt+(_e-lt)*Te;Ge=Oe+ge*N[2]+te*N[1]+A*N[0],y.values[Ge]=Ct+(ze-Ct)*ye}}}else for(let ne=0;ne<g;++ne){let ae=g>1?z*(d-1)+ne*J:.5*(z+K)*(d-1);if(ae<0||ae>d-1){for(let Se=0;Se<f;Se++){let be=Se+ne*N[2]+te*N[1]+A*N[0];y.values[be]=l}continue}let ye=Math.round(ae),ge=Math.round(ie);for(let Se=0;Se<f;Se++){let be=Se+ye*I[2]+ge*I[1]+Z*I[0],ke=Se+ne*N[2]+te*N[1]+A*N[0];y.values[ke]=C[be]}}}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}var B7={kernelName:Lp,backendName:"cpu",kernelFunc:VDe};function UDe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n;de(o,"cumprod");let u=T.getAxesPermutation([s],o.shape.length),l=o;u!=null&&(l=Hr({inputs:{x:o},backend:e,attrs:{perm:u}}));let c=T.getInnerMostAxes(1,o.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);let p=mr(l.dtype,"int32"),d=b.makeOnesTypedArray(b.sizeFromShape(l.shape),p),f=e.data.get(l.dataId).values,h=l.shape[l.shape.length-1],m=a?(y,x)=>y+h-x-1:(y,x)=>y+x;for(let y=0;y<f.length;y+=h)for(let x=0;x<h;x++){let w=m(y,x);if(x===0)d[w]=i?1:f[w];else{let C=m(y,x-1);d[w]=i?f[C]*d[C]:f[w]*d[C]}}let g=e.makeTensorInfo(l.shape,p,d);if(u!=null){let y=T.getUndoAxesPermutation(u),x=Hr({inputs:{x:g},backend:e,attrs:{perm:y}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(l),x}return g}var V7={kernelName:Pp,backendName:"cpu",kernelFunc:UDe};function GDe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n;de(o,"cumsum");let u=T.getAxesPermutation([s],o.shape.length),l=o;u!=null&&(l=Hr({inputs:{x:o},backend:e,attrs:{perm:u}}));let c=T.getInnerMostAxes(1,o.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);let p=mr(l.dtype,"int32"),d=b.makeZerosTypedArray(b.sizeFromShape(l.shape),p),f=e.data.get(l.dataId).values,h=l.shape[l.shape.length-1],m=a?(y,x)=>y+h-x-1:(y,x)=>y+x;for(let y=0;y<f.length;y+=h)for(let x=0;x<h;x++){let w=m(y,x);if(x===0)d[w]=i?0:f[w];else{let C=m(y,x-1);d[w]=i?f[C]+d[C]:f[w]+d[C]}}let g=e.makeTensorInfo(l.shape,p,d);if(u!=null){let y=T.getUndoAxesPermutation(u),x=Hr({inputs:{x:g},backend:e,attrs:{perm:y}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(l),x}return g}var U7={kernelName:Hu,backendName:"cpu",kernelFunc:GDe};function WDe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:i,binaryOutput:a}=n;if(o.shape.length===1){let u=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,c=by(u,l,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,c)}else if(o.shape.length===2){let u=e.bufferSync(o),l=e.bufferSync(s),c=tT(u,l,i,a);return e.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var G7={kernelName:zp,backendName:"cpu",kernelFunc:WDe};function jDe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockSize:s,dataFormat:i}=n;b.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let a=o.shape[0],u=o.shape[1],l=o.shape[2],c=o.shape[3],p=u*s,d=l*s,f=c/(s*s),h=e.data.get(o.dataId).values,m=new Float32Array(a*p*d*f),g=0;for(let y=0;y<a;++y)for(let x=0;x<p;++x){let w=Math.floor(x/s),C=x%s;for(let I=0;I<d;++I){let N=Math.floor(I/s),A=I%s,O=(C*s+A)*f;for(let $=0;$<f;++$){let G=$+O+c*(N+l*(w+u*y));m[g++]=h[G]}}}return e.makeTensorInfo([a,p,d,f],o.dtype,m)}var W7={kernelName:Bp,backendName:"cpu",kernelFunc:jDe};function BF(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u,dimRoundingMode:l}=n;de([o,s],"depthwiseConv2DNative");let c=b.computeStrides(o.shape),p=b.computeStrides(s.shape),d=u;d==null&&(d=[1,1]),b.assert(T.eitherStridesOrDilationsAreOne(i,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let f=T.computeConv2DInfo(o.shape,s.shape,i,d,a,l,!0),{filterHeight:h,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:x}=f,w=x.left,C=x.top,I=f.outChannels/f.inChannels,N=new jt(f.outShape,o.dtype),A=e.data.get(o.dataId).values,O=e.data.get(s.dataId).values,$=N.values;for(let z=0;z<f.batchSize;++z){let G=z*c[0],K=z*N.strides[0];for(let Z=0;Z<f.outHeight;++Z){let Q=K+Z*N.strides[1],J=Z*f.strideHeight-C;for(let te=0;te<h;++te){let ie=J+te*g;if(ie<0||ie>=f.inHeight)continue;let ne=te*p[0],ae=G+ie*c[1];for(let ye=0;ye<f.outWidth;++ye){let ge=Q+ye*N.strides[2],Se=ye*f.strideWidth-w;for(let be=0;be<m;++be){let ke=Se+be*y;if(ke<0||ke>=f.inWidth)continue;let Te=ne+be*p[1],Oe=ae+ke*f.inChannels,Ge=ge,Ke=Te;for(let Ze=0;Ze<f.inChannels;++Ze){let lt=A[Oe+Ze];for(let _e=0;_e<I;++_e)$[Ge+_e]+=lt*O[Ke+_e];Ge+=I,Ke+=I}}}}}}return e.makeTensorInfo(N.shape,N.dtype,N.values)}var j7={kernelName:qu,backendName:"cpu",kernelFunc:BF};function HDe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,filterShape:c}=n;de([o,s],"depthwiseConv2dNativeBackpropFilter");let p=T.computeConv2DInfo(o.shape,c,i,a,u,l,!0),{strideHeight:d,strideWidth:f,filterHeight:h,filterWidth:m}=p,g=new jt(p.filterShape,"float32"),y=p.padInfo.left,x=p.padInfo.top,w=p.outChannels/p.inChannels,C=e.data.get(o.dataId).values,I=new jt(o.shape,o.dtype,C),N=e.data.get(s.dataId).values,A=new jt(s.shape,s.dtype,N);for(let O=0;O<h;++O){let $=Math.max(0,Math.ceil((x-O)/d)),z=Math.min(p.outHeight,(p.inHeight+x-O)/d);for(let G=0;G<m;++G){let K=Math.max(0,Math.ceil((y-G)/f)),Z=Math.min(p.outWidth,(p.inWidth+y-G)/f);for(let Q=0;Q<p.outChannels;++Q){let J=Math.trunc(Q/w),te=Q%w,ie=0;for(let ne=0;ne<p.batchSize;++ne)for(let ae=$;ae<z;++ae){let ye=O+ae*d-x;for(let ge=K;ge<Z;++ge){let Se=G+ge*f-y;ie+=I.get(ne,ye,Se,J)*A.get(ne,ae,ge,Q)}}g.set(ie,O,G,J,te)}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}var H7={kernelName:Vp,backendName:"cpu",kernelFunc:HDe};function qDe(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,inputShape:c}=n;de([o,s],"depthwiseConv2DNativeBackpropInput");let p=b.computeStrides(o.shape),d=b.computeStrides(s.shape),f=T.computeConv2DInfo(c,s.shape,i,a,u,l,!0),h=new jt(f.inShape,"float32"),m=h.values,[g,y,x]=h.strides,w=e.data.get(o.dataId).values,[C,I,N]=p,A=e.data.get(s.dataId).values,[O,$,z]=d,{batchSize:G,filterHeight:K,filterWidth:Z,inChannels:Q,inHeight:J,inWidth:te,outChannels:ie,outHeight:ne,outWidth:ae,strideHeight:ye,strideWidth:ge}=f,Se=K-1-f.padInfo.top,be=Z-1-f.padInfo.left,ke=ie/Q;for(let Te=0;Te<G;++Te)for(let Oe=0;Oe<Q;++Oe)for(let Ge=0;Ge<J;++Ge){let Ke=Ge-Se,Ze=Math.max(0,Math.ceil(Ke/ye)),lt=Math.min(ne,(K+Ke)/ye);for(let _e=0;_e<te;++_e){let Ct=_e-be,ze=Math.max(0,Math.ceil(Ct/ge)),nt=Math.min(ae,(Z+Ct)/ge),Lt=0;for(let tt=Ze;tt<lt;++tt){let vr=tt*ye-Ke;for(let Or=ze;Or<nt;++Or){let ei=Or*ge-Ct,Dn=C*Te+I*tt+N*Or,zi=O*(K-1-vr)+$*(Z-1-ei)+z*Oe;for(let ho=0;ho<ke;++ho){let gu=Oe*ke+ho,Kn=w[Dn+gu],ti=A[zi+ho];Lt+=Kn*ti}}}m[g*Te+y*Ge+x*_e+Oe]=Lt}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}var q7={kernelName:Up,backendName:"cpu",kernelFunc:qDe};function KDe(r){let{inputs:t,backend:e}=r,{x:n}=t,o=b.sizeFromShape(n.shape),s=e.data.get(n.dataId).values,i=Ne([o,o],n.dtype),a=i.values;for(let l=0;l<s.length;l++)a[l*o+l]=s[l];let u=[...n.shape,...n.shape];return e.makeTensorInfo(u,i.dtype,i.values)}var K7={kernelName:Gp,backendName:"cpu",kernelFunc:KDe};var X7={kernelName:Ku,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:e})=>{let{x:n,filter:o}=r,{strides:s,pad:i,dilations:a}=e,u=t,l=u.data.get(n.dataId).values,c=n.shape.length,p=u.data.get(o.dataId).values,d=o.shape.length,{batchSize:f,inHeight:h,inWidth:m,inChannels:g,outHeight:y,outWidth:x,padInfo:w,strideHeight:C,strideWidth:I,filterHeight:N,filterWidth:A,dilationHeight:O,dilationWidth:$,outShape:z}=T.computeDilation2DInfo(n.shape,o.shape,s,i,"NHWC",a),G=b.sizeFromShape(z),K=z.length,Z=b.getArrayFromDType(n.dtype,G);for(let J=0;J<f;++J)for(let te=0;te<y;++te){let ie=te*C-w.top;for(let ne=0;ne<x;++ne){let ae=ne*I-w.left;for(let ye=0;ye<g;++ye){let ge=Number.MIN_SAFE_INTEGER;for(let be=0;be<N;++be){let ke=ie+be*O;if(ke>=0&&ke<h)for(let Te=0;Te<A;++Te){let Oe=ae+Te*$;if(Oe>=0&&Oe<m){let Ge=b.locToIndex([J,ke,Oe,ye],c,b.computeStrides(n.shape)),Ke=b.locToIndex([be,Te,ye],d,b.computeStrides(o.shape)),Ze=l[Ge]+p[Ke];Ze>ge&&(ge=Ze)}}}let Se=b.locToIndex([J,te,ne,ye],K,b.computeStrides(z));Z[Se]=ge}}}return{dataId:u.write(b.toTypedArray(Z,n.dtype),z,n.dtype),shape:z,dtype:n.dtype}}};var Y7={kernelName:eh,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:e})=>{let{x:n,filter:o,dy:s}=r,{strides:i,pad:a,dilations:u}=e,l=t,c=b.toNestedArray(n.shape,l.data.get(n.dataId).values),p=b.toNestedArray(o.shape,l.data.get(o.dataId).values),{batchSize:d,inHeight:f,inWidth:h,inChannels:m,outHeight:g,outWidth:y,padInfo:x,strideHeight:w,strideWidth:C,filterHeight:I,filterWidth:N,dilationHeight:A,dilationWidth:O,outShape:$}=T.computeDilation2DInfo(n.shape,o.shape,i,a,"NHWC",u);b.assert(s.rank===$.length,()=>`Error in ${eh}, dy must have the same rank as output ${$.length}, but got ${s.rank}`);let z=b.toNestedArray($,l.data.get(s.dataId).values),G=b.makeZerosNestedTypedArray(o.shape,o.dtype);for(let Z=0;Z<d;++Z)for(let Q=0;Q<g;++Q){let J=Q*w-x.top;for(let te=0;te<y;++te){let ie=te*C-x.left;for(let ne=0;ne<m;++ne){let ae=Number.MIN_SAFE_INTEGER,ye=0,ge=0;for(let Se=0;Se<I;++Se){let be=J+Se*A;if(be>=0&&be<f)for(let ke=0;ke<N;++ke){let Te=ie+ke*O;if(Te>=0&&Te<h){let Oe=c[Z][be][Te][ne]+p[Se][ke][ne];Oe>ae&&(ae=Oe,ye=Se,ge=ke)}}}G[ye][ge][ne]+=z[Z][Q][te][ne]}}}return{dataId:l.write(b.toTypedArray(G,n.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};var Z7={kernelName:Jf,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:e})=>{let{x:n,filter:o,dy:s}=r,{strides:i,pad:a,dilations:u}=e,l=t,c=b.toNestedArray(n.shape,l.data.get(n.dataId).values),p=b.toNestedArray(o.shape,l.data.get(o.dataId).values),{batchSize:d,inHeight:f,inWidth:h,inChannels:m,outHeight:g,outWidth:y,padInfo:x,strideHeight:w,strideWidth:C,filterHeight:I,filterWidth:N,dilationHeight:A,dilationWidth:O,outShape:$}=T.computeDilation2DInfo(n.shape,o.shape,i,a,"NHWC",u);b.assert(s.rank===$.length,()=>`Error in ${Jf}, dy must have the same rank as output ${$.length}, but got ${s.rank}`);let z=b.toNestedArray($,l.data.get(s.dataId).values),G=b.makeZerosNestedTypedArray(n.shape,n.dtype);for(let Z=0;Z<d;++Z)for(let Q=0;Q<g;++Q){let J=Q*w-x.top;for(let te=0;te<y;++te){let ie=te*C-x.left;for(let ne=0;ne<m;++ne){let ae=Number.MIN_SAFE_INTEGER,ye=J<0?0:J,ge=ie<0?0:ie;for(let Se=0;Se<I;++Se){let be=J+Se*A;if(be>=0&&be<f)for(let ke=0;ke<N;++ke){let Te=ie+ke*O;if(Te>=0&&Te<h){let Oe=c[Z][be][Te][ne]+p[Se][ke][ne];Oe>ae&&(ae=Oe,ye=be,ge=Te)}}}G[Z][ye][ge][ne]+=z[Z][Q][te][ne]}}}return{dataId:l.write(b.toTypedArray(G,n.dtype),n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};function XDe(r){let{inputs:t,backend:e,attrs:n}=r,{image:o}=t,{canvas:s,options:i}=n,{contextOptions:a,imageOptions:u}=i||{},l=u?.alpha||1,c=a?.contextType||"2d";if(c!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);let p=s.getContext(c,a?.contextAttributes||{});if(p==null)throw new Error(`Could not get the context with ${c} type.`);let[d,f]=o.shape.slice(0,2),h=o.shape.length===2?1:o.shape[2],m=e.data.get(o.dataId).values,g=o.dtype==="float32"?255:1,y=new Uint8ClampedArray(f*d*4);for(let w=0;w<d*f;++w){let C=[0,0,0,255*l];for(let N=0;N<h;N++){let A=m[w*h+N];if(o.dtype==="float32"){if(A<0||A>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${A}.`)}else if(o.dtype==="int32"&&(A<0||A>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${A}.`);h===1?(C[0]=A*g,C[1]=A*g,C[2]=A*g):C[N]=A*g}let I=w*4;y[I+0]=Math.round(C[0]),y[I+1]=Math.round(C[1]),y[I+2]=Math.round(C[2]),y[I+3]=Math.round(C[3])}s.width=f,s.height=d;let x=new ImageData(y,f,d);return p.putImageData(x,0,0),o}var Q7={kernelName:th,backendName:"cpu",kernelFunc:XDe};function qc(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;de(o,"sum");let a;o.dtype==="bool"?a=_i({inputs:{x:o},backend:e,attrs:{dtype:"int32"}}):a=po({inputs:{x:o},backend:e});let u=a.shape.length,l=b.parseAxisParam(s,a.shape),c=T.getAxesPermutation(l,u),p=l,d=a;c!=null&&(d=Hr({inputs:{x:a},backend:e,attrs:{perm:c}}),p=T.getInnerMostAxes(p.length,u)),T.assertAxesAreInnerMostDims("sum",p,d.shape.length);let[f,h]=T.computeOutAndReduceShapes(d.shape,p),m=T.upcastType(d.dtype,"int32"),g=xy(e,f,m),y=b.sizeFromShape(h),x=e.data.get(g.dataId).values,w=e.data.get(d.dataId).values;for(let C=0;C<x.length;++C){let I=C*y,N=0;for(let A=0;A<y;++A)N+=w[I+A];x[C]=N}if(i){let C=T.expandShapeToKeepDim(g.shape,l),I=g;g=Tt({inputs:{x:g},backend:e,attrs:{shape:C}}),e.disposeIntermediateTensorInfo(I)}return e.disposeIntermediateTensorInfo(a),c!=null&&e.disposeIntermediateTensorInfo(d),g}var J7={kernelName:vl,backendName:"cpu",kernelFunc:qc};function YDe(r){let{inputs:t,backend:e,attrs:n}=r,{equation:o}=n,s=t,{allDims:i,summedDims:a,idDims:u}=T.decodeEinsumEquation(o,s.length);T.checkEinsumDimSizes(i.length,u,s);let{path:l,steps:c}=T.getEinsumComputePath(a,u),p=c.length,d=null,f=i.length,h=[];for(let m=0;m<p;++m){for(let g of c[m]){let{permutationIndices:y,expandDims:x}=T.getEinsumPermutation(f,u[g]),w;T.isIdentityPermutation(y)?w=s[g]:(w=Hr({inputs:{x:s[g]},backend:e,attrs:{perm:y}}),h.push(w));let C=w.shape.slice();for(let I=0;I<x.length;++I)C.splice(x[I],0,1);b.arraysEqual(w.shape,C)||(w=Tt({inputs:{x:w},backend:e,attrs:{shape:C}}),h.push(w)),d===null?d=w:(d=Mh({inputs:{a:w,b:d},backend:e}),h.push(d))}m<p-1&&(l[m]>=0&&(d=qc({inputs:{x:d},backend:e,attrs:{axis:l[m]-(i.length-f),keepDims:!1}}),h.push(d)),f--)}for(let m of h)m!==d&&e.disposeIntermediateTensorInfo(m);return d}var eZ={kernelName:Wp,backendName:"cpu",kernelFunc:YDe};function ZDe(r){let{inputs:t,backend:e}=r,{dy:n,y:o}=t;de([n,o],"eluGrad");let s=new Float32Array(b.sizeFromShape(o.shape)),i=e.data.get(o.dataId).values,a=e.data.get(n.dataId).values;for(let u=0;u<i.length;++u){let l=i[u];l>=0?s[u]=a[u]:s[u]=a[u]*(l+1)}return e.makeTensorInfo(o.shape,"float32",s)}var tZ={kernelName:jp,backendName:"cpu",kernelFunc:ZDe};var QDe=T.ERF_P,JDe=T.ERF_A1,eAe=T.ERF_A2,tAe=T.ERF_A3,rAe=T.ERF_A4,nAe=T.ERF_A5,oAe=Je(pa,r=>{let t=Math.sign(r),e=Math.abs(r),n=1/(1+QDe*e);return t*(1-((((nAe*n+rAe)*n+tAe)*n+eAe)*n+JDe)*n*Math.exp(-e*e))}),rZ={kernelName:pa,backendName:"cpu",kernelFunc:oAe};function Hy(r){let{inputs:t,backend:e,attrs:n}=r,{input:o}=t,{dim:s}=n,i=o.shape.length,a=o.shape.slice(),u=s;return s<0&&(b.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),a.splice(u,0,1),Tt({inputs:{x:o},backend:e,attrs:{shape:a}})}var nZ={kernelName:Xu,backendName:"cpu",kernelFunc:Hy};var sAe=It((r,t)=>r/t),jb=Mt(la,sAe),Hb={kernelName:la,backendName:"cpu",kernelFunc:jb};function O1(r,t,e){let n=r.shape,o=n[0],s=n[1],i=e.data.get(r.dataId),a=i.complexTensorInfos.real,u=i.complexTensorInfos.imag,l=[o,s],c=b.sizeFromShape(l),p=b.getTypedArrayFromDType("float32",c),d=b.getTypedArrayFromDType("float32",c);for(let g=0;g<o;g++){let y=ki({inputs:{x:a},backend:e,attrs:{begin:[g,0],size:[1,s]}}),x=ki({inputs:{x:u},backend:e,attrs:{begin:[g,0],size:[1,s]}}),w=Mn({inputs:{real:y,imag:x},backend:e}),{real:C,imag:I}=iAe(w,t,e),N=T.mergeRealAndImagArrays(C,I);for(let A=0;A<s;A++){let O=T.getComplexWithIndex(N,A);p[g*s+A]=O.real,d[g*s+A]=O.imag}e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(w)}let f=e.makeTensorInfo(l,"float32",p),h=e.makeTensorInfo(l,"float32",d),m=Mn({inputs:{real:f,imag:h},backend:e});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(h),m}function iAe(r,t,e){let n=b.sizeFromShape(r.shape),o=e.data.get(r.dataId),s=e.data.get(o.complexTensorInfos.real.dataId).values,i=e.data.get(o.complexTensorInfos.imag.dataId).values;if(aAe(n)){let a=VF(s,i,n,t,e),u=[r.shape[0],r.shape[1]];if(t){let l=e.makeTensorInfo(u,"float32",a.real),c=e.makeTensorInfo(u,"float32",a.imag),p=e.makeTensorInfo([],"float32",b.createScalarValue(n,"float32")),d=po({inputs:{x:p},backend:e}),f=Hb.kernelFunc({inputs:{a:l,b:p},backend:e}),h=Hb.kernelFunc({inputs:{a:c,b:d},backend:e}),m=e.data.get(f.dataId).values,g=e.data.get(h.dataId).values;return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(h),{real:m,imag:g}}return a}else{let a=T.mergeRealAndImagArrays(s,i),u=uAe(a,n,t);return T.splitRealAndImagArrays(u)}}function aAe(r){return(r&r-1)===0}function VF(r,t,e,n,o){if(e===1)return{real:r,imag:t};let s=T.mergeRealAndImagArrays(r,t),i=e/2,a=T.complexWithEvenIndex(s),u=a.real,l=a.imag,c=[u.length],p=o.makeTensorInfo(c,"float32",u),d=o.makeTensorInfo(c,"float32",l),f=Mn({inputs:{real:p,imag:d},backend:o}),h=T.complexWithOddIndex(s),m=h.real,g=h.imag,y=[m.length],x=o.makeTensorInfo(y,"float32",m),w=o.makeTensorInfo(y,"float32",g),C=Mn({inputs:{real:x,imag:w},backend:o}),I=VF(u,l,i,n,o),N=I.real,A=I.imag,O=[N.length],$=o.makeTensorInfo(O,"float32",N),z=o.makeTensorInfo(O,"float32",A),G=Mn({inputs:{real:$,imag:z},backend:o}),K=VF(m,g,i,n,o),Z=K.real,Q=K.imag,J=[Z.length],te=o.makeTensorInfo(J,"float32",Z),ie=o.makeTensorInfo(J,"float32",Q),ne=Mn({inputs:{real:te,imag:ie},backend:o}),ae=T.exponents(e,n),ye=[ae.real.length],ge=o.makeTensorInfo(ye,"float32",ae.real),Se=o.makeTensorInfo(ye,"float32",ae.imag),be=Mn({inputs:{real:ge,imag:Se},backend:o}),ke=Mh({inputs:{a:be,b:ne},backend:o}),Te=Ll({inputs:{a:G,b:ke},backend:o}),Oe=vb({inputs:{a:G,b:ke},backend:o}),Ge=Ti({inputs:{input:Te},backend:o}),Ke=Ti({inputs:{input:Oe},backend:o}),Ze=jl({inputs:{input:Te},backend:o}),lt=jl({inputs:{input:Oe},backend:o}),_e=nf({inputs:[Ge,Ke],backend:o,attrs:{axis:0}}),Ct=nf({inputs:[Ze,lt],backend:o,attrs:{axis:0}}),ze=o.data.get(_e.dataId).values,nt=o.data.get(Ct.dataId).values;return o.disposeIntermediateTensorInfo(p),o.disposeIntermediateTensorInfo(d),o.disposeIntermediateTensorInfo(f),o.disposeIntermediateTensorInfo(x),o.disposeIntermediateTensorInfo(w),o.disposeIntermediateTensorInfo(C),o.disposeIntermediateTensorInfo($),o.disposeIntermediateTensorInfo(z),o.disposeIntermediateTensorInfo(G),o.disposeIntermediateTensorInfo(te),o.disposeIntermediateTensorInfo(ie),o.disposeIntermediateTensorInfo(ne),o.disposeIntermediateTensorInfo(ge),o.disposeIntermediateTensorInfo(Se),o.disposeIntermediateTensorInfo(be),o.disposeIntermediateTensorInfo(ke),o.disposeIntermediateTensorInfo(Te),o.disposeIntermediateTensorInfo(Oe),o.disposeIntermediateTensorInfo(Ge),o.disposeIntermediateTensorInfo(Ze),o.disposeIntermediateTensorInfo(Ke),o.disposeIntermediateTensorInfo(lt),o.disposeIntermediateTensorInfo(_e),o.disposeIntermediateTensorInfo(Ct),{real:ze,imag:nt}}function uAe(r,t,e){let n=new Float32Array(t*2);for(let o=0;o<t;o++){let s=0,i=0;for(let a=0;a<t;a++){let u=T.exponent(o*a,t,e),l=T.getComplexWithIndex(r,a);s+=l.real*u.real-l.imag*u.imag,i+=l.real*u.imag+l.imag*u.real}e&&(s/=t,i/=t),T.assignToTypedArray(n,s,i,o)}return n}function lAe(r){let{inputs:t,backend:e}=r,{input:n}=t,o=b.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],i=o/s,a=Tt({inputs:{x:n},backend:e,attrs:{shape:[i,s]}}),u=O1(a,!1,e),l=Tt({inputs:{x:u},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),l}var oZ={kernelName:Hp,backendName:"cpu",kernelFunc:lAe};function qb(r){let{backend:t,attrs:e}=r,{shape:n,value:o,dtype:s}=e,i=s||b.inferDtype(o),a=b.getArrayFromDType(i,b.sizeFromShape(n));return cAe(a,o,i),t.makeTensorInfo(n,i,a)}var sZ={kernelName:qp,backendName:"cpu",kernelFunc:qb};function cAe(r,t,e){r.fill(t)}var iZ={kernelName:Kp,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:n}=r,o=e,s=b.getTypedArrayFromDType(n.dtype,b.sizeFromShape(n.shape)),[i,a,u,l]=n.shape,c=o.data.get(n.dataId).values;for(let d=0;d<i;d++){let f=d*u*a*l;for(let h=0;h<a;h++){let m=h*(u*l);for(let g=0;g<u;g++){let y=g*l;for(let x=0;x<l;x++){let w=Math.round(u-g-1),C=f+m+y+x,I=c[C];if(w>=0&&w<u){let N=w*l,A=f+m+N+x;I=c[A]}s[C]=I}}}}return{dataId:o.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};function pAe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:d,activation:f,leakyreluAlpha:h}=n,m=zF({inputs:{x:o,filter:s},backend:e,attrs:{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:d}});if(i){let g=m;if(c==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){let y=Tt({inputs:{x:i},backend:e,attrs:{shape:[i.shape[0],1,1]}});m=Ll({inputs:{a:m,b:y},backend:e}),e.disposeIntermediateTensorInfo(y)}else m=Ll({inputs:{a:m,b:i},backend:e});e.disposeIntermediateTensorInfo(g)}if(f){let g=m;if(c==="NCHW"&&f==="prelu"&&a.shape.length===1&&a.shape[0]!==1){let y=Tt({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});m=jh(e,m,f,y,h),e.disposeIntermediateTensorInfo(y)}else m=jh(e,m,f,a,h);e.disposeIntermediateTensorInfo(g)}return m}var aZ={kernelName:Sc,backendName:"cpu",kernelFunc:pAe};function dAe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:d,activation:f,leakyreluAlpha:h}=n,m=BF({inputs:{x:o,filter:s},backend:e,attrs:{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:d}});if(i){let g=m;m=Ll({inputs:{a:m,b:i},backend:e}),e.disposeIntermediateTensorInfo(g)}if(f){let g=m;m=jh(e,m,f,a,h),e.disposeIntermediateTensorInfo(g)}return m}var uZ={kernelName:Ic,backendName:"cpu",kernelFunc:dAe};function fAe(r){let{inputs:t,backend:e}=r,{params:n,indices:o}=t,s=b.sizeFromShape(n.shape),i=o.shape,a=i[i.length-1],[u,l,c,p]=T.prepareAndValidate(n,o);if(l===0)return e.makeTensorInfo(u,n.dtype,[]);let d=e.data.get(o.dataId).values,f=e.bufferSync(n),h=nT(d,f,n.dtype,l,a,c,p,n.shape,s);return e.makeTensorInfo(u,n.dtype,h.values)}var lZ={kernelName:Xp,backendName:"cpu",kernelFunc:fAe};function hAe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,indices:s}=t,{axis:i,batchDims:a}=n;de([o,s],"gatherV2");let u=b.parseAxisParam(i,o.shape)[0],l=e.data.get(s.dataId).values,c=o.shape[u];for(let C=0;C<l.length;++C){let I=l[C];b.assert(I<=c-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${c-1}]`)}let p=a;a==null&&(p=0);let d=b.sizeFromShape(s.shape),f=T.segment_util.collectGatherOpShapeInfo(o,s,u,p),h=Tt({inputs:{x:o},backend:e,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),m=Tt({inputs:{x:s},backend:e,attrs:{shape:[f.batchSize,d/f.batchSize]}}),g=[f.batchSize,f.outerSize,d/f.batchSize,f.sliceSize],y=e.bufferSync(m),x=e.bufferSync(h),w=oT(x,y,g);return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(m),e.makeTensorInfo(f.outputShape,w.dtype,w.values)}var cZ={kernelName:Zu,backendName:"cpu",kernelFunc:hAe};function mAe(r){let{inputs:t,backend:e}=r,{input:n}=t,o=b.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],i=o/s,a=Tt({inputs:{x:n},backend:e,attrs:{shape:[i,s]}}),u=O1(a,!0,e),l=Tt({inputs:{x:u},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),l}var pZ={kernelName:Yp,backendName:"cpu",kernelFunc:mAe};var gAe=Je(ya,r=>Number.isFinite(r)?1:0,"bool"),dZ={kernelName:ya,backendName:"cpu",kernelFunc:gAe};var yAe=Je(xa,r=>Math.abs(r)===1/0?1:0,"bool"),fZ={kernelName:xa,backendName:"cpu",kernelFunc:yAe};var xAe=Je(va,r=>Number.isNaN(r)?1:0,"bool"),hZ={kernelName:va,backendName:"cpu",kernelFunc:xAe};function vAe(r){let{backend:t,attrs:e}=r,{start:n,stop:o,num:s}=e,i=sT(n,o,s);return t.makeTensorInfo([i.length],"float32",i)}var mZ={kernelName:Qp,backendName:"cpu",kernelFunc:vAe};var bAe=Je(wa,r=>Math.log1p(r)),gZ={kernelName:wa,backendName:"cpu",kernelFunc:bAe};var wAe=It((r,t)=>r&&t),CAe=Mt(xc,wAe,null,"bool"),yZ={kernelName:xc,backendName:"cpu",kernelFunc:CAe};var SAe=Je(vc,r=>r?0:1,"bool"),xZ={kernelName:vc,backendName:"cpu",kernelFunc:SAe};var IAe=It((r,t)=>r||t),TAe=Mt(bc,IAe,null,"bool"),vZ={kernelName:bc,backendName:"cpu",kernelFunc:TAe};function _Ae(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{depthRadius:s,bias:i,alpha:a,beta:u}=n;de(o,"LRN");let l=o.shape[3],c=l-1,p=e.data.get(o.dataId).values,d=b.sizeFromShape(o.shape),f=new Float32Array(d);function h(m){let g=m%l,y=m-g+Math.max(0,g-s),x=m-g+Math.min(g+s,c),w=0;for(;y<=x;y++){let C=p[y];w+=C*C}return w}for(let m=0;m<d;m++){let g=h(m),y=p[m]*Math.pow(i+a*g,-u);f[m]=y}return e.makeTensorInfo(o.shape,o.dtype,f)}var bZ={kernelName:Ju,backendName:"cpu",kernelFunc:_Ae};function EAe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,y:s,dy:i}=t,{depthRadius:a,bias:u,alpha:l,beta:c}=n;de(i,"LRNGrad");let p=b.sizeFromShape(i.shape),d=i.shape[3],f=e.data.get(i.dataId).values,h=e.data.get(o.dataId).values,m=e.data.get(s.dataId).values,g=new Float32Array(p),y=p;for(let x=0;x<y;x++){let w=x%d,C=x-w+Math.max(0,w-a),I=x-w+Math.min(d,w+a+1),N=0;for(let A=C;A<I;A++)N+=Math.pow(h[A],2);N=l*N+u;for(let A=C;A<I;A++){let O=-2*l*c*h[A]*m[x]/N;x===A&&(O+=Math.pow(N,-c)),O*=f[x],g[A]+=O}}return e.makeTensorInfo(i.shape,o.dtype,g)}var wZ={kernelName:Jp,backendName:"cpu",kernelFunc:EAe};function UF(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reductionIndices:s,keepDims:i}=n,a=e,u=o.shape,l=u.length,c=b.parseAxisParam(s,u),p=c,d=T.getAxesPermutation(p,l),f=a.data.get(o.dataId).values;if(d!=null){let C=new Array(l);for(let I=0;I<C.length;I++)C[I]=u[d[I]];f=wy(f,u,o.dtype,d,C),p=T.getInnerMostAxes(p.length,l),u=C}de(o,"max"),T.assertAxesAreInnerMostDims("max",p,l);let[h,m]=T.computeOutAndReduceShapes(u,p),g=b.sizeFromShape(m),y=iT(f,g,h,o.dtype),x=a.write(y,h,o.dtype),w=h;return i&&(w=T.expandShapeToKeepDim(h,c)),{dataId:x,shape:w,dtype:o.dtype}}var CZ={kernelName:el,backendName:"cpu",kernelFunc:UF};function kAe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;de(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;b.assert(T.eitherStridesOrDilationsAreOne(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let c=T.computePool2DInfo(o.shape,s,i,l,a,u),p;if(c.filterWidth===1&&c.filterHeight===1&&b.arraysEqual(c.inShape,c.outShape))p=po({inputs:{x:o},backend:e});else{let d=e.data.get(o.dataId).values,f=b.computeStrides(o.shape),h=jy(d,o.shape,o.dtype,f,c,"max");p=e.makeTensorInfo(c.outShape,o.dtype,h.values)}return p}var SZ={kernelName:tl,backendName:"cpu",kernelFunc:kAe};function NAe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=n;de(o,"maxPool3d");let c=T.computePool3DInfo(o.shape,s,i,1,a,u,l),p=e.data.get(o.dataId).values,d=R1(p,o.shape,o.dtype,b.computeStrides(o.shape),c,"max");return e.makeTensorInfo(d.shape,"float32",d.values)}var IZ={kernelName:rl,backendName:"cpu",kernelFunc:NAe};function DAe(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=n;de([o,s],"maxPool3DGrad");let c=T.computePool3DInfo(s.shape,i,a,1,u,l),p=e.bufferSync(s),d=v7(p,c),f=c.strideDepth,h=c.strideHeight,m=c.strideWidth,g=c.dilationDepth,y=c.dilationHeight,x=c.dilationWidth,w=c.effectiveFilterDepth,C=c.effectiveFilterHeight,I=c.effectiveFilterWidth,N=w-1-c.padInfo.front,A=I-1-c.padInfo.left,O=C-1-c.padInfo.top,$=Ne(s.shape,"float32"),z=e.bufferSync(o);for(let G=0;G<c.batchSize;++G)for(let K=0;K<c.inChannels;++K)for(let Z=0;Z<c.inDepth;++Z)for(let Q=0;Q<c.inHeight;++Q)for(let J=0;J<c.inWidth;++J){let te=Z-N,ie=Q-O,ne=J-A,ae=0;for(let ye=0;ye<w;ye+=g){let ge=(te+ye)/f;if(!(ge<0||ge>=c.outDepth||Math.floor(ge)!==ge))for(let Se=0;Se<C;Se+=y){let be=(ie+Se)/h;if(!(be<0||be>=c.outHeight||Math.floor(be)!==be))for(let ke=0;ke<I;ke+=x){let Te=(ne+ke)/m;if(Te<0||Te>=c.outWidth||Math.floor(Te)!==Te)continue;let Oe=w*C*I-1-d.get(G,ge,be,Te,K),Ge=ye*C*I+Se*I+ke,Ke=Oe===Ge?1:0;if(Ke===0)continue;let Ze=z.get(G,ge,be,Te,K);ae+=Ze*Ke}}}$.set(ae,G,Z,Q,J,K)}return e.makeTensorInfo($.shape,$.dtype,$.values)}var TZ={kernelName:td,backendName:"cpu",kernelFunc:DAe};function AAe(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s,output:i}=t,a=s;de([s,i],"maxPoolGrad");let{filterSize:u,strides:l,pad:c,dimRoundingMode:p}=n,d=T.computePool2DInfo(a.shape,u,l,1,c,p),f=e.data.get(a.dataId).values,h=Ne(d.outShape,a.dtype,A1(f,a.shape,a.dtype,d).values),m=d.strideHeight,g=d.strideWidth,y=d.dilationHeight,x=d.dilationWidth,w=d.effectiveFilterHeight,C=d.effectiveFilterWidth,I=C-1-d.padInfo.left,N=w-1-d.padInfo.top,A=Ne(a.shape,"float32"),O=e.data.get(o.dataId).values,$=Ne(o.shape,"float32",O);for(let z=0;z<d.batchSize;++z)for(let G=0;G<d.inChannels;++G)for(let K=0;K<d.inHeight;++K)for(let Z=0;Z<d.inWidth;++Z){let Q=K-N,J=Z-I,te=0;for(let ie=0;ie<w;ie+=y){let ne=(Q+ie)/m;if(!(ne<0||ne>=d.outHeight||Math.floor(ne)!==ne))for(let ae=0;ae<C;ae+=x){let ye=(J+ae)/g;if(ye<0||ye>=d.outWidth||Math.floor(ye)!==ye)continue;let ge=w*C-1-h.get(z,ne,ye,G),Se=ie*C+ae,be=ge===Se?1:0;if(be===0)continue;let ke=$.get(z,ne,ye,G);te+=ke*be}}A.set(te,z,K,Z,G)}return e.makeTensorInfo(A.shape,A.dtype,A.values)}var _Z={kernelName:ed,backendName:"cpu",kernelFunc:AAe};function EZ(r,t,e,n,o){let s=b.computeStrides(t),i=jy(r,t,e,s,o,"max"),a=A1(r,t,e,o,!0,n);return[i.values,a.values]}var kZ={kernelName:rd,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n}=r,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=t,u=e;de(n,"MaxPoolWithArgmax");let l=u.data.get(n.dataId).values,c=T.computePool2DInfo(n.shape,o,s,[1,1],i),[p,d]=EZ(l,n.shape,n.dtype,a,c),f=u.write(p,c.outShape,n.dtype),h=u.write(d,c.outShape,n.dtype);return[{dataId:f,shape:c.outShape,dtype:n.dtype},{dataId:h,shape:c.outShape,dtype:"int32"}]}};function RAe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=b.parseAxisParam(s,o.shape),l=T.computeOutAndReduceShapes(o.shape,a)[1],c=b.sizeFromShape(l),p=[],d=e.makeTensorInfo([],"float32",new Float32Array([c]));p.push(d);let f=_i({inputs:{x:o},backend:e,attrs:{dtype:"float32"}});p.push(f);let h=jb({inputs:{a:f,b:d},backend:e});p.push(h);let m=qc({inputs:{x:h},backend:e,attrs:{axis:s,keepDims:i}});return p.forEach(g=>e.disposeIntermediateTensorInfo(g)),m}var NZ={kernelName:nl,backendName:"cpu",kernelFunc:RAe};function OAe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;de(o,"min");let a=b.parseAxisParam(s,o.shape),u=a,l=T.getAxesPermutation(u,o.shape.length),c=o;l!=null&&(c=Hr({inputs:{x:o},backend:e,attrs:{perm:l}}),u=T.getInnerMostAxes(u.length,o.shape.length)),T.assertAxesAreInnerMostDims("min",u,c.shape.length);let[p,d]=T.computeOutAndReduceShapes(c.shape,u),f=b.sizeFromShape(d),h=b.makeZerosTypedArray(b.sizeFromShape(p),c.dtype),m=e.data.get(c.dataId).values;for(let y=0;y<h.length;++y){let x=y*f,w=m[x];for(let C=0;C<f;++C){let I=m[x+C];(Number.isNaN(I)||I<w)&&(w=I)}h[y]=w}l!=null&&e.disposeIntermediateTensorInfo(c);let g=e.makeTensorInfo(p,c.dtype,h);if(i){let y=T.expandShapeToKeepDim(p,a),x=Tt({inputs:{x:g},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(g),x}return g}var DZ={kernelName:ol,backendName:"cpu",kernelFunc:OAe};function MAe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{paddings:s,mode:i}=n;de(o,"mirrorPad");let a=s.map((w,C)=>w[0]+o.shape[C]+w[1]),u=s.map(w=>w[0]),l=s.map((w,C)=>w[0]+o.shape[C]),c=i==="reflect"?0:1,p=e.data.get(o.dataId).values,d=o.shape.length,f=b.computeStrides(o.shape),h=b.sizeFromShape(a),m=a.length,g=b.computeStrides(a),y=b.getTypedArrayFromDType(o.dtype,h);for(let w=0;w<h;w++){let C=b.indexToLoc(w,m,g);for(let N=0;N<m;N++)C[N]<u[N]?C[N]=u[N]*2-C[N]-c:C[N]>=l[N]&&(C[N]=(l[N]-1)*2-C[N]+c);C=C.map((N,A)=>N-u[A]);let I=b.locToIndex(C,d,f);y[w]=p[I]}return{dataId:e.write(y,a,o.dtype),shape:a,dtype:o.dtype}}var AZ={kernelName:sl,backendName:"cpu",kernelFunc:MAe};var FAe=It((r,t)=>{let e=r%t;return r<0&&t<0||r>=0&&t>=0?e:(e+t)%t}),$Ae=Mt(Ia,FAe),RZ={kernelName:Ia,backendName:"cpu",kernelFunc:$Ae};var MZ=If(eb());function GF(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{dim:s}=n,i=o.shape.length,a=s;if(a===-1&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);let u=b.parseAxisParam([a],o.shape),l=UF({inputs:{x:o},backend:e,attrs:{reductionIndices:u,keepDims:!1}}),c=T.expandShapeToKeepDim(l.shape,u),p=Tt({inputs:{x:l},backend:e,attrs:{shape:c}}),d=vb({inputs:{a:o,b:p},backend:e}),f=YO({inputs:{x:d},backend:e}),h=qc({inputs:{x:f},backend:e,attrs:{axis:u,keepDims:!1}}),m=Tt({inputs:{x:h},backend:e,attrs:{shape:c}}),g=jb({inputs:{a:f,b:m},backend:e});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(m),g}var OZ={kernelName:Cl,backendName:"cpu",kernelFunc:GF};function PAe(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{numSamples:s,seed:i,normalized:a}=n;de(o,"multinomial");let u=a?o:GF({inputs:{logits:o},backend:e,attrs:{dim:-1}}),l=u.shape[0],c=u.shape[1],p=e.data.get(u.dataId).values,d=[l,s],f=b.makeZerosTypedArray(b.sizeFromShape(d),"int32");for(let h=0;h<l;++h){let m=h*c,g=new Float32Array(c-1);g[0]=p[m];for(let w=1;w<g.length;++w)g[w]=g[w-1]+p[m+w];let y=MZ.alea(i.toString()),x=h*s;for(let w=0;w<s;++w){let C=y();f[x+w]=g.length;for(let I=0;I<g.length;I++)if(C<g[I]){f[x+w]=I;break}}}return a||e.disposeIntermediateTensorInfo(u),e.makeTensorInfo(d,"int32",f)}var FZ={kernelName:nd,backendName:"cpu",kernelFunc:PAe};var LAe=En.nonMaxSuppressionV3Impl;function zAe(r){let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=n;de(o,"NonMaxSuppression");let l=e.data.get(o.dataId).values,c=e.data.get(s.dataId).values,{selectedIndices:p}=LAe(l,c,i,a,u);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}var $Z={kernelName:od,backendName:"cpu",kernelFunc:zAe};var BAe=En.nonMaxSuppressionV4Impl;function VAe(r){let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:l}=n;de(o,"NonMaxSuppressionPadded");let c=e.data.get(o.dataId).values,p=e.data.get(s.dataId).values,{selectedIndices:d,validOutputs:f}=BAe(c,p,i,a,u,l);return[e.makeTensorInfo([d.length],"int32",new Int32Array(d)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}var PZ={kernelName:fg,backendName:"cpu",kernelFunc:VAe};var UAe=En.nonMaxSuppressionV5Impl;function GAe(r){let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=n;de(o,"NonMaxSuppressionWithScore");let c=e.data.get(o.dataId).values,p=e.data.get(s.dataId).values,d=i,f=a,h=u,m=l,{selectedIndices:g,selectedScores:y}=UAe(c,p,d,f,h,m);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var LZ={kernelName:sd,backendName:"cpu",kernelFunc:GAe};function WAe(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o}=t,{dtype:s,depth:i,onValue:a,offValue:u}=n;de(o,"oneHot");let l=b.sizeFromShape(o.shape),c=new Float32Array(l*i);c.fill(u);let p=e.data.get(o.dataId).values;for(let d=0;d<l;++d)p[d]>=0&&p[d]<i&&(c[d*i+p[d]]=a);return e.makeTensorInfo([...o.shape,i],s,c)}var zZ={kernelName:ul,backendName:"cpu",kernelFunc:WAe};function Kb(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(n.dtype==="complex64"){let o=Ti({inputs:{input:n},backend:e}),s=Kb({inputs:{x:o},backend:e}),i=jl({inputs:{input:n},backend:e}),a=Kb({inputs:{x:i},backend:e}),u=Mn({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}else return qb({backend:e,attrs:{shape:n.shape,value:0,dtype:n.dtype}})}var BZ={kernelName:Tl,backendName:"cpu",kernelFunc:Kb};function VZ(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(n.dtype==="complex64"){let o=Ti({inputs:{input:n},backend:e}),s=VZ({inputs:{x:o},backend:e}),i=jl({inputs:{input:n},backend:e}),a=Kb({inputs:{x:i},backend:e}),u=Mn({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}else return qb({backend:e,attrs:{shape:n.shape,value:1,dtype:n.dtype}})}var UZ={kernelName:al,backendName:"cpu",kernelFunc:VZ};function WF(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n;if(t.length===1)return Hy({inputs:{input:t[0]},backend:e,attrs:{dim:o}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{b.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),b.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],u=t.map(c=>{let p=Hy({inputs:{input:c},backend:e,attrs:{dim:o}});return a.push(p),p}),l=nf({inputs:u,backend:e,attrs:{axis:o}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),l}var GZ={kernelName:ll,backendName:"cpu",kernelFunc:WF};function jAe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{paddings:s,constantValue:i}=n;de(o,"pad");let a=s.map((x,w)=>x[0]+o.shape[w]+x[1]),u=s.map(x=>x[0]),l=e.data.get(o.dataId).values,c=b.sizeFromShape(o.shape),p=o.shape.length,d=b.computeStrides(o.shape),f=b.sizeFromShape(a),h=a.length,m=b.computeStrides(a),g=b.getTypedArrayFromDType(o.dtype,f);i!==0&&g.fill(i);for(let x=0;x<c;x++){let C=b.indexToLoc(x,p,d).map((N,A)=>N+u[A]),I=b.locToIndex(C,h,m);g[I]=l[x]}return{dataId:e.write(g,a,o.dtype),shape:a,dtype:o.dtype}}var M1={kernelName:cl,backendName:"cpu",kernelFunc:jAe};var HAe=It((r,t)=>Math.pow(r,t)),qAe=Mt(_a,HAe),WZ={kernelName:_a,backendName:"cpu",kernelFunc:qAe};function KAe(r){let{inputs:t,backend:e,attrs:n}=r,{paramsNestedSplits:o,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:a}=n,u=o.map(y=>e.data.get(y.dataId).values),l=o.map(y=>y.shape),c=e.data.get(s.dataId).values,p=e.data.get(i.dataId).values,[d,f,h]=aT(u,l,c,s.shape,s.dtype,p,i.shape,a),m=d.map(y=>e.makeTensorInfo([y.length],"int32",y)),g=e.makeTensorInfo(h,s.dtype,f);return m.concat([g])}var jZ={kernelName:hg,backendName:"cpu",kernelFunc:KAe};function XAe(r){let{inputs:t,backend:e}=r,{starts:n,limits:o,deltas:s}=t,i=e.data.get(n.dataId).values,a=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,[l,c]=uT(i,n.shape,n.dtype,a,o.shape,u,s.shape),p=e.makeTensorInfo([l.length],"int32",l),d=e.makeTensorInfo([c.length],n.dtype,c);return[p,d]}var HZ={kernelName:mg,backendName:"cpu",kernelFunc:XAe};function YAe(r){let{inputs:t,backend:e,attrs:n}=r,{shape:o,values:s,defaultValue:i,rowPartitionTensors:a}=t,{rowPartitionTypes:u}=n,l=e.data.get(o.dataId).values,c=e.data.get(s.dataId).values,p=e.data.get(i.dataId).values,d=a.map(g=>e.data.get(g.dataId).values),f=a.map(g=>g.shape),[h,m]=lT(l,o.shape,c,s.shape,s.dtype,p,i.shape,d,f,u);return e.makeTensorInfo(h,s.dtype,m)}var qZ={kernelName:gg,backendName:"cpu",kernelFunc:YAe};function ZAe(r){let{backend:t,attrs:e}=r,{start:n,stop:o,dtype:s,step:i}=e,a=cT(n,o,i,s);return t.makeTensorInfo([a.length],s,a)}var KZ={kernelName:id,backendName:"cpu",kernelFunc:ZAe};var QAe=Je(Ea,r=>1/r),XZ={kernelName:Ea,backendName:"cpu",kernelFunc:QAe};function JAe(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n;de(o,"resizeBilinear");let u=b.computeStrides(o.shape),[l,c]=a,[p,d,f,h]=o.shape,m=e.data.get(o.dataId).values,g=new Float32Array(b.sizeFromShape([p,l,c,h])),y=[s&&l>1?d-1:d,s&&c>1?f-1:f],x=[s&&l>1?l-1:l,s&&c>1?c-1:c],w=0,C=y[0]/x[0],I=y[1]/x[1];for(let N=0;N<p;N++)for(let A=0;A<l;A++){let O;i?O=C*(A+.5)-.5:O=C*A;let $=Math.max(0,Math.floor(O)),z=O-$,G=Math.min(d-1,Math.ceil(O)),K=N*u[0]+$*u[1],Z=N*u[0]+G*u[1];for(let Q=0;Q<c;Q++){let J;i?J=I*(Q+.5)-.5:J=I*Q;let te=Math.max(0,Math.floor(J)),ie=J-te,ne=Math.min(f-1,Math.ceil(J)),ae=K+te*u[2],ye=Z+te*u[2],ge=K+ne*u[2],Se=Z+ne*u[2];for(let be=0;be<h;be++){let ke=m[ae+be],Te=m[ye+be],Oe=m[ge+be],Ge=m[Se+be],Ke=ke+(Oe-ke)*ie,Ze=Te+(Ge-Te)*ie,lt=Ke+(Ze-Ke)*z;g[w++]=lt}}}return e.makeTensorInfo([p,l,c,h],"float32",g)}var YZ={kernelName:ml,backendName:"cpu",kernelFunc:JAe};function eRe(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:i}=n;de([s,o],"resizeBilinearGrad");let a=b.computeStrides(o.shape),[u,l,c,p]=o.shape,[,d,f]=s.shape,h=new Float32Array(u*l*c*p),m=[i&&d>1?l-1:l,i&&f>1?c-1:c],g=[i&&d>1?d-1:d,i&&f>1?f-1:f],y=m[0]/g[0],x=m[1]/g[1],w=e.data.get(s.dataId).values,C=0;for(let I=0;I<u;I++){let N=I*a[0];for(let A=0;A<d;A++){let O=A*y,$=Math.floor(O),z=Math.min(Math.ceil(O),l-1),G=N+$*a[1],K=N+z*a[1],Z=O-$,Q=1-Z;for(let J=0;J<f;J++){let te=J*x,ie=Math.floor(te),ne=Math.min(Math.ceil(te),c-1),ae=te-ie,ye=1-ae,ge=G+ie*a[2],Se=G+ne*a[2],be=K+ie*a[2],ke=K+ne*a[2],Te=Q*ye,Oe=Q*ae,Ge=Z*ye,Ke=Z*ae;for(let Ze=0;Ze<p;Ze++){let lt=w[C++];h[ge+Ze]+=lt*Te,h[Se+Ze]+=lt*Oe,h[be+Ze]+=lt*Ge,h[ke+Ze]+=lt*Ke}}}}return e.makeTensorInfo([u,c,l,p],"float32",h)}var ZZ={kernelName:ld,backendName:"cpu",kernelFunc:eRe};function tRe(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n;de(o,"resizeNearestNeighbor");let u=b.computeStrides(o.shape),[l,c]=a,[p,d,f,h]=o.shape,m=e.data.get(o.dataId).values,g=new Float32Array(p*l*c*h),y=[s&&l>1?d-1:d,s&&c>1?f-1:f],x=[s&&l>1?l-1:l,s&&c>1?c-1:c],w=y[0]/x[0],C=y[1]/x[1],I=0;for(let N=0;N<p;N++){let A=N*u[0];for(let O=0;O<l;O++){let $=i?w*(O+.5):w*O,z=Math.min(d-1,s?Math.round($):Math.floor($));i&&(z=Math.max(0,z));let G=A+z*u[1];for(let K=0;K<c;K++){let Z=i?C*(K+.5):C*K,Q=Math.min(f-1,s?Math.round(Z):Math.floor(Z));i&&(Q=Math.max(0,Q));let J=G+Q*u[2];for(let te=0;te<h;te++){let ie=m[J+te];g[I++]=ie}}}}return e.makeTensorInfo([p,l,c,h],o.dtype,g)}var QZ={kernelName:hl,backendName:"cpu",kernelFunc:tRe};function rRe(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:i}=n;de([s,o],"resizeNearestNeighborGrad");let a=b.computeStrides(o.shape),u=b.computeStrides(s.shape),[l,c,p,d]=o.shape,[,f,h]=s.shape,m=new Float32Array(l*c*p*d),g=e.data.get(s.dataId).values,y=[i&&f>1?c-1:c,i&&h>1?p-1:p],x=[i&&f>1?f-1:f,i&&h>1?h-1:h],w=y[0]/x[0],C=y[1]/x[1],I=1/w,N=1/C,A=Math.ceil(I)*2+2,O=Math.ceil(N)*2+2;for(let $=0;$<l;$++){let z=$*a[0];for(let G=0;G<c;G++){let K=z+G*a[1],Z=Math.floor(G*I),Q=Math.floor(Z-A/2);for(let J=0;J<p;J++){let te=K+J*a[2],ie=Math.floor(J*N),ne=Math.floor(ie-O/2);for(let ae=0;ae<d;ae++){let ye=0;for(let ge=0;ge<A;ge++){let Se=ge+Q;if(Se<0||Se>=f)continue;let be=z+Se*u[1],ke=Se*w,Te=Math.min(c-1,i?Math.round(ke):Math.floor(ke));if(G===Te)for(let Oe=0;Oe<O;Oe++){let Ge=Oe+ne;if(Ge<0||Ge>=h)continue;let Ke=be+Ge*u[2],Ze=Ge*C,lt=Math.min(p-1,i?Math.round(Ze):Math.floor(Ze));J===lt&&(ye+=g[Ke+ae])}}m[te+ae]=ye}}}}return e.makeTensorInfo(o.shape,o.dtype,m)}var JZ={kernelName:ud,backendName:"cpu",kernelFunc:rRe};function nRe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dims:s}=n;de(o,"reverse");let i=o.shape.length,a=b.parseAxisParam(s,o.shape);if(i===0)return po({inputs:{x:o},backend:e});let u=new jt(o.shape,o.dtype),l=e.bufferSync(o);for(let c=0;c<u.size;c++){let p=u.indexToLoc(c),d=p.slice();a.forEach(f=>d[f]=o.shape[f]-1-d[f]),u.set(l.get(...d),...p)}return e.makeTensorInfo(u.shape,u.dtype,u.values)}var eQ={kernelName:gl,backendName:"cpu",kernelFunc:nRe};var tQ={kernelName:wd,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:n}=r,{radians:o,fillValue:s,center:i}=t,a=e,u=b.getTypedArrayFromDType(n.dtype,b.sizeFromShape(n.shape)),[l,c,p,d]=n.shape,[f,h]=T.getImageCenter(i,c,p),m=255,g=Math.sin(o),y=Math.cos(o),x=a.data.get(n.dataId).values;for(let C=0;C<l;C++){let I=C*p*c*d;for(let N=0;N<c;N++){let A=N*(p*d);for(let O=0;O<p;O++){let $=O*d;for(let z=0;z<d;z++){let G=[l,N,O,z],K=G[2],Z=G[1],Q=(K-f)*y-(Z-h)*g,J=(K-f)*g+(Z-h)*y;Q=Math.round(Q+f),J=Math.round(J+h);let te=s;if(typeof s!="number"&&(z===3?te=m:te=s[z]),Q>=0&&Q<p&&J>=0&&J<c){let ne=J*(p*d),ae=Q*d,ye=I+ne+ae+z;te=x[ye]}let ie=I+A+$+z;u[ie]=te}}}}return{dataId:a.write(u,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var oRe=Je(Da,r=>{let t=Math.floor(r);return r-t<.5?Math.floor(r):r-t>.5?Math.ceil(r):t%2===0?t:t+1}),rQ={kernelName:Da,backendName:"cpu",kernelFunc:oRe};function sRe(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o,updates:s}=t,{shape:i}=n,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:p}=T.calculateShapes(s,o,i),d=!0,f=e.bufferSync(o),h=e.bufferSync(s),m=eu(f,h,i,p,l,u,a,c,0,d);return e.makeTensorInfo(i,m.dtype,m.values)}var nQ={kernelName:cd,backendName:"cpu",kernelFunc:sRe};function iRe(r,t){let e=0,n=r.length,o=0;for(;e<n;)o=Math.floor((e+n)/2),r[o]<t?e=o+1:n=o;return n}function aRe(r,t){let e=0,n=r.length,o=0;for(;e<n;)o=Math.floor((e+n)/2),r[o]<=t?e=o+1:n=o;return n}function oQ(r,t,e,n,o,s){let i=b.getArrayFromDType("int32",e*o);for(let a=0;a<e;++a){let u=r.slice(a*n,(a+1)*n),l=a*o;for(let c=0;c<o;++c)i[l+c]=s==="left"?iRe(u,t[c+l]):aRe(u,t[c+l])}return i}function uRe(r){let{inputs:t,backend:e,attrs:n}=r,{sortedSequence:o,values:s}=t,{side:i}=n,a=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,l=oQ(a,u,o.shape[0],o.shape[1],s.shape[1],i);return e.makeTensorInfo(s.shape,"int32",l)}var sQ={kernelName:dd,backendName:"cpu",kernelFunc:uRe};function lRe(r){let{inputs:t,backend:e}=r,{condition:n,t:o,e:s}=t;de([n,o,s],"select");let i=n.shape.length,a=e.data.get(n.dataId).values,u=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,c=mr(o.dtype,s.dtype),p=b.makeZerosTypedArray(b.sizeFromShape(o.shape),c),d=0,f=i===0||i>1||o.shape.length===1?1:b.sizeFromShape(o.shape.slice(1));for(let h=0;h<a.length;h++)for(let m=0;m<f;m++)a[h]===1?p[d++]=u[h]:p[d++]=l[h];return e.makeTensorInfo(o.shape,c,p)}var iQ={kernelName:yl,backendName:"cpu",kernelFunc:lRe};var cRe=T.SELU_SCALEALPHA,pRe=T.SELU_SCALE,dRe=Je(Ra,r=>r>=0?pRe*r:cRe*(Math.exp(r)-1)),aQ={kernelName:Ra,backendName:"cpu",kernelFunc:dRe};var fRe=Je(Fa,r=>r<0?-1:r>0?1:0),uQ={kernelName:Fa,backendName:"cpu",kernelFunc:fRe};var hRe=Je(Oa,r=>Math.sin(r)),lQ={kernelName:Oa,backendName:"cpu",kernelFunc:hRe};var mRe=Je(Ma,r=>Math.sinh(r)),cQ={kernelName:Ma,backendName:"cpu",kernelFunc:mRe};var gRe=11920928955078125e-23,pQ=Math.log(gRe)+2,yRe=Je(Pa,r=>{let t=r>-pQ,e=r<pQ,n=Math.exp(r),o;return e?o=n:t?o=r:o=Math.log(1+n),o}),dQ={kernelName:Pa,backendName:"cpu",kernelFunc:yRe};function xRe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,paddings:i}=n;de([o],"spaceToBatchND");let a=b.sizeFromShape(s),u=[[0,0]];u.push(...i);for(let N=1+s.length;N<o.shape.length;++N)u.push([0,0]);let l=M1.kernelFunc({inputs:{x:o},backend:e,attrs:{paddings:u,constantValue:0}}),c=T.getReshaped(l.shape,s,a,!1),p=T.getPermuted(c.length,s.length,!1),d=T.getReshapedPermuted(l.shape,s,a,!1),m=Tt({inputs:{x:l},backend:e,attrs:{shape:c}}),x=Hr({inputs:{x:m},backend:e,attrs:{perm:p}}),I=Tt({inputs:{x},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(x),I}var fQ={kernelName:bl,backendName:"cpu",kernelFunc:xRe};function vRe(r){let{inputs:t,backend:e}=r,{indices:n,values:o,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=e.data.get(n.dataId).values,u=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,c=e.data.get(i.dataId).values[0],[p,d,f,h,m]=pT(a,n.shape,n.dtype,u,o.dtype,l,c);return[e.makeTensorInfo(d,n.dtype,p),e.makeTensorInfo([d[0]],o.dtype,f),e.makeTensorInfo([h.length],"bool",new Uint8Array(h.map(g=>Number(g)))),e.makeTensorInfo([m.length],n.dtype,new Int32Array(m))]}var hQ={kernelName:yg,backendName:"cpu",kernelFunc:vRe};function bRe(r){let{inputs:t,backend:e}=r,{inputIndices:n,inputShape:o,newShape:s}=t;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(e.data.get(o.dataId).values),a=e.data.get(n.dataId).values,u=Array.from(e.data.get(s.dataId).values),[l,c,p]=dT(a,n.shape,n.dtype,i,u);return[e.makeTensorInfo(c,n.dtype,l),e.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var mQ={kernelName:xg,backendName:"cpu",kernelFunc:bRe};function wRe(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=e.data.get(n.dataId).values,a=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,[l,c]=Cy(i,n.shape,n.dtype,a,u,!0);return e.makeTensorInfo(c,n.dtype,l)}var gQ={kernelName:fd,backendName:"cpu",kernelFunc:wRe};function CRe(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=e.data.get(n.dataId).values,a=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,[l,c]=Cy(i,n.shape,n.dtype,a,u);return e.makeTensorInfo(c,n.dtype,l)}var yQ={kernelName:hd,backendName:"cpu",kernelFunc:CRe};function SRe(r){let{inputs:t,backend:e,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:i}=t,{outputShape:a}=n,{sliceRank:u,numUpdates:l,sliceSize:c,strides:p,outputSize:d}=T.calculateShapes(s,o,a),f=!1,h=e.bufferSync(o),m;switch(s.dtype){case"bool":{let g=e.bufferSync(s),y=!!e.data.get(i.dataId).values[0];m=eu(h,g,a,d,c,l,u,p,y,f);break}case"float32":{let g=e.bufferSync(s),y=e.data.get(i.dataId).values[0];m=eu(h,g,a,d,c,l,u,p,y,f);break}case"int32":{let g=e.bufferSync(s),y=e.data.get(i.dataId).values[0];m=eu(h,g,a,d,c,l,u,p,y,f);break}case"string":{let g=e.bufferSync(s),y=b.decodeString(e.data.get(i.dataId).values[0]);m=eu(h,g,a,d,c,l,u,p,y,f);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return e.makeTensorInfo(a,m.dtype,m.values)}var xQ={kernelName:md,backendName:"cpu",kernelFunc:SRe};function IRe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{numOrSizeSplits:s,axis:i}=n,a=b.parseAxisParam(i,o.shape)[0],u=T.prepareSplitSize(o,s,a),l=new Array(o.shape.length).fill(0),c=o.shape.slice();return u.map(p=>{let d=[...c];d[a]=p;let f=ki({inputs:{x:o},backend:e,attrs:{begin:l,size:d}});return l[a]+=p,f})}var vQ={kernelName:wl,backendName:"cpu",kernelFunc:IRe};var bQ={kernelName:gd,backendName:"cpu",kernelFunc:({inputs:r,backend:t})=>{let{x:e}=r,n=t;de(e,"square");let o=n.data.get(e.dataId).values,s=new Float32Array(o.length);for(let a=0;a<o.length;++a){let u=o[a];s[a]=u*u}return{dataId:n.write(s,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}};var TRe=Je(Ga,(r,t)=>{let e=t;return isNaN(r)?NaN:r>0?1:e.alpha}),wQ={kernelName:Ga,backendName:"cpu",kernelFunc:TRe};function _Re(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:d}=n;de(o,"stridedSlice");let{finalShapeSparse:f,finalShape:h,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:x,end:w,strides:C}=en.sliceInfo(o.shape,s,i,a,u,l,c,p,d),I;if(m)I=Tt({inputs:{x:o},backend:e,attrs:{shape:h}});else if(g||y){b.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let N=en.computeOutShape(x,w,C),A=ki({inputs:{x:o},backend:e,attrs:{begin:x,size:N}});I=Tt({inputs:{x:A},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(A)}else{let N=e.bufferSync(o),A=fT(f,N,C,x);I=e.makeTensorInfo(h,A.dtype,A.values)}return I}var CQ={kernelName:yd,backendName:"cpu",kernelFunc:_Re};function ERe(r){let{inputs:t,backend:e,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:l}=n,{data:c,dataSplits:p}=t,d=e.data.get(c.dataId).values,f=e.data.get(p.dataId).values,[h,m]=hT(d,f,o,s,i,a,u,l);return[e.makeTensorInfo([h.length],"string",h),e.makeTensorInfo(p.shape,"int32",m)]}var SQ={kernelName:xd,backendName:"cpu",kernelFunc:ERe};function kRe(r){let{inputs:t,backend:e,attrs:n}=r,{skipEmpty:o}=n,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=e.data.get(s.dataId).values,u=e.data.get(i.dataId).values[0],[l,c,p]=mT(a,u,o),d=c.length;return[e.makeTensorInfo([d,2],"int32",l),e.makeTensorInfo([d],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(p))]}var IQ={kernelName:vg,backendName:"cpu",kernelFunc:kRe};function NRe(r){let{inputs:t,backend:e,attrs:n}=r,{numBuckets:o}=n,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=e.data.get(s.dataId).values,a=gT(i,o);return e.makeTensorInfo(s.shape,"int32",a)}var TQ={kernelName:bg,backendName:"cpu",kernelFunc:NRe};var DRe=Je(Va,r=>Math.tan(r)),_Q={kernelName:Va,backendName:"cpu",kernelFunc:DRe};var ARe=Je(Ua,r=>Math.tanh(r)),EQ={kernelName:Ua,backendName:"cpu",kernelFunc:ARe};function RRe(r){let{inputs:t,backend:e}=r,{tensor:n,indices:o,updates:s}=t,{sliceRank:i,numUpdates:a,sliceSize:u,strides:l,outputSize:c}=T.calculateShapes(s,o,n.shape),p=!1,d=e.bufferSync(o),f=e.bufferSync(s),h=e.bufferSync(n),m=eu(d,f,n.shape,c,u,a,i,l,h,p);return e.makeTensorInfo(n.shape,m.dtype,m.values)}var kQ={kernelName:pd,backendName:"cpu",kernelFunc:RRe};function ORe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reps:s}=n;de(o,"tile");let i=yT(e.bufferSync(o),s);return e.makeTensorInfo(i.shape,i.dtype,i.values)}var NQ={kernelName:hi,backendName:"cpu",kernelFunc:ORe};function MRe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{k:s,sorted:i}=n;de(o,"topk");let a=e.data.get(o.dataId).values,[u,l]=xT(a,o.shape,o.dtype,s,i);return[e.makeTensorInfo(u.shape,u.dtype,u.values),e.makeTensorInfo(l.shape,l.dtype,l.values)]}var DQ={kernelName:vd,backendName:"cpu",kernelFunc:MRe};function FRe(r){let{inputs:t,attrs:e,backend:n}=r,{image:o,transforms:s}=t,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=e,[c,p,d,f]=o.shape,[h,m]=l??[p,d],g=[c,h,m,f],y=b.computeStrides(o.shape),x=y[0],w=y[1],C=y[2],I=b.computeStrides(g),N=I[0],A=I[1],O=I[2],$=b.getTypedArrayFromDType(o.dtype,b.sizeFromShape(g));$.fill(u);let z=n.data.get(o.dataId).values,G=n.data.get(s.dataId).values;for(let Z=0;Z<c;++Z){let Q=s.shape[0]===1?G:G.subarray(Z*8,Z*8+8);for(let J=0;J<h;++J)for(let te=0;te<m;++te)for(let ie=0;ie<f;++ie){let ne,ae=Q[6]*te+Q[7]*J+1;if(ae===0)continue;let ye=(Q[0]*te+Q[1]*J+Q[2])/ae,ge=(Q[3]*te+Q[4]*J+Q[5])/ae,Se=AQ(ye,d,a),be=AQ(ge,p,a);switch(i){case"nearest":ne=BRe(z,p,d,x,w,C,Z,be,Se,ie,u);break;case"bilinear":ne=VRe(z,p,d,x,w,C,Z,be,Se,ie,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let ke=Z*N+J*A+te*O+ie;$[ke]=ne}return n.makeTensorInfo(g,o.dtype,$)}return{dataId:n.write($,g,o.dtype),shape:o.shape,dtype:o.dtype}}var RQ={kernelName:bd,backendName:"cpu",kernelFunc:FRe};function AQ(r,t,e){switch(e){case"reflect":return $Re(r,t);case"wrap":return PRe(r,t);case"nearest":return zRe(r,t);case"constant":default:return LRe(r,t)}}function $Re(r,t){let e=r;if(e<0)if(t<=1)e=0;else{let n=2*t;e<n&&(e=n*Math.trunc(-e/n)+e),e=e<-t?e+n:-e-1}else if(e>t-1)if(t<=1)e=0;else{let n=2*t;e-=n*Math.trunc(e/n),e>=t&&(e=n-e-1)}return b.clamp(0,e,t-1)}function PRe(r,t){let e=r;if(e<0)if(t<=1)e=0;else{let n=t-1;e+=t*(Math.trunc(-e/n)+1)}else if(e>t-1)if(t<=1)e=0;else{let n=t-1;e-=t*Math.trunc(e/n)}return b.clamp(0,e,t-1)}function LRe(r,t){return r}function zRe(r,t){return b.clamp(0,r,t-1)}function Xb(r,t,e,n,o,s,i,a,u,l,c){let p=i*n+a*o+u*s+l;return 0<=a&&a<t&&0<=u&&u<e?r[p]:c}function BRe(r,t,e,n,o,s,i,a,u,l,c){let p=Math.round(a),d=Math.round(u);return Xb(r,t,e,n,o,s,i,p,d,l,c)}function VRe(r,t,e,n,o,s,i,a,u,l,c){let p=Math.floor(a),d=Math.floor(u),f=p+1,h=d+1,m=(h-u)*Xb(r,t,e,n,o,s,i,p,d,l,c)+(u-d)*Xb(r,t,e,n,o,s,i,p,h,l,c),g=(h-u)*Xb(r,t,e,n,o,s,i,f,d,l,c)+(u-d)*Xb(r,t,e,n,o,s,i,f,h,l,c);return(f-a)*m+(a-p)*g}function URe(r){let{inputs:t,attrs:e,backend:n}=r,{axis:o}=e,{x:s}=t;de(s,"unique");let i=n.data.get(s.dataId).values,{outputValues:a,outputShape:u,indices:l}=vT(i,o,s.shape,s.dtype);return[n.makeTensorInfo(u,s.dtype,a),n.makeTensorInfo([l.length],"int32",l)]}var OQ={kernelName:wg,backendName:"cpu",kernelFunc:URe};function GRe(r){let{inputs:t,backend:e,attrs:n}=r,{value:o}=t,{axis:s}=n;s<0&&(s+=o.shape.length);let i=o.shape.length,a=o.shape[s],u=new Array(i-1),l=0;for(let f=0;f<i;f++)f!==s&&(u[l++]=o.shape[f]);let c=new Array(i).fill(0),p=o.shape.slice();p[s]=1;let d=new Array(a);for(let f=0;f<d.length;f++){c[s]=f;let h=ki({inputs:{x:o},backend:e,attrs:{begin:c,size:p}});d[f]=Tt({inputs:{x:h},backend:e,attrs:{shape:u}}),e.disposeIntermediateTensorInfo(h)}return d}var MQ={kernelName:Sl,backendName:"cpu",kernelFunc:GRe};function WRe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,segmentIds:s}=t,{numSegments:i}=n;de(o,"unsortedSegmentSum");let a=o.shape.length,u=s.shape.length,l=[],c=[],p=a-u,d=s;for(let h=0;h<p;++h){let m=Hy({inputs:{input:d},backend:e,attrs:{dim:h+1}});d=m,c.push(m)}for(let h=0;h<i;++h){let m=b.createScalarValue(h,"int32"),g=e.makeTensorInfo([],"int32",m),y=KO({inputs:{a:g,b:d},backend:e}),x=_i({inputs:{x:y},backend:e,attrs:{dtype:"float32"}}),w=Mh({inputs:{a:x,b:o},backend:e}),C=qc({inputs:{x:w},backend:e,attrs:{axis:0,keepDims:!1}});l.push(C),c.push(g),c.push(y),c.push(x),c.push(w),c.push(C)}let f=WF({inputs:l,backend:e,attrs:{axis:0}});return c.forEach(h=>e.disposeIntermediateTensorInfo(h)),f}var FQ={kernelName:Il,backendName:"cpu",kernelFunc:WRe};var jRe=[i7,Cj,a7,u7,Ej,l7,c7,p7,d7,f7,h7,m7,g7,y7,x7,b7,w7,C7,S7,s7,I7,T7,_7,kj,E7,_j,Nj,k7,Sj,N7,A7,R7,O7,M7,F7,$7,P7,L7,z7,B7,V7,U7,G7,W7,j7,H7,q7,K7,X7,Y7,Z7,Q7,eZ,J9,tZ,Dj,rZ,Aj,nZ,Rj,oZ,sZ,iZ,Oj,Mj,aZ,uZ,lZ,cZ,Fj,$j,Ij,pZ,D7,dZ,fZ,hZ,e7,Pj,Lj,mZ,zj,gZ,yZ,xZ,vZ,bZ,wZ,CZ,Bj,SZ,IZ,TZ,_Z,kZ,NZ,DZ,Vj,AZ,RZ,FZ,Uj,Gj,$Z,PZ,LZ,Wj,zZ,UZ,GZ,M1,WZ,t7,Hj,jZ,HZ,qZ,KZ,Tj,Hb,XZ,r7,n7,o7,YZ,ZZ,QZ,JZ,eQ,tQ,rQ,Zj,nQ,sQ,iQ,aQ,Jj,uQ,lQ,cQ,eH,OZ,dQ,fQ,hQ,mQ,gQ,yQ,xQ,vQ,rH,bQ,nH,oH,wQ,CQ,SQ,IQ,TQ,sH,J7,_Q,EQ,kQ,NQ,DQ,RQ,jj,OQ,MQ,FQ,BZ];for(let r of jRe)Sg(r);var Hh={},F1={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function $Q(r,t){Hh[r]=t}function As(r,t){if(!(r in Hh)||t!=null){let n=qRe(r,t);if(n!==null)Hh[r]=n;else return console.log("Could not get context for WebGL version",r),null}let e=Hh[r];return e==null||e.isContextLost()?(delete Hh[r],As(r)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Hh[r])}function HRe(r){if(!j().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&r===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function qRe(r,t){if(r!==1&&r!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let e=t??HRe(r);return e.addEventListener("webglcontextlost",n=>{n.preventDefault(),delete Hh[r]},!1),j().getBool("SOFTWARE_WEBGL_ENABLED")&&(F1.failIfMajorPerformanceCaveat=!1),r===1?e.getContext("webgl",F1)||e.getContext("experimental-webgl",F1):e.getContext("webgl2",F1)}var qh=function(r){return r[r.DENSE=0]="DENSE",r[r.SHARED_BATCH=1]="SHARED_BATCH",r}(qh||{}),ko=function(r){return r[r.RENDER=0]="RENDER",r[r.UPLOAD=1]="UPLOAD",r[r.PIXELS=2]="PIXELS",r[r.DOWNLOAD=3]="DOWNLOAD",r}(ko||{}),fo=function(r){return r[r.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",r[r.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",r[r.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",r[r.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",r[r.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",r}(fo||{});function Kh(r,t){return[t,r]}function PQ(r,t){return r*t}function Yb(r){let t=b.sizeFromShape(r),e=Math.ceil(t/4);return b.sizeToSquarishShape(e)}function Hl(r,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(r/2))]}function LQ(r,t){let[e,n]=Hl(r,t);return e*n*4}function Zb(r,t){let e=r,n,o,s,i,a,u,l,c,p,d;return j().getNumber("WEBGL_VERSION")===2?(n=e.R32F,o=e.R16F,s=e.RGBA16F,i=e.RGBA32F,a=e.RED,l=4,c=1,p=e.HALF_FLOAT,d=e.FLOAT,u=e.RGBA8):(n=r.RGBA,o=r.RGBA,s=r.RGBA,i=e.RGBA,a=r.RGBA,l=4,c=4,p=t!=null?t.HALF_FLOAT_OES:null,d=r.FLOAT,u=r.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:c,textureTypeHalfFloat:p,textureTypeFloat:d}}function Re(r,t){let e=t();return j().getBool("DEBUG")&&KRe(r),e}function KRe(r){let t=r.getError();if(t!==r.NO_ERROR)throw new Error("WebGL Error: "+ZRe(r,t))}var XRe=596e-10,YRe=65504;function zQ(r){return!!(j().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||r===0||XRe<Math.abs(r)&&Math.abs(r)<YRe)}function ZRe(r,t){switch(t){case r.NO_ERROR:return"NO_ERROR";case r.INVALID_ENUM:return"INVALID_ENUM";case r.INVALID_VALUE:return"INVALID_VALUE";case r.INVALID_OPERATION:return"INVALID_OPERATION";case r.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case r.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case r.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function Qb(r,t){return Kc(r,()=>r.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function BQ(r,t){let e=Kc(r,()=>r.createShader(r.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Re(r,()=>r.shaderSource(e,t)),Re(r,()=>r.compileShader(e)),r.getShaderParameter(e,r.COMPILE_STATUS)===!1)throw console.log(r.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}function VQ(r,t){let e=Kc(r,()=>r.createShader(r.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Re(r,()=>r.shaderSource(e,t)),Re(r,()=>r.compileShader(e)),j().get("ENGINE_COMPILE_ONLY"))return e;if(r.getShaderParameter(e,r.COMPILE_STATUS)===!1)throw XF(t,r.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}var QRe=/ERROR: [0-9]+:([0-9]+):/g;function XF(r,t){let e=QRe.exec(t);if(e==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(r);return}let n=+e[1],o=r.split(`
`),s=o.length.toString().length+2,i=o.map((p,d)=>b.rightPad((d+1).toString(),s)+p),a=0;for(let p=0;p<i.length;p++)a=Math.max(i[p].length,a);let u=i.slice(0,n-1),l=i.slice(n-1,n),c=i.slice(n);console.log(u.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${b.rightPad(l[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function UQ(r){return Kc(r,()=>r.createProgram(),"Unable to create WebGLProgram.")}function GQ(r,t){if(Re(r,()=>r.linkProgram(t)),!j().get("ENGINE_COMPILE_ONLY")&&r.getProgramParameter(t,r.LINK_STATUS)===!1)throw console.log(r.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function P1(r,t){if(Re(r,()=>r.validateProgram(t)),r.getProgramParameter(t,r.VALIDATE_STATUS)===!1)throw console.log(r.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function WQ(r,t){let e=Kc(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return Re(r,()=>r.bindBuffer(r.ARRAY_BUFFER,e)),Re(r,()=>r.bufferData(r.ARRAY_BUFFER,t,r.STATIC_DRAW)),e}function jQ(r,t){let e=Kc(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return Re(r,()=>r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,e)),Re(r,()=>r.bufferData(r.ELEMENT_ARRAY_BUFFER,t,r.STATIC_DRAW)),e}function HQ(r){return Kc(r,()=>r.createTexture(),"Unable to create WebGLTexture.")}function qQ(r,t){let e=j().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(r<=0||t<=0){let n=`[${r}x${t}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(r>e||t>e){let n=`[${r}x${t}]`,o=`[${e}x${e}]`;throw new Error("Requested texture size "+n+" greater than WebGL maximum on this browser / GPU "+o+".")}}function KQ(r){return Kc(r,()=>r.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function YF(r,t,e,n,o,s,i){let a=r.getAttribLocation(t,e);return a===-1?!1:(Re(r,()=>r.bindBuffer(r.ARRAY_BUFFER,n)),Re(r,()=>r.vertexAttribPointer(a,o,r.FLOAT,!1,s,i)),Re(r,()=>r.enableVertexAttribArray(a)),!0)}function JRe(r,t,e){t2e(r,e),Re(r,()=>r.activeTexture(r.TEXTURE0+e)),Re(r,()=>r.bindTexture(r.TEXTURE_2D,t))}function XQ(r,t,e){return Kc(r,()=>r.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}function YQ(r,t,e){return r.getUniformLocation(t,e)}function ZQ(r,t,e,n){Re(r,()=>JRe(r,t,n)),Re(r,()=>r.uniform1i(e,n))}function L1(r,t,e){Re(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,e)),Re(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,t,0))}function ZF(r,t){Re(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,t)),Re(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,null,0))}function Jb(r){let t=r.checkFramebufferStatus(r.FRAMEBUFFER);if(t!==r.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+e2e(r,t))}function e2e(r,t){switch(t){case r.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case r.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Kc(r,t,e){let n=Re(r,()=>t());if(n==null)throw new Error(e);return n}function t2e(r,t){let e=r.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=t+r.TEXTURE0;if(n<r.TEXTURE0||n>e){let o=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${o}.`)}}function of(r,t=2){return b.sizeFromShape(r.slice(0,r.length-t))}function sf(r){if(r.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[r.length>1?r[r.length-2]:1,r[r.length-1]]}function ew(r){let t=[1,1,1];return r.length===0||r.length===1&&r[0]===1||(t=[of(r),...sf(r)]),t}function QQ(r,t=!1){let e=j().getNumber("WEBGL_MAX_TEXTURE_SIZE"),n=j().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");n===1/0&&j().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(n=e/2),t&&(e=e*2,n=n*2,r=r.map((a,u)=>u>=r.length-2?b.nearestLargerEven(r[u]):r[u]),r.length===1&&(r=[2,r[0]])),r.length!==2&&(r=b.squeezeShape(r).newShape);let o=b.sizeFromShape(r),s=null;r.length<=1&&o<=e?s=[1,o]:r.length===2&&r[0]<=e&&r[1]<=e?s=r:r.length===3&&r[0]*r[1]<=e&&r[2]<=e?s=[r[0]*r[1],r[2]]:r.length===3&&r[0]<=e&&r[1]*r[2]<=e?s=[r[0],r[1]*r[2]]:r.length===4&&r[0]*r[1]*r[2]<=e&&r[3]<=e?s=[r[0]*r[1]*r[2],r[3]]:r.length===4&&r[0]<=e&&r[1]*r[2]*r[3]<=e&&(s=[r[0],r[1]*r[2]*r[3]]);let i=s!=null&&Math.max(...s)>n&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(s==null||i)if(t){let a=of(r),u=2,l=2;r.length&&([u,l]=sf(r)),o=a*(u/2)*(l/2),s=b.sizeToSquarishShape(o).map(c=>c*2)}else s=b.sizeToSquarishShape(o);return s}function $1(r){return r%2===0}function Xh(r,t){if(r=r.slice(-2),t=t.slice(-2),b.arraysEqual(r,t)||!r.length||!t.length||r[0]===0||r[1]===0||t[0]===0||t[1]===0)return!0;if(r.length!==t.length){let e=r[r.length-1],n=t[t.length-1];if(e===n||$1(e)&&$1(n)&&(r[0]===1||t[0]===1))return!0}return r[1]===t[1]&&$1(r[0])&&$1(t[0])}var HF,qF;function JQ(r){if(HF==null){let t=As(r);HF=t.getParameter(t.MAX_TEXTURE_SIZE)}return HF}function eJ(r){if(qF==null){let t=As(r);qF=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,qF)}function tJ(r){if(r===0)return 0;let t,e=As(r);return Qs(e,"EXT_disjoint_timer_query_webgl2")&&r===2?t=2:Qs(e,"EXT_disjoint_timer_query")?t=1:t=0,t}function Qs(r,t){return r.getExtension(t)!=null}function QF(r){try{if(As(r)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function rJ(r){if(r===0)return!1;let t=As(r);if(r===1){if(!Qs(t,"OES_texture_float"))return!1}else if(!Qs(t,"EXT_color_buffer_float"))return!1;return KF(t)}function nJ(r){if(r===0)return!1;let t=As(r);if(r===1){if(!Qs(t,"OES_texture_float")||!Qs(t,"WEBGL_color_buffer_float"))return!1}else{if(Qs(t,"EXT_color_buffer_float"))return KF(t);let n="EXT_color_buffer_half_float";if(Qs(t,n)){let o=t.getExtension(n);return r2e(t,o)}return!1}return KF(t)}function KF(r){let t=Zb(r),e=r.createTexture();r.bindTexture(r.TEXTURE_2D,e),r.texImage2D(r.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let s=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,s),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,e,0);let i=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(e),r.deleteFramebuffer(s),i}function r2e(r,t){let e=Zb(r,t),n=r.createTexture();r.bindTexture(r.TEXTURE_2D,n),r.texImage2D(r.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);let i=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,i),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,n,0);let a=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(n),r.deleteFramebuffer(i),a}function oJ(r){return r!==2?!1:As(r).fenceSync!=null}function ql(r,t){Array.isArray(r)||(r=[r]),r.forEach(e=>{e!=null&&b.assert(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var qe=j();qe.registerFlag("HAS_WEBGL",()=>qe.getNumber("WEBGL_VERSION")>0);qe.registerFlag("WEBGL_VERSION",()=>QF(2)?2:QF(1)?1:0);qe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);qe.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>qe.get("WEBGL_VERSION")===2);qe.registerFlag("WEBGL_CPU_FORWARD",()=>!0);qe.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);qe.registerFlag("WEBGL_PACK",()=>qe.getBool("HAS_WEBGL"));qe.registerFlag("WEBGL_PACK_NORMALIZATION",()=>qe.getBool("WEBGL_PACK"));qe.registerFlag("WEBGL_PACK_CLIP",()=>qe.getBool("WEBGL_PACK"));qe.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>qe.getBool("WEBGL_PACK"));qe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>qe.getBool("WEBGL_PACK"));qe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>qe.getBool("WEBGL_PACK"));qe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>qe.getBool("WEBGL_PACK"));qe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>qe.getBool("WEBGL_PACK"));qe.registerFlag("WEBGL_PACK_REDUCE",()=>qe.getBool("WEBGL_PACK"));qe.registerFlag("WEBGL_LAZILY_UNPACK",()=>qe.getBool("WEBGL_PACK"));qe.registerFlag("WEBGL_CONV_IM2COL",()=>qe.getBool("WEBGL_PACK"));qe.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>qe.getBool("WEBGL_PACK"));qe.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>JQ(qe.getNumber("WEBGL_VERSION")));qe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>eJ(qe.getNumber("WEBGL_VERSION")));qe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let r=qe.getNumber("WEBGL_VERSION");return r===0?0:tJ(r)});qe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>qe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Id.isMobile());qe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>rJ(qe.getNumber("WEBGL_VERSION")));qe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>qe.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:qe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));qe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>nJ(qe.getNumber("WEBGL_VERSION")));qe.registerFlag("WEBGL_FENCE_API_ENABLED",()=>oJ(qe.getNumber("WEBGL_VERSION")));qe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>qe.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);qe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,r=>{if(typeof r!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${r}.`);if(r<0&&r!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${r}.`)});qe.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Id.isMobile()?1:-1,r=>{if(typeof r!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${r}.`);if(r<0&&r!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${r}.`)});qe.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);qe.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);qe.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);qe.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);qe.registerFlag("WEBGL_EXP_CONV",()=>!1);qe.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>qe.getBool("IS_TEST"));qe.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);qe.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);qe.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);qe.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function Xr(){let r,t,e,n,o,s,i,a,u,l;return j().getNumber("WEBGL_VERSION")===2?(r="#version 300 es",t="in",e="out",n="in",o="texture",s="outputColor",i="out vec4 outputColor;",a=j().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",u="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(r="",t="attribute",e="varying",n="varying",o="texture2D",s="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:r,attribute:t,varyingVs:e,varyingFs:n,texture2D:o,output:s,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:u,defineRound:l}}function uu(r,t,e="index"){let n=b.computeStrides(t);return n.map((o,s)=>{let i=`int ${r[s]} = ${e} / ${o}`,a=s===n.length-1?`int ${r[s+1]} = ${e} - ${r[s]} * ${o}`:`index -= ${r[s]} * ${o}`;return`${i}; ${a};`}).join("")}function Yh(r,t,e="index"){let n=b.computeStrides(t);return n.map((o,s)=>{let i=`int ${r[s]} = ${e} / outShapeStrides[${s}]`,a=s===n.length-1?`int ${r[s+1]} = ${e} - ${r[s]} * outShapeStrides[${s}]`:`index -= ${r[s]} * outShapeStrides[${s}]`;return`${i}; ${a};`}).join("")}function n2e(r,t){let e=r.length,n=r.map(s=>`${t}[${s}]`),o=new Array(e-1);o[e-2]=n[e-1];for(let s=e-3;s>=0;--s)o[s]=`(${o[s+1]} * ${n[s+1]})`;return o}function sJ(r,t,e="index"){let n=r.map((s,i)=>i),o=n2e(n,t);return o.map((s,i)=>{let a=`int ${r[i]} = ${e} / ${o[i]}`,u=i===o.length-1?`int ${r[i+1]} = ${e} - ${r[i]} * ${o[i]}`:`index -= ${r[i]} * ${o[i]}`;return`${a}; ${u};`}).join("")}function qy(r){let t=b.computeStrides(r).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function Ky(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var B1=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;var{getBroadcastDims:iJ}=T;function aJ(r,t,e){let n=[];if(r.forEach(f=>{let h=b.sizeFromShape(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?n.push(`uniform float ${f.name}${h>1?`[${h}]`:""};`):(n.push(`uniform sampler2D ${f.name};`),n.push(`uniform int offset${f.name};`)),e.enableShapeUniforms){let{uniformShape:m}=V1(e.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(m.length){case 1:n.push(`uniform int ${f.name}Shape;`);break;case 2:n.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:n.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:n.push(`uniform ivec4 ${f.name}Shape;`);break;default:break}n.push(`uniform ivec2 ${f.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:n.push("uniform int outShape;");break;case 2:n.push("uniform ivec2 outShape;"),n.push("uniform int outShapeStrides;");break;case 3:n.push("uniform ivec3 outShape;"),n.push("uniform ivec2 outShapeStrides;");break;case 4:n.push("uniform ivec4 outShape;"),n.push("uniform ivec3 outShapeStrides;");break;default:break}n.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(f=>{n.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});let o=n.join(`
`),s=r.map(f=>o2e(f,t,e.packedInputs,e.enableShapeUniforms)).join(`
`),i=t.texShape,a=Xr(),u=a2e(a),l,c,p=c2e(a);return t.isPacked?(l=s2e(t.logicalShape,i,e.enableShapeUniforms),c=l2e(a)):(l=i2e(t.logicalShape,i,e.enableShapeUniforms),c=u2e(a)),e.packedInputs&&(p+=h2e),[p,u,c,o,l,s,e.userCode].join(`
`)}function Yy(r,t=!1){let e=r.shapeInfo.logicalShape;switch(e.length){case 0:return _2e(r,t);case 1:return k2e(r,t);case 2:return D2e(r,t);case 3:return R2e(r,t);case 4:return M2e(r,t);case 5:return F2e(r);case 6:return $2e(r);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function uJ(r,t){switch(r.shapeInfo.logicalShape.length){case 0:return T2e(r);case 1:return E2e(r,t);case 2:return N2e(r,t);case 3:return A2e(r,t);default:return O2e(r,t)}}function o2e(r,t,e=!1,n){let o="";e?o+=uJ(r,n):o+=Yy(r,n);let s=r.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(e?o+=P2e(r,t):o+=L2e(r,t)),o}function s2e(r,t,e){switch(r.length){case 0:return lJ();case 1:return m2e(r,t,e);case 2:return S2e(r,t,e);case 3:return y2e(r,t,e);default:return v2e(r,t,e)}}function i2e(r,t,e){switch(r.length){case 0:return lJ();case 1:return g2e(r,t,e);case 2:return I2e(r,t,e);case 3:return x2e(r,t,e);case 4:return b2e(r,t,e);case 5:return w2e(r,t);case 6:return C2e(r,t);default:throw new Error(`${r.length}-D output sampling is not yet supported`)}}function a2e(r){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${r.texture2D}(textureSampler, uv).r;
    }
  `}function u2e(r){return`
    void setOutput(float val) {
      ${r.output} = vec4(val, 0, 0, 0);
    }
  `}function l2e(r){return`
    void setOutput(vec4 val) {
      ${r.output} = val;
    }
  `}function c2e(r){return`${r.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${r.varyingFs} vec2 resultUV;
    ${r.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${r.defineSpecialNaN}
    ${r.defineSpecialInf}
    ${r.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${p2e}
    ${d2e}
    ${f2e}
  `}var p2e=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,d2e=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,f2e=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,h2e=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function lJ(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function m2e(r,t,e){let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return n[0]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${n[1]}.0);
      }
    `:n[1]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${n[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);
    }
  `}function g2e(r,t,e){return t[0]===1?e?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?e?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function y2e(r,t,e){if(e)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],o=Math.ceil(r[2]/2),s=o*Math.ceil(r[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec3(b, r, c);
    }
  `}function x2e(r,t,e){if(e)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Yh(["r","c","d"],r)}
    return ivec3(r, c, d);
  }
`;let n=uu(["r","c","d"],r);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${n}
      return ivec3(r, c, d);
    }
  `}function v2e(r,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],o=Math.ceil(r[r.length-1]/2),s=o*Math.ceil(r[r.length-2]/2),i=s,a="",u="b, r, c";for(let l=2;l<r.length-1;l++)i*=r[r.length-l-1],a=`
      int b${l} = index / ${i};
      index -= b${l} * ${i};
    `+a,u=`b${l}, `+u;return`
    ivec${r.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      ${a}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec${r.length}(${u});
    }
  `}function b2e(r,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Yh(["r","c","d","d2"],r)}
      return ivec4(r, c, d, d2);
    }
  `;let n=uu(["r","c","d","d2"],r);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${n}
      return ivec4(r, c, d, d2);
    }
  `}function w2e(r,t){let e=uu(["r","c","d","d2","d3"],r);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function C2e(r,t){let e=uu(["r","c","d","d2","d3","d4"],r);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function S2e(r,t,e){let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(b.arraysEqual(r,t))return e?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));
      }
    `;let o=Math.ceil(r[1]/2);return e?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));

      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec2(r, c);
    }
  `}function I2e(r,t,e){return b.arraysEqual(r,t)?e?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:r[1]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:r[0]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:e?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${r[1]};
      int c = index - r * ${r[1]};
      return ivec2(r, c);
    }
  `}function Zh(r){return`offset${r}`}function T2e(r){let t=r.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),n=Xr();return`
    vec4 ${e}() {
      return ${n.texture2D}(${t}, halfCR);
    }
  `}function _2e(r,t){let e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(r.shapeInfo.isUniform)return`float ${n}() {return ${e};}`;let[o,s]=r.shapeInfo.texShape;if(o===1&&s===1)return`
      float ${n}() {
        return sampleTexture(${e}, halfCR);
      }
    `;let i=Zh(e);if(t)return`
    float ${n}() {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${i});
      return sampleTexture(${e}, uv);
    }
  `;let[a,u]=r.shapeInfo.texShape;return`
    float ${n}() {
      vec2 uv = uvFromFlat(${a}, ${u}, ${i});
      return sampleTexture(${e}, uv);
    }
  `}function E2e(r,t){let e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),o=r.shapeInfo.texShape,s=Xr();if(t)return`
    vec4 ${n}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${e}, uv);
    }
  `;let i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`
    vec4 ${n}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${e}, uv);
    }
  `}function k2e(r,t){let e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(r.shapeInfo.isUniform)return`
      float ${n}(int index) {
        ${Zy(r)}
      }
    `;let o=r.shapeInfo.texShape,s=o[0],i=o[1];if(i===1&&s===1)return`
      float ${n}(int index) {
        return sampleTexture(${e}, halfCR);
      }
    `;let a=Zh(e);return i===1?t?`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);
        return sampleTexture(${e}, uv);
      }
    `:s===1?t?`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${e}, uv);
      }
    `:t?`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});
      return sampleTexture(${e}, uv);
    }
  `:`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${a});
      return sampleTexture(${e}, uv);
    }
  `}function N2e(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape,i=s[0],a=s[1],u=Xr();if(s!=null&&b.arraysEqual(e,s))return t?`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);

        return ${u.texture2D}(${n}, uv);
      }
    `:`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${u.texture2D}(${n}, uv);
      }
    `;if(t)return`
    vec4 ${o}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `;let l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(e[1]/2);return`
    vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${l[0]}, ${l[1]}, row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `}function D2e(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape;if(s!=null&&b.arraysEqual(e,s)){if(t)return`
      float ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `;let d=s[0],f=s[1];return`
    float ${o}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${d}.0);
      return sampleTexture(${n}, uv);
    }
  `}let{newShape:i,keptDims:a}=b.squeezeShape(e),u=i;if(u.length<e.length){let d=Qy(r,u),f=["row","col"];return`
      ${Yy(d,t)}
      float ${o}(int row, int col) {
        return ${o}(${Jy(f,a)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));
        ${Zy(r)}
      }
    `;let l=s[0],c=s[1],p=Zh(n);return c===1?t?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${n}, uv);
    }
  `:l===1?t?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${n}, uv);
    }
  `:t?`
      float ${o}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${n}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
        return sampleTexture(${n}, uv);
      }
    `:`
  float ${o}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${e[1]} + col + ${p};
    vec2 uv = uvFromFlat(${l}, ${c}, index);
    return sampleTexture(${n}, uv);
  }
`}function A2e(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(e[0]===1){let d=e.slice(1),f=[1,2],h=Qy(r,d),m=["b","row","col"];return`
        ${uJ(h,t)}
        vec4 ${o}(int b, int row, int col) {
          return ${o}(${Jy(m,f)});
        }
      `}let a=Xr();if(t)return`
    vec4 ${o}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${n}, uv);
    }
  `;let u=i[0],l=i[1],c=Math.ceil(e[2]/2),p=c*Math.ceil(e[1]/2);return`
    vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${l}, ${p}, ${c}, b, row, col);
      return ${a.texture2D}(${n}, uv);
    }
  `}function R2e(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[1]*e[2],i=e[2],{newShape:a,keptDims:u}=b.squeezeShape(e),l=a;if(l.length<e.length){let m=Qy(r,l),g=["row","col","depth"];return`
        ${Yy(m,t)}
        float ${o}(int row, int col, int depth) {
          return ${o}(${Jy(g,u)});
        }
      `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${Zy(r)}
      }
    `;let c=r.shapeInfo.texShape,p=c[0],d=c[1],f=r.shapeInfo.flatOffset;if(d===s&&f==null)return t?`
      float ${o}(int row, int col, int depth) {
        int stride1 = ${n}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
        float ${o}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${p}.0);
          return sampleTexture(${n}, uv);
        }
      `;if(d===i&&f==null)return t?`
      float ${o}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${n}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${p}.0);
      return sampleTexture(${n}, uv);
    }
  `;let h=Zh(n);return t?`
    float ${o}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${n}Shape[1] * ${n}Shape[2];
      int stride1 = ${n}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${h};
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
      return sampleTexture(${n}, uv);
    }
    `:`
      float ${o}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${h};
        vec2 uv = uvFromFlat(${p}, ${d}, index);
        return sampleTexture(${n}, uv);
      }
  `}function O2e(r,t){let e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),o=Xr();if(t)return`
    vec4 ${n}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${e}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${e}, uv);
    }
  `;let s=r.shapeInfo.logicalShape,i=s.length,a=r.shapeInfo.texShape,u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],l=u[0],c=u[1],p=Math.ceil(s[i-1]/2),d=p*Math.ceil(s[i-2]/2),f="int b, int row, int col",h=`b * ${d} + (row / 2) * ${p} + (col / 2)`;for(let m=2;m<i-1;m++)f=`int b${m}, `+f,d*=s[i-m-1],h=`b${m} * ${d} + `+h;return`
    vec4 ${n}(${f}) {
      int index = ${h};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${l});
      return ${o.texture2D}(${e}, uv);
    }
  `}function M2e(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[3],i=e[2]*s,a=e[1]*i,{newShape:u,keptDims:l}=b.squeezeShape(e);if(u.length<e.length){let x=Qy(r,u),w=["row","col","depth","depth2"];return`
      ${Yy(x,t)}
      float ${o}(int row, int col, int depth, int depth2) {
        return ${o}(${Jy(w,l)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${s}, 1)));
        ${Zy(r)}
      }
    `;let c=r.shapeInfo.flatOffset,p=r.shapeInfo.texShape,d=p[0],f=p[1],h=`int stride2 = ${n}Shape[3];`,m=`int stride1 = ${n}Shape[2] * stride2;`,g=`int stride0 = ${n}Shape[1] * stride1;`;if(f===a&&c==null)return t?`
      float ${o}(int row, int col, int depth, int depth2) {
        ${h}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===s&&c==null)return t?`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n}Shape[1] * ${n}Shape[2], ${n}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e[1]*e[2]}, ${e[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;let y=Zh(n);return t?`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${h}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${y});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${d}, ${f}, index + ${y});
      return sampleTexture(${n}, uv);
    }
  `}function F2e(r){let t=r.shapeInfo.logicalShape,e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),o=t[4],s=t[3]*o,i=t[2]*s,a=t[1]*i,{newShape:u,keptDims:l}=b.squeezeShape(t);if(u.length<t.length){let m=Qy(r,u),g=["row","col","depth","depth2","depth3"];return`
      ${Yy(m)}
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        return ${n}(${Jy(g,l)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${s}, ${o})) +
          depth3;
        ${Zy(r)}
      }
    `;let c=r.shapeInfo.flatOffset,p=r.shapeInfo.texShape,d=p[0],f=p[1];if(f===a&&c==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(f===o&&c==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${e}, uv);
      }
    `;let h=Zh(e);return`
    float ${n}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${s} +
          depth2 * ${o} + depth3 + ${h};
      vec2 uv = uvFromFlat(${d}, ${f}, index);
      return sampleTexture(${e}, uv);
    }
  `}function $2e(r){let t=r.shapeInfo.logicalShape,e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:o,keptDims:s}=b.squeezeShape(t);if(o.length<t.length){let g=Qy(r,o),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${Yy(g)}
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${n}(${Jy(y,s)});
      }
    `}let i=t[5],a=t[4]*i,u=t[3]*a,l=t[2]*u,c=t[1]*l;if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${l}, ${u}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Zy(r)}
      }
    `;let p=r.shapeInfo.flatOffset,d=r.shapeInfo.texShape,f=d[0],h=d[1];if(h===c&&p==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${u}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${f}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(h===i&&p==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${f}.0);
        return sampleTexture(${e}, uv);
      }
    `;let m=Zh(e);return`
    float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${l} + depth * ${u} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${m};
      vec2 uv = uvFromFlat(${f}, ${h}, index);
      return sampleTexture(${e}, uv);
    }
  `}function Zy(r){let t=r.name,e=b.sizeFromShape(r.shapeInfo.logicalShape);return e<2?`return ${t};`:`
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function P2e(r,t){let e=r.name,n=e.charAt(0).toUpperCase()+e.slice(1),o="get"+n+"AtOutCoords",s=r.shapeInfo.logicalShape.length,i=t.logicalShape.length,a=iJ(r.shapeInfo.logicalShape,t.logicalShape),u=ut(i),l=i-s,c,p=["x","y","z","w","u","v"];s===0?c="":i<2&&a.length>=1?c="coords = 0;":c=a.map(x=>`coords.${p[x+l]} = 0;`).join(`
`);let d="";i<2&&s>0?d="coords":d=r.shapeInfo.logicalShape.map((x,w)=>`coords.${p[w+l]}`).join(", ");let f="return outputValue;",m=b.sizeFromShape(r.shapeInfo.logicalShape)===1,y=b.sizeFromShape(t.logicalShape)===1;if(s===1&&!m&&!y)f=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!y)i===1?f=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:f=`
        return vec4(outputValue.x);
      `;else if(a.length){let x=s-2,w=s-1;a.indexOf(x)>-1&&a.indexOf(w)>-1?f="return vec4(outputValue.x);":a.indexOf(x)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(w)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${o}() {
      ${u} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${n}(${d});
      ${f}
    }
  `}function L2e(r,t){let e=r.name,n=e.charAt(0).toUpperCase()+e.slice(1),o="get"+n+"AtOutCoords",s=t.texShape,i=r.shapeInfo.texShape,a=r.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!r.shapeInfo.isUniform&&a===u&&r.shapeInfo.flatOffset==null&&b.arraysEqual(i,s))return`
      float ${o}() {
        return sampleTexture(${e}, resultUV);
      }
    `;let l=ut(u),c=iJ(r.shapeInfo.logicalShape,t.logicalShape),p=u-a,d,f=["x","y","z","w","u","v"];a===0?d="":u<2&&c.length>=1?d="coords = 0;":d=c.map(m=>`coords.${f[m+p]} = 0;`).join(`
`);let h="";return u<2&&a>0?h="coords":h=r.shapeInfo.logicalShape.map((m,g)=>`coords.${f[g+p]}`).join(", "),`
    float ${o}() {
      ${l} coords = getOutputCoords();
      ${d}
      return get${n}(${h});
    }
  `}function ut(r){if(r<=1)return"int";if(r===2)return"ivec2";if(r===3)return"ivec3";if(r===4)return"ivec4";if(r===5)return"ivec5";if(r===6)return"ivec6";throw Error(`GPU for rank ${r} is not yet supported`)}function V1(r,t,e){let{newShape:n,keptDims:o}=b.squeezeShape(t),s=t.length,i=r&&s===3&&t[0]===1,a=i?t.slice(1):n,u=!r&&s>1&&!b.arraysEqual(t,e)&&n.length<s||i;return{useSqueezeShape:u,uniformShape:u?a:t,keptDims:o}}function Qy(r,t){let e=JSON.parse(JSON.stringify(r));return e.shapeInfo.logicalShape=t,e}function Jy(r,t){return t.map(e=>r[e]).join(", ")}function pJ(r,t,e,n){let o=e.map((c,p)=>{let d={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(d.flatOffset=c.texData.slice.flatOffset),{name:t.variableNames[p],shapeInfo:d}}),s=o.map(c=>c.shapeInfo),i={logicalShape:n.shape,texShape:n.texData.texShape,isUniform:!1,isPacked:n.texData.isPacked,flatOffset:null},a=aJ(o,i,t),u=VQ(r.gl,a),l=r.createProgram(u);return j().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:u,source:a,webGLProgram:l,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(r.buildVao(l),Object.assign({program:t,fragmentShader:u,source:a,webGLProgram:l,inShapeInfos:s,outShapeInfo:i},JF(r,t,l)))}function JF(r,t,e){let n=[],o=[],s,i,a,u=null,l=null;l=r.getUniformLocation(e,"NAN",!1),j().getNumber("WEBGL_VERSION")===1&&(u=r.getUniformLocation(e,"INFINITY",!1));let c=!1;for(let p of t.variableNames){let d={name:p,uniform:r.getUniformLocation(e,p,c),offset:r.getUniformLocation(e,`offset${p}`,c)};t.enableShapeUniforms&&(d.shape=r.getUniformLocation(e,`${p}Shape`,c),d.texShape=r.getUniformLocation(e,`${p}TexShape`,c)),n.push(d)}if(t.enableShapeUniforms&&(s=r.getUniformLocation(e,"outShape",c),a=r.getUniformLocation(e,"outShapeStrides",c),i=r.getUniformLocation(e,"outTexShape",c)),t.customUniforms)for(let p of t.customUniforms)o.push(r.getUniformLocation(e,p.name,c));return{variablesLocations:n,customUniformLocations:o,infLoc:u,nanLoc:l,outShapeLocation:s,outShapeStridesLocation:a,outTexShapeLocation:i}}function cJ(r,t){if(r.length!==t.length)throw Error(`Binary was compiled with ${r.length} inputs, but was executed with ${t.length} inputs`);r.forEach((e,n)=>{let o=e.logicalShape,s=t[n],i=s.shape;if(!b.arraysEqual(o,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${i} must match`);if(e.isUniform&&s.isUniform)return;let a=e.texShape,u=s.isUniform?null:s.texData.texShape;if(!b.arraysEqual(a,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${u} must match`)})}function dJ(r,t,e,n,o){t.program.enableShapeUniforms||(cJ(t.inShapeInfos,e),cJ([t.outShapeInfo],[n]));let s=n.texData.texture,i=n.texData.texShape;n.texData.isPacked?r.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):r.setOutputMatrixTexture(s.texture,i[0],i[1]),r.setProgram(t.webGLProgram),r.bindVertexArray(t.webGLProgram.vao),j().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&r.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&r.gl.uniform1f(t.nanLoc,NaN);for(let u=0;u<e.length;++u){let l=e[u],{uniform:c,offset:p,shape:d,texShape:f}=t.variablesLocations[u];if(d){let{uniformShape:h}=V1(t.program.packedInputs,l.shape,l.texData.texShape);switch(h.length){case 1:r.gl.uniform1iv(d,new Int32Array(h));break;case 2:r.gl.uniform2iv(d,new Int32Array(h));break;case 3:r.gl.uniform3iv(d,new Int32Array(h));break;case 4:r.gl.uniform4iv(d,new Int32Array(h));break;default:break}}if(f&&r.gl.uniform2i(f,l.texData.texShape[0],l.texData.texShape[1]),c!=null){if(l.isUniform){if(b.sizeFromShape(l.shape)<2)r.gl.uniform1f(c,l.uniformValues[0]);else{let h=l.uniformValues;h instanceof Float32Array||(h=new Float32Array(h)),r.gl.uniform1fv(c,h)}continue}l.texData.slice!=null&&p!=null&&r.gl.uniform1i(p,l.texData.slice.flatOffset),r.setInputMatrixTexture(l.texData.texture.texture,c,u)}}let a=t.outShapeLocation;if(a)switch(n.shape.length){case 1:r.gl.uniform1iv(a,new Int32Array(n.shape));break;case 2:r.gl.uniform2iv(a,new Int32Array(n.shape));break;case 3:r.gl.uniform3iv(a,new Int32Array(n.shape));break;case 4:r.gl.uniform4iv(a,new Int32Array(n.shape));break;default:break}if(t.outShapeStridesLocation){let u=b.computeStrides(n.shape);switch(n.shape.length){case 2:r.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(u));break;case 3:r.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(u));break;case 4:r.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(u));break;default:break}}if(t.outTexShapeLocation&&r.gl.uniform2i(t.outTexShapeLocation,n.texData.texShape[0],n.texData.texShape[1]),t.program.customUniforms&&o)for(let u=0;u<t.program.customUniforms.length;++u){let l=t.program.customUniforms[u],c=t.customUniformLocations[u],p=o[u];if(l.type==="float")r.gl.uniform1fv(c,p);else if(l.type==="vec2")r.gl.uniform2fv(c,p);else if(l.type==="vec3")r.gl.uniform3fv(c,p);else if(l.type==="vec4")r.gl.uniform4fv(c,p);else if(l.type==="int")r.gl.uniform1iv(c,p);else if(l.type==="ivec2")r.gl.uniform2iv(c,p);else if(l.type==="ivec3")r.gl.uniform3iv(c,p);else if(l.type==="ivec4")r.gl.uniform4iv(c,p);else throw Error(`uniform type ${l.type} is not supported yet.`)}r.executeProgram()}function fJ(r,t,e){let n="";t.concat(e).forEach(i=>{let a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(r.enableShapeUniforms&&!i.isUniform){let u=i.texData.texShape,{useSqueezeShape:l,uniformShape:c,keptDims:p}=V1(r.packedInputs,i.shape,u),d="",f="",h="";if(c.length===1&&r.packedInputs){let I=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];d=`${I[0]>1}_${I[1]>1}`}else if(c.length===2&&!r.packedInputs)f=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!r.packedInputs){let I=b.computeStrides(c);h=`${I[0]===u[1]}_${I[I.length-1]===u[1]}`}let m=i.shape.length,g=c.length===2&&b.arraysEqual(i.shape,u),y=b.sizeFromShape(i.shape)===1,x=T.getBroadcastDims(i.shape,e.shape),w=!r.packedInputs&&m===e.shape.length&&b.arraysEqual(u,e.texData.texShape),C=r.packedInputs||c.length>2?"":`${u[0]>1}_${u[1]>1}`;n+=`${m}_${w}_${l?p:""}_${c.length}_${y}_${x}_${g}_${d}_${f}_${h}_${C}_${a}`}else{let u=i.isUniform?"uniform":i.texData.texShape;n+=`${i.shape}_${u}_${a}`}});let o=r.userCode,s=r.constructor.name;return s+="_"+n+"_"+o+`${j().getNumber("WEBGL_VERSION")}`,s}function ir(r){return j().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&r<=4}var U1=class{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=qh.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let e=Xr();this.outputShape=t,this.enableShapeUniforms=ir(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Yh(["r","c","d"],t):uu(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${e.output} = result;
      }
    `}};var G1=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=qh.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let e=Xr();this.outputShape=t,this.enableShapeUniforms=ir(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Yh(["r","c","d"],t):uu(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${e.output} = result;
      }
    `}};var W1=class{constructor(t){this.variableNames=["A"],this.outTexUsage=ko.DOWNLOAD;let e=Xr();this.outputShape=t,this.userCode=`
      ${B1}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `}};var j1=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=ko.DOWNLOAD;let e=Xr();this.outputShape=t,this.userCode=`
      ${B1}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `}};var V2e={R:0,G:1,B:2,A:3},tw=class{constructor(t,e=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let o=Xr();this.outputShape=t,this.enableShapeUniforms=ir(this.outputShape.length);let s="result";e&&(s="floor(result * 255. + 0.5)");let i="";for(let a=0;a<n.length;a++){let u=n[a];i+=`
          if(offset == ${a}) {
            result = values[${V2e[u]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?Ky():qy(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${o.texture2D}(A, uv);
          ${i}
        }
        ${o.output} = vec4(${s}, 0., 0., 0.);
      }
    `}};var H1=class{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=Xr();this.outputShape=t,this.enableShapeUniforms=ir(this.outputShape.length);let o="",s="result";e&&(s="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){let u=i*2+a;o+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Ky():qy(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${o}

          ${n.output} = ${s};
        }
    `}};function hJ(r){let t=Xr(),e=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return BQ(r,e)}function mJ(r){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return WQ(r,t)}function gJ(r){let t=new Uint16Array([0,1,2,2,1,3]);return jQ(r,t)}function rw(r,t,e,n,o,s){qQ(t,e);let i=HQ(r),a=r.TEXTURE_2D;return Re(r,()=>r.bindTexture(a,i)),Re(r,()=>r.texParameteri(a,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE)),Re(r,()=>r.texParameteri(a,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE)),Re(r,()=>r.texParameteri(a,r.TEXTURE_MIN_FILTER,r.NEAREST)),Re(r,()=>r.texParameteri(a,r.TEXTURE_MAG_FILTER,r.NEAREST)),j().getNumber("WEBGL_VERSION")===1?Re(r,()=>r.texImage2D(a,0,n,t,e,0,o,s,null)):Re(r,()=>r.texStorage2D(a,1,n,t,e)),Re(r,()=>r.bindTexture(r.TEXTURE_2D,null)),{texture:i,texShape:[e,t]}}function e$(r){return r.internalFormatFloat}function yJ(r,t,e,n){let[o,s]=Kh(t,e);return rw(r,o,s,e$(n),n.textureFormatFloat,r.FLOAT)}function t$(r){return r.internalFormatHalfFloat}function xJ(r,t,e,n){let[o,s]=Kh(t,e);return rw(r,o,s,t$(n),n.textureFormatFloat,n.textureTypeHalfFloat)}function r$(r){return r.downloadTextureFormat}function vJ(r,t,e,n){let[o,s]=Kh(t,e);return rw(r,o,s,r$(n),r.RGBA,r.UNSIGNED_BYTE)}function n$(r){return r.internalFormatPackedFloat}function bJ(r,t,e,n){let[o,s]=Hl(t,e);return rw(r,o,s,n$(n),r.RGBA,r.FLOAT)}function o$(r){return r.internalFormatPackedHalfFloat}function wJ(r,t,e,n){let[o,s]=Hl(t,e);return rw(r,o,s,o$(n),r.RGBA,n.textureTypeHalfFloat)}function CJ(r,t,e){return Re(r,()=>r.bindBuffer(r.ARRAY_BUFFER,e)),YF(r,t,"clipSpacePos",e,3,20,0)&&YF(r,t,"uv",e,2,20,12)}function SJ(r,t,e,n,o,s){Re(r,()=>r.bindTexture(r.TEXTURE_2D,t));let i,a,u;o instanceof Uint8Array?(i=new Uint8Array(e*n*4),a=r.UNSIGNED_BYTE,u=r.RGBA):(i=new Float32Array(e*n*4),a=r.FLOAT,u=s.internalFormatPackedFloat),i.set(o),j().getNumber("WEBGL_VERSION")===2?Re(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,e,n,r.RGBA,a,i)):Re(r,()=>r.texImage2D(r.TEXTURE_2D,0,u,e,n,0,r.RGBA,a,i)),Re(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function IJ(r,t,e){Re(r,()=>r.bindTexture(r.TEXTURE_2D,t)),e.data instanceof Uint8Array?j().getNumber("WEBGL_VERSION")===2?Re(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,e.width,e.height,r.RGBA,r.UNSIGNED_BYTE,e.data)):Re(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,e.width,e.height,0,r.RGBA,r.UNSIGNED_BYTE,e.data)):j().getNumber("WEBGL_VERSION")===2?Re(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,r.RGBA,r.UNSIGNED_BYTE,e)):Re(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,e)),Re(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function TJ(r,t,e,n){let o=r.createBuffer();Re(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,o));let a=4*4*t*e;return Re(r,()=>r.bufferData(r.PIXEL_PACK_BUFFER,a,r.STREAM_READ)),Re(r,()=>r.readPixels(0,0,e,t,r.RGBA,r.FLOAT,0)),Re(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,null)),o}function _J(r,t,e){let n=r,o=new Float32Array(e);return n.bindBuffer(n.PIXEL_PACK_BUFFER,t),n.getBufferSubData(n.PIXEL_PACK_BUFFER,0,o),n.bindBuffer(n.PIXEL_PACK_BUFFER,null),o}function EJ(r,t,e,n){let[o,s]=Kh(t,e),i=4,a=new Uint8Array(PQ(t*e,i));return Re(r,()=>r.readPixels(0,0,o,s,n.downloadTextureFormat,r.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function kJ(r,t,e,n,o,s,i,a){let u=r,l=new Float32Array(LQ(s,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function NJ(r,t,e){let n=new Float32Array(t*e*4);return Re(r,()=>r.readPixels(0,0,e,t,r.RGBA,r.FLOAT,n)),n}var ex=class{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let e=j().getNumber("WEBGL_VERSION");if(t!=null?(this.gl=t,$Q(e,t)):this.gl=As(e),t=this.gl,j().getNumber("WEBGL_VERSION")===2){let s=t;this.createVertexArray=()=>Re(s,()=>s.createVertexArray()),this.bindVertexArray=i=>Re(s,()=>s.bindVertexArray(i)),this.deleteVertexArray=i=>Re(s,()=>s.deleteVertexArray(i)),this.getVertexArray=()=>Re(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(t!=null){let s=t.getExtension("OES_vertex_array_object");if(s==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Re(t,()=>s.createVertexArrayOES()),this.bindVertexArray=i=>Re(t,()=>s.bindVertexArrayOES(i)),this.deleteVertexArray=i=>Re(t,()=>s.deleteVertexArrayOES(i)),this.getVertexArray=()=>Re(t,()=>t.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float",o="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),j().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=Qb(this.gl,s),Qs(this.gl,i))this.textureHalfFloatExtension=Qb(this.gl,i);else if(j().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Qs(this.gl,o))this.colorBufferHalfFloatExtension=Qb(this.gl,o);else if(j().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Qs(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(Qs(this.gl,o))this.colorBufferHalfFloatExtension=this.gl.getExtension(o);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=mJ(this.gl),this.indexBuffer=gJ(this.gl),this.framebuffer=KQ(this.gl),this.textureConfig=Zb(this.gl,this.textureHalfFloatExtension)}get debug(){return j().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let t=this.gl;Re(t,()=>t.finish()),Re(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),Re(t,()=>t.deleteFramebuffer(this.framebuffer)),Re(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),Re(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),Re(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),yJ(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),xJ(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),vJ(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),IJ(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,o){this.throwIfDisposed(),SJ(this.gl,t,e,n,o,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),wJ(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),bJ(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(ZF(this.gl,this.framebuffer),this.outputTexture=null),Re(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,()=>EJ(this.gl,e,n,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,n,o,s,i){return kJ(this.gl,t,e,n,o,s,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return _J(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);let o=TJ(this.gl,e,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),o}createAndWaitForFence(){let t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(j().getBool("WEBGL_FENCE_API_ENABLED")){let o=t,s=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{let i=o.clientWaitSync(s,0,0);return i===o.ALREADY_SIGNALED||i===o.CONDITION_SATISFIED},e=s}else j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,()=>NJ(this.gl,e,n))}createProgram(t){this.throwIfDisposed();let e=this.gl;this.vertexShader==null&&(this.vertexShader=hJ(e));let n=UQ(e);Re(e,()=>e.attachShader(n,this.vertexShader)),Re(e,()=>e.attachShader(n,t)),GQ(e,n);let o=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&P1(e,o),o}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);let e=this.gl;Re(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),CJ(e,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&(Re(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&P1(this.gl,this.program),Re(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,n=!0){return this.throwIfDisposed(),n?XQ(this.gl,t,e):YQ(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),Re(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),ZQ(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();let[o,s]=Hl(e,n);this.setOutputMatrixTextureDriver(t,o,s)}setOutputMatrixWriteRegion(t,e,n,o){this.setOutputMatrixWriteRegionDriver(n,t,o,e)}setOutputPackedMatrixWriteRegion(t,e,n,o){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&P1(this.gl,this.program),Jb(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let t=this.gl;if(this.debug){let e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Re(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Re(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Qb(this.gl,j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.createQuery();return n.beginQuery(o.TIME_ELAPSED_EXT,s),s}let t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let e=this.gl,n=this.getQueryTimerExtensionWebGL2();e.endQuery(n.TIME_ELAPSED_EXT);return}let t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(t){return L(this,null,function*(){return yield b.repeatedTry(()=>this.disposed||this.isQueryAvailable(t,j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})}getQueryTime(t,e){if(e===0)return null;if(e===2){let n=this.gl;return n.getQueryParameter(t,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(t,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(e===0)return!0;if(e===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.getQueryParameter(t,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),o=n.getQueryObjectEXT(t,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),o&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){let t=G2e(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){let{resolveFn:n}=this.itemsToPoll[e];n()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in j().platform&&(n=j().platform.setTimeoutCustom.bind(j().platform)),b.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),L1(this.gl,t,this.framebuffer),this.debug&&Jb(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(L1(this.gl,this.outputTexture,this.framebuffer),this.debug&&Jb(this.gl)):ZF(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);let n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();let o=this.gl;L1(o,t,this.framebuffer),this.debug&&Jb(o),this.outputTexture=t,Re(o,()=>o.viewport(0,0,e,n)),Re(o,()=>o.scissor(0,0,e,n))}setOutputMatrixWriteRegionDriver(t,e,n,o){this.throwIfDisposed(),Re(this.gl,()=>this.gl.scissor(t,e,n,o))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function G2e(r){let t=0;for(;t<r.length&&r[t]();++t);return t-1}var{addImpl:DJ,bincountImpl:q1,bincountReduceImpl:AJ,bitwiseAndImpl:RJ,castImpl:OJ,ceilImpl:MJ,concatImpl:FJ,equalImpl:$J,expImpl:PJ,expm1Impl:LJ,floorImpl:zJ,gatherNdImpl:BJ,gatherV2Impl:VJ,greaterImpl:UJ,greaterEqualImpl:GJ,lessImpl:WJ,lessEqualImpl:jJ,linSpaceImpl:HJ,logImpl:qJ,maxImpl:KJ,maximumImpl:XJ,minimumImpl:YJ,multiplyImpl:ZJ,negImpl:QJ,notEqualImpl:JJ,prodImpl:eee,raggedGatherImpl:tee,raggedRangeImpl:ree,raggedTensorToTensorImpl:nee,rangeImpl:oee,rsqrtImpl:see,scatterImpl:iee,sigmoidImpl:aee,simpleAbsImpl:K1,sliceImpl:uee,sparseFillEmptyRowsImpl:lee,sparseReshapeImpl:cee,sparseSegmentReductionImpl:X1,sqrtImpl:pee,staticRegexReplaceImpl:dee,stridedSliceImpl:fee,stringNGramsImpl:hee,stringSplitImpl:mee,stringToHashBucketFastImpl:gee,subImpl:yee,tileImpl:xee,topKImpl:vee,transposeImpl:Qh,uniqueImpl:bee}=wb;function s$(r,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${r}.${e}`)}function un(r,t){return t===1?[r]:s$(r,t)}function wee(r,t){if(r===1)return"rc";let e="";for(let n=0;n<r;n++)e+=t[n],n<r-1&&(e+=",");return e}var Y1=class{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=ir(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let e=un("rc",this.rank),n=ut(this.rank),o=this.getOutOfBoundsCondition(e),s=this.getSetup(e),i=this.getOutput(e);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(t){let e=[];for(let n=0;n<=1;n++)for(let o=0;o<=1;o++){let s=`${n===0?"r":"rp1"}, ${o===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)s=`${t[t.length-1-i]},`+s;e.push(s)}return e}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let n=this.rank-2;n<this.rank;n++)e+=`${t[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(e+="||");return e}getSetup(t){if(this.rank===1)return"";let e=t.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],o=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${e[0]};
      int c = ${e[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${o};
    `}getOutput(t){let e=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),
            cEdge ? 0. : getA(${e[1]}),
            rEdge ? 0. : getA(${e[2]}),
            rEdge || cEdge ? 0. : getA(${e[3]})`}};var tx=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=ir(this.outputShape.length);let n="";for(let o=0;o<4;o++){let s="thisRC = rc;";o%2===1&&(s+="thisRC.z += 1;"),o>1&&(s+="thisRC.y += 1;"),n+=`
        ${s}
        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${o}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${o>0?"}":""}
      `}this.userCode=`
      ${W2e(e,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Ky():qy(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${n}

        setOutput(result);
      }
    `}};function W2e(r,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?sJ(["r","c","d"],"inputShape"):uu(["r","c","d"],r)}
      return ivec3(r, c, d);
    }
  `}var Z1=class{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,n){let o=See(e,n),s=Iee(t,o,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let i=Cee(t,o,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let u=this.freeTextures[s].pop();return this.usedTextures[s].push(u),u}let a;return o===fo.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):o===fo.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):o===fo.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):o===fo.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):o===fo.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(t,e,n,o){if(this.freeTextures==null)return;let s=See(n,o),i=Iee(e,s,o);i in this.freeTextures||(this.freeTextures[i]=[]);let a=Cee(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,o),u=j().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;let l=this.usedTextures[i],c=l&&l.indexOf(t);if(c==null||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[c]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);let e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(let t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function j2e(r,t){let e=r;if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===r.RGBA)return 16;if(t===e.RGBA16F)return 8;if(t===e.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function Cee(r,t,e,n,o){let s=H2e(t,n),i;if(o){let[u,l]=Hl(r[0],r[1]);i=u*l}else{let[u,l]=Kh(r[0],r[1]);i=u*l}let a=j2e(e,s);return i*a}function H2e(r,t){switch(r){case fo.PACKED_2X2_FLOAT32:return n$(t);case fo.PACKED_2X2_FLOAT16:return o$(t);case fo.UNPACKED_FLOAT32:return e$(t);case fo.UNPACKED_FLOAT16:return t$(t);case fo.PACKED_4X1_UNSIGNED_BYTE:return r$(t);default:throw new Error(`Unknown physical texture type ${r}`)}}function q2e(r){return j().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?r?fo.PACKED_2X2_FLOAT32:fo.UNPACKED_FLOAT32:r?fo.PACKED_2X2_FLOAT16:fo.UNPACKED_FLOAT16}function See(r,t){if(r===ko.UPLOAD)return fo.PACKED_2X2_FLOAT32;if(r===ko.RENDER||r==null)return q2e(t);if(r===ko.DOWNLOAD||r===ko.PIXELS)return fo.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${r}`)}function Iee(r,t,e){return`${r[0]}_${r[1]}_${t}_${e}`}var no=class{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=ir(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},kn="if (isnan(x)) return x;",Tee="return x;",i$="return abs(x);";var _ee="return (x >= 0.0) ? x : (exp(x) - 1.0);",Eee=kn+`
  return (x < 0.0) ? 0.0 : x;
`,kee=kn+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Kl="return x;",Nee="return 1.0 / (1.0 + exp(-1.0 * x));";var Aee="return x;",Ree=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Oee=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Mee=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Fee="return 1.0 / (1.0 + exp(-1.0 * x));",ss=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=ir(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}};var Q1=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=ir(this.outputShape.length);let e=t.length,n=un("rc",e),o=ut(e),s=wee(e,n),i=n.slice(-2),a=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}};var X2e=En.whereImpl,Y2e=1e-7,Z2e=1e-4,J1={};function Q2e(r){return r in J1||(J1[r]={}),J1[r]}var J2e=j().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),eOe=600;function tOe(){return j().global.screen==null?1024:j().global.screen.height*j().global.screen.width*window.devicePixelRatio*eOe/1024/1024}var $ee=(()=>{class r extends Zi{nextDataId(){return r.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!j().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(e!=null){if(e instanceof ex)n=e;else{let o=As(j().getNumber("WEBGL_VERSION"),e);n=new ex(o)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let o=As(j().getNumber("WEBGL_VERSION"));n=new ex(o),this.binaryCache=Q2e(j().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Z1(this.gpgpu),this.numMBBeforeWarning=tOe(),this.texData=new dc(this,Pn())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,n,o,s,i,a){let u=this.makeTensorInfo(n,o),l=this.texData.get(u.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[s,i]},l.texShape=[s,i];let c=ew(n),p=new tw(c,!1,a),d=this.runWebGLProgram(p,[u],o,[[s,i]]);return d.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(u),d.dataId}write(e,n,o){if((j().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||j().getBool("DEBUG"))&&this.checkNumericalProblems(e),o==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let s={id:this.nextDataId()};return this.texData.set(s,{shape:n,dtype:o,values:e,usage:ko.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let n=this.texData.get(e);n.refCount++}decRef(e){if(this.texData.has(e)){let n=this.texData.get(e);n.refCount--}}move(e,n,o,s,i){if(j().getBool("DEBUG")&&this.checkNumericalProblems(n),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:o,dtype:s,values:n,usage:ko.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let n=this.texData.get(e),{values:o,dtype:s,complexTensorInfos:i,slice:a,shape:u,isPacked:l}=n;if(a!=null){let f;l?f=new ss(u,Kl):f=new no(u,Kl);let h=this.runWebGLProgram(f,[{dataId:e,shape:u,dtype:s}],s),m=this.readSync(h.dataId);return this.disposeIntermediateTensorInfo(h),m}if(o!=null)return this.convertAndCacheOnCPU(e);if(s==="string")return o;let c=this.activeTimers!=null,p;c&&(p=b.now());let d;if(s==="complex64"){let f=this.readSync(i.real.dataId),h=this.readSync(i.imag.dataId);d=T.mergeRealAndImagArrays(f,h)}else d=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=b.now()-p),this.convertAndCacheOnCPU(e,d)}read(e){return L(this,null,function*(){if(this.pendingRead.has(e)){let m=this.pendingRead.get(e);return new Promise(g=>m.push(g))}let n=this.texData.get(e),{values:o,shape:s,slice:i,dtype:a,complexTensorInfos:u,isPacked:l}=n;if(i!=null){let m;l?m=new ss(s,Kl):m=new no(s,Kl);let g=this.runWebGLProgram(m,[{dataId:e,shape:s,dtype:a}],a),y=this.read(g.dataId);return this.disposeIntermediateTensorInfo(g),y}if(o!=null)return this.convertAndCacheOnCPU(e);if(j().getBool("DEBUG")&&!j().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&j().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,p;if(a!=="complex64"&&j().get("WEBGL_BUFFER_SUPPORTED")){p=this.decode(e);let m=this.texData.get(p.dataId);c=this.gpgpu.createBufferFromTexture(m.texture.texture,...Yb(s))}this.pendingRead.set(e,[]),a!=="complex64"&&(yield this.gpgpu.createAndWaitForFence());let d;if(a==="complex64"){let m=yield Promise.all([this.read(u.real.dataId),this.read(u.imag.dataId)]),g=m[0],y=m[1];d=T.mergeRealAndImagArrays(g,y)}else if(c==null)d=this.getValuesFromTexture(e);else{let m=b.sizeFromShape(s);d=this.gpgpu.downloadFloat32MatrixFromBuffer(c,m)}if(p!=null&&this.disposeIntermediateTensorInfo(p),c!=null){let m=this.gpgpu.gl;Re(m,()=>m.deleteBuffer(c))}let f=this.convertAndCacheOnCPU(e,d),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach(m=>m(f)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Pn().removeDataId(e,this),this.pendingDeletes--),f})}readToGPU(e,n={}){let o=this.texData.get(e),{values:s,shape:i,slice:a,dtype:u,isPacked:l,texture:c}=o;if(u==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let h;l?h=new ss(i,Kl):h=new no(i,Kl);let m=this.runWebGLProgram(h,[{dataId:e,shape:i,dtype:u}],u),g=this.readToGPU(m,n);return this.disposeIntermediateTensorInfo(m),g}if(c==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let p=this.decode(e,n.customTexShape),d=Pn().makeTensorFromTensorInfo(p),f=this.texData.get(p.dataId);return Object.assign({tensorRef:d},f.texture)}bufferSync(e){let n=this.readSync(e.dataId);if(e.dtype==="string")try{let o=n.map(s=>b.decodeString(s));return Ne(e.shape,e.dtype,o)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ne(e.shape,e.dtype,n)}checkNumericalProblems(e){if(e!=null)for(let n=0;n<e.length;n++){let o=e[n];if(!zQ(o))throw j().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${o} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${o} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:n,dtype:o,isPacked:s}=this.texData.get(e),i=b.sizeFromShape(n);if(j().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let f=this.decode(e),h=this.texData.get(f.dataId),m=this.gpgpu.downloadMatrixFromPackedTexture(h.texture.texture,...Yb(n)).subarray(0,i);return this.disposeIntermediateTensorInfo(f),m}let a=j().getBool("WEBGL_PACK")&&s===!0,u=a?ew(n):n,l=a?new j1(u):new W1(u),c=this.runWebGLProgram(l,[{shape:u,dtype:o,dataId:e}],"float32"),p=this.texData.get(c.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(p.texture.texture,p.texShape[0],p.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(c),d}timerAvailable(){return j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let n=this.activeTimers,o=[],s=!1;this.programTimersStack==null?(this.programTimersStack=o,s=!0):this.activeTimers.push(o),this.activeTimers=o,e();let i=b.flatten(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),a=b.flatten(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,s&&(this.programTimersStack=null);let u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return L(this,null,function*(){if(j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let l=yield Promise.all(i);u.kernelMs=b.sum(l),u.getExtraProfileInfo=()=>l.map((c,p)=>({name:a[p],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else u.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,u})}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:b.now(),endMs:null}}endTimer(e){return j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=b.now(),e)}getQueryTime(e){return L(this,null,function*(){if(j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let n=e;return n.endMs-n.startMs})}disposeData(e,n=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(n?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!n&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:o}=this.texData.get(e);return o!=null&&(this.disposeData(o.real.dataId,n),this.disposeData(o.imag.dataId,n)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:n,dtype:o,texShape:s,usage:i,isPacked:a,slice:u}=this.texData.get(e),l=u&&u.origDataId||e,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(s,o),this.textureManager.releaseTexture(n,s,i,a)));let p=this.texData.get(e);p.texture=null,p.texShape=null,p.isPacked=!1,p.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,n=J2e){return j().getBool("WEBGL_CPU_FORWARD")&&e.every(o=>this.texData.get(o.dataId).texture==null&&b.sizeFromShape(o.shape)<n)}getGPGPUContext(){return this.gpgpu}where(e){T.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let n=e.dataSync();return X2e(e.shape,n)}packedUnaryOp(e,n,o){let s=new ss(e.shape,n),i=this.compileAndRun(s,[e],o);return Pn().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){let s=K1(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if(j().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,i$,e.dtype);let n=new no(e.shape,i$),o=this.compileAndRun(n,[e]);return Pn().makeTensorFromTensorInfo(o)}makeTensorInfo(e,n,o){let s;if(n==="string"&&o!=null&&o.length>0&&b.isString(o[0])){let i=o.map(a=>b.encodeString(a));s=this.write(i,e,n)}else s=this.write(o,e,n);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:n}}makeOutput(e,n,o){return Pn().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,o),this)}unpackTensor(e){let n=new Q1(e.shape);return this.runWebGLProgram(n,[e],e.dtype)}packTensor(e){let n=new Y1(e.shape);return this.runWebGLProgram(n,[e],e.dtype,null,!0)}packedReshape(e,n){let o=[of(e.shape),...sf(e.shape)],s={dtype:e.dtype,shape:o,dataId:e.dataId},i=[of(n),...sf(n)],a=new tx(i,o),u=!0,l=[o],c=this.runWebGLProgram(a,[s],e.dtype,l,u);return{dataId:c.dataId,shape:n,dtype:c.dtype}}decode(e,n){let o=this.texData.get(e),{isPacked:s,shape:i,dtype:a}=o;if(n!=null){let f=b.sizeFromShape(i),h=n[0]*n[1]*4;b.assert(f<=h,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let u=ew(i),l;s?l=new G1(u):l=new U1(u);let c=!0,p=[n??Yb(u)],d=this.runWebGLProgram(l,[{shape:u,dtype:a,dataId:e}],a,p,c,n);return{dtype:a,shape:i,dataId:d.dataId}}runWebGLProgram(e,n,o,s,i=!1,a){let u=this.makeTensorInfo(e.outputShape,o),l=this.texData.get(u.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===qh.DENSE){let x=a??Yb(e.outputShape);l.texShape=x.map(w=>w*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),b.sizeFromShape(u.shape)===0)return l.values=b.getTypedArrayFromDType(u.dtype,0),u;let c=[],p=n.map(x=>{if(x.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let w=this.texData.get(x.dataId);if(w.texture==null){if(!e.packedInputs&&b.sizeFromShape(x.shape)<=j().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:x.shape,texData:null,isUniform:!0,uniformValues:w.values};e.packedInputs&&(w.isPacked=!0,w.shape=x.shape)}if(this.uploadToGPU(x.dataId),!!w.isPacked!=!!e.packedInputs)x=w.isPacked?this.unpackTensor(x):this.packTensor(x),c.push(x),w=this.texData.get(x.dataId);else if(w.isPacked&&!Xh(w.shape,x.shape)){let C=x,I=x.shape;x.shape=w.shape,x=this.packedReshape(x,I),c.push(x),w=this.texData.get(x.dataId),C.shape=I}return{shape:x.shape,texData:w,isUniform:!1}});this.uploadToGPU(u.dataId);let d={shape:u.shape,texData:l,isUniform:!1},f=fJ(e,p,d),h=this.getAndSaveBinary(f,()=>pJ(this.gpgpu,e,p,d)),m=this.activeTimers!=null,g;m&&(g=this.startTimer()),j().get("ENGINE_COMPILE_ONLY")||dJ(this.gpgpu,h,p,d,s),c.forEach(x=>this.disposeIntermediateTensorInfo(x)),m&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)}));let y=j().getNumber("WEBGL_FLUSH_THRESHOLD");if(y>0){let x=b.now();x-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=x)}if(!j().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&i===!1){let x=this.unpackTensor(u);return this.disposeIntermediateTensorInfo(u),x}return u}compileAndRun(e,n,o,s,i=!1){return o=o||n[0].dtype,this.runWebGLProgram(e,n,o,s,i)}getAndSaveBinary(e,n){return e in this.binaryCache||(this.binaryCache[e]=n()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(j().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(n=>{this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram),delete this.binaryCache[n]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=X(()=>{if(!j().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=j().getBool("DEBUG");j().set("DEBUG",!1);let n=this.abs(we(1e-8)).dataSync()[0];if(j().set("DEBUG",e),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?Y2e:Z2e}uploadToGPU(e){let n=this.texData.get(e),{shape:o,dtype:s,values:i,texture:a,usage:u,isPacked:l}=n;if(a!=null)return;let c=this.activeTimers!=null,p;c&&(p=b.now());let d=n.texShape;if(d==null&&(d=QQ(o,l),n.texShape=d),i!=null){let f=ew(o),h,m=d[1],g=d[0],y=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(l||!y)&&([m,g]=Hl(d[0],d[1])),l?h=new H1(f,y):h=new tw(f,y);let x=y?[g,m]:d,w=this.makeTensorInfo(x,s),C=this.texData.get(w.dataId);y?C.usage=ko.PIXELS:C.usage=ko.UPLOAD,C.texShape=x,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(w.dataId),m,g,i);let I=[[g,m]],A=this.runWebGLProgram(h,[w],s,I,!0),O=this.texData.get(A.dataId);n.texShape=O.texShape,n.isPacked=O.isPacked,n.usage=O.usage,j().get("ENGINE_COMPILE_ONLY")?this.disposeData(A.dataId):(n.texture=O.texture,n.values=null,this.texData.delete(A.dataId)),this.disposeIntermediateTensorInfo(w),c&&(this.uploadWaitMs+=b.now()-p)}else{let f=this.acquireTexture(d,u,s,l);n.texture=f}}convertAndCacheOnCPU(e,n){let o=this.texData.get(e),{dtype:s}=o;return n!=null&&(o.values=rOe(n,s)),o.values}acquireTexture(e,n,o,s){if(this.numBytesInGPU+=this.computeBytes(e,o),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,n,s)}computeBytes(e,n){return e[0]*e[1]*b.bytesPerElement(n)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){return L(this,null,function*(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,n]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(n));return Promise.all(e)}else{for(let[,n]of Object.entries(this.binaryCache)){let o=new Promise(s=>{try{this.checkCompletion_(n),s(!0)}catch(i){throw i}});e.push(o)}return Promise.all(e)}})}checkCompletionAsync_(e){return L(this,null,function*(){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(yield ib(),this.checkCompletionAsync_(e))})}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(XF(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);let{variablesLocations:n,customUniformLocations:o,infLoc:s,nanLoc:i,outShapeLocation:a,outShapeStridesLocation:u,outTexShapeLocation:l}=JF(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=n,e.customUniformLocations=o,e.infLoc=s,e.nanLoc=i,e.outShapeLocation=a,e.outShapeStridesLocation=u,e.outTexShapeLocation=l}}createTensorFromGPUData(e,n,o){e.channels=e.channels||"RGBA";let{texture:s,height:i,width:a,channels:u}=e,l=Pn().backend;if(!l.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let c=l.writeTexture(s,n,o,i,a,u);return Pn().makeTensorFromDataId(c,n,o,l)}}return r.nextDataId=0,r})();function rOe(r,t){if(t==="float32"||t==="complex64")return r;if(t==="int32"||t==="bool"){let e=t==="int32"?new Int32Array(r.length):new Uint8Array(r.length);for(let n=0;n<e.length;++n)e[n]=Math.round(r[n]);return e}else throw new Error(`Unknown dtype ${t}`)}Id.isBrowser()&&Dg("webgl",()=>new $ee,2);var rx=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;var is=class{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=T.assertAndGetBroadcastShape(e,n),this.enableShapeUniforms=ir(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};var Os=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;var Rs=class{constructor(t,e,n,o=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=T.assertAndGetBroadcastShape(e,n);let s=this.outputShape.length;this.enableShapeUniforms=ir(s);let i="";if(o)if(s===0||b.sizeFromShape(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${ut(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let u=un("coords",s);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${u[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${u[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${u[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${u[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}};function ln(r){let{inputs:t,backend:e}=r,{x:n}=t;return e.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var Pee={kernelName:fi,backendName:"webgl",kernelFunc:ln};function as(r){let{inputs:t,backend:e}=r,{real:n,imag:o}=t,s=e.makeTensorInfo(n.shape,"complex64"),i=e.texData.get(s.dataId),a=ln({inputs:{x:n},backend:e}),u=ln({inputs:{x:o},backend:e});return i.complexTensorInfos={real:a,imag:u},s}var Lee={kernelName:Op,backendName:"webgl",kernelFunc:as};var a$="return (a < 0.) ? b * a : a;",u$=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function nOe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{alpha:s}=n,i=e.makeTensorInfo([],"float32",b.createScalarValue(s,"float32")),a=j().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Rs(u$,o.shape,i.shape):new is(a$,o.shape,i.shape),u=e.runWebGLProgram(a,[o,i],"float32");return e.disposeIntermediateTensorInfo(i),u}var zee={kernelName:Qu,backendName:"webgl",kernelFunc:nOe};var l$="return (a < 0.) ? b * a : a;",c$=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function oOe(r){let{inputs:t,backend:e}=r,{x:n,alpha:o}=t,s=j().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Rs(c$,n.shape,o.shape):new is(l$,n.shape,o.shape);return e.runWebGLProgram(s,[n,o],"float32")}var Bee={kernelName:pl,backendName:"webgl",kernelFunc:oOe};var $i="if (isnan(x)) return x;";function Ve({opSnippet:r,packedOpSnippet:t,cpuKernelImpl:e,dtype:n}){return({inputs:o,backend:s})=>{let{x:i}=o,a=s,u=n||i.dtype;if(a.shouldExecuteOnCPU([i])&&e!=null){let p=a.texData.get(i.dataId),d=e(p.values,u);return a.makeTensorInfo(i.shape,u,d)}let l=j().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,c;return l?c=new ss(i.shape,t):c=new no(i.shape,r),a.runWebGLProgram(c,[i],u)}}function Zt({opSnippet:r,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:n=!1,cpuKernelImpl:o,dtype:s}){return({inputs:i,backend:a})=>{let{a:u,b:l}=i,c=a;if(n&&u.dtype==="complex64"){let h=c.texData.get(u.dataId),m=c.texData.get(l.dataId),[g,y]=[[h.complexTensorInfos.real,m.complexTensorInfos.real],[h.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(w=>{let[C,I]=w,N={dataId:C.dataId,dtype:C.dtype,shape:u.shape},A={dataId:I.dataId,dtype:I.dtype,shape:l.shape},O=new is(r,u.shape,l.shape);return c.runWebGLProgram(O,[N,A],mr(C.dtype,I.dtype))}),x=as({inputs:{real:g,imag:y},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(y),x}let p=s||mr(u.dtype,l.dtype);if((u.dtype==="string"||l.dtype==="string"||c.shouldExecuteOnCPU([u,l]))&&o!=null){let h=c.texData.get(u.dataId).values,m=c.texData.get(l.dataId).values,g=u.dtype==="string"?T.fromUint8ToStringArray(h):h,y=u.dtype==="string"?T.fromUint8ToStringArray(m):m,[x,w]=o(u.shape,l.shape,g,y,p),C=c.makeTensorInfo(w,p),I=c.texData.get(C.dataId);return I.values=x,C}let d=j().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,f;return d?f=new Rs(t,u.shape,l.shape,e):f=new is(r,u.shape,l.shape),c.runWebGLProgram(f,[u,l],p)}}function Xc(r,t=!1){if(r==="linear")return t?Aee:Tee;if(r==="relu")return t?Oee:Eee;if(r==="elu")return t?Ree:_ee;if(r==="relu6")return t?Mee:kee;if(r==="prelu")return t?c$:l$;if(r==="leakyrelu")return t?u$:a$;if(r==="sigmoid")return t?Fee:Nee;throw new Error(`Activation ${r} has not been implemented for the WebGL backend.`)}var nx=class{constructor(t,e,n,o=!1,s=!1,i=!1,a=null,u=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=ir(this.outputShape.length);let c=o?t[1]:t[2],p=Math.ceil(c/2),d=o?"i * 2, rc.y":"rc.y, i * 2",f=s?"rc.z, i * 2":"i * 2, rc.z",h=o?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],g="",y="";a&&(u?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:l?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:g=`vec4 activation(vec4 x) {
          ${a}
        }`,y="result = activation(result);");let x=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let w="rc.x",C="rc.x";t[0]<e[0]?w=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&(C=`imod(rc.x, ${e[0]})`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${w};
        int batchB = ${C};
        for (int i = 0; i < ${p}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${f});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${h[0]} * ${m[0]});
          result += (${h[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${x}

        ${y}

        setOutput(result);
      }
    `}};var p$={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},nw=class{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=T.assertAndGetBroadcastShape(e,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var Vee="return a * b;";function ow(r){let{inputs:t,backend:e}=r,{a:n,b:o}=t,s=T.upcastType(n.dtype,o.dtype);if(n.dtype==="complex64"){let a=e.texData.get(n.dataId),u=e.texData.get(o.dataId),l=new nw(p$.REAL,n.shape,o.shape),c=new nw(p$.IMAG,n.shape,o.shape),p=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:n.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:n.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:o.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:o.shape}],d=e.runWebGLProgram(l,p,"float32"),f=e.runWebGLProgram(c,p,"float32"),h=as({inputs:{real:d,imag:f},backend:e});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(f),h}if(e.shouldExecuteOnCPU([n,o])){let a=e.texData.get(n.dataId),u=e.texData.get(o.dataId),[l,c]=ZJ(n.shape,o.shape,a.values,u.values,s),p=e.makeTensorInfo(c,s),d=e.texData.get(p.dataId);return d.values=l,p}let i;return j().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Rs(Vee,n.shape,o.shape):i=new is(Vee,n.shape,o.shape),e.runWebGLProgram(i,[n,o],s)}var Uee={kernelName:Ta,backendName:"webgl",kernelFunc:ow};function Gee(r,t,e){let n=[of(r.shape),...sf(r.shape)],o={dtype:r.dtype,shape:n,dataId:r.dataId},s=[of(t),...sf(t)],i=new tx(s,n),a=!0,u=[n],l=e.runWebGLProgram(i,[o],r.dtype,u,a);return{dataId:l.dataId,shape:t,dtype:l.dtype}}function ve(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{shape:s}=n,i=e,a=b.sizeFromShape(o.shape),u=b.inferFromImplicitShape(s,a),l=b.sizeFromShape(u);b.assert(a===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${o.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);let c=i.texData.get(o.dataId);return c.isPacked&&!Xh(o.shape,u)&&!(c.texture!==null&&Xh(c.shape,u))?Gee(o,u,i):(i.incRef(o.dataId),{dataId:o.dataId,shape:u,dtype:o.dtype})}var Wee={kernelName:fl,backendName:"webgl",kernelFunc:ve};var sw=class{constructor(t,e){this.variableNames=["x"];let{windowSize:n,batchSize:o,inSize:s,outSize:i}=t;this.outputShape=[o,i];let a=Math.floor(n/4)*4,u=n%4,l="sumValue += dot(values, ones);";if(e!=null){let p=1/e;l=`sumValue += dot(values * ${b.isInt(p)?p.toPrecision(2):p}, ones);`}let c="";s%n>0&&(c=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${a};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}};var eE=class{constructor(t,e){this.variableNames=["x"];let{windowSize:n,batchSize:o,inSize:s,outSize:i}=t;this.outputShape=[o,i];let a="0.0",u="";e==="prod"?a="1.0":e==="min"?(a="1.0 / 1e-20",u="min"):e==="max"&&(a="-1.0 / 1e-20",u="max");let l=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?l="sumValue":e==="prod"?l="prodValue":e==="all"?l="allValue":e==="any"&&(l="anyValue");let c=Math.floor(n/4)*4,p=n%4,d=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${e==="min"} || ${e==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,f="vec4";e==="all"?(a="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,f="bvec4"):e==="any"&&(a="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,f="bvec4");let h="";s%n>0&&(h=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${p===2}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${p===3}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${l});
      }
    `}};function iOe(r){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let e=t.length?t[t.length-1].outSize:r[1],n=T.computeOptimalWindowSize(e);t.push({inSize:e,windowSize:n,outSize:Math.ceil(e/n)})}return t}function Ms(r,t,e,n){let o=iOe(r.shape),s=r;for(let i=0;i<o.length;i++){let{inSize:a,windowSize:u,outSize:l}=o[i],c,p;e==="mean"?c=i===0?new sw({windowSize:u,inSize:a,batchSize:r.shape[0],outSize:l},a):new sw({windowSize:u,inSize:a,batchSize:r.shape[0],outSize:l}):c=new eE({windowSize:u,inSize:a,batchSize:r.shape[0],outSize:l},e),p=s,s=n.runWebGLProgram(c,[s],t),p.dataId!==r.dataId&&n.disposeIntermediateTensorInfo(p)}return s}var tE=class{constructor(t,e){this.variableNames=["A"];let n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[e[i]];this.outputShape=n,this.rank=n.length;let o=ut(this.rank),s=aOe(e);this.userCode=`
    void main() {
      ${o} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function aOe(r){let t=r.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],n=new Array(t);for(let o=0;o<r.length;o++)n[r[o]]=e[o];return n.join()}var rE=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(t.length);for(let c=0;c<n.length;c++)n[c]=t[e[c]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let o=ut(this.rank),s=s$("rc",this.rank),i=new Array(this.rank);for(let c=0;c<e.length;c++)i[e[c]]=s[c];let a=`vec2(${i.slice(-2).join()})`,u=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${o} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${u}) {
        result[1] = ${l};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${l};
        if(${u}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function af(r,t,e){let n=j().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new rE(r.shape,t):new tE(r.shape,t);return e.runWebGLProgram(n,[r],r.dtype)}function jee(r,t,e,n){let o=t,s=r.shape.length,i=b.parseAxisParam(o,r.shape),a=i,u=T.getAxesPermutation(a,s),l=u!=null,c=r;l&&(c=af(r,u,n),a=T.getInnerMostAxes(a.length,s)),T.assertAxesAreInnerMostDims("sum",a,s);let[p,d]=T.computeOutAndReduceShapes(c.shape,a),f=p;e&&(f=T.expandShapeToKeepDim(p,i));let h=b.sizeFromShape(d),g=b.sizeFromShape(r.shape)/h,y=ve({inputs:{x:c},attrs:{shape:[g,h]},backend:n}),x=_c(r.dtype),w=Ms(y,x,"sum",n),C=ve({inputs:{x:w},attrs:{shape:f},backend:n});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(w),l&&n.disposeIntermediateTensorInfo(c),C}function Jh(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;return jee(o,s,i,e)}var Hee={kernelName:vl,backendName:"webgl",kernelFunc:Jh};function Pr(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{perm:s}=n,i=e,a=o.shape.length,u=new Array(a);for(let c=0;c<u.length;c++)u[c]=o.shape[s[c]];let l;if(i.shouldExecuteOnCPU([o])){let p=i.texData.get(o.dataId).values,d=Qh(p,o.shape,o.dtype,s,u);l=i.makeTensorInfo(u,o.dtype);let f=i.texData.get(l.dataId);f.values=d}else l=af(o,s,i);return l}var qee={kernelName:mi,backendName:"webgl",kernelFunc:Pr};var d$=1e3;function em({a:r,b:t,transposeA:e,transposeB:n,backend:o,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:u=null}){let l=r.shape.length,c=t.shape.length,p=e?r.shape[l-2]:r.shape[l-1],d=n?t.shape[c-1]:t.shape[c-2],f=e?r.shape[l-1]:r.shape[l-2],h=n?t.shape[c-2]:t.shape[c-1],m=r.shape.slice(0,-2),g=t.shape.slice(0,-2),y=b.sizeFromShape(m),x=b.sizeFromShape(g),C=Fo.assertAndGetBroadcastShape(r.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,h]);b.assert(p===d,()=>`Error in matMul: inner shapes (${p}) and (${d}) of Tensors with shapes ${r.shape} and ${t.shape} and transposeA=${e} and transposeB=${n} must match.`);let I=e?[y,p,f]:[y,f,p],N=n?[x,h,d]:[x,d,h],A=ve({inputs:{x:r},backend:o,attrs:{shape:I}}),O=ve({inputs:{x:t},backend:o,attrs:{shape:N}}),$=[A,O],z=Math.max(y,x),G=e?A.shape[1]:A.shape[2],K=s!=null,Z=i!=null,Q=u==="leakyrelu",J=u!=null?Xc(u,!0):null,te=K||Z||Q||J!=null,ie;if((f===1||h===1)&&G>d$&&te===!1){let ae=A,ye=O;e&&(ae=Pr({inputs:{x:A},backend:o,attrs:{perm:[0,2,1]}}),$.push(ae)),n&&(ye=Pr({inputs:{x:O},backend:o,attrs:{perm:[0,2,1]}}),$.push(ye));let ge=h!==1,Se=h===1,be=ae;ge&&(be=ve({inputs:{x:ae},backend:o,attrs:{shape:[z,G,1]}}),$.push(be));let ke=h===1?2:1,Te=ye;Se&&(Te=ve({inputs:{x:ye},backend:o,attrs:{shape:[z,1,G]}}),$.push(Te));let Oe=ow({inputs:{a:be,b:Te},backend:o});ie=Jh({inputs:{x:Oe},backend:o,attrs:{axis:ke,keepDims:!0}}),$.push(Oe)}else{let ae=mr(r.dtype,t.dtype),ye=new nx(I,N,[z,f,h],e,n,K,J,Z,Q),ge=[A,O];if(s!=null&&ge.push(s),Z&&ge.push(i),Q){let Se=o.makeTensorInfo([],"float32",b.createScalarValue(a,"float32"));ge.push(Se),$.push(Se)}ie=o.runWebGLProgram(ye,ge,ae)}let ne=ve({inputs:{x:ie},backend:o,attrs:{shape:C}});$.push(ie);for(let ae of $)o.disposeIntermediateTensorInfo(ae);return ne}function uOe(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s,bias:i,preluActivationWeights:a}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:p}=n;return em({a:o,b:s,transposeA:u,transposeB:l,backend:e,bias:i,preluActivationWeights:a,leakyreluAlpha:p,activation:c})}var Kee={kernelName:Cc,backendName:"webgl",kernelFunc:uOe};var Xee="return abs(x);";function lOe(r){let{inputs:t,backend:e}=r,{x:n}=t;if(e.shouldExecuteOnCPU([n])&&n.dtype!=="complex64"){let s=e.texData.get(n.dataId),i=K1(s.values);return e.makeTensorInfo(n.shape,n.dtype,i)}let o;return j().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new ss(n.shape,Xee):o=new no(n.shape,Xee),e.runWebGLProgram(o,[n],n.dtype)}var Yee={kernelName:Ou,backendName:"webgl",kernelFunc:lOe};var cOe=kn+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,pOe=Ve({opSnippet:cOe}),Zee={kernelName:Qi,backendName:"webgl",kernelFunc:pOe};var dOe=kn+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,fOe=Ve({opSnippet:dOe}),Qee={kernelName:Ji,backendName:"webgl",kernelFunc:fOe};var Jee="return a + b;",hOe=Zt({opSnippet:Jee,packedOpSnippet:Jee,supportsComplex:!0,cpuKernelImpl:DJ}),ete={kernelName:js,backendName:"webgl",kernelFunc:hOe};var nE=class{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((s,i)=>`T${i}`);let n=[];this.variableNames.forEach(s=>{n.push(`float v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${o};
        setOutput(result);
      }
    `}};var oE=class{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((s,i)=>`T${i}`);let n=[];this.variableNames.forEach(s=>{n.push(`vec4 v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${o};
        setOutput(result);
      }
    `}};function sE(r){let{inputs:t,backend:e}=r,n=t;if(n.length===1)return ln({inputs:{x:n[0]},backend:e});if(n.length>j().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let u=Math.floor(n.length/2),l=sE({inputs:n.slice(0,u),backend:e}),c=sE({inputs:n.slice(u),backend:e});return sE({inputs:[l,c],backend:e})}let o=n.map(u=>u.dtype).reduce((u,l)=>mr(u,l)),s=n.map(u=>u.shape),a=j().getBool("WEBGL_PACK")?new oE(n[0].shape,s):new nE(n[0].shape,s);return e.runWebGLProgram(a,n,o)}var tte={kernelName:Mu,backendName:"webgl",kernelFunc:sE};function mOe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=o.shape.length,u=b.parseAxisParam(s,o.shape),l=u,c=T.getAxesPermutation(l,a),p=o;c!=null&&(p=Pr({inputs:{x:o},backend:e,attrs:{perm:c}}),l=T.getInnerMostAxes(l.length,a)),T.assertAxesAreInnerMostDims("all",l,a);let[d,f]=T.computeOutAndReduceShapes(p.shape,l),h=b.sizeFromShape(f),m=ve({inputs:{x:p},backend:e,attrs:{shape:[-1,h]}}),g=Ms(m,m.dtype,"all",e),y;if(i){let x=T.expandShapeToKeepDim(d,u);y=ve({inputs:{x:g},backend:e,attrs:{shape:x}})}else y=ve({inputs:{x:g},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),c!=null&&e.disposeIntermediateTensorInfo(p),y}var rte={kernelName:Ep,backendName:"webgl",kernelFunc:mOe};function gOe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=o.shape.length,u=b.parseAxisParam(s,o.shape),l=u,c=T.getAxesPermutation(l,a),p=o;c!=null&&(p=Pr({inputs:{x:o},backend:e,attrs:{perm:c}}),l=T.getInnerMostAxes(l.length,a)),T.assertAxesAreInnerMostDims("any",l,a);let[d,f]=T.computeOutAndReduceShapes(p.shape,l),h=b.sizeFromShape(f),m=ve({inputs:{x:p},backend:e,attrs:{shape:[-1,h]}}),g=Ms(m,m.dtype,"any",e),y;if(i){let x=T.expandShapeToKeepDim(d,u);y=ve({inputs:{x:g},backend:e,attrs:{shape:x}})}else y=ve({inputs:{x:g},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),c!=null&&e.disposeIntermediateTensorInfo(p),y}var nte={kernelName:kp,backendName:"webgl",kernelFunc:gOe};var iE=class{constructor(t,e,n){this.variableNames=["A"];let{windowSize:o,batchSize:s,outSize:i}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,i];let a=e==="max"?">":"<",u=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${o}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};var aE=class{constructor(t,e,n,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,b.assert(t.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let s=t[t.length-1],i=Math.ceil(s/e);this.outputShape=t.slice(0,-1),i>1&&this.outputShape.push(i),o||this.variableNames.push("bestIndicesA");let a=this.outputShape,u=a.length,l=ut(u),c=un("coords",u),p,d;if(i===1){d=u+1;let O=ut(d);p=`
        ${O} sourceLocR = ${O}(${c.join()}, 0);
        ++${c[u-1]};
        ${O} sourceLocG = ${O}(${c.join()}, 0);
        ++${c[u-2]};
        ${O} sourceLocA = ${O}(${c.join()}, 0);
        --${c[u-1]};
        ${O} sourceLocB = ${O}(${c.join()}, 0);
        --${c[u-2]};`}else d=u,p=`
        ${l} sourceLocR = coords;
        ++${c[u-1]};
        ${l} sourceLocG = coords;
        ++${c[u-2]};
        ${l} sourceLocA = coords;
        --${c[u-1]};
        ${l} sourceLocB = coords;
        --${c[u-2]};`;let f=["x","y","z","w","u","v"].slice(0,d),h="."+f[d-1],m=f.map(O=>"int "+O),g=un("sourceLocR",d-1).concat("inIdx.r"),y=un("sourceLocG",d-1).concat("inIdx.g"),x=un("sourceLocB",d-1).concat("inIdx.b"),w=un("sourceLocA",d-1).concat("inIdx.a"),C=n==="max"?"greaterThan":"lessThan",I=o?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${w.join()})));`,N=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${x.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${w.join()}) : 0.)`,A=o?"":`
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${f.join()}),
                                          vec2(${f.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${m.join()}) {
        return getChannel(getA(${f.join()}),
                               vec2(${f.slice(-2).join()}));
      }
      ${A}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${c[u-1]} < ${a[u-1]-1};
        bool hasNextRow = ${c[u-2]} < ${a[u-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${h}, sourceLocG${h},
          sourceLocB${h}, sourceLocA${h}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${N};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${I}
          vec4 candidate = ${N};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${C}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function ote(r,t,e,n=null){let o=t.shape[0],s=t.shape[1];n!=null&&(o=n.shape[0],s=n.shape[1]);let i=T.computeOptimalWindowSize(s),a={windowSize:i,inSize:s,batchSize:o,outSize:Math.ceil(s/i)},u=new iE(a,e,n==null),l=[t];n!=null&&l.push(n);let c=r.runWebGLProgram(u,l,"int32");if(c.shape[1]===1)return c;let p=ote(r,t,e,c);return r.disposeIntermediateTensorInfo(c),p}function ste(r,t,e,n=null){let o=n!=null?n.shape:t.shape,s=o[o.length-1],i=T.computeOptimalWindowSize(s),a=new aE(o,i,e,n==null),u=n==null?[t]:[t,n],l=r.runWebGLProgram(a,u,"int32");if(l.shape.length===t.shape.length){let c=ste(r,t,e,l);return r.disposeIntermediateTensorInfo(l),c}return l}function uE(r,t,e,n){let o=[e];if(T.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),o,t.shape.length),!j().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let s=[],i=r.texData.get(t.dataId),a=i!==null&&i.isPacked,u=t;a&&(u=r.unpackTensor(t),s.push(u));let[l,c]=T.computeOutAndReduceShapes(u.shape,o),p=b.sizeFromShape(c),d=ve({inputs:{x:u},backend:r,attrs:{shape:[-1,p]}});s.push(d);let f=ote(r,d,n);s.push(f);let h=ve({inputs:{x:f},backend:r,attrs:{shape:l}});return s.forEach(m=>r.disposeIntermediateTensorInfo(m)),h}return ste(r,t,n)}function yOe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n,i=b.parseAxisParam(s,o.shape),a=T.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=Pr({inputs:{x:o},backend:e,attrs:{perm:a}}),l.push(u),i=T.getInnerMostAxes(i.length,u.shape.length)),T.assertAxesAreInnerMostDims("argMax",[i[0]],u.shape.length);let c=uE(e,u,i[0],"max");return l.forEach(p=>e.disposeIntermediateTensorInfo(p)),c}var ite={kernelName:Fu,backendName:"webgl",kernelFunc:yOe};function xOe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n,i=b.parseAxisParam(s,o.shape),a=T.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=Pr({inputs:{x:o},backend:e,attrs:{perm:a}}),l.push(u),i=T.getInnerMostAxes(i.length,u.shape.length)),T.assertAxesAreInnerMostDims("argMin",[i[0]],u.shape.length);let c=uE(e,u,i[0],"min");return l.forEach(p=>e.disposeIntermediateTensorInfo(p)),c}var ate={kernelName:$u,backendName:"webgl",kernelFunc:xOe};var vOe=kn+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,bOe=Ve({opSnippet:vOe}),ute={kernelName:ea,backendName:"webgl",kernelFunc:bOe};var wOe=kn+"return log(x + sqrt(x * x + 1.0));",COe=Ve({opSnippet:wOe}),lte={kernelName:ta,backendName:"webgl",kernelFunc:COe};var SOe=kn+`
  return atan(x);
`,IOe=Ve({opSnippet:SOe}),cte={kernelName:ra,backendName:"webgl",kernelFunc:IOe};var TOe=rx+`
  return atan(a, b);
`,_Oe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Os+`
  return result;
`,EOe=Zt({opSnippet:TOe,packedOpSnippet:_Oe}),pte={kernelName:oa,backendName:"webgl",kernelFunc:EOe};var kOe=kn+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,NOe=Ve({opSnippet:kOe}),dte={kernelName:na,backendName:"webgl",kernelFunc:NOe};var lu=class{constructor(t,e,n,o=!1,s=!1){if(this.variableNames=["x"],e==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let i=t.filterWidth,a=t.strideHeight,u=t.strideWidth,l=t.dilationHeight,c=t.dilationWidth,p=t.effectiveFilterHeight,d=t.effectiveFilterWidth,f=t.padInfo.top,h=t.padInfo.left;this.outputShape=t.outShape;let m=e==="avg",g=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,y=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`,x="0.0";if(m||(x="-1.0 / 1e-20"),n){let O=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${u});
        const ivec2 pads = ivec2(${f}, ${h});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${O} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${o?s?g:y:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let w="max",C=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(C="avgValue / max(count, 1.0)");let I=Math.floor(i/4)*4,N=i%4,A=`
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${u});
      const ivec2 pads = ivec2(${f}, ${h});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${I}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${A}
          }

          int xC = xCCorner + ${I};
          if (${N===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${A}
          } else if (${N===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${A}
          } else if (${N===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${A}
          }
        }
        setOutput(${C});
      }
    `}},uf=class{constructor(t,e,n,o=!1,s=!1){if(this.variableNames=["x"],e==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let i=t.filterWidth,a=t.strideDepth,u=t.strideHeight,l=t.strideWidth,c=t.dilationDepth,p=t.dilationHeight,d=t.dilationWidth,f=t.effectiveFilterDepth,h=t.effectiveFilterHeight,m=t.effectiveFilterWidth,g=t.padInfo.front,y=t.padInfo.top,x=t.padInfo.left;this.outputShape=t.outShape;let w=e==="avg",C="0.0";if(w||(C="-1.0 / 1e-20"),n){let z=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${u}, ${l});
        const ivec3 pads = ivec3(${g}, ${y}, ${x});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${f};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${h};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${z} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${o?s?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${h} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let I="max",N=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(N="avgValue / max(count, 1.0)");let A=Math.floor(i/4)*4,O=i%4,$=`
      if (${w}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${I}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${u}, ${l});
      const ivec3 pads = ivec3(${g}, ${y}, ${x});
      const float initializationValue = ${C};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${C});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${A}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${$}
            }

            int xC = xCCorner + ${A};
            if (${O===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${$}
            } else if (${O===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${$}
            } else if (${O===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${$}
            }
          }
        }
        setOutput(${N});
      }
    `}};function DOe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;ql(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;b.assert(T.eitherStridesOrDilationsAreOne(i,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let c=T.computePool2DInfo(o.shape,s,i,l,a,u);if(c.filterWidth===1&&c.filterHeight===1&&b.arraysEqual(c.inShape,c.outShape))return ln({inputs:{x:o},backend:e});let p=new lu(c,"avg",!1);return e.runWebGLProgram(p,[o],"float32")}var fte={kernelName:Pu,backendName:"webgl",kernelFunc:DOe};function AOe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=n,c=[1,1,1],p=T.computePool3DInfo(o.shape,s,i,c,a,u,l),d=new uf(p,"avg",!1);return e.runWebGLProgram(d,[o],"float32")}var hte={kernelName:Lu,backendName:"webgl",kernelFunc:AOe};var lE=class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let e=t.filterHeight,n=t.filterWidth,o=t.strideHeight,s=t.strideWidth,i=t.dilationHeight,a=t.dilationWidth,u=t.effectiveFilterHeight,l=t.effectiveFilterWidth,c=u-1-t.padInfo.top,p=l-1-t.padInfo.left,d=1/(e*n);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${p});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},cE=class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let e=t.filterDepth,n=t.filterHeight,o=t.filterWidth,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,u=t.dilationDepth,l=t.dilationHeight,c=t.dilationWidth,p=t.effectiveFilterDepth,d=t.effectiveFilterHeight,f=t.effectiveFilterWidth,h=p-1-t.padInfo.front,m=d-1-t.padInfo.top,g=f-1-t.padInfo.left,y=1/(e*n*o);this.userCode=`
      const ivec3 pads = ivec3(${h}, ${m}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function ROe(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,i=s,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=n,p=[1,1,1],d=T.computePool3DInfo(i.shape,a,u,p,l,c),f=new cE(d);return e.runWebGLProgram(f,[o],i.dtype)}var mte={kernelName:Dp,backendName:"webgl",kernelFunc:ROe};function OOe(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,i=s;ql([o,s],"avgPoolGrad");let{filterSize:a,strides:u,pad:l}=n,c=T.computePool2DInfo(i.shape,a,u,1,l),p=new lE(c);return e.runWebGLProgram(p,[o],i.dtype)}var gte={kernelName:Np,backendName:"webgl",kernelFunc:OOe};function MOe(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s}=t,{transposeA:i,transposeB:a}=n;return em({a:o,b:s,transposeA:i,transposeB:a,backend:e})}var yte={kernelName:zu,backendName:"webgl",kernelFunc:MOe};var pE=class{constructor(t,e,n,o,s,i){this.outputShape=[],this.variableNames=["x","mean","variance"],T.assertAndGetBroadcastShape(t,e),T.assertAndGetBroadcastShape(t,n);let a="0.0";o!=null&&(T.assertAndGetBroadcastShape(t,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="1.0";s!=null&&(T.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};var dE=class{constructor(t,e,n,o,s,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],T.assertAndGetBroadcastShape(t,e),T.assertAndGetBroadcastShape(t,n);let a="vec4(0.0)";o!=null&&(T.assertAndGetBroadcastShape(t,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="vec4(1.0)";s!=null&&(T.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}};var FOe=({inputs:r,backend:t,attrs:e})=>{let{x:n,mean:o,variance:s,offset:i,scale:a}=r;b.assert(o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),b.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),b.assert(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=e;u==null&&(u=.001);let l=[n,o,s],c=null;i!=null&&(c=i.shape,l.push(i));let p=null;a!=null&&(p=a.shape,l.push(a));let d=j().getBool("WEBGL_PACK_NORMALIZATION")?new dE(n.shape,o.shape,s.shape,c,p,u):new pE(n.shape,o.shape,s.shape,c,p,u);return t.runWebGLProgram(d,l,l[0].dtype)},xte={kernelName:Yu,backendName:"webgl",kernelFunc:FOe};var fE=class{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;let e=ut(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=$Oe(this.rank),o,s=t.map((i,a)=>`sourceLoc.${f$[a]} = start[${a}] + coords.${f$[a]};`);o=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${o}
        setOutput(getSource(${n}));
      }
    `}},f$=["x","y","z","w","u","v"];function $Oe(r){if(r===1)return"sourceLoc";if(r<=6)return f$.slice(0,r).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}var hE=class{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let e=ut(this.rank),n=un("coords",this.rank),o=un("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${o.slice(-2).join()})`,i=`getChannel(getSource(${o.join()}), ${s})`,a=`
      result.x = ${i};
      if (++${n[this.rank-1]} < ${t[this.rank-1]}) {
        ++${o[this.rank-1]};
        result.y = ${i};
        --${o[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${t[this.rank-2]}) {
        ++${o[this.rank-2]};
        result.z = ${i};
        if (++${n[this.rank-1]} < ${t[this.rank-1]}) {
          ++${o[this.rank-1]};
          result.w = ${i};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${e}(${t.map((c,p)=>`start[${p}]`).join()});`:t.map((c,p)=>`${o[p]} = ${n[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${a}
        ${u}
        setOutput(result);
      }
    `}};function POe(r,t,e,n){let o=n.texData.get(r.dataId),s=n.makeTensorInfo(e,r.dtype),i=n.texData.get(s.dataId);Object.assign(i,o),i.refCount=1,i.shape=e,i.dtype=r.dtype;let a=en.computeFlatOffset(t,b.computeStrides(r.shape));o.slice&&(a+=o.slice.flatOffset),i.slice={flatOffset:a,origDataId:o.slice&&o.slice.origDataId||r.dataId};let u=n.dataRefCount.get(i.slice.origDataId)||1;return n.dataRefCount.set(i.slice.origDataId,u+1),s}function cu(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,size:i}=n,[a,u]=en.parseSliceParams(o,s,i);if(en.assertParamsValid(o,a,u),b.sizeFromShape(u)===0)return e.makeTensorInfo(u,o.dtype,[]);if(e.shouldExecuteOnCPU([o])||o.dtype==="string"){let p=e.texData.get(o.dataId),d=uee(p.values,a,u,o.shape,o.dtype);return e.makeTensorInfo(u,o.dtype,d)}let{isPacked:l}=e.texData.get(o.dataId),c=en.isSliceContinous(o.shape,a,u);if(l||!c){let p=j().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new hE(u):new fE(u),d=[a];return e.runWebGLProgram(p,[o],o.dtype,d)}return e.uploadToGPU(o.dataId),POe(o,a,u,e)}var vte={kernelName:xl,backendName:"webgl",kernelFunc:cu};var LOe=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,crops:i}=n;b.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((x,w)=>x*w),u=T.getReshaped(o.shape,s,a),l=T.getPermuted(u.length,s.length),c=T.getReshapedPermuted(o.shape,s,a),p=T.getSliceBeginCoords(i,s.length),d=T.getSliceSize(c,i,s.length),f=[],h=ve({inputs:{x:o},backend:e,attrs:{shape:u}}),m=Pr({inputs:{x:h},backend:e,attrs:{perm:l}}),g=ve({inputs:{x:m},backend:e,attrs:{shape:c}}),y=cu({inputs:{x:g},backend:e,attrs:{begin:p,size:d}});return f.push(h),f.push(m),f.push(g),f.forEach(x=>e.disposeIntermediateTensorInfo(x)),y},bte={kernelName:Bu,backendName:"webgl",kernelFunc:LOe};function zOe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:i}=n,a=e.readSync(o.dataId),u=e.readSync(s.dataId),l=q1(a,u,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,l)}var wte={kernelName:Ap,backendName:"webgl",kernelFunc:zOe};var BOe=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,VOe=`
  return float(int(a.r) & int(b.r));
`;function UOe(r){let{inputs:t,backend:e}=r,{a:n,b:o}=t,s=j().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=j().getNumber("WEBGL_VERSION");if(e.shouldExecuteOnCPU([n,o])||i===1){let u=e.texData.get(n.dataId).values,l=e.texData.get(o.dataId).values,[c,p]=RJ(n.shape,o.shape,u,l,n.dtype),d=e.makeTensorInfo(p,n.dtype),f=e.texData.get(d.dataId);return f.values=c,d}let a;return s?a=new Rs(BOe,n.shape,o.shape,!1):a=new is(VOe,n.shape,o.shape),e.runWebGLProgram(a,[n,o],n.dtype)}var Cte={kernelName:Qf,backendName:"webgl",kernelFunc:UOe};function GOe(r){let{inputs:t,backend:e}=r,{s0:n,s1:o}=t,s=e.readSync(n.dataId),i=e.readSync(o.dataId),a=T.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var Ste={kernelName:Rp,backendName:"webgl",kernelFunc:GOe};var WOe="return float(a != b);",h$=Zt({opSnippet:WOe,cpuKernelImpl:JJ,dtype:"bool"}),Ite={kernelName:wc,backendName:"webgl",kernelFunc:h$};function Yc(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.texData.get(n.dataId);return ln({inputs:{x:o.complexTensorInfos.real},backend:e})}var Tte={kernelName:ad,backendName:"webgl",kernelFunc:Yc};var jOe="return float(int(x));";function _te(r,t){let e=new no(r.shape,jOe),n=t.runWebGLProgram(e,[r],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}function m$(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return ln({inputs:{x:o},backend:e});let i=er(o.shape),a=m$({inputs:{x:o},backend:e,attrs:{dtype:"float32"}}),u=as({inputs:{real:a,imag:i},backend:e});return i.dispose(),e.disposeIntermediateTensorInfo(a),u}if(o.dtype==="complex64"){let i=Yc({inputs:{input:o},backend:e}),a=m$({inputs:{x:i},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(i),a}if(!b.hasEncodingLoss(o.dtype,s)){let i=ln({inputs:{x:o},backend:e});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(e.shouldExecuteOnCPU([o])){let i=e.texData.get(o.dataId).values,[a,u,l]=OJ(i,o.shape,o.dtype,s);return e.makeTensorInfo(a,u,l)}if(s==="int32")return _te(o,e);if(s==="bool"){let i=e.makeTensorInfo([],"bool",b.getTypedArrayFromDType("bool",1)),u=h$({inputs:{a:o,b:i},backend:e});return e.disposeIntermediateTensorInfo(i),u}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var Ete={kernelName:di,backendName:"webgl",kernelFunc:m$};var kte="return ceil(x);",HOe=Ve({opSnippet:kte,packedOpSnippet:kte,cpuKernelImpl:MJ}),Nte={kernelName:sa,backendName:"webgl",kernelFunc:HOe};var mE=class{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};var gE=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function qOe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{clipValueMin:s,clipValueMax:i}=n,a;j().getBool("WEBGL_PACK_CLIP")?a=new gE(o.shape):a=new mE(o.shape);let u=[[s],[i]];return e.runWebGLProgram(a,[o],o.dtype,u)}var Dte={kernelName:ia,backendName:"webgl",kernelFunc:qOe};var yE=class{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function Ate(r,t){return{dataId:t.dataId,dtype:t.dtype,shape:r.shape}}function KOe(r){let{inputs:t,backend:e}=r,{x:n}=t,o=e.texData.get(n.dataId),s=new yE(n.shape),i=[Ate(n,o.complexTensorInfos.real),Ate(n,o.complexTensorInfos.imag)];return e.runWebGLProgram(s,i,i[0].dtype)}var Rte={kernelName:Vu,backendName:"webgl",kernelFunc:KOe};var xE=class{constructor(t){this.outputShape=[],this.outputShape=T.computeOutShape(t,1),this.variableNames=t.map((i,a)=>`T${a}`);let e=new Array(t.length-1);e[0]=t[0][1];for(let i=1;i<e.length;i++)e[i]=e[i-1]+t[i][1];let n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<e.length;i++){let a=e[i-1];n.push(`else if (yC < ${e[i]}) setOutput(getT${i}(yR, yC-${a}));`)}let o=e.length,s=e[e.length-1];n.push(`else setOutput(getT${o}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}};var bE=class{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=T.computeOutShape(t,e);let n=this.outputShape,o=n.length,s=ut(o),i=un("coords",o),a=["x","y","z","w","u","v"].slice(0,o);this.variableNames=t.map((m,g)=>`T${g}`);let u=new Array(t.length-1);u[0]=t[0][e];for(let m=1;m<u.length;m++)u[m]=u[m-1]+t[m][e];let l=a[e],c=a.slice(-2),p=a.join(),d=`if (${l} < ${u[0]}) {
        return getChannel(
            getT0(${p}), vec2(${c.join()}));
        }`;for(let m=1;m<u.length;m++){let g=u[m-1];d+=`
        if (${l} < ${u[m]}  && ${l} >= ${u[m-1]}) {
          return getChannel(
            getT${m}(${vE(a,l,g)}),
            vec2(${vE(c,l,g)}));
        }`}let f=u.length,h=u[u.length-1];d+=`
        return getChannel(
          getT${f}(${vE(a,l,h)}),
          vec2(${vE(c,l,h)}));`,this.userCode=`
      float getValue(${a.map(m=>"int "+m)}) {
        ${d}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[o-1]} = ${i[o-1]} + 1;
        if (${i[o-1]} < ${n[o-1]}) {
          result.g = getValue(${i});
        }

        ${i[o-2]} = ${i[o-2]} + 1;
        if (${i[o-2]} < ${n[o-2]}) {
          result.a = getValue(${i});
        }

        ${i[o-1]} = ${i[o-1]} - 1;
        if (${i[o-2]} < ${n[o-2]} &&
            ${i[o-1]} < ${n[o-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}};function vE(r,t,e){let n=r.indexOf(t);return r.map((s,i)=>i===n?`${s} - ${e}`:s).join()}function tm(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.texData.get(n.dataId);return ln({inputs:{x:o.complexTensorInfos.imag},backend:e})}var Ote={kernelName:Zp,backendName:"webgl",kernelFunc:tm};function ox(r,t,e){let n=r[0].dtype;if(n==="complex64"){let f=r.map(x=>Yc({inputs:{input:x},backend:e})),h=r.map(x=>tm({inputs:{input:x},backend:e})),m=ox(f,t,e),g=ox(h,t,e),y=as({inputs:{real:m,imag:g},backend:e});return f.forEach(x=>e.disposeIntermediateTensorInfo(x)),h.forEach(x=>e.disposeIntermediateTensorInfo(x)),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),y}let o=e.shouldExecuteOnCPU(r);if(n==="string"&&(o=!0),o){let f=r.map(C=>{let N=[-1,b.sizeFromShape(C.shape.slice(t))];return ve({inputs:{x:C},backend:e,attrs:{shape:N}})}),h=f.map(C=>({vals:e.readSync(C.dataId),shape:C.shape})),m=T.computeOutShape(f.map(C=>C.shape),1),g=f[0].shape[0]===1,y=FJ(h,m,n,g),x=T.computeOutShape(r.map(C=>C.shape),t),w=e.makeTensorInfo(x,n,y);return f.forEach(C=>e.disposeIntermediateTensorInfo(C)),w}let s=r.filter(f=>b.sizeFromShape(f.shape)>0),i=j().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){let f=i?new no(r[0].shape,Kl):new ss(r[0].shape,Kl);return e.runWebGLProgram(f,r,n)}let a=j().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>a){let f=[];for(let m=0;m<s.length;m+=a){let g=s.slice(m,m+a);f.push(ox(g,t,e))}let h=ox(f,t,e);for(let m of f)e.disposeIntermediateTensorInfo(m);return h}if(i){let f=new bE(s.map(h=>h.shape),t);return e.runWebGLProgram(f,s,n)}let{tensors2D:u,outShape:l}=XOe(s,t,e),c=new xE(u.map(f=>f.shape)),p=e.runWebGLProgram(c,u,n);u.forEach(f=>e.disposeIntermediateTensorInfo(f));let d=ve({inputs:{x:p},attrs:{shape:l},backend:e});return e.disposeIntermediateTensorInfo(p),d}function XOe(r,t,e){let n=T.computeOutShape(r.map(s=>s.shape),t);return{tensors2D:r.map(s=>ve({inputs:{x:s},attrs:{shape:[-1,b.sizeFromShape(s.shape.slice(t))]},backend:e})),outShape:n}}function g$(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n,s=b.parseAxisParam(o,t[0].shape)[0],i=t.map(l=>l.shape);T.assertParamsConsistent(i,s);let a=T.computeOutShape(t.map(l=>l.shape),s);if(b.sizeFromShape(a)===0)return e.makeTensorInfo(a,t[0].dtype,[]);let u=t.filter(l=>b.sizeFromShape(l.shape)>0);return u.length===1?ln({inputs:{x:u[0]},backend:e}):ox(u,s,e)}var Mte={kernelName:Uu,backendName:"webgl",kernelFunc:g$};var sx=class{constructor(t,e=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;let i=t.padInfo.top,a=t.padInfo.left,u=t.strideHeight,l=t.strideWidth,c=t.dilationHeight,p=t.dilationWidth,d=t.filterHeight,f=t.filterWidth,h=Math.floor(t.inChannels/4)*4,m=t.inChannels%4,g=t.dataFormat==="channelsLast",y=g?1:2,x=g?2:3,w=g?3:1,C="",I="";n&&(o?C=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?C=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:C=`
          float activation(float x) {
            ${n}
          }
        `,I="result = activation(result);");let N=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${C}

      const ivec2 strides = ivec2(${u}, ${l});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${w}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${x}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${f}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${h}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${h}) *
                    getW(wR, wC, ${h}, d2);
              } else {
                dotProd +=
                    getX(batch, ${h}, xR, xC) *
                    getW(wR, wC, ${h}, d2);
              }

            } else if (${m===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2),
                getW(wR, wC, ${h} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1),
                  getX(batch, xR, xC, ${h} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC),
                  getX(batch, ${h} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${N}
        ${I}
        setOutput(result);
      }
    `}},wE=class{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let e=t.padInfo.front,n=t.padInfo.top,o=t.padInfo.left,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,u=t.dilationDepth,l=t.dilationHeight,c=t.dilationWidth,p=t.filterDepth,d=t.filterHeight,f=t.filterWidth,h=Math.floor(t.inChannels/4)*4,m=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${i}, ${a});
      const ivec3 pads = ivec3(${e}, ${n}, ${o});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${h}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${h}) *
                  getW(wF, wR, wC, ${h}, d2);
              } else if (${m===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1),
                  getX(batch, xF, xR, xC, ${h} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2),
                  getW(wF, wR, wC, ${h} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var ix=class{constructor(t,e=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ir(this.outputShape.length);let i=t.padInfo.left,a=t.strideWidth,u=t.dilationWidth,l=t.filterHeight,c=t.filterWidth,p=c,d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<c;g++)d+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;d+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let g=0;g<c;g++)d+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(p+1)/2;g++){let y=g*2;if(d+=`
           xC = xCCorner + ${y*u};
           `,a===1){if(y<c&&(i%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,u===1&&y>0?d+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<c)){let x=i%2===0?b.nearestLargerEven(u):u;u%2===0&&i%2===1||u%2!==0&&i%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${x};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,u>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:d+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):x===1?d+=`
                     xC${y+1} = xTexelC${y};
                     `:d+=`
                     xCOffset = xC + ${x};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<c&&(i%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<c&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<c&&(d+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<c&&(d+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<c&&(d+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let f="",h="";n&&(o?f=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:s?f=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:f=`vec4 activation(vec4 x) {
           ${n}
         }`,h="result = activation(result);");let m=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${f}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${m}
         ${h}
         setOutput(result);
       }
     `}};var CE=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=ir(this.outputShape.length);let{dataFormat:n}=e,o=Xr(),s=n==="channelsLast",i=s?1:2,a=s?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`,l="";for(let c=0;c<=1;c++)for(let p=0;p<=1;p++)l+=`
          blockIndex = rc.z + ${p};
          pos = rc.y + ${c};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+p}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+p}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${o.output} = result;
      }
    `}};function SE(r,t){let e=r.length;return e>=3?t?[...r.slice(0,-3),r[e-3]*r[e-2],r[e-1]]:[...r.slice(0,-3),r[e-3],r[e-2]*r[e-1]]:!t&&e===1&&r[0]>1?[r[0],1]:null}function IE({x:r,filter:t,convInfo:e,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let u=r.shape,l=n.texData.get(r.dataId),c=e.inChannels,p=u[0]*u[1]*u[2],d=e.outChannels,f=e.dataFormat==="channelsLast",h=!1,m=!1,g,y=[];if(s!=null){let C=SE(s.shape,f);C!=null&&(s=ve({inputs:{x:s},backend:n,attrs:{shape:C}}),y.push(s))}if(o!=null){let C=SE(o.shape,f);C!=null&&(o=ve({inputs:{x:o},backend:n,attrs:{shape:C}}),y.push(o))}if(!((p===1||d===1)&&c>d$)&&l.isPacked&&f&&l.texture!=null&&u[2]%2!==0&&b.arraysEqual(l.shape.slice(-3),u.slice(-3))){let C=u[0]*u[1]*(u[2]+1),I={dataId:r.dataId,shape:[1,C,e.inChannels],dtype:r.dtype},N=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,b.assert(Xh(l.shape,I.shape),()=>`packed reshape ${l.shape} to ${I.shape} isn't free`);let A=ve({inputs:{x:t},backend:n,attrs:{shape:[1,e.inChannels,e.outChannels]}});y.push(A);let O=em({a:I,b:A,backend:n,transposeA:h,transposeB:m,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i}),$=n.texData.get(O.dataId);b.assert($.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=N,$.shape=e.outShape,g=ln({inputs:{x:O},backend:n}),g.shape=e.outShape,y.push(O)}else{let C=e.outHeight*e.outWidth,I=ve({inputs:{x:r},backend:n,attrs:{shape:f?[e.batchSize,C,e.inChannels]:[e.batchSize,e.inChannels,C]}}),N=ve({inputs:{x:t},backend:n,attrs:{shape:[1,e.inChannels,e.outChannels]}}),A=em({a:f?I:N,b:f?N:I,transposeA:!f,transposeB:m,backend:n,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i});g=ve({inputs:{x:A},backend:n,attrs:{shape:e.outShape}}),y.push(I),y.push(N),y.push(A)}for(let C of y)n.disposeIntermediateTensorInfo(C);return g}function TE({x:r,filter:t,convInfo:e,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let{filterWidth:u,filterHeight:l,inChannels:c,outWidth:p,outHeight:d,dataFormat:f}=e,h=f==="channelsLast",m=u*l*c,g=d*p,y=[e.batchSize,m,g],x=!0,w=!1,C=[];if(s!=null){let ne=SE(s.shape,h);ne!=null&&(s=ve({inputs:{x:s},backend:n,attrs:{shape:ne}}),C.push(s))}if(o!=null){let ne=SE(o.shape,h);ne!=null&&(o=ve({inputs:{x:o},backend:n,attrs:{shape:ne}}),C.push(o))}let I=ve({inputs:{x:t},backend:n,attrs:{shape:[1,m,b.sizeFromShape(t.shape)/m]}});C.push(I);let N=new CE(y,e),A=[r.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]],O=n.runWebGLProgram(N,[r],"float32",A),$=ve({inputs:{x:O},backend:n,attrs:{shape:y}});C.push(O),C.push($);let z=o!=null,G=s!=null,K=a==="leakyrelu",Z=a?Xc(a,!0):null,Q=new nx(h?$.shape:I.shape,h?I.shape:$.shape,h?[e.batchSize,g,e.outChannels]:[e.batchSize,e.outChannels,g],x,w,z,Z,G,K),J=h?[$,I]:[I,$];if(o&&J.push(o),G&&J.push(s),K){let ne=n.makeTensorInfo([],"float32",b.createScalarValue(i,"float32"));J.push(ne),C.push(ne)}let te=n.runWebGLProgram(Q,J,"float32"),ie=ve({inputs:{x:te},backend:n,attrs:{shape:e.outShape}});C.push(te);for(let ne of C)n.disposeIntermediateTensorInfo(ne);return ie}function YOe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=n,p=T.convertConv2DDataFormat(u),d=T.computeConv2DInfo(o.shape,s.shape,i,l,a,c,!1,p),f;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))f=IE({x:o,filter:s,convInfo:d,backend:e});else if(d.strideWidth<=2&&p==="channelsLast"&&j().getBool("WEBGL_EXP_CONV")){let m=new ix(d),g=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];f=e.runWebGLProgram(m,[o,s],"float32",g)}else if(j().getBool("WEBGL_CONV_IM2COL"))f=TE({x:o,filter:s,convInfo:d,backend:e});else{let m=new sx(d);f=e.runWebGLProgram(m,[o,s],"float32")}let h=ve({inputs:{x:f},backend:e,attrs:{shape:d.outShape}});return e.disposeIntermediateTensorInfo(f),h}var Fte={kernelName:Gu,backendName:"webgl",kernelFunc:YOe};var _E=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideHeight,n=t.strideWidth,o=t.padInfo.top,s=t.padInfo.left,i=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${o};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},EE=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterHeight,n=t.filterWidth,o=t.strideHeight,s=t.strideWidth,i=t.dataFormat==="channelsLast",a=e-1-t.padInfo.top,u=n-1-t.padInfo.left,l=i?1:2,c=i?2:3,p=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},kE=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideDepth,n=t.strideHeight,o=t.strideWidth,s=t.padInfo.front,i=t.padInfo.top,a=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${s};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${i};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${o} - ${a};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},NE=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterDepth,n=t.filterHeight,o=t.filterWidth,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,u=e-1-t.padInfo.front,l=n-1-t.padInfo.top,c=o-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${l}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${o}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${o} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function ZOe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:c}=n,p=T.convertConv2DDataFormat(u),d=T.computeConv2DInfo(o.shape,c,i,1,a,l,!1,p),f=new _E(d);return e.runWebGLProgram(f,[o,s],"float32")}var $te={kernelName:Mp,backendName:"webgl",kernelFunc:ZOe};var DE=class{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=ir(this.outputShape.length);let e=t.filterHeight,n=t.filterWidth,o=e-1-t.padInfo.top,s=n-1-t.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            int wCPerm = ${n} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};function QOe(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{inputShape:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:c}=n,p=T.convertConv2DDataFormat(l),d=T.computeConv2DInfo(i,s.shape,a,1,u,c,!1,p);if(j().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&p==="channelsLast"){let f=[[d.strideHeight,d.strideWidth]],h=new DE(d);return e.runWebGLProgram(h,[o,s],"float32",f)}else{let f=new EE(d);return e.runWebGLProgram(f,[o,s],"float32")}}var Pte={kernelName:Wu,backendName:"webgl",kernelFunc:QOe};function JOe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u}=n,l=T.computeConv3DInfo(o.shape,s.shape,i,u,a),c=new wE(l);return e.runWebGLProgram(c,[o,s],"float32")}var Lte={kernelName:ju,backendName:"webgl",kernelFunc:JOe};function eMe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,pad:a,filterShape:u}=n,l=T.computeConv3DInfo(o.shape,u,i,1,a),c=new kE(l);return e.runWebGLProgram(c,[o,s],"float32")}var zte={kernelName:Fp,backendName:"webgl",kernelFunc:eMe};function tMe(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{pad:i,strides:a,inputShape:u}=n,l=T.computeConv3DInfo(u,s.shape,a,1,i),c=new NE(l);return e.runWebGLProgram(c,[o,s],"float32")}var Bte={kernelName:$p,backendName:"webgl",kernelFunc:tMe};var rMe=$i+`
  return cos(x);
`,nMe=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Os}
  return result;
`,oMe=Ve({opSnippet:rMe,packedOpSnippet:nMe}),Vte={kernelName:aa,backendName:"webgl",kernelFunc:oMe};var sMe=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,iMe=Ve({opSnippet:sMe}),Ute={kernelName:ua,backendName:"webgl",kernelFunc:iMe};var AE=class{constructor(t,e,n,o,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[i,a,u,l]=t,[c]=e,[p,d]=n;this.outputShape=[c,p,d,l];let f=o==="bilinear"?1:0,[h,m]=[`${a-1}.0`,`${u-1}.0`],[g,y,x]=p>1?[`${(a-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[w,C,I]=d>1?[`${(u-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${w});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${C};

        float in_y = ${x};
        if( in_y < 0.0 || in_y > ${h} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${I};
        if( in_x < 0.0 || in_x > ${m} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${f} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};var aMe=r=>{let{inputs:t,backend:e,attrs:n}=r,{image:o,boxes:s,boxInd:i}=t,{cropSize:a,method:u,extrapolationValue:l}=n,c=new AE(o.shape,s.shape,a,u,l);return e.runWebGLProgram(c,[o,s,i],"float32")},Gte={kernelName:Lp,backendName:"webgl",kernelFunc:aMe};var ax=function(r){return r.Prod="*",r.Sum="+",r}(ax||{}),iw=class{constructor(t,e,n,o){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let s=this.outputShape.length,i=this.op===ax.Prod?"1.0":"0.0",a=n?i:`getX(${Wte(s,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1],l="",c="";n?(l=o?`end != ${u-1}`:"end != 0",c=o?"end + 1":"end - 1"):(l=o?`end + pow2 < ${u}`:"end >= pow2",c=o?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${ut(s)} coords = getOutputCoords();
        int end = ${jte(s,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${c};
          ${jte(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${Wte(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function Wte(r,t,e){if(r===1)return`${t}`;if(r===2)return`${t}.x, ${t}.y`;if(r===3)return`${t}.x, ${t}.y, ${t}.z`;if(r===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${r} is not yet supported`)}function jte(r,t,e){if(r===1)return`${t}`;if(r===2)return`${t}.y`;if(r===3)return`${t}.z`;if(r===4)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${r} is not yet supported`)}function RE(r,t,e,n,o,s){let i=t.shape.length,a=T.getAxesPermutation([n],i),u=t;a!=null&&(u=Pr({inputs:{x:t},backend:e,attrs:{perm:a}}));let l=T.getInnerMostAxes(1,i)[0];if(l!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${n}`);let c=u.shape[l],p=ln({inputs:{x:u},backend:e});for(let d=0;d<=Math.ceil(Math.log2(c))-1;d++){let f=new iw(r,u.shape,!1,s),h=[[d]],m=p;p=e.runWebGLProgram(f,[p],p.dtype,h),e.disposeIntermediateTensorInfo(m)}if(o){let d=new iw(r,u.shape,o,s),f=p;p=e.runWebGLProgram(d,[p],p.dtype),e.disposeIntermediateTensorInfo(f)}if(a!=null){let d=T.getUndoAxesPermutation(a),f=Pr({inputs:{x:p},backend:e,attrs:{perm:d}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(u),f}return p}function uMe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n;return RE(ax.Prod,o,e,s,i,a)}var Hte={kernelName:Pp,backendName:"webgl",kernelFunc:uMe};function lMe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n;return RE(ax.Sum,o,e,s,i,a)}var qte={kernelName:Hu,backendName:"webgl",kernelFunc:lMe};function cMe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:i,binaryOutput:a}=n;if(o.shape.length===1){let u=e.readSync(o.dataId),l=e.readSync(s.dataId),c=q1(u,l,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,c)}else if(o.shape.length===2){let u=e.bufferSync(o),l=e.bufferSync(s),c=AJ(u,l,i,a);return e.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var Kte={kernelName:zp,backendName:"webgl",kernelFunc:cMe};var OE=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function pMe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockSize:s,dataFormat:i}=n,a=o.shape[0],u=i==="NHWC"?o.shape[1]:o.shape[2],l=i==="NHWC"?o.shape[2]:o.shape[3],c=i==="NHWC"?o.shape[3]:o.shape[1],p=u*s,d=l*s,f=c/(s*s),h=i==="NHWC"?[a,p,d,f]:[a,f,p,d],m=new OE(h,s,i);return e.runWebGLProgram(m,[o],o.dtype)}var Xte={kernelName:Bp,backendName:"webgl",kernelFunc:pMe};var ux=class{constructor(t,e=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ir(this.outputShape.length);let i=t.filterHeight,a=t.filterWidth,u=t.outChannels/t.inChannels,l="",c="";n&&(o?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:l=`
          float activation(float x) {
            ${n}
          }
        `,c="result = activation(result);");let p=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${c}
        setOutput(result);
      }
    `}};var lx=class{constructor(t,e=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ir(this.outputShape.length);let i=t.outChannels/t.inChannels,a=t.padInfo.left,u=t.strideWidth,l=t.dilationWidth,c=t.filterHeight,p=t.filterWidth,d=p,f=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<p;y++)f+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;f+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let y=0;y<p;y++)f+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;f+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(d+1)/2;y++){let x=y*2;if(f+=`
          xC = xCCorner + ${x*l};
          `,u===1){if(x<p&&(a%2===1?(f+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }
              `,l===1&&x>0?f+=`
                xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);
                `:f+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                  } else {
                    xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                  }
                  `):f+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xC${x} = xTexelC${x};
                `,x+1<p)){let w=a%2===0?b.nearestLargerEven(l):l;l%2===0&&a%2===1||l%2!==0&&a%2!==1?(f+=`
                  xCOffset = xC + imod(pads[1], 2) + ${w};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                    xTexelC${x+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${x+1}.zw = vec2(0.0);
                    }
                    xTexelC${x+1}Ready = 1;
                  }
                  `,l>1?f+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${x+1} = vec4(previous.zw, xTexelC${x+1}.xy);
                    } else {
                     xC${x+1} = vec4(0.0, 0.0, xTexelC${x+1}.xy);
                    }
                    `:f+=`
                    xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);
                    `):w===1?f+=`
                    xC${x+1} = xTexelC${x};
                    `:f+=`
                    xCOffset = xC + ${w};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                      xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${x+1}.zw = vec2(0.0);
                      }
                      xTexelC${x+1}Ready = 1;
                    }

                    xC${x+1} = xTexelC${x+1};
                    `}}else x<p&&(a%2===1?(f+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.0);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
              `,x+1<p&&(f+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);
                `)):(f+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(
                  xTexelC${x}.xy, xTexelC${x+1}.xy);
              `,x+1<p&&(f+=`
                  xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
                `)));x<p&&(f+=`
            wTexel = getW(r, ${x}, d1, q);
            dotProd += xC${x} * vec4(wTexel.xz, wTexel.xz);
          `,x+1<p&&(f+=`
              wTexel = getW(r, ${x+1}, d1, q);
              dotProd += xC${x+1} * vec4(wTexel.xz, wTexel.xz);
            `))}f+=`
    }
  `,f+=`
      }
    `;let h="",m="";n&&(o?h=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?h=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:h=`vec4 activation(vec4 x) {
          ${n}
        }`,m="result = activation(result);");let g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${h}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${f}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${m}
        setOutput(result);
      }
    `}};function dMe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u,dimRoundingMode:l}=n,c=u;c==null&&(c=[1,1]),b.assert(T.eitherStridesOrDilationsAreOne(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let p=T.computeConv2DInfo(o.shape,s.shape,i,c,a,l,!0),d;j().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?d=new lx(p):d=new ux(p);let f=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return e.runWebGLProgram(d,[o,s],"float32",f)}var Yte={kernelName:qu,backendName:"webgl",kernelFunc:dMe};var ME=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideHeight,n=t.strideWidth,o=t.padInfo.top,s=t.padInfo.left,i=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${o};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},FE=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterHeight,n=t.filterWidth,o=t.strideHeight,s=t.strideWidth,i=e-1-t.padInfo.top,a=n-1-t.padInfo.left,u=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function fMe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,filterShape:c}=n,p=T.computeConv2DInfo(o.shape,c,i,a,u,l,!0),d=new ME(p);return e.runWebGLProgram(d,[o,s],"float32")}var Zte={kernelName:Vp,backendName:"webgl",kernelFunc:fMe};function hMe(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,inputShape:c}=n,p=T.computeConv2DInfo(c,s.shape,i,a,u,l,!0),d=new FE(p);return e.runWebGLProgram(d,[o,s],"float32")}var Qte={kernelName:Up,backendName:"webgl",kernelFunc:hMe};var $E=class{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function mMe(r){let{inputs:t,backend:e}=r,{x:n}=t,o=[...n.shape,...n.shape],s=b.sizeFromShape(n.shape),i=ve({inputs:{x:n},backend:e,attrs:{shape:[s]}}),a=new $E(s),u=e.runWebGLProgram(a,[i],i.dtype),l=ve({inputs:{x:u},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(u),l}var Jte={kernelName:Gp,backendName:"webgl",kernelFunc:mMe};var PE=class{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let{inHeight:e,inWidth:n,padInfo:o,strideHeight:s,strideWidth:i,filterHeight:a,filterWidth:u,dilationHeight:l,dilationWidth:c}=t,{top:p,left:d}=o;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${i});
      const ivec2 pads = ivec2(${p}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function gMe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u}=n,l=T.computeDilation2DInfo(o.shape,s.shape,i,a,"NHWC",u),c,p=new PE(l);c=e.runWebGLProgram(p,[o,s],"float32");let d=ve({inputs:{x:c},backend:e,attrs:{shape:l.outShape}});return e.disposeIntermediateTensorInfo(c),d}var ere={kernelName:Ku,backendName:"webgl",kernelFunc:gMe};function yMe(r){let{inputs:t,backend:e,attrs:n}=r,{equation:o}=n,s=t,{allDims:i,summedDims:a,idDims:u}=T.decodeEinsumEquation(o,s.length);T.checkEinsumDimSizes(i.length,u,s);let{path:l,steps:c}=T.getEinsumComputePath(a,u),p=c.length,d=null,f=i.length,h=[];for(let m=0;m<p;++m){for(let g of c[m]){let{permutationIndices:y,expandDims:x}=T.getEinsumPermutation(f,u[g]),w;T.isIdentityPermutation(y)?w=s[g]:(w=Pr({inputs:{x:s[g]},backend:e,attrs:{perm:y}}),h.push(w));let C=w.shape.slice();for(let I=0;I<x.length;++I)C.splice(x[I],0,1);b.arraysEqual(w.shape,C)||(w=ve({inputs:{x:w},backend:e,attrs:{shape:C}}),h.push(w)),d===null?d=w:(d=ow({inputs:{a:w,b:d},backend:e}),h.push(d))}m<p-1&&(l[m]>=0&&(d=Jh({inputs:{x:d},backend:e,attrs:{axis:l[m]-(i.length-f),keepDims:!1}}),h.push(d)),f--)}for(let m of h)m!==d&&e.disposeIntermediateTensorInfo(m);return d}var tre={kernelName:Wp,backendName:"webgl",kernelFunc:yMe};var xMe="return (x >= 0.0) ? x : (exp(x) - 1.0);",vMe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,bMe=Ve({opSnippet:xMe,packedOpSnippet:vMe}),rre={kernelName:ca,backendName:"webgl",kernelFunc:bMe};var wMe="return (b >= 0.0) ? a : a * (b + 1.0);",CMe=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,SMe=r=>{let{inputs:t,backend:e}=r,{dy:n,y:o}=t,s=j().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Rs(CMe,n.shape,o.shape):new is(wMe,n.shape,o.shape);return e.runWebGLProgram(s,[n,o],n.dtype)},nre={kernelName:jp,backendName:"webgl",kernelFunc:SMe};var IMe=`
  return vec4(equal(a, b));
`,TMe="return float(a == b);",_Me=Zt({opSnippet:TMe,packedOpSnippet:IMe,dtype:"bool",cpuKernelImpl:$J}),ore={kernelName:hc,backendName:"webgl",kernelFunc:_Me};var EMe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${T.ERF_P};
  float a1 = ${T.ERF_A1};
  float a2 = ${T.ERF_A2};
  float a3 = ${T.ERF_A3};
  float a4 = ${T.ERF_A4};
  float a5 = ${T.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,kMe=Ve({opSnippet:EMe}),sre={kernelName:pa,backendName:"webgl",kernelFunc:kMe};var NMe=$i+`
  return exp(x);
`,DMe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,y$=Ve({opSnippet:NMe,packedOpSnippet:DMe,cpuKernelImpl:PJ,dtype:"float32"}),ire={kernelName:da,backendName:"webgl",kernelFunc:y$};function LE(r){let{inputs:t,attrs:e,backend:n}=r,{dim:o}=e,{input:s}=t,i=s.shape.length,a=s.shape.slice(),u=o;return o<0&&(b.assert(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+o+1),a.splice(u,0,1),ve({inputs:{x:s},backend:n,attrs:{shape:a}})}var are={kernelName:Xu,backendName:"webgl",kernelFunc:LE};var ure="return exp(x) - 1.0;",AMe=Ve({opSnippet:ure,packedOpSnippet:ure,cpuKernelImpl:LJ}),lre={kernelName:fa,backendName:"webgl",kernelFunc:AMe};var aw=class{constructor(t,e,n){this.variableNames=["real","imag"];let o=e[1];this.outputShape=e;let s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${o}.0`:"1.0",a;if(t==="real")a="return real * expR - imag * expI;";else if(t==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${o});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${o}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function zE(r,t,e){let n=e.texData.get(r.dataId),o=b.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=o/s,a=ve({inputs:{x:r},backend:e,attrs:{shape:[i,s]}}),u=a.shape,l=new aw("real",u,t),c=new aw("imag",u,t),p=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:u},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:u}],d=e.runWebGLProgram(l,p,"float32"),f=e.runWebGLProgram(c,p,"float32"),h=as({inputs:{real:d,imag:f},backend:e});e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(f);let m=ve({inputs:{x:h},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(h),m}function RMe(r){let{inputs:t,backend:e}=r,{input:n}=t;return zE(n,!1,e)}var cre={kernelName:Hp,backendName:"webgl",kernelFunc:RMe};var BE=class{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function Zc(r){let{backend:t,attrs:e}=r,{shape:n,value:o}=e,{dtype:s}=e;if(s=s||b.inferDtype(o),s==="string"){let i=b.getArrayFromDType(s,b.sizeFromShape(n));return i.fill(o),t.makeTensorInfo(n,s,i)}else{let i=new BE(n,o),a=[[o]];return t.runWebGLProgram(i,[],s,a)}}var pre={kernelName:qp,backendName:"webgl",kernelFunc:Zc};var VE=class{constructor(t){this.variableNames=["Image"],this.outputShape=[];let e=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var dre={kernelName:Kp,backendName:"webgl",kernelFunc:({inputs:r,backend:t})=>{let{image:e}=r,n=t,o=new VE(e.shape);return n.runWebGLProgram(o,[e],e.dtype)}};var fre="return floor(x);",OMe=Ve({opSnippet:fre,packedOpSnippet:fre,cpuKernelImpl:zJ}),hre={kernelName:ha,backendName:"webgl",kernelFunc:OMe};var MMe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,FMe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,$Me=Zt({opSnippet:MMe,packedOpSnippet:FMe,dtype:"int32"}),mre={kernelName:ma,backendName:"webgl",kernelFunc:$Me};var UE=class{constructor(t){this.variableNames=["A"];let e=Xr(),[n,o]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${n}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};var GE=class{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let e=Xr(),[n,o]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${o}.0, ${n}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `}};var gre={kernelName:nh,backendName:"webgl",kernelFunc:PMe},cx,x$=j().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function PMe(r){let{inputs:t,backend:e,attrs:n}=r,{pixels:o}=t,{numChannels:s}=n,i=typeof HTMLVideoElement<"u"&&o instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement,[u,l]=i?[o.videoWidth,o.videoHeight]:[o.width,o.height],c=[l,u],p=[l,u,s];if(a||i){let m=j().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(cx==null||m!==x$)&&(x$=m,cx=document.createElement("canvas").getContext("2d",{willReadFrequently:x$})),cx.canvas.width=u,cx.canvas.height=l,cx.drawImage(o,0,0,u,l),o=cx.canvas}let d=e.makeTensorInfo(c,"int32");e.texData.get(d.dataId).usage=ko.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(d.dataId),o);let f=j().getBool("WEBGL_PACK")?new GE(p):new UE(p),h=e.runWebGLProgram(f,[d],"int32");return e.disposeData(d.dataId),h}function LMe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:d,activation:f,leakyreluAlpha:h}=n,m=T.convertConv2DDataFormat(c),g=T.computeConv2DInfo(o.shape,s.shape,u,p,l,d,!1,m),y,x=[],w=i!=null,C=a!=null,I=f==="leakyrelu",N=()=>{let O=[o,s],$=(z,G)=>{if(G==="NCHW"&&z.shape.length===1&&z.shape[0]!==1){let K=ve({inputs:{x:z},backend:e,attrs:{shape:[z.shape[0],1,1]}});return x.push(K),K}return z};if(w&&O.push($(i,c)),C&&O.push($(a,c)),I){let z=e.makeTensorInfo([],"float32",b.createScalarValue(h,"float32"));O.push(z),x.push(z)}return O};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=IE({x:o,filter:s,convInfo:g,backend:e,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:h});else if(g.strideWidth<=2&&m==="channelsLast"&&j().getBool("WEBGL_EXP_CONV")){let O=f?Xc(f,!0):null,$=new ix(g,w,O,C,I),z=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],G=N();y=e.runWebGLProgram($,G,"float32",z)}else if(j().getBool("WEBGL_CONV_IM2COL"))y=TE({x:o,filter:s,convInfo:g,backend:e,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:h});else{let O=f?Xc(f,!1):null,$=new sx(g,w,O,C,I),z=N();y=e.runWebGLProgram($,z,"float32")}let A=ve({inputs:{x:y},backend:e,attrs:{shape:g.outShape}});return x.push(y),x.forEach(O=>e.disposeIntermediateTensorInfo(O)),A}var yre={kernelName:Sc,backendName:"webgl",kernelFunc:LMe};function zMe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dilations:c,dimRoundingMode:p,activation:d,leakyreluAlpha:f}=n,h=[],m=c;m==null&&(m=[1,1]),b.assert(T.eitherStridesOrDilationsAreOne(u,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${m}'`);let g=T.computeConv2DInfo(o.shape,s.shape,u,m,l,p,!0),y=j().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,x=d?Xc(d,y):null,w=[o,s],C=i!=null,I=a!=null,N=d==="leakyrelu";if(C&&w.push(i),I&&w.push(a),N){let z=e.makeTensorInfo([],"float32",b.createScalarValue(f,"float32"));w.push(z),h.push(z)}let A;y?A=new lx(g,C,x,I,N):A=new ux(g,C,x,I,N);let O=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],$=e.runWebGLProgram(A,w,"float32",O);return h.forEach(z=>e.disposeIntermediateTensorInfo(z)),$}var xre={kernelName:Ic,backendName:"webgl",kernelFunc:zMe};var WE=class{constructor(t,e,n,o){this.sliceDim=t,this.strides=e,this.paramsShape=o,this.variableNames=["x","indices"],this.outputShape=n;let s=ut(n.length),i=`
    int index;`;for(let a=0;a<this.sliceDim;a++)i+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function BMe(r){let{inputs:t,backend:e}=r,{params:n,indices:o}=t,s=o.shape,i=s[s.length-1],a=b.sizeFromShape(n.shape),[u,l,c,p]=T.prepareAndValidate(n,o),d=ve({inputs:{x:o},backend:e,attrs:{shape:[l,i]}}),f=ve({inputs:{x:n},backend:e,attrs:{shape:[b.sizeFromShape(n.shape)/c,c]}});if(e.shouldExecuteOnCPU([n,o])||n.dtype==="string"){let y=e.readSync(o.dataId),x=e.bufferSync(n),w=BJ(y,x,n.dtype,l,i,c,p,n.shape,a);return e.makeTensorInfo(u,n.dtype,w.values)}let h=new WE(i,p,[l,c],n.shape),m=e.runWebGLProgram(h,[f,d],f.dtype),g=ve({inputs:{x:m},backend:e,attrs:{shape:u}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),g}var vre={kernelName:Xp,backendName:"webgl",kernelFunc:BMe};var jE=class{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;let n=ut(this.rank),o=VMe(t,2);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${o}));
      }
    `}};function VMe(r,t){let e=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let o=0;o<r.length;o++)o===2?n.push("index"):n.push(`${e[o]}`);return n.join()}function v$(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,indices:s}=t,{axis:i,batchDims:a}=n,u=b.parseAxisParam(i,o.shape)[0];if(j().get("DEBUG")){let x=e.readSync(s.dataId),w=o.shape[u];for(let C=0;C<x.length;++C){let I=x[C];b.assert(I<=w-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${w-1}]`)}}let l=T.segment_util.collectGatherOpShapeInfo(o,s,u,a),c=b.sizeFromShape(s.shape),p=[],d=ve({inputs:{x:o},backend:e,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),f=ve({inputs:{x:s},backend:e,attrs:{shape:[l.batchSize,c/l.batchSize]}});p.push(d),p.push(f);let h=[l.batchSize,l.outerSize,c/l.batchSize,l.sliceSize];if(e.shouldExecuteOnCPU([o,s])||o.dtype==="string"){let x=e.bufferSync(f),w=e.bufferSync(d),C=VJ(w,x,h);return p.forEach(I=>e.disposeIntermediateTensorInfo(I)),e.makeTensorInfo(l.outputShape,C.dtype,C.values)}let m=new jE(d.shape,h),g=e.runWebGLProgram(m,[d,f],d.dtype);p.push(g);let y=ve({inputs:{x:g},backend:e,attrs:{shape:l.outputShape}});return p.forEach(x=>e.disposeIntermediateTensorInfo(x)),y}var bre={kernelName:Zu,backendName:"webgl",kernelFunc:v$};var UMe="return float(a > b);",GMe=`
  return vec4(greaterThan(a, b));
`,WMe=Zt({opSnippet:UMe,packedOpSnippet:GMe,cpuKernelImpl:UJ,dtype:"bool"}),wre={kernelName:mc,backendName:"webgl",kernelFunc:WMe};var jMe="return float(a >= b);",HMe=`
  return vec4(greaterThanEqual(a, b));
`,qMe=Zt({opSnippet:jMe,packedOpSnippet:HMe,dtype:"bool",cpuKernelImpl:GJ}),Cre={kernelName:ga,backendName:"webgl",kernelFunc:qMe};function KMe(r){let{inputs:t,backend:e}=r,{input:n}=t;return zE(n,!0,e)}var Sre={kernelName:Yp,backendName:"webgl",kernelFunc:KMe};var XMe="return float(!isnan(x) && !isinf(x));",YMe=Ve({opSnippet:XMe,dtype:"bool"}),Ire={kernelName:ya,backendName:"webgl",kernelFunc:YMe};var ZMe="return float(isinf(x));",QMe=Ve({opSnippet:ZMe,dtype:"bool"}),Tre={kernelName:xa,backendName:"webgl",kernelFunc:QMe};var JMe="return float(isnan(x));",eFe=Ve({opSnippet:JMe,dtype:"bool"}),_re={kernelName:va,backendName:"webgl",kernelFunc:eFe};var tFe="return float(a < b);",rFe=`
  return vec4(lessThan(a, b));
`,nFe=Zt({opSnippet:tFe,packedOpSnippet:rFe,cpuKernelImpl:WJ,dtype:"bool"}),Ere={kernelName:gc,backendName:"webgl",kernelFunc:nFe};var oFe="return float(a <= b);",sFe=`
  return vec4(lessThanEqual(a, b));
`,iFe=Zt({opSnippet:oFe,packedOpSnippet:sFe,cpuKernelImpl:jJ,dtype:"bool"}),kre={kernelName:yc,backendName:"webgl",kernelFunc:iFe};function aFe(r){let{backend:t,attrs:e}=r,{start:n,stop:o,num:s}=e,i=HJ(n,o,s);return t.makeTensorInfo([i.length],"float32",i)}var Nre={kernelName:Qp,backendName:"webgl",kernelFunc:aFe};var uFe=$i+`
  return x < 0.0 ? 0./0. : log(x);
`,lFe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,cFe=Ve({opSnippet:uFe,packedOpSnippet:lFe,cpuKernelImpl:qJ}),Dre={kernelName:ba,backendName:"webgl",kernelFunc:cFe};var pFe=$i+`
  return log(1.0 + x);
`,dFe=Ve({opSnippet:pFe}),Are={kernelName:wa,backendName:"webgl",kernelFunc:dFe};var fFe="return float(a >= 1.0 && b >= 1.0);",hFe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,mFe=Zt({opSnippet:fFe,packedOpSnippet:hFe,dtype:"bool"}),Rre={kernelName:xc,backendName:"webgl",kernelFunc:mFe};var gFe="return float(!(x >= 1.0));",yFe=Ve({opSnippet:gFe}),Ore={kernelName:vc,backendName:"webgl",kernelFunc:yFe};var xFe="return float(a >= 1.0 || b >= 1.0);",vFe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,bFe=Zt({opSnippet:xFe,packedOpSnippet:vFe,dtype:"bool"}),Mre={kernelName:bc,backendName:"webgl",kernelFunc:bFe};var HE=class{constructor(t,e,n,o,s){this.variableNames=["x"],this.outputShape=[];let i=e,a=t[3]-1;this.outputShape=t;let u,l=`float(${n}) + float(${o}) * sum`;s===.5?u=`inversesqrt(${l})`:s===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}};var qE=class{constructor(t,e,n,o,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let i=e,a=t[3]-1;this.outputShape=t;let u,l=`float(${n}) + float(${o}) * sum`;s===.5?u=`inversesqrt(${l})`:s===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}};var wFe=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{depthRadius:s,bias:i,alpha:a,beta:u}=n,l=j().getBool("WEBGL_PACK_NORMALIZATION")?new qE(o.shape,s,i,a,u):new HE(o.shape,s,i,a,u);return e.runWebGLProgram(l,[o],o.dtype)},Fre={kernelName:Ju,backendName:"webgl",kernelFunc:wFe};var KE=class{constructor(t,e,n,o,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=o,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${o}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${o})
                * float(${s})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};var CFe=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o,y:s,dy:i}=t,{depthRadius:a,bias:u,alpha:l,beta:c}=n,p=new KE(o.shape,a,u,l,c);return e.runWebGLProgram(p,[o,s,i],o.dtype)},$re={kernelName:Jp,backendName:"webgl",kernelFunc:CFe};function Pre(r,t,e,n){let o=b.sizeFromShape(t),i=b.sizeFromShape(r.shape)/o,a=ve({inputs:{x:r},attrs:{shape:[i,o]},backend:n}),u=Ms(a,r.dtype,"max",n),l=ve({inputs:{x:u},attrs:{shape:e},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(u),l}function b$(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reductionIndices:s,keepDims:i}=n,a=o.shape.length,u=b.parseAxisParam(s,o.shape),l=u,c=T.getAxesPermutation(l,a),p=c!=null,d=e.shouldExecuteOnCPU([o]),f=o;if(p){if(d){let w=e.texData.get(f.dataId).values,C=new Array(a);for(let A=0;A<C.length;A++)C[A]=o.shape[c[A]];let I=Qh(w,o.shape,o.dtype,c,C);f=e.makeTensorInfo(C,o.dtype);let N=e.texData.get(f.dataId);N.values=I}else f=af(o,c,e);l=T.getInnerMostAxes(l.length,a)}T.assertAxesAreInnerMostDims("max",l,a);let[h,m]=T.computeOutAndReduceShapes(f.shape,l),g=h;i&&(g=T.expandShapeToKeepDim(h,u));let y;if(d){let w=e.texData.get(f.dataId).values,C=KJ(w,b.sizeFromShape(m),g,o.dtype);y=e.makeTensorInfo(g,o.dtype);let I=e.texData.get(y.dataId);I.values=C}else y=Pre(f,m,g,e);return p&&e.disposeIntermediateTensorInfo(f),y}var Lre={kernelName:el,backendName:"webgl",kernelFunc:b$};var SFe=rx+`
  return max(a, b);
`,IFe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Os+`
  return result;
`,TFe=Zt({opSnippet:SFe,packedOpSnippet:IFe,cpuKernelImpl:XJ}),zre={kernelName:Ca,backendName:"webgl",kernelFunc:TFe};function _Fe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;ql(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;b.assert(T.eitherStridesOrDilationsAreOne(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let c=T.computePool2DInfo(o.shape,s,i,l,a,u);if(c.filterWidth===1&&c.filterHeight===1&&b.arraysEqual(c.inShape,c.outShape))return ln({inputs:{x:o},backend:e});let p=new lu(c,"max",!1);return e.runWebGLProgram(p,[o],o.dtype)}var Bre={kernelName:tl,backendName:"webgl",kernelFunc:_Fe};function EFe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:i,pad:a,dataFormat:u,dimRoundingMode:l}=n,c=[1,1,1],p=T.computePool3DInfo(o.shape,s,i,c,a,l,u),d=new uf(p,"max",!1);return e.runWebGLProgram(d,[o],o.dtype)}var Vre={kernelName:rl,backendName:"webgl",kernelFunc:EFe};var XE=class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let e=t.strideHeight,n=t.strideWidth,o=t.dilationHeight,s=t.effectiveFilterHeight,i=t.effectiveFilterWidth,a=s-1-t.padInfo.top,u=i-1-t.padInfo.left,l=s*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},YE=class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let e=t.strideDepth,n=t.strideHeight,o=t.strideWidth,s=t.dilationDepth,i=t.dilationHeight,a=t.dilationWidth,u=t.effectiveFilterDepth,l=t.effectiveFilterHeight,c=t.effectiveFilterWidth,p=u-1-t.padInfo.front,d=l-1-t.padInfo.top,f=c-1-t.padInfo.left,h=u*l*c-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${d}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${h} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function kFe(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,i=s,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=n,p=[1,1,1],d=T.computePool3DInfo(i.shape,a,u,p,l,c),f=new uf(d,"max",!0),h=e.runWebGLProgram(f,[i],i.dtype),m=new YE(d),g=e.runWebGLProgram(m,[o,h],i.dtype);return e.disposeIntermediateTensorInfo(h),g}var Ure={kernelName:td,backendName:"webgl",kernelFunc:kFe};function NFe(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s,output:i}=t,a=s;ql([s,i],"maxPoolGrad");let{filterSize:u,strides:l,pad:c,dimRoundingMode:p}=n,d=T.computePool2DInfo(a.shape,u,l,1,c,p),f=!0,h=new lu(d,"max",f),m=e.runWebGLProgram(h,[a],a.dtype),g=new XE(d),y=e.runWebGLProgram(g,[o,m],a.dtype);return e.disposeIntermediateTensorInfo(m),y}var Gre={kernelName:ed,backendName:"webgl",kernelFunc:NFe};function Wre(r,t,e,n){let o=new lu(e,"max",!1),s=n.runWebGLProgram(o,[r],"float32");o=new lu(e,"max",!0,!0,t);let i=n.runWebGLProgram(o,[r],"float32");return[s,i]}var jre={kernelName:rd,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n}=r,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=t,u=e;b.assert(n.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${n.shape.length}.`);let l=[1,1];b.assert(T.eitherStridesOrDilationsAreOne(s,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${l}'`);let c=T.computePool2DInfo(n.shape,o,s,l,i),[p,d]=Wre(n,a,c,u);return[p,d]}};function Hre(r,t,e,n){let o=b.sizeFromShape(t),i=b.sizeFromShape(r.shape)/o,a=ve({inputs:{x:r},attrs:{shape:[i,o]},backend:n}),u=Ms(a,"float32","mean",n),l=ve({inputs:{x:u},attrs:{shape:e},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(u),l}var qre={kernelName:nl,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n}=r,{keepDims:o,axis:s}=t,i=e,a=n.shape.length,u=b.parseAxisParam(s,n.shape),l=u,c=T.getAxesPermutation(l,a),p=c!=null,d=i.shouldExecuteOnCPU([n]),f=[],h=n;if(p){if(d){let C=i.texData.get(h.dataId).values,I=new Array(a);for(let O=0;O<I.length;O++)I[O]=n.shape[c[O]];let N=Qh(C,n.shape,n.dtype,c,I);h=i.makeTensorInfo(I,n.dtype);let A=i.texData.get(h.dataId);A.values=N}else h=af(n,c,i);f.push(h),l=T.getInnerMostAxes(l.length,a)}T.assertAxesAreInnerMostDims("sum",l,a);let[m,g]=T.computeOutAndReduceShapes(h.shape,l),y=m;o&&(y=T.expandShapeToKeepDim(m,u));let x=Hre(h,g,y,i);for(let w of f)i.disposeIntermediateTensorInfo(w);return x}};function DFe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=o.shape.length,u=b.parseAxisParam(s,o.shape),l=u,c=T.getAxesPermutation(l,a),p=o;c!=null&&(p=Pr({inputs:{x:o},backend:e,attrs:{perm:c}}),l=T.getInnerMostAxes(l.length,o.shape.length)),T.assertAxesAreInnerMostDims("min",l,a);let[d,f]=T.computeOutAndReduceShapes(p.shape,l),h=b.sizeFromShape(f),m=ve({inputs:{x:p},backend:e,attrs:{shape:[-1,h]}}),g=Ms(m,m.dtype,"min",e),y;if(i){let x=T.expandShapeToKeepDim(d,u);y=ve({inputs:{x:g},backend:e,attrs:{shape:x}})}else y=ve({inputs:{x:g},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),c!=null&&e.disposeIntermediateTensorInfo(p),y}var Kre={kernelName:ol,backendName:"webgl",kernelFunc:DFe};var AFe=rx+`
  return min(a, b);
`,RFe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Os+`
  return result;
`,OFe=Zt({opSnippet:AFe,packedOpSnippet:RFe,cpuKernelImpl:YJ}),Xre={kernelName:Sa,backendName:"webgl",kernelFunc:OFe};var ZE=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map((c,p)=>c[0]+t[p]+c[1]);let o=t.length,s=ut(o),i=e.map(c=>c[0]).join(","),a=e.map((c,p)=>c[0]+t[p]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o),l=n==="reflect"?0:1;if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${o}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}};var QE=class{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((h,m)=>h[0]+t[m]+h[1]);let o=t.length,s=ut(o),i=e.map(h=>h[0]).join(","),a=e.map((h,m)=>h[0]+t[m]).join(","),u=un("rc",o),l=un("source",o),c=`${u[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${l.slice(-2).join()})`,d=n==="reflect"?0:1,f="";if(o===1){let h=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${l.join()}), ${p});
        ${u[o-1]} += 1;
        if(${c}) {
          ${h}
          result[1] = getChannel(getX(${l.join()}), ${p});
        }
      `}else{let h=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${l.join()}), ${p});
        ${u[o-1]} += 1;
        if(${c}) {
          ${h}
          result[1] = getChannel(getX(${l.join()}), ${p});
        }
        rc = outputLoc;
        ${u[o-2]} += 1;
        if(${u[o-2]} < ${this.outputShape[o-2]}) {
          ${h}
          result[2] = getChannel(getX(${l.join()}), ${p});
          ${u[o-1]} += 1;
          if(${c}) {
            ${h}
            result[3] = getChannel(getX(${l.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}};var MFe=({inputs:r,backend:t,attrs:e})=>{let{x:n}=r,{paddings:o,mode:s}=e,i=j().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new QE(n.shape,o,s):new ZE(n.shape,o,s);return t.runWebGLProgram(i,[n],n.dtype)},Yre={kernelName:sl,backendName:"webgl",kernelFunc:MFe};var FFe=`if (b == 0.0) return NAN;
  return mod(a, b);`,$Fe=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Os+`
  return result;
`,PFe=Zt({opSnippet:FFe,packedOpSnippet:$Fe}),Zre={kernelName:Ia,backendName:"webgl",kernelFunc:PFe};var JE=class{constructor(t,e,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}};var LFe=`
if (a == b) {
  return 1.0;
};
return a / b;`,zFe=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,w$=Zt({opSnippet:LFe,packedOpSnippet:zFe,checkOutOfBounds:!0}),Qre={kernelName:la,backendName:"webgl",kernelFunc:w$};var Jre="return a - b;",C$=Zt({opSnippet:Jre,packedOpSnippet:Jre,supportsComplex:!0,cpuKernelImpl:yee}),ene={kernelName:Ba,backendName:"webgl",kernelFunc:C$};function S$(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{dim:s}=n,i=b.parseAxisParam([s],o.shape),a=b$({inputs:{x:o},backend:e,attrs:{reductionIndices:i,keepDims:!1}}),u=T.expandShapeToKeepDim(a.shape,i),l=ve({inputs:{x:a},backend:e,attrs:{shape:u}}),c=C$({inputs:{a:o,b:l},backend:e}),p=y$({inputs:{x:c},backend:e}),d=Jh({inputs:{x:p},backend:e,attrs:{axis:i,keepDims:!1}}),f=ve({inputs:{x:d},backend:e,attrs:{shape:u}}),h=w$({inputs:{a:p,b:f},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(f),h}var tne={kernelName:Cl,backendName:"webgl",kernelFunc:S$};function BFe(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{numSamples:s,seed:i,normalized:a}=n,u=a?o:S$({inputs:{logits:o},backend:e,attrs:{dim:o.shape.length-1}}),l=u.shape[0],c=u.shape[1],p=new JE(l,c,s),d=[[i]],f=e.runWebGLProgram(p,[u],"int32",d);return a||e.disposeIntermediateTensorInfo(u),f}var rne={kernelName:nd,backendName:"webgl",kernelFunc:BFe};var VFe=kn+`
  return -x;
`,UFe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function GFe(r){let{inputs:t,backend:e}=r,{x:n}=t;if(e.shouldExecuteOnCPU([n])){let s=e.texData.get(n.dataId),[i,a]=QJ(s.values,n.shape,n.dtype);return e.makeTensorInfo(a,n.dtype,i)}let o;return j().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new ss(n.shape,UFe):o=new no(n.shape,VFe),e.runWebGLProgram(o,[n],n.dtype)}var nne={kernelName:il,backendName:"webgl",kernelFunc:GFe};var WFe=En.nonMaxSuppressionV3Impl;function jFe(r){T.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=n,l=e.readSync(o.dataId),c=e.readSync(s.dataId),{selectedIndices:p}=WFe(l,c,i,a,u);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}var one={kernelName:od,backendName:"webgl",kernelFunc:jFe};var HFe=En.nonMaxSuppressionV4Impl;function qFe(r){T.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:l}=n,c=e.readSync(o.dataId),p=e.readSync(s.dataId),{selectedIndices:d,validOutputs:f}=HFe(c,p,i,a,u,l);return[e.makeTensorInfo([d.length],"int32",new Int32Array(d)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}var sne={kernelName:fg,backendName:"webgl",kernelFunc:qFe};var KFe=En.nonMaxSuppressionV5Impl;function XFe(r){T.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=n,c=e.readSync(o.dataId),p=e.readSync(s.dataId),d=i,f=a,h=u,m=l,{selectedIndices:g,selectedScores:y}=KFe(c,p,d,f,h,m);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var ine={kernelName:sd,backendName:"webgl",kernelFunc:XFe};var ek=class{constructor(t,e,n,o){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${o}), float(${n}),
                      float(index == coords.y)));
      }
    `}};var YFe=r=>{let{inputs:t,backend:e,attrs:n}=r,{indices:o}=t,{dtype:s,depth:i,onValue:a,offValue:u}=n,l=b.sizeFromShape(o.shape),c=new ek(l,i,a,u),p=ve({inputs:{x:o},backend:e,attrs:{shape:[l]}}),d=e.runWebGLProgram(c,[p],s);e.disposeIntermediateTensorInfo(p);let f=[...o.shape,i],h=ve({inputs:{x:d},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(d),h},ane={kernelName:ul,backendName:"webgl",kernelFunc:YFe};function uw(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="complex64"){let o=Yc({inputs:{input:n},backend:e}),s=uw({inputs:{x:o},backend:e}),i=tm({inputs:{input:n},backend:e}),a=uw({inputs:{x:i},backend:e}),u=as({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}else return Zc({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:e})}var une={kernelName:Tl,backendName:"webgl",kernelFunc:uw};function lne(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(n.dtype==="complex64"){let o=Yc({inputs:{input:n},backend:e}),s=lne({inputs:{x:o},backend:e}),i=tm({inputs:{input:n},backend:e}),a=uw({inputs:{x:i},backend:e}),u=as({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}else return Zc({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:e})}var cne={kernelName:al,backendName:"webgl",kernelFunc:lne};function ZFe(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n;if(t.length===1)return LE({inputs:{input:t[0]},backend:e,attrs:{dim:o}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{b.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),b.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],u=t.map(c=>{let p=LE({inputs:{input:c},backend:e,attrs:{dim:o}});return a.push(p),p}),l=g$({inputs:u,backend:e,attrs:{axis:o}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),l}var pne={kernelName:ll,backendName:"webgl",kernelFunc:ZFe};var tk=class{constructor(t,e,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((l,c)=>l[0]+t[c]+l[1]);let o=t.length,s=ut(o),i=e.map(l=>l[0]).join(","),a=e.map((l,c)=>l[0]+t[c]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o);if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}};var rk=class{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((m,g)=>m[0]+t[g]+m[1]);let o=t.length,s=ut(o),i=e.map(m=>m[0]).join(","),a=e.map((m,g)=>m[0]+t[g]).join(","),u=un("rc",o),l=un("source",o),c=`${u[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${l.slice(-2).join()})`,d=[`${s} rc = outputLoc;`,`${u[o-1]} += 1;
       if(${c}) {
      `,o===1?"":`}
       rc = outputLoc;
       ${u[o-2]} += 1;
       if(${u[o-2]} < ${this.outputShape[o-2]}) {`,o===1?"":`  ${u[o-1]} += 1;
         if(${c}) {`],f=o===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",h="";for(let m=0,g=o===1?2:4;m<g;m++)h+=`
        ${d[m]}
        if (${f}) {
          result[${m}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${m}] = getChannel(getX(${l.join()}), ${p});
        }
      `;h+=o===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `}};var I$=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{paddings:s,constantValue:i}=n;if(b.sizeFromShape(o.shape)===0){let l=s.map((c,p)=>c[0]+o.shape[p]+c[1]);return Zc({backend:e,attrs:{shape:l,value:i,dtype:o.dtype}})}let a=j().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new rk(o.shape,s,i):new tk(o.shape,s,i),u=[[i]];return e.runWebGLProgram(a,[o],o.dtype,u)},dne={kernelName:cl,backendName:"webgl",kernelFunc:I$};var QFe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,JFe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Os+`
  return result;
`,e$e=Zt({opSnippet:QFe,packedOpSnippet:JFe}),fne={kernelName:_a,backendName:"webgl",kernelFunc:e$e};function t$e(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=o.shape.length,u=[],l=b.parseAxisParam(s,o.shape),c=l,p=T.getAxesPermutation(c,a),d=o;p!=null&&(d=Pr({inputs:{x:o},backend:e,attrs:{perm:p}}),c=T.getInnerMostAxes(c.length,a),u.push(d)),T.assertAxesAreInnerMostDims("prod",c,a);let f;if(e.shouldExecuteOnCPU([d])){let h=e.texData.get(d.dataId).values,{outVals:m,outShape:g,outDtype:y}=eee(d.shape,d.dtype,h,c);f=e.makeTensorInfo(g,y,m)}else{let[h,m]=T.computeOutAndReduceShapes(d.shape,c),g=b.sizeFromShape(m),y=ve({inputs:{x:d},backend:e,attrs:{shape:[-1,g]}}),x=_c(o.dtype),w=Ms(y,x,"prod",e);f=ve({inputs:{x:w},backend:e,attrs:{shape:h}}),u.push(y),u.push(w)}if(i){u.push(f);let h=T.expandShapeToKeepDim(f.shape,l);f=ve({inputs:{x:f},backend:e,attrs:{shape:h}})}return u.forEach(h=>e.disposeIntermediateTensorInfo(h)),f}var hne={kernelName:dl,backendName:"webgl",kernelFunc:t$e};function r$e(r){let{inputs:t,backend:e,attrs:n}=r,{paramsNestedSplits:o,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:a}=n,u=o.map(y=>e.readSync(y.dataId)),l=o.map(y=>y.shape),c=e.readSync(s.dataId),p=e.readSync(i.dataId),[d,f,h]=tee(u,l,c,s.shape,s.dtype,p,i.shape,a),m=d.map(y=>e.makeTensorInfo([y.length],"int32",y)),g=e.makeTensorInfo(h,s.dtype,f);return m.concat([g])}var mne={kernelName:hg,backendName:"webgl",kernelFunc:r$e};function n$e(r){let{inputs:t,backend:e}=r,{starts:n,limits:o,deltas:s}=t,i=e.readSync(n.dataId),a=e.readSync(o.dataId),u=e.readSync(s.dataId),[l,c]=ree(i,n.shape,n.dtype,a,o.shape,u,s.shape),p=e.makeTensorInfo([l.length],"int32",l),d=e.makeTensorInfo([c.length],n.dtype,c);return[p,d]}var gne={kernelName:mg,backendName:"webgl",kernelFunc:n$e};function o$e(r){let{inputs:t,backend:e,attrs:n}=r,{shape:o,values:s,defaultValue:i,rowPartitionTensors:a}=t,{rowPartitionTypes:u}=n,l=e.readSync(o.dataId),c=e.readSync(s.dataId),p=e.readSync(i.dataId),d=a.map(g=>e.readSync(g.dataId)),f=a.map(g=>g.shape),[h,m]=nee(l,o.shape,c,s.shape,s.dtype,p,i.shape,d,f,u);return e.makeTensorInfo(h,s.dtype,m)}var yne={kernelName:gg,backendName:"webgl",kernelFunc:o$e};var T$=r=>{let{backend:t,attrs:e}=r,{start:n,stop:o,step:s,dtype:i}=e,a=oee(n,o,s,i);return t.makeTensorInfo([a.length],i,a)},xne={kernelName:id,backendName:"webgl",kernelFunc:T$};var s$e="return 1.0 / x;",i$e=Ve({opSnippet:s$e}),vne={kernelName:Ea,backendName:"webgl",kernelFunc:i$e};var a$e=kn+`
  return (x < 0.0) ? 0.0 : x;
`,u$e=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,l$e=Ve({opSnippet:a$e,packedOpSnippet:u$e}),bne={kernelName:ka,backendName:"webgl",kernelFunc:l$e};var c$e=kn+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,p$e=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,d$e=Ve({opSnippet:c$e,packedOpSnippet:p$e}),wne={kernelName:Na,backendName:"webgl",kernelFunc:d$e};var nk=class{constructor(t,e,n,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,u,l]=t;this.outputShape=[i,e,n,l];let c=[o&&e>1?a-1:a,o&&n>1?u-1:u],p=[o&&e>1?e-1:e,o&&n>1?n-1:n],d;s?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};var ok=class{constructor(t,e,n,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,u,l]=t;this.outputShape=[i,e,n,l];let c=[o&&e>1?a-1:a,o&&n>1?u-1:u],p=[o&&e>1?e-1:e,o&&n>1?n-1:n],d;s?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function f$e(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n,[u,l]=a,c=j().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ok(o.shape,u,l,s,i):new nk(o.shape,u,l,s,i);return e.runWebGLProgram(c,[o],"float32")}var Cne={kernelName:ml,backendName:"webgl",kernelFunc:f$e};var sk=class{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;let[,o,s]=e,[,i,a]=t,u=[n&&i>1?o-1:o,n&&a>1?s-1:s],l=[n&&i>1?i-1:i,n&&a>1?a-1:a],c=u[0]/l[0],p=u[1]/l[1],d=1/c,f=1/p,h=Math.ceil(d)*2+2,m=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${f});

        const int winHeight = int(${h});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function h$e(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:i}=n,a=new sk(s.shape,o.shape,i);return e.runWebGLProgram(a,[s],s.dtype)}var Sne={kernelName:ld,backendName:"webgl",kernelFunc:h$e};var ik=class{constructor(t,e,n,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,u,l]=t;this.outputShape=[i,e,n,l];let c=[o&&e>1?a-1:a,o&&n>1?u-1:u],p=[o&&e>1?e-1:e,o&&n>1?n-1:n],d=o?"0.5":"0.0",f;s?f="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};var ak=class{constructor(t,e,n,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,u,l]=t;this.outputShape=[i,e,n,l];let c=[o&&e>1?a-1:a,o&&n>1?u-1:u],p=[o&&e>1?e-1:e,o&&n>1?n-1:n],d=o?"0.5":"0.0",f;s?f="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function m$e(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n,[u,l]=a,c=j().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ak(o.shape,u,l,s,i):new ik(o.shape,u,l,s,i);return e.runWebGLProgram(c,[o],o.dtype)}var Ine={kernelName:hl,backendName:"webgl",kernelFunc:m$e};var uk=class{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;let[,o,s]=e,[,i,a]=t,u=[n&&i>1?o-1:o,n&&a>1?s-1:s],l=[n&&i>1?i-1:i,n&&a>1?a-1:a],c=u[0]/l[0],p=u[1]/l[1],d=1/c,f=1/p,h=Math.ceil(d)*2+2,m=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${f});

        const int winHeight = int(${h});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${o}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function g$e(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:i}=n,a=new uk(s.shape,o.shape,i);return e.runWebGLProgram(a,[s],s.dtype)}var Tne={kernelName:ud,backendName:"webgl",kernelFunc:g$e};var lk=class{constructor(t,e){this.variableNames=["x"];let n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}let o=a=>e.indexOf(a)!==-1&&t[a]!==1?`${t[a]} - coords[${a}] - 1`:`coords[${a}]`,s=t.map((a,u)=>o(u)).join(","),i=ut(n);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}};var ck=class{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=t;let o=un("rc",n),s=`${o[n-1]} + 1 < ${this.outputShape[n-1]}`,i=`${o[n-2]} + 1 < ${this.outputShape[n-2]}`,a=ut(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(o.slice())};
          if(${s}){
            result.g = ${l(o.slice())};
          }
          if(${i}) {
            result.b = ${c(o.slice())};
            if(${s}) {
              result.a = ${p(o.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(h){return d(h)}function l(h){return h[n-1]="("+h[n-1]+" + 1)",d(h)}function c(h){return h[n-2]="("+h[n-2]+" + 1)",d(h)}function p(h){return h[n-1]="("+h[n-1]+" + 1)",h[n-2]="("+h[n-2]+" + 1)",d(h)}function d(h){let m=t.map((x,w)=>f(w,h)),g=m.join(","),y=m.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function f(h,m){return e.indexOf(h)!==-1&&t[h]!==1?`${t[h]} - ${m[h]} - 1`:`${m[h]}`}}};function y$e(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dims:s}=n,i=o.shape.length,a=b.parseAxisParam(s,o.shape);if(i===0)return ln({inputs:{x:o},backend:e});let u=j().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ck(o.shape,a):new lk(o.shape,a);return e.runWebGLProgram(u,[o],o.dtype)}var _ne={kernelName:gl,backendName:"webgl",kernelFunc:y$e};var pk=class{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=t[1],o=t[2];this.outputShape=t;let s="";typeof e=="number"?s=`float outputValue = ${e.toFixed(2)};`:s=`
        vec3 fill = vec3(${e.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var Ene={kernelName:wd,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:n}=r,{radians:o,fillValue:s,center:i}=t,a=e,u=new pk(n.shape,s),[l,c]=T.getImageCenter(i,n.shape[1],n.shape[2]),p=[[l,c,Math.sin(o),Math.cos(o)]];return a.runWebGLProgram(u,[n],n.dtype,p)}};var x$e=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,v$e=Ve({opSnippet:x$e}),kne={kernelName:Da,backendName:"webgl",kernelFunc:v$e};var b$e="return inversesqrt(x);",w$e=Ve({opSnippet:b$e,cpuKernelImpl:see}),Nne={kernelName:Aa,backendName:"webgl",kernelFunc:w$e};var lf=class{constructor(t,e,n,o,s,i,a=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;let l=ut(s.length),c=ut(i.length),p="";n===1?p="i":n===2&&(p="i, j");let d=`getIndices(${p})`,f="";o===1?f="i":o===2&&(f="i, coords[1]");let h=`getUpdates(${f})`,m="";u&&(m="coords[0], coords[1]");let g=`getDefaultValue(${m})`,y=e>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${s});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${y};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${h};
              found = true;
            }
          }
          setOutput(mix(${g}, sum, float(found)));
        }
      `}};var dk=class{constructor(t,e,n,o,s,i,a=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;let l=ut(s.length),c=ut(i.length),p="";n===1?p="i":n===2&&(p="i, j");let d=`getIndices(${p})`,f="";o===1?f="i":o===2&&(f="i, coords[1]");let h=`getUpdates(${f})`,m="";u&&(m="coords[0], coords[1]");let g=`getDefaultValue(${m})`,y=e>1?"strides[j]":"strides",x=e>1?"strides[j + 1]":"strides";this.userCode=`
        ${l} strides = ${l}(${s});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${t}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${e}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${y};
              if (j + 1 < ${e}) {
                flattenedIndex += index.yw * ${x};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${h};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${g}, sum, found));
        }
      `}};function C$e(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o,updates:s}=t,{shape:i}=n,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:p}=T.calculateShapes(s,o,i),d=[p/l,l];if(p===0)return e.makeTensorInfo(i,o.dtype);let f=ve({inputs:{x:o},backend:e,attrs:{shape:[u,a]}}),h=ve({inputs:{x:s},backend:e,attrs:{shape:[u,l]}}),m=e.makeTensorInfo([],"float32",new Float32Array([0])),g;j().getBool("WEBGL_PACK")?g=new dk(u,a,f.shape.length,h.shape.length,c,d):g=new lf(u,a,f.shape.length,h.shape.length,c,d);let y=e.runWebGLProgram(g,[h,f,m],h.dtype),x=ve({inputs:{x:y},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(m),x}var Dne={kernelName:cd,backendName:"webgl",kernelFunc:C$e};var fk=class{constructor(t,e,n,o){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,n];let s="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=j().getNumber("WEBGL_VERSION")===2?s:i,u=o==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${u} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function S$e(r){let{inputs:t,backend:e,attrs:n}=r,{sortedSequence:o,values:s}=t,{side:i}=n,a=new fk(o.shape[0],o.shape[1],s.shape[1],i),u=[[o.shape[1]]];return e.runWebGLProgram(a,[o,s],"int32",u)}var Ane={kernelName:dd,backendName:"webgl",kernelFunc:S$e};var hk=class{constructor(t,e,n){this.variableNames=["c","a","b"],this.outputShape=e;let o,s;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)s="resRC",o="resRC";else{let a=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],l=[];for(let c=0;c<e.length;c++)l.push(`${a[c]}`),c<t&&u.push(`${a[c]}`);o=u.join(),s=l.join()}let i=ut(n);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${o});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function I$e(r){let{inputs:t,backend:e}=r,{condition:n,t:o,e:s}=t,i=new hk(n.shape.length,o.shape,o.shape.length);return e.runWebGLProgram(i,[n,o,s],mr(o.dtype,s.dtype))}var Rne={kernelName:yl,backendName:"webgl",kernelFunc:I$e};var T$e=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${T.SELU_SCALEALPHA};
  float scale = ${T.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,_$e=Ve({opSnippet:T$e}),One={kernelName:Ra,backendName:"webgl",kernelFunc:_$e};var E$e=$i+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,k$e=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,N$e=Ve({opSnippet:E$e,packedOpSnippet:k$e,cpuKernelImpl:aee}),Mne={kernelName:$a,backendName:"webgl",kernelFunc:N$e};var D$e=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,A$e=Ve({opSnippet:D$e}),Fne={kernelName:Fa,backendName:"webgl",kernelFunc:A$e};var R$e=$i+`
  return sin(x);
`,O$e=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Os}
  return result;
`,M$e=Ve({opSnippet:R$e,packedOpSnippet:O$e}),$ne={kernelName:Oa,backendName:"webgl",kernelFunc:M$e};var F$e=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,$$e=Ve({opSnippet:F$e}),Pne={kernelName:Ma,backendName:"webgl",kernelFunc:$$e};var P$e=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,L$e=Ve({opSnippet:P$e}),Lne={kernelName:Pa,backendName:"webgl",kernelFunc:L$e};var z$e=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,paddings:i}=n;b.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((y,x)=>y*x),u=[[0,0]];u.push(...i);for(let y=1+s.length;y<o.shape.length;++y)u.push([0,0]);let l=[],c=I$({inputs:{x:o},backend:e,attrs:{paddings:u,constantValue:0}}),p=T.getReshaped(c.shape,s,a,!1),d=T.getPermuted(p.length,s.length,!1),f=T.getReshapedPermuted(c.shape,s,a,!1),h=ve({inputs:{x:c},backend:e,attrs:{shape:p}}),m=Pr({inputs:{x:h},backend:e,attrs:{perm:d}}),g=ve({inputs:{x:m},backend:e,attrs:{shape:f}});return l.push(c),l.push(h),l.push(m),l.forEach(y=>e.disposeIntermediateTensorInfo(y)),g},zne={kernelName:bl,backendName:"webgl",kernelFunc:z$e};function B$e(r){let{inputs:t,backend:e}=r,{indices:n,values:o,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${n.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=e.readSync(n.dataId),u=e.readSync(o.dataId),l=e.readSync(s.dataId),c=e.readSync(i.dataId)[0],[p,d,f,h,m]=lee(a,n.shape,n.dtype,u,o.dtype,l,c);return[e.makeTensorInfo(d,n.dtype,p),e.makeTensorInfo([d[0]],o.dtype,f),e.makeTensorInfo([h.length],"bool",new Uint8Array(h.map(g=>Number(g)))),e.makeTensorInfo([m.length],n.dtype,new Int32Array(m))]}var Bne={kernelName:yg,backendName:"webgl",kernelFunc:B$e};function V$e(r){let{inputs:t,backend:e}=r,{inputIndices:n,inputShape:o,newShape:s}=t;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(e.readSync(o.dataId)),a=e.readSync(n.dataId),u=Array.from(e.readSync(s.dataId)),[l,c,p]=cee(a,n.shape,n.dtype,i,u);return[e.makeTensorInfo(c,n.dtype,l),e.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var Vne={kernelName:xg,backendName:"webgl",kernelFunc:V$e};function U$e(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=e.readSync(n.dataId),a=e.readSync(o.dataId),u=e.readSync(s.dataId),[l,c]=X1(i,n.shape,n.dtype,a,u,!0);return e.makeTensorInfo(c,n.dtype,l)}var Une={kernelName:fd,backendName:"webgl",kernelFunc:U$e};function G$e(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=e.readSync(n.dataId),a=e.readSync(o.dataId),u=e.readSync(s.dataId),[l,c]=X1(i,n.shape,n.dtype,a,u);return e.makeTensorInfo(c,n.dtype,l)}var Gne={kernelName:hd,backendName:"webgl",kernelFunc:G$e};function W$e(r){let{inputs:t,backend:e,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:i}=t,{outputShape:a}=n,{sliceRank:u,numUpdates:l,sliceSize:c,strides:p,outputSize:d}=T.calculateShapes(s,o,a),f=!1;if(s.dtype==="string"){let y=e.bufferSync(o),x=e.bufferSync(s),w=b.decodeString(e.readSync(i.dataId)[0]),C=iee(y,x,a,d,c,l,u,p,w,f);return e.makeTensorInfo(a,C.dtype,C.values)}let h=new lf(l,u,o.shape.length,s.shape.length,p,[d,1],f),m=e.runWebGLProgram(h,[s,o,i],s.dtype),g=ve({inputs:{x:m},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(m),g}var Wne={kernelName:md,backendName:"webgl",kernelFunc:W$e};function j$e(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{numOrSizeSplits:s,axis:i}=n,a=b.parseAxisParam(i,o.shape)[0],u=T.prepareSplitSize(o,s,a),l=o.shape.length,c=new Array(l).fill(0),p=o.shape.slice();return u.map(d=>{let f=[...p];f[a]=d;let h=cu({inputs:{x:o},backend:e,attrs:{begin:c,size:f}});return c[a]+=d,h})}var jne={kernelName:wl,backendName:"webgl",kernelFunc:j$e};var Hne="return sqrt(x);",H$e=Ve({opSnippet:Hne,packedOpSnippet:Hne,cpuKernelImpl:pee}),qne={kernelName:La,backendName:"webgl",kernelFunc:H$e};var q$e="return x * x;",K$e=Ve({opSnippet:q$e}),Kne={kernelName:gd,backendName:"webgl",kernelFunc:K$e};var Xne="return (a - b) * (a - b);",X$e=Zt({opSnippet:Xne,packedOpSnippet:Xne}),Yne={kernelName:za,backendName:"webgl",kernelFunc:X$e};function Y$e(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;if(o.dtype!=="string")throw new Error("Input must be of datatype string");let s=e.readSync(o.dataId),i=T.fromUint8ToStringArray(s),a=dee(i,"string",n);return e.makeTensorInfo(o.shape,"string",a)}var Zne={kernelName:rh,backendName:"webgl",kernelFunc:Y$e};function Z$e({inputs:r,attrs:t,backend:e}){let{x:n}=r,o=kn+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,s=new no(n.shape,o);return e.runWebGLProgram(s,[n],n.dtype)}var Qne={kernelName:Ga,backendName:"webgl",kernelFunc:Z$e};var mk=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;let o=n.length,s=ut(n.length),i=ut(n.length),a="";if(o===1)a="coords * strides + begin";else{let u=0;a=n.map((l,c)=>(u++,n.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${u-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${t});
      ${s} strides = ${s}(${e});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};function Q$e(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:d}=n,{finalShapeSparse:f,finalShape:h,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:x,end:w,strides:C}=en.sliceInfo(o.shape,s,i,a,u,l,c,p,d),I;if(m)I=ve({inputs:{x:o},backend:e,attrs:{shape:h}});else if(g||y){b.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let A=en.computeOutShape(x,w,C),O=cu({inputs:{x:o},backend:e,attrs:{begin:x,size:A}});I=ve({inputs:{x:O},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(O)}else if(e.shouldExecuteOnCPU([o])){let O=e.readSync(o.dataId),$=Ne(o.shape,o.dtype,O),z=fee(f,$,C,x);I=e.makeTensorInfo(h,o.dtype,z.values)}else{let O=new mk(x,C,f);I=e.runWebGLProgram(O,[o],o.dtype)}let N=ve({inputs:{x:I},backend:e,attrs:{shape:h}});return e.disposeIntermediateTensorInfo(I),N}var Jne={kernelName:yd,backendName:"webgl",kernelFunc:Q$e};function J$e(r){let{inputs:t,backend:e,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:l}=n,{data:c,dataSplits:p}=t,d=e.readSync(c.dataId),f=e.readSync(p.dataId),[h,m]=hee(d,f,o,s,i,a,u,l);return[e.makeTensorInfo([h.length],"string",h),e.makeTensorInfo(p.shape,"int32",m)]}var eoe={kernelName:xd,backendName:"webgl",kernelFunc:J$e};function ePe(r){let{inputs:t,backend:e,attrs:n}=r,{skipEmpty:o}=n,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=e.readSync(s.dataId),u=e.readSync(i.dataId)[0],[l,c,p]=mee(a,u,o),d=c.length;return[e.makeTensorInfo([d,2],"int32",l),e.makeTensorInfo([d],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(p))]}var toe={kernelName:vg,backendName:"webgl",kernelFunc:ePe};function tPe(r){let{inputs:t,backend:e,attrs:n}=r,{numBuckets:o}=n,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=e.readSync(s.dataId),a=gee(i,o);return e.makeTensorInfo(s.shape,"int32",a)}var roe={kernelName:bg,backendName:"webgl",kernelFunc:tPe};var rPe="return tan(x);",nPe=Ve({opSnippet:rPe}),noe={kernelName:Va,backendName:"webgl",kernelFunc:nPe};var oPe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,sPe=Ve({opSnippet:oPe}),ooe={kernelName:Ua,backendName:"webgl",kernelFunc:sPe};function iPe(r){let{inputs:t,backend:e,attrs:n}=r,{tensor:o,indices:s,updates:i}=t,{}=n,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:p}=T.calculateShapes(i,s,o.shape),d=[p/l,l];if(p===0)return e.makeTensorInfo(o.shape,s.dtype);let f=ve({inputs:{x:s},backend:e,attrs:{shape:[u,a]}}),h=ve({inputs:{x:i},backend:e,attrs:{shape:[u,l]}}),m=ve({inputs:{x:o},backend:e,attrs:{shape:d}}),g=new lf(u,a,f.shape.length,h.shape.length,c,d,!1,!0),y=e.runWebGLProgram(g,[h,f,m],m.dtype),x=ve({inputs:{x:y},backend:e,attrs:{shape:o.shape}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),x}var soe={kernelName:pd,backendName:"webgl",kernelFunc:iPe};var gk=class{constructor(t,e){this.variableNames=["A"];let n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[i]*e[i];this.outputShape=n,this.rank=n.length;let o=ut(this.rank),s=aPe(t);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function aPe(r){let t=r.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${r[0]})`;let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],n=[];for(let o=0;o<r.length;o++)n.push(`imod(${e[o]}, ${r[o]})`);return n.join()}function _$(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reps:s}=n;if(o.dtype==="string"||o.shape.length>5){let u=e.readSync(o.dataId),l=o.dtype==="string"?u.map(d=>b.decodeString(d)):u,c=Ne(o.shape,o.dtype,l),p=xee(c,s);return e.makeTensorInfo(p.shape,p.dtype,p.values)}let i=new gk(o.shape,s);return e.runWebGLProgram(i,[o],o.dtype)}var ioe={kernelName:hi,backendName:"webgl",kernelFunc:_$};var yk=class{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},xk=class{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function rm(r,t){t!==null&&r.disposeIntermediateTensorInfo(t)}function aoe(r){let t=1;for(;t<r;)t*=2;return t}function uPe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{k:s,sorted:i}=n,a=j().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=j().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=o.shape,c=l[l.length-1];if(e.shouldExecuteOnCPU([o])||c<a||s>u){let z=e.readSync(o.dataId),[G,K]=vee(z,l,o.dtype,s,i);return[e.makeTensorInfo(G.shape,G.dtype,G.values),e.makeTensorInfo(K.shape,K.dtype,K.values)]}if(s===0)return l[l.length-1]=0,[e.makeTensorInfo(l,o.dtype,[]),e.makeTensorInfo(l,"int32",[])];if(c===1)return[o,Zc({attrs:{shape:l,dtype:"int32",value:0},backend:e})];let p=e.texData.get(o.dataId),d=p!==null&&p.isPacked,f=d?e.unpackTensor(o):o,m=b.sizeFromShape(l)/c,g=ve({inputs:{x:f},attrs:{shape:[m,c]},backend:e});d&&rm(e,f);let y=aoe(s),x=aoe(c),w=null,C=()=>w===null?[g,g]:[g,w],I=(z,G,K)=>{let Z=C(),Q=new yk(K),te=[[c],[w===null?1:0],[Number.NEGATIVE_INFINITY],[z],[G]],ie=w;w=e.runWebGLProgram(Q,Z,"int32",te),rm(e,ie)};for(let z=1;z<y;z*=2){let G=z*2;for(let K=z;K>=1;K/=2)I(G,K,[m,x])}for(let z=x;z>y;z/=2){let G=C(),K=new xk([m,z/2]),Q=[[c],[w===null?1:0],[y]],J=w;w=e.runWebGLProgram(K,G,"int32",Q),rm(e,J);let te=y/2,ie=te*2;for(let ne=te;ne>=1;ne/=2)I(ie,ne,w.shape)}let N=w;w=cu({inputs:{x:w},backend:e,attrs:{begin:0,size:[m,s]}}),rm(e,N);let A=v$({inputs:{x:g,indices:w},backend:e,attrs:{axis:1,batchDims:1}});rm(e,g);let O=l.slice(0,-1);O.push(s),N=w,w=ve({inputs:{x:w},attrs:{shape:O},backend:e}),rm(e,N);let $=A;return A=ve({inputs:{x:A},attrs:{shape:O},backend:e}),rm(e,$),[A,w]}var uoe={kernelName:vd,backendName:"webgl",kernelFunc:uPe};var vk=class{constructor(t,e,n,o,s,i){this.variableNames=["Image","Transforms"],this.outputShape=i;let a=n==="nearest"?1:2,u;switch(o){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${e}));
                float mapY = mapCoord(inY, float(${t}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function lPe(r){let{inputs:t,backend:e,attrs:n}=r,{image:o,transforms:s}=t,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=n,[c,p,d,f]=o.shape,[h,m]=l??[p,d],g=[c,h,m,f],y=new vk(p,d,i,a,u,g);return e.runWebGLProgram(y,[o,s],"float32")}var loe={kernelName:bd,backendName:"webgl",kernelFunc:lPe};function cPe(r){let{inputs:t,attrs:e,backend:n}=r,{axis:o}=e,{x:s}=t;ql(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=n.readSync(s.dataId),{outputValues:a,outputShape:u,indices:l}=bee(i,o,s.shape,s.dtype);return[n.makeTensorInfo(u,s.dtype,a),n.makeTensorInfo([l.length],"int32",l)]}var coe={kernelName:wg,backendName:"webgl",kernelFunc:cPe};function pPe(r){let{inputs:t,backend:e,attrs:n}=r,{value:o}=t,{axis:s}=n;s<0&&(s+=o.shape.length);let i=o,a=i.shape.length,u=o.shape[s],l=new Array(a-1),c=0;for(let m=0;m<a;m++)m!==s&&(l[c++]=i.shape[m]);let p=[],d=new Array(a).fill(0),f=i.shape.slice();f[s]=1;let h=new Array(u);for(let m=0;m<h.length;m++){d[s]=m;let g=cu({inputs:{x:i},backend:e,attrs:{begin:d,size:f}}),y=ve({inputs:{x:g},backend:e,attrs:{shape:l}});h[m]=y,p.push(g)}return p.forEach(m=>e.disposeIntermediateTensorInfo(m)),h}var poe={kernelName:Sl,backendName:"webgl",kernelFunc:pPe};var bk=class{constructor(t,e){this.variableNames=["x","segmentIds"];let n=t.windowSize,o=t.batchSize,s=t.inSize,i=t.numSegments,a=i*Math.ceil(s/n);this.outputShape=[o,a];let u="0.0",l="sumValue",c=Math.floor(n/4)*4,p=n%4,d=`
        sumValue += dot(values, segFilter);
    `,f="";s%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let h="";s%n>0&&(h=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${h}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${l});
      }
    `}};function dPe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,segmentIds:s}=t,{numSegments:i}=n,a=o.shape.length,u=[],l=0,c=T.getAxesPermutation([l],a),p=o;c!=null&&(p=Pr({inputs:{x:o},backend:e,attrs:{perm:c}}),u.push(p),l=T.getInnerMostAxes(1,a)[0]);let d=T.segment_util.computeOutShape(p.shape,l,i),f=b.sizeFromShape([p.shape[l]]),h=ve({inputs:{x:p},backend:e,attrs:{shape:[-1,f]}});u.push(h);let m=_c(o.dtype),g=(C,I,N,A,O)=>{let $=C.shape[0],z=C.shape[1],G=T.segment_util.segOpComputeOptimalWindowSize(z,O),K={windowSize:G,inSize:z,batchSize:$,numSegments:O},Z=new bk(K,I),Q=e.compileAndRun(Z,[C,N],A);if(u.push(Q),Q.shape[1]===O)return Q;let J=T$({backend:e,attrs:{start:0,stop:O,step:1,dtype:"float32"}}),te=_$({inputs:{x:J},backend:e,attrs:{reps:[z/G]}});return u.push(J),u.push(te),g(Q,I,te,A,O)},y=g(h,"unsortedSegmentSum",s,m,i),x=ve({inputs:{x:y},backend:e,attrs:{shape:d}}),w=x;if(c!=null){u.push(x);let C=T.getUndoAxesPermutation(c);w=Pr({inputs:{x:w},backend:e,attrs:{perm:C}})}return u.forEach(C=>e.disposeIntermediateTensorInfo(C)),w}var doe={kernelName:Il,backendName:"webgl",kernelFunc:dPe};var fPe=[Kee,Yee,Zee,Qee,ete,tte,rte,nte,ite,ate,ute,lte,cte,pte,dte,fte,hte,mte,gte,yte,xte,bte,wte,Cte,Ste,Ete,Nte,Dte,Lee,Rte,Mte,Fte,$te,Pte,Lte,zte,Bte,Vte,Ute,Gte,Hte,qte,Kte,Xte,Yte,Zte,Qte,Jte,ere,tre,rre,nre,ore,sre,ire,are,lre,cre,pre,dre,hre,mre,gre,yre,xre,vre,bre,wre,Cre,Pee,Sre,Ote,Ire,Tre,_re,zee,Ere,kre,Nre,Dre,Are,Rre,Ore,Mre,Fre,$re,Lre,zre,Bre,Vre,Ure,Gre,jre,qre,Kre,Xre,Yre,Zre,rne,Uee,nne,one,sne,ine,Ite,ane,cne,pne,dne,fne,Bee,hne,mne,gne,yne,xne,Tte,Qre,vne,bne,wne,Wee,Cne,Sne,Ine,Tne,_ne,Ene,kne,Nne,Dne,Ane,Rne,One,Mne,Fne,$ne,Pne,vte,tne,Lne,zne,Bne,Vne,Une,Gne,Wne,jne,qne,Kne,Yne,Zne,Qne,Jne,eoe,toe,roe,ene,Hee,noe,ooe,soe,ioe,uoe,loe,qee,coe,poe,doe,une];for(let r of fPe)Sg(r);var nm={production:!0,mixpanelApiKey:"af85a6f92f0558a68810eb47ac470c7c",supabaseApiKey:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imh4cXZ5b3R5bGVzY3F4YWF5cWJsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjUyMDU3NjMsImV4cCI6MjA0MDc4MTc2M30.ypdZbKEQX7iZR8t6EoWFIJJj5sktkQGsNAt7kIjWkJk",supabaseProjectURL:"https://hxqvyotylescqxaayqbl.supabase.co",applicationLinkURLPreffix:"https://moveplayground.com"};var oo=function(r){return r[r.Document=0]="Document",r[r.DocumentType=1]="DocumentType",r[r.Element=2]="Element",r[r.Text=3]="Text",r[r.CDATA=4]="CDATA",r[r.Comment=5]="Comment",r}(oo||{});function mPe(r){return r.nodeType===r.ELEMENT_NODE}function cw(r){let t=r?.host;return t?.shadowRoot===r}function pw(r){return Object.prototype.toString.call(r)==="[object ShadowRoot]"}function gPe(r){return r.includes(" background-clip: text;")&&!r.includes(" -webkit-background-clip: text;")&&(r=r.replace(" background-clip: text;"," -webkit-background-clip: text; background-clip: text;")),r}function yPe(r){let{cssText:t}=r;if(t.split('"').length<3)return t;let e=["@import",`url(${JSON.stringify(r.href)})`];return r.layerName===""?e.push("layer"):r.layerName&&e.push(`layer(${r.layerName})`),r.supportsText&&e.push(`supports(${r.supportsText})`),r.media.length&&e.push(r.media.mediaText),e.join(" ")+";"}function _k(r){try{let t=r.rules||r.cssRules;return t?gPe(Array.from(t,Moe).join("")):null}catch{return null}}function Moe(r){let t;if(vPe(r))try{t=_k(r.styleSheet)||yPe(r)}catch{}else if(bPe(r)&&r.selectorText.includes(":"))return xPe(r.cssText);return t||r.cssText}function xPe(r){let t=/(\[(?:[\w-]+)[^\\])(:(?:[\w-]+)\])/gm;return r.replace(t,"$1\\$2")}function vPe(r){return"styleSheet"in r}function bPe(r){return"selectorText"in r}var Ek=class{constructor(){this.idNodeMap=new Map,this.nodeMetaMap=new WeakMap}getId(t){var e;if(!t)return-1;let n=(e=this.getMeta(t))===null||e===void 0?void 0:e.id;return n??-1}getNode(t){return this.idNodeMap.get(t)||null}getIds(){return Array.from(this.idNodeMap.keys())}getMeta(t){return this.nodeMetaMap.get(t)||null}removeNodeFromMap(t){let e=this.getId(t);this.idNodeMap.delete(e),t.childNodes&&t.childNodes.forEach(n=>this.removeNodeFromMap(n))}has(t){return this.idNodeMap.has(t)}hasNode(t){return this.nodeMetaMap.has(t)}add(t,e){let n=e.id;this.idNodeMap.set(n,t),this.nodeMetaMap.set(t,e)}replace(t,e){let n=this.getNode(t);if(n){let o=this.nodeMetaMap.get(n);o&&this.nodeMetaMap.set(e,o)}this.idNodeMap.set(t,e)}reset(){this.idNodeMap=new Map,this.nodeMetaMap=new WeakMap}};function wPe(){return new Ek}function q$({element:r,maskInputOptions:t,tagName:e,type:n,value:o,maskInputFn:s}){let i=o||"",a=n&&im(n);return(t[e.toLowerCase()]||a&&t[a])&&(s?i=s(i,r):i="*".repeat(i.length)),i}function im(r){return r.toLowerCase()}var foe="__rrweb_original__";function CPe(r){let t=r.getContext("2d");if(!t)return!0;let e=50;for(let n=0;n<r.width;n+=e)for(let o=0;o<r.height;o+=e){let s=t.getImageData,i=foe in s?s[foe]:s;if(new Uint32Array(i.call(t,n,o,Math.min(e,r.width-n),Math.min(e,r.height-o)).data.buffer).some(u=>u!==0))return!1}return!0}function K$(r){let t=r.type;return r.hasAttribute("data-rr-is-password")?"password":t?im(t):null}function Foe(r,t){var e;let n;try{n=new URL(r,t??window.location.href)}catch{return null}let o=/\.([0-9a-z]+)(?:$)/i,s=n.pathname.match(o);return(e=s?.[1])!==null&&e!==void 0?e:null}var SPe=1,IPe=new RegExp("[^a-z0-9-_:]"),mw=-2;function $oe(){return SPe++}function TPe(r){if(r instanceof HTMLFormElement)return"form";let t=im(r.tagName);return IPe.test(t)?"div":t}function _Pe(r){let t="";return r.indexOf("//")>-1?t=r.split("/").slice(0,3).join("/"):t=r.split("/")[0],t=t.split("?")[0],t}var px,hoe,EPe=/url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm,kPe=/^(?:[a-z+]+:)?\/\//i,NPe=/^www\..*/i,DPe=/^(data:)([^,]*),(.*)/i;function kk(r,t){return(r||"").replace(EPe,(e,n,o,s,i,a)=>{let u=o||i||a,l=n||s||"";if(!u)return e;if(kPe.test(u)||NPe.test(u))return`url(${l}${u}${l})`;if(DPe.test(u))return`url(${l}${u}${l})`;if(u[0]==="/")return`url(${l}${_Pe(t)+u}${l})`;let c=t.split("/"),p=u.split("/");c.pop();for(let d of p)d!=="."&&(d===".."?c.pop():c.push(d));return`url(${l}${c.join("/")}${l})`})}var APe=/^[^ \t\n\r\u000c]+/,RPe=/^[, \t\n\r\u000c]+/;function OPe(r,t){if(t.trim()==="")return t;let e=0;function n(s){let i,a=s.exec(t.substring(e));return a?(i=a[0],e+=i.length,i):""}let o=[];for(;n(RPe),!(e>=t.length);){let s=n(APe);if(s.slice(-1)===",")s=fx(r,s.substring(0,s.length-1)),o.push(s);else{let i="";s=fx(r,s);let a=!1;for(;;){let u=t.charAt(e);if(u===""){o.push((s+i).trim());break}else if(a)u===")"&&(a=!1);else if(u===","){e+=1,o.push((s+i).trim());break}else u==="("&&(a=!0);i+=u,e+=1}}}return o.join(", ")}function fx(r,t){if(!t||t.trim()==="")return t;let e=r.createElement("a");return e.href=t,e.href}function MPe(r){return!!(r.tagName==="svg"||r.ownerSVGElement)}function X$(){let r=document.createElement("a");return r.href="",r.href}function Poe(r,t,e,n){return n&&(e==="src"||e==="href"&&!(t==="use"&&n[0]==="#")||e==="xlink:href"&&n[0]!=="#"||e==="background"&&(t==="table"||t==="td"||t==="th")?fx(r,n):e==="srcset"?OPe(r,n):e==="style"?kk(n,X$()):t==="object"&&e==="data"?fx(r,n):n)}function Loe(r,t,e){return(r==="video"||r==="audio")&&t==="autoplay"}function FPe(r,t,e){try{if(typeof t=="string"){if(r.classList.contains(t))return!0}else for(let n=r.classList.length;n--;){let o=r.classList[n];if(t.test(o))return!0}if(e)return r.matches(e)}catch{}return!1}function Nk(r,t,e){if(!r)return!1;if(r.nodeType!==r.ELEMENT_NODE)return e?Nk(r.parentNode,t,e):!1;for(let n=r.classList.length;n--;){let o=r.classList[n];if(t.test(o))return!0}return e?Nk(r.parentNode,t,e):!1}function zoe(r,t,e,n){try{let o=r.nodeType===r.ELEMENT_NODE?r:r.parentElement;if(o===null)return!1;if(typeof t=="string"){if(n){if(o.closest(`.${t}`))return!0}else if(o.classList.contains(t))return!0}else if(Nk(o,t,n))return!0;if(e){if(n){if(o.closest(e))return!0}else if(o.matches(e))return!0}}catch{}return!1}function $Pe(r,t,e){let n=r.contentWindow;if(!n)return;let o=!1,s;try{s=n.document.readyState}catch{return}if(s!=="complete"){let a=setTimeout(()=>{o||(t(),o=!0)},e);r.addEventListener("load",()=>{clearTimeout(a),o=!0,t()});return}let i="about:blank";if(n.location.href!==i||r.src===i||r.src==="")return setTimeout(t,0),r.addEventListener("load",t);r.addEventListener("load",t)}function PPe(r,t,e){let n=!1,o;try{o=r.sheet}catch{return}if(o)return;let s=setTimeout(()=>{n||(t(),n=!0)},e);r.addEventListener("load",()=>{clearTimeout(s),n=!0,t()})}function LPe(r,t){let{doc:e,mirror:n,blockClass:o,blockSelector:s,needsMask:i,inlineStylesheet:a,maskInputOptions:u={},maskTextFn:l,maskInputFn:c,dataURLOptions:p={},inlineImages:d,recordCanvas:f,keepIframeSrcFn:h,newlyAddedElement:m=!1}=t,g=zPe(e,n);switch(r.nodeType){case r.DOCUMENT_NODE:return r.compatMode!=="CSS1Compat"?{type:oo.Document,childNodes:[],compatMode:r.compatMode}:{type:oo.Document,childNodes:[]};case r.DOCUMENT_TYPE_NODE:return{type:oo.DocumentType,name:r.name,publicId:r.publicId,systemId:r.systemId,rootId:g};case r.ELEMENT_NODE:return VPe(r,{doc:e,blockClass:o,blockSelector:s,inlineStylesheet:a,maskInputOptions:u,maskInputFn:c,dataURLOptions:p,inlineImages:d,recordCanvas:f,keepIframeSrcFn:h,newlyAddedElement:m,rootId:g});case r.TEXT_NODE:return BPe(r,{needsMask:i,maskTextFn:l,rootId:g});case r.CDATA_SECTION_NODE:return{type:oo.CDATA,textContent:"",rootId:g};case r.COMMENT_NODE:return{type:oo.Comment,textContent:r.textContent||"",rootId:g};default:return!1}}function zPe(r,t){if(!t.hasNode(r))return;let e=t.getId(r);return e===1?void 0:e}function BPe(r,t){var e;let{needsMask:n,maskTextFn:o,rootId:s}=t,i=r.parentNode&&r.parentNode.tagName,a=r.textContent,u=i==="STYLE"?!0:void 0,l=i==="SCRIPT"?!0:void 0;if(u&&a){try{r.nextSibling||r.previousSibling||!((e=r.parentNode.sheet)===null||e===void 0)&&e.cssRules&&(a=_k(r.parentNode.sheet))}catch(c){console.warn(`Cannot get CSS styles from text's parentNode. Error: ${c}`,r)}a=kk(a,X$())}return l&&(a="SCRIPT_PLACEHOLDER"),!u&&!l&&a&&n&&(a=o?o(a,r.parentElement):a.replace(/[\S]/g,"*")),{type:oo.Text,textContent:a||"",isStyle:u,rootId:s}}function VPe(r,t){let{doc:e,blockClass:n,blockSelector:o,inlineStylesheet:s,maskInputOptions:i={},maskInputFn:a,dataURLOptions:u={},inlineImages:l,recordCanvas:c,keepIframeSrcFn:p,newlyAddedElement:d=!1,rootId:f}=t,h=FPe(r,n,o),m=TPe(r),g={},y=r.attributes.length;for(let w=0;w<y;w++){let C=r.attributes[w];Loe(m,C.name,C.value)||(g[C.name]=Poe(e,m,im(C.name),C.value))}if(m==="link"&&s){let w=Array.from(e.styleSheets).find(I=>I.href===r.href),C=null;w&&(C=_k(w)),C&&(delete g.rel,delete g.href,g._cssText=kk(C,w.href))}if(m==="style"&&r.sheet&&!(r.innerText||r.textContent||"").trim().length){let w=_k(r.sheet);w&&(g._cssText=kk(w,X$()))}if(m==="input"||m==="textarea"||m==="select"){let w=r.value,C=r.checked;g.type!=="radio"&&g.type!=="checkbox"&&g.type!=="submit"&&g.type!=="button"&&w?g.value=q$({element:r,type:K$(r),tagName:m,value:w,maskInputOptions:i,maskInputFn:a}):C&&(g.checked=C)}if(m==="option"&&(r.selected&&!i.select?g.selected=!0:delete g.selected),m==="canvas"&&c){if(r.__context==="2d")CPe(r)||(g.rr_dataURL=r.toDataURL(u.type,u.quality));else if(!("__context"in r)){let w=r.toDataURL(u.type,u.quality),C=document.createElement("canvas");C.width=r.width,C.height=r.height;let I=C.toDataURL(u.type,u.quality);w!==I&&(g.rr_dataURL=w)}}if(m==="img"&&l){px||(px=e.createElement("canvas"),hoe=px.getContext("2d"));let w=r,C=w.crossOrigin;w.crossOrigin="anonymous";let I=()=>{w.removeEventListener("load",I);try{px.width=w.naturalWidth,px.height=w.naturalHeight,hoe.drawImage(w,0,0),g.rr_dataURL=px.toDataURL(u.type,u.quality)}catch(N){console.warn(`Cannot inline img src=${w.currentSrc}! Error: ${N}`)}C?g.crossOrigin=C:w.removeAttribute("crossorigin")};w.complete&&w.naturalWidth!==0?I():w.addEventListener("load",I)}if(m==="audio"||m==="video"){let w=g;w.rr_mediaState=r.paused?"paused":"played",w.rr_mediaCurrentTime=r.currentTime,w.rr_mediaPlaybackRate=r.playbackRate,w.rr_mediaMuted=r.muted,w.rr_mediaLoop=r.loop,w.rr_mediaVolume=r.volume}if(d||(r.scrollLeft&&(g.rr_scrollLeft=r.scrollLeft),r.scrollTop&&(g.rr_scrollTop=r.scrollTop)),h){let{width:w,height:C}=r.getBoundingClientRect();g={class:g.class,rr_width:`${w}px`,rr_height:`${C}px`}}m==="iframe"&&!p(g.src)&&(r.contentDocument||(g.rr_src=g.src),delete g.src);let x;try{customElements.get(m)&&(x=!0)}catch{}return{type:oo.Element,tagName:m,attributes:g,childNodes:[],isSVG:MPe(r)||void 0,needBlock:h,rootId:f,isCustom:x}}function rn(r){return r==null?"":r.toLowerCase()}function UPe(r,t){if(t.comment&&r.type===oo.Comment)return!0;if(r.type===oo.Element){if(t.script&&(r.tagName==="script"||r.tagName==="link"&&(r.attributes.rel==="preload"||r.attributes.rel==="modulepreload")&&r.attributes.as==="script"||r.tagName==="link"&&r.attributes.rel==="prefetch"&&typeof r.attributes.href=="string"&&Foe(r.attributes.href)==="js"))return!0;if(t.headFavicon&&(r.tagName==="link"&&r.attributes.rel==="shortcut icon"||r.tagName==="meta"&&(rn(r.attributes.name).match(/^msapplication-tile(image|color)$/)||rn(r.attributes.name)==="application-name"||rn(r.attributes.rel)==="icon"||rn(r.attributes.rel)==="apple-touch-icon"||rn(r.attributes.rel)==="shortcut icon")))return!0;if(r.tagName==="meta"){if(t.headMetaDescKeywords&&rn(r.attributes.name).match(/^description|keywords$/))return!0;if(t.headMetaSocial&&(rn(r.attributes.property).match(/^(og|twitter|fb):/)||rn(r.attributes.name).match(/^(og|twitter):/)||rn(r.attributes.name)==="pinterest"))return!0;if(t.headMetaRobots&&(rn(r.attributes.name)==="robots"||rn(r.attributes.name)==="googlebot"||rn(r.attributes.name)==="bingbot"))return!0;if(t.headMetaHttpEquiv&&r.attributes["http-equiv"]!==void 0)return!0;if(t.headMetaAuthorship&&(rn(r.attributes.name)==="author"||rn(r.attributes.name)==="generator"||rn(r.attributes.name)==="framework"||rn(r.attributes.name)==="publisher"||rn(r.attributes.name)==="progid"||rn(r.attributes.property).match(/^article:/)||rn(r.attributes.property).match(/^product:/)))return!0;if(t.headMetaVerification&&(rn(r.attributes.name)==="google-site-verification"||rn(r.attributes.name)==="yandex-verification"||rn(r.attributes.name)==="csrf-token"||rn(r.attributes.name)==="p:domain_verify"||rn(r.attributes.name)==="verify-v1"||rn(r.attributes.name)==="verification"||rn(r.attributes.name)==="shopify-checkout-api-token"))return!0}}return!1}function hx(r,t){let{doc:e,mirror:n,blockClass:o,blockSelector:s,maskTextClass:i,maskTextSelector:a,skipChild:u=!1,inlineStylesheet:l=!0,maskInputOptions:c={},maskTextFn:p,maskInputFn:d,slimDOMOptions:f,dataURLOptions:h={},inlineImages:m=!1,recordCanvas:g=!1,onSerialize:y,onIframeLoad:x,iframeLoadTimeout:w=5e3,onStylesheetLoad:C,stylesheetLoadTimeout:I=5e3,keepIframeSrcFn:N=()=>!1,newlyAddedElement:A=!1}=t,{needsMask:O}=t,{preserveWhiteSpace:$=!0}=t;!O&&r.childNodes&&(O=zoe(r,i,a,O===void 0));let z=LPe(r,{doc:e,mirror:n,blockClass:o,blockSelector:s,needsMask:O,inlineStylesheet:l,maskInputOptions:c,maskTextFn:p,maskInputFn:d,dataURLOptions:h,inlineImages:m,recordCanvas:g,keepIframeSrcFn:N,newlyAddedElement:A});if(!z)return console.warn(r,"not serialized"),null;let G;n.hasNode(r)?G=n.getId(r):UPe(z,f)||!$&&z.type===oo.Text&&!z.isStyle&&!z.textContent.replace(/^\s+|\s+$/gm,"").length?G=mw:G=$oe();let K=Object.assign(z,{id:G});if(n.add(r,K),G===mw)return null;y&&y(r);let Z=!u;if(K.type===oo.Element){Z=Z&&!K.needBlock,delete K.needBlock;let Q=r.shadowRoot;Q&&pw(Q)&&(K.isShadowHost=!0)}if((K.type===oo.Document||K.type===oo.Element)&&Z){f.headWhitespace&&K.type===oo.Element&&K.tagName==="head"&&($=!1);let Q={doc:e,mirror:n,blockClass:o,blockSelector:s,needsMask:O,maskTextClass:i,maskTextSelector:a,skipChild:u,inlineStylesheet:l,maskInputOptions:c,maskTextFn:p,maskInputFn:d,slimDOMOptions:f,dataURLOptions:h,inlineImages:m,recordCanvas:g,preserveWhiteSpace:$,onSerialize:y,onIframeLoad:x,iframeLoadTimeout:w,onStylesheetLoad:C,stylesheetLoadTimeout:I,keepIframeSrcFn:N};if(!(K.type===oo.Element&&K.tagName==="textarea"&&K.attributes.value!==void 0))for(let J of Array.from(r.childNodes)){let te=hx(J,Q);te&&K.childNodes.push(te)}if(mPe(r)&&r.shadowRoot)for(let J of Array.from(r.shadowRoot.childNodes)){let te=hx(J,Q);te&&(pw(r.shadowRoot)&&(te.isShadow=!0),K.childNodes.push(te))}}return r.parentNode&&cw(r.parentNode)&&pw(r.parentNode)&&(K.isShadow=!0),K.type===oo.Element&&K.tagName==="iframe"&&$Pe(r,()=>{let Q=r.contentDocument;if(Q&&x){let J=hx(Q,{doc:Q,mirror:n,blockClass:o,blockSelector:s,needsMask:O,maskTextClass:i,maskTextSelector:a,skipChild:!1,inlineStylesheet:l,maskInputOptions:c,maskTextFn:p,maskInputFn:d,slimDOMOptions:f,dataURLOptions:h,inlineImages:m,recordCanvas:g,preserveWhiteSpace:$,onSerialize:y,onIframeLoad:x,iframeLoadTimeout:w,onStylesheetLoad:C,stylesheetLoadTimeout:I,keepIframeSrcFn:N});J&&x(r,J)}},w),K.type===oo.Element&&K.tagName==="link"&&typeof K.attributes.rel=="string"&&(K.attributes.rel==="stylesheet"||K.attributes.rel==="preload"&&typeof K.attributes.href=="string"&&Foe(K.attributes.href)==="css")&&PPe(r,()=>{if(C){let Q=hx(r,{doc:e,mirror:n,blockClass:o,blockSelector:s,needsMask:O,maskTextClass:i,maskTextSelector:a,skipChild:!1,inlineStylesheet:l,maskInputOptions:c,maskTextFn:p,maskInputFn:d,slimDOMOptions:f,dataURLOptions:h,inlineImages:m,recordCanvas:g,preserveWhiteSpace:$,onSerialize:y,onIframeLoad:x,iframeLoadTimeout:w,onStylesheetLoad:C,stylesheetLoadTimeout:I,keepIframeSrcFn:N});Q&&C(r,Q)}},I),K}function GPe(r,t){let{mirror:e=new Ek,blockClass:n="rr-block",blockSelector:o=null,maskTextClass:s="rr-mask",maskTextSelector:i=null,inlineStylesheet:a=!0,inlineImages:u=!1,recordCanvas:l=!1,maskAllInputs:c=!1,maskTextFn:p,maskInputFn:d,slimDOM:f=!1,dataURLOptions:h,preserveWhiteSpace:m,onSerialize:g,onIframeLoad:y,iframeLoadTimeout:x,onStylesheetLoad:w,stylesheetLoadTimeout:C,keepIframeSrcFn:I=()=>!1}=t||{};return hx(r,{doc:r,mirror:e,blockClass:n,blockSelector:o,maskTextClass:s,maskTextSelector:i,skipChild:!1,inlineStylesheet:a,maskInputOptions:c===!0?{color:!0,date:!0,"datetime-local":!0,email:!0,month:!0,number:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0,textarea:!0,select:!0,password:!0}:c===!1?{password:!0}:c,maskTextFn:p,maskInputFn:d,slimDOMOptions:f===!0||f==="all"?{script:!0,comment:!0,headFavicon:!0,headWhitespace:!0,headMetaDescKeywords:f==="all",headMetaSocial:!0,headMetaRobots:!0,headMetaHttpEquiv:!0,headMetaAuthorship:!0,headMetaVerification:!0}:f===!1?{}:f,dataURLOptions:h,inlineImages:u,recordCanvas:l,preserveWhiteSpace:m,onSerialize:g,onIframeLoad:y,iframeLoadTimeout:x,onStylesheetLoad:w,stylesheetLoadTimeout:C,keepIframeSrcFn:I,newlyAddedElement:!1})}function us(r,t,e=document){let n={capture:!0,passive:!0};return e.addEventListener(r,t,n),()=>e.removeEventListener(r,t,n)}var dx=`Please stop import mirror directly. Instead of that,\r
now you can use replayer.getMirror() to access the mirror instance of a replayer,\r
or you can use record.mirror to access the mirror instance during recording.`,moe={map:{},getId(){return console.error(dx),-1},getNode(){return console.error(dx),null},removeNodeFromMap(){console.error(dx)},has(){return console.error(dx),!1},reset(){console.error(dx)}};typeof window<"u"&&window.Proxy&&window.Reflect&&(moe=new Proxy(moe,{get(r,t,e){return t==="map"&&console.error(dx),Reflect.get(r,t,e)}}));function gw(r,t,e={}){let n=null,o=0;return function(...s){let i=Date.now();!o&&e.leading===!1&&(o=i);let a=t-(i-o),u=this;a<=0||a>t?(n&&(clearTimeout(n),n=null),o=i,r.apply(u,s)):!n&&e.trailing!==!1&&(n=setTimeout(()=>{o=e.leading===!1?0:Date.now(),n=null,r.apply(u,s)},a))}}function Bk(r,t,e,n,o=window){let s=o.Object.getOwnPropertyDescriptor(r,t);return o.Object.defineProperty(r,t,n?e:{set(i){setTimeout(()=>{e.set.call(this,i)},0),s&&s.set&&s.set.call(this,i)}}),()=>Bk(r,t,s||{},!0)}function wx(r,t,e){try{if(!(t in r))return()=>{};let n=r[t],o=e(n);return typeof o=="function"&&(o.prototype=o.prototype||{},Object.defineProperties(o,{__rrweb_original__:{enumerable:!1,value:n}})),r[t]=o,()=>{r[t]=n}}catch{return()=>{}}}var Dk=Date.now;/[1-9][0-9]{12}/.test(Date.now().toString())||(Dk=()=>new Date().getTime());function Boe(r){var t,e,n,o,s,i;let a=r.document;return{left:a.scrollingElement?a.scrollingElement.scrollLeft:r.pageXOffset!==void 0?r.pageXOffset:a?.documentElement.scrollLeft||((e=(t=a?.body)===null||t===void 0?void 0:t.parentElement)===null||e===void 0?void 0:e.scrollLeft)||((n=a?.body)===null||n===void 0?void 0:n.scrollLeft)||0,top:a.scrollingElement?a.scrollingElement.scrollTop:r.pageYOffset!==void 0?r.pageYOffset:a?.documentElement.scrollTop||((s=(o=a?.body)===null||o===void 0?void 0:o.parentElement)===null||s===void 0?void 0:s.scrollTop)||((i=a?.body)===null||i===void 0?void 0:i.scrollTop)||0}}function Voe(){return window.innerHeight||document.documentElement&&document.documentElement.clientHeight||document.body&&document.body.clientHeight}function Uoe(){return window.innerWidth||document.documentElement&&document.documentElement.clientWidth||document.body&&document.body.clientWidth}function Goe(r){return r?r.nodeType===r.ELEMENT_NODE?r:r.parentElement:null}function ls(r,t,e,n){if(!r)return!1;let o=Goe(r);if(!o)return!1;try{if(typeof t=="string"){if(o.classList.contains(t)||n&&o.closest("."+t)!==null)return!0}else if(Nk(o,t,n))return!0}catch{}return!!(e&&(o.matches(e)||n&&o.closest(e)!==null))}function WPe(r,t){return t.getId(r)!==-1}function E$(r,t){return t.getId(r)===mw}function Woe(r,t){if(cw(r))return!1;let e=t.getId(r);return t.has(e)?r.parentNode&&r.parentNode.nodeType===r.DOCUMENT_NODE?!1:r.parentNode?Woe(r.parentNode,t):!0:!0}function M$(r){return!!r.changedTouches}function jPe(r=window){"NodeList"in r&&!r.NodeList.prototype.forEach&&(r.NodeList.prototype.forEach=Array.prototype.forEach),"DOMTokenList"in r&&!r.DOMTokenList.prototype.forEach&&(r.DOMTokenList.prototype.forEach=Array.prototype.forEach),Node.prototype.contains||(Node.prototype.contains=(...t)=>{let e=t[0];if(!(0 in t))throw new TypeError("1 argument is required");do if(this===e)return!0;while(e=e&&e.parentNode);return!1})}function joe(r,t){return!!(r.nodeName==="IFRAME"&&t.getMeta(r))}function Hoe(r,t){return!!(r.nodeName==="LINK"&&r.nodeType===r.ELEMENT_NODE&&r.getAttribute&&r.getAttribute("rel")==="stylesheet"&&t.getMeta(r))}function F$(r){return!!r?.shadowRoot}var $$=class{constructor(){this.id=1,this.styleIDMap=new WeakMap,this.idStyleMap=new Map}getId(t){var e;return(e=this.styleIDMap.get(t))!==null&&e!==void 0?e:-1}has(t){return this.styleIDMap.has(t)}add(t,e){if(this.has(t))return this.getId(t);let n;return e===void 0?n=this.id++:n=e,this.styleIDMap.set(t,n),this.idStyleMap.set(n,t),n}getStyle(t){return this.idStyleMap.get(t)||null}reset(){this.styleIDMap=new WeakMap,this.idStyleMap=new Map,this.id=1}generateId(){return this.id++}};function qoe(r){var t,e;let n=null;return((e=(t=r.getRootNode)===null||t===void 0?void 0:t.call(r))===null||e===void 0?void 0:e.nodeType)===Node.DOCUMENT_FRAGMENT_NODE&&r.getRootNode().host&&(n=r.getRootNode().host),n}function HPe(r){let t=r,e;for(;e=qoe(t);)t=e;return t}function qPe(r){let t=r.ownerDocument;if(!t)return!1;let e=HPe(r);return t.contains(e)}function Koe(r){let t=r.ownerDocument;return t?t.contains(r)||qPe(r):!1}var dr=(r=>(r[r.DomContentLoaded=0]="DomContentLoaded",r[r.Load=1]="Load",r[r.FullSnapshot=2]="FullSnapshot",r[r.IncrementalSnapshot=3]="IncrementalSnapshot",r[r.Meta=4]="Meta",r[r.Custom=5]="Custom",r[r.Plugin=6]="Plugin",r))(dr||{}),rr=(r=>(r[r.Mutation=0]="Mutation",r[r.MouseMove=1]="MouseMove",r[r.MouseInteraction=2]="MouseInteraction",r[r.Scroll=3]="Scroll",r[r.ViewportResize=4]="ViewportResize",r[r.Input=5]="Input",r[r.TouchMove=6]="TouchMove",r[r.MediaInteraction=7]="MediaInteraction",r[r.StyleSheetRule=8]="StyleSheetRule",r[r.CanvasMutation=9]="CanvasMutation",r[r.Font=10]="Font",r[r.Log=11]="Log",r[r.Drag=12]="Drag",r[r.StyleDeclaration=13]="StyleDeclaration",r[r.Selection=14]="Selection",r[r.AdoptedStyleSheet=15]="AdoptedStyleSheet",r[r.CustomElement=16]="CustomElement",r))(rr||{}),Fs=(r=>(r[r.MouseUp=0]="MouseUp",r[r.MouseDown=1]="MouseDown",r[r.Click=2]="Click",r[r.ContextMenu=3]="ContextMenu",r[r.DblClick=4]="DblClick",r[r.Focus=5]="Focus",r[r.Blur=6]="Blur",r[r.TouchStart=7]="TouchStart",r[r.TouchMove_Departed=8]="TouchMove_Departed",r[r.TouchEnd=9]="TouchEnd",r[r.TouchCancel=10]="TouchCancel",r))(Fs||{}),Qc=(r=>(r[r.Mouse=0]="Mouse",r[r.Pen=1]="Pen",r[r.Touch=2]="Touch",r))(Qc||{}),xx=(r=>(r[r["2D"]=0]="2D",r[r.WebGL=1]="WebGL",r[r.WebGL2=2]="WebGL2",r))(xx||{});function goe(r){return"__ln"in r}var P$=class{constructor(){this.length=0,this.head=null,this.tail=null}get(t){if(t>=this.length)throw new Error("Position outside of list range");let e=this.head;for(let n=0;n<t;n++)e=e?.next||null;return e}addNode(t){let e={value:t,previous:null,next:null};if(t.__ln=e,t.previousSibling&&goe(t.previousSibling)){let n=t.previousSibling.__ln.next;e.next=n,e.previous=t.previousSibling.__ln,t.previousSibling.__ln.next=e,n&&(n.previous=e)}else if(t.nextSibling&&goe(t.nextSibling)&&t.nextSibling.__ln.previous){let n=t.nextSibling.__ln.previous;e.previous=n,e.next=t.nextSibling.__ln,t.nextSibling.__ln.previous=e,n&&(n.next=e)}else this.head&&(this.head.previous=e),e.next=this.head,this.head=e;e.next===null&&(this.tail=e),this.length++}removeNode(t){let e=t.__ln;this.head&&(e.previous?(e.previous.next=e.next,e.next?e.next.previous=e.previous:this.tail=e.previous):(this.head=e.next,this.head?this.head.previous=null:this.tail=null),t.__ln&&delete t.__ln,this.length--)}},yoe=(r,t)=>`${r}@${t}`,L$=class{constructor(){this.frozen=!1,this.locked=!1,this.texts=[],this.attributes=[],this.attributeMap=new WeakMap,this.removes=[],this.mapRemoves=[],this.movedMap={},this.addedSet=new Set,this.movedSet=new Set,this.droppedSet=new Set,this.processMutations=t=>{t.forEach(this.processMutation),this.emit()},this.emit=()=>{if(this.frozen||this.locked)return;let t=[],e=new Set,n=new P$,o=u=>{let l=u,c=mw;for(;c===mw;)l=l&&l.nextSibling,c=l&&this.mirror.getId(l);return c},s=u=>{if(!u.parentNode||!Koe(u)||u.parentNode.tagName==="TEXTAREA")return;let l=cw(u.parentNode)?this.mirror.getId(qoe(u)):this.mirror.getId(u.parentNode),c=o(u);if(l===-1||c===-1)return n.addNode(u);let p=hx(u,{doc:this.doc,mirror:this.mirror,blockClass:this.blockClass,blockSelector:this.blockSelector,maskTextClass:this.maskTextClass,maskTextSelector:this.maskTextSelector,skipChild:!0,newlyAddedElement:!0,inlineStylesheet:this.inlineStylesheet,maskInputOptions:this.maskInputOptions,maskTextFn:this.maskTextFn,maskInputFn:this.maskInputFn,slimDOMOptions:this.slimDOMOptions,dataURLOptions:this.dataURLOptions,recordCanvas:this.recordCanvas,inlineImages:this.inlineImages,onSerialize:d=>{joe(d,this.mirror)&&this.iframeManager.addIframe(d),Hoe(d,this.mirror)&&this.stylesheetManager.trackLinkElement(d),F$(u)&&this.shadowDomManager.addShadowRoot(u.shadowRoot,this.doc)},onIframeLoad:(d,f)=>{this.iframeManager.attachIframe(d,f),this.shadowDomManager.observeAttachShadow(d)},onStylesheetLoad:(d,f)=>{this.stylesheetManager.attachLinkElement(d,f)}});p&&(t.push({parentId:l,nextId:c,node:p}),e.add(p.id))};for(;this.mapRemoves.length;)this.mirror.removeNodeFromMap(this.mapRemoves.shift());for(let u of this.movedSet)xoe(this.removes,u,this.mirror)&&!this.movedSet.has(u.parentNode)||s(u);for(let u of this.addedSet)!voe(this.droppedSet,u)&&!xoe(this.removes,u,this.mirror)||voe(this.movedSet,u)?s(u):this.droppedSet.add(u);let i=null;for(;n.length;){let u=null;if(i){let l=this.mirror.getId(i.value.parentNode),c=o(i.value);l!==-1&&c!==-1&&(u=i)}if(!u){let l=n.tail;for(;l;){let c=l;if(l=l.previous,c){let p=this.mirror.getId(c.value.parentNode);if(o(c.value)===-1)continue;if(p!==-1){u=c;break}else{let f=c.value;if(f.parentNode&&f.parentNode.nodeType===Node.DOCUMENT_FRAGMENT_NODE){let h=f.parentNode.host;if(this.mirror.getId(h)!==-1){u=c;break}}}}}}if(!u){for(;n.head;)n.removeNode(n.head.value);break}i=u.previous,n.removeNode(u.value),s(u.value)}let a={texts:this.texts.map(u=>{let l=u.node;return l.parentNode&&l.parentNode.tagName==="TEXTAREA"&&this.genTextAreaValueMutation(l.parentNode),{id:this.mirror.getId(l),value:u.value}}).filter(u=>!e.has(u.id)).filter(u=>this.mirror.has(u.id)),attributes:this.attributes.map(u=>{let{attributes:l}=u;if(typeof l.style=="string"){let c=JSON.stringify(u.styleDiff),p=JSON.stringify(u._unchangedStyles);c.length<l.style.length&&(c+p).split("var(").length===l.style.split("var(").length&&(l.style=u.styleDiff)}return{id:this.mirror.getId(u.node),attributes:l}}).filter(u=>!e.has(u.id)).filter(u=>this.mirror.has(u.id)),removes:this.removes,adds:t};!a.texts.length&&!a.attributes.length&&!a.removes.length&&!a.adds.length||(this.texts=[],this.attributes=[],this.attributeMap=new WeakMap,this.removes=[],this.addedSet=new Set,this.movedSet=new Set,this.droppedSet=new Set,this.movedMap={},this.mutationCb(a))},this.genTextAreaValueMutation=t=>{let e=this.attributeMap.get(t);e||(e={node:t,attributes:{},styleDiff:{},_unchangedStyles:{}},this.attributes.push(e),this.attributeMap.set(t,e)),e.attributes.value=Array.from(t.childNodes,n=>n.textContent||"").join("")},this.processMutation=t=>{if(!E$(t.target,this.mirror))switch(t.type){case"characterData":{let e=t.target.textContent;!ls(t.target,this.blockClass,this.blockSelector,!1)&&e!==t.oldValue&&this.texts.push({value:zoe(t.target,this.maskTextClass,this.maskTextSelector,!0)&&e?this.maskTextFn?this.maskTextFn(e,Goe(t.target)):e.replace(/[\S]/g,"*"):e,node:t.target});break}case"attributes":{let e=t.target,n=t.attributeName,o=t.target.getAttribute(n);if(n==="value"){let i=K$(e);o=q$({element:e,maskInputOptions:this.maskInputOptions,tagName:e.tagName,type:i,value:o,maskInputFn:this.maskInputFn})}if(ls(t.target,this.blockClass,this.blockSelector,!1)||o===t.oldValue)return;let s=this.attributeMap.get(t.target);if(e.tagName==="IFRAME"&&n==="src"&&!this.keepIframeSrcFn(o))if(!e.contentDocument)n="rr_src";else return;if(s||(s={node:t.target,attributes:{},styleDiff:{},_unchangedStyles:{}},this.attributes.push(s),this.attributeMap.set(t.target,s)),n==="type"&&e.tagName==="INPUT"&&(t.oldValue||"").toLowerCase()==="password"&&e.setAttribute("data-rr-is-password","true"),!Loe(e.tagName,n)&&(s.attributes[n]=Poe(this.doc,im(e.tagName),im(n),o),n==="style")){if(!this.unattachedDoc)try{this.unattachedDoc=document.implementation.createHTMLDocument()}catch{this.unattachedDoc=this.doc}let i=this.unattachedDoc.createElement("span");t.oldValue&&i.setAttribute("style",t.oldValue);for(let a of Array.from(e.style)){let u=e.style.getPropertyValue(a),l=e.style.getPropertyPriority(a);u!==i.style.getPropertyValue(a)||l!==i.style.getPropertyPriority(a)?l===""?s.styleDiff[a]=u:s.styleDiff[a]=[u,l]:s._unchangedStyles[a]=[u,l]}for(let a of Array.from(i.style))e.style.getPropertyValue(a)===""&&(s.styleDiff[a]=!1)}break}case"childList":{if(ls(t.target,this.blockClass,this.blockSelector,!0))return;if(t.target.tagName==="TEXTAREA"){this.genTextAreaValueMutation(t.target);return}t.addedNodes.forEach(e=>this.genAdds(e,t.target)),t.removedNodes.forEach(e=>{let n=this.mirror.getId(e),o=cw(t.target)?this.mirror.getId(t.target.host):this.mirror.getId(t.target);ls(t.target,this.blockClass,this.blockSelector,!1)||E$(e,this.mirror)||!WPe(e,this.mirror)||(this.addedSet.has(e)?(z$(this.addedSet,e),this.droppedSet.add(e)):this.addedSet.has(t.target)&&n===-1||Woe(t.target,this.mirror)||(this.movedSet.has(e)&&this.movedMap[yoe(n,o)]?z$(this.movedSet,e):this.removes.push({parentId:o,id:n,isShadow:cw(t.target)&&pw(t.target)?!0:void 0})),this.mapRemoves.push(e))});break}}},this.genAdds=(t,e)=>{if(!this.processedNodeManager.inOtherBuffer(t,this)&&!(this.addedSet.has(t)||this.movedSet.has(t))){if(this.mirror.hasNode(t)){if(E$(t,this.mirror))return;this.movedSet.add(t);let n=null;e&&this.mirror.hasNode(e)&&(n=this.mirror.getId(e)),n&&n!==-1&&(this.movedMap[yoe(this.mirror.getId(t),n)]=!0)}else this.addedSet.add(t),this.droppedSet.delete(t);ls(t,this.blockClass,this.blockSelector,!1)||(t.childNodes.forEach(n=>this.genAdds(n)),F$(t)&&t.shadowRoot.childNodes.forEach(n=>{this.processedNodeManager.add(n,this),this.genAdds(n,t)}))}}}init(t){["mutationCb","blockClass","blockSelector","maskTextClass","maskTextSelector","inlineStylesheet","maskInputOptions","maskTextFn","maskInputFn","keepIframeSrcFn","recordCanvas","inlineImages","slimDOMOptions","dataURLOptions","doc","mirror","iframeManager","stylesheetManager","shadowDomManager","canvasManager","processedNodeManager"].forEach(e=>{this[e]=t[e]})}freeze(){this.frozen=!0,this.canvasManager.freeze()}unfreeze(){this.frozen=!1,this.canvasManager.unfreeze(),this.emit()}isFrozen(){return this.frozen}lock(){this.locked=!0,this.canvasManager.lock()}unlock(){this.locked=!1,this.canvasManager.unlock(),this.emit()}reset(){this.shadowDomManager.reset(),this.canvasManager.reset()}};function z$(r,t){r.delete(t),t.childNodes.forEach(e=>z$(r,e))}function xoe(r,t,e){return r.length===0?!1:Xoe(r,t,e)}function Xoe(r,t,e){let{parentNode:n}=t;if(!n)return!1;let o=e.getId(n);return r.some(s=>s.id===o)?!0:Xoe(r,n,e)}function voe(r,t){return r.size===0?!1:Yoe(r,t)}function Yoe(r,t){let{parentNode:e}=t;return e?r.has(e)?!0:Yoe(r,e):!1}var dw;function KPe(r){dw=r}function XPe(){dw=void 0}var ar=r=>dw?(...e)=>{try{return r(...e)}catch(n){if(dw&&dw(n)===!0)return;throw n}}:r,om=[];function vw(r){try{if("composedPath"in r){let t=r.composedPath();if(t.length)return t[0]}else if("path"in r&&r.path.length)return r.path[0]}catch{}return r&&r.target}function Zoe(r,t){var e,n;let o=new L$;om.push(o),o.init(r);let s=window.MutationObserver||window.__rrMutationObserver,i=(n=(e=window?.Zone)===null||e===void 0?void 0:e.__symbol__)===null||n===void 0?void 0:n.call(e,"MutationObserver");i&&window[i]&&(s=window[i]);let a=new s(ar(o.processMutations.bind(o)));return a.observe(t,{attributes:!0,attributeOldValue:!0,characterData:!0,characterDataOldValue:!0,childList:!0,subtree:!0}),a}function YPe({mousemoveCb:r,sampling:t,doc:e,mirror:n}){if(t.mousemove===!1)return()=>{};let o=typeof t.mousemove=="number"?t.mousemove:50,s=typeof t.mousemoveCallback=="number"?t.mousemoveCallback:500,i=[],a,u=gw(ar(p=>{let d=Date.now()-a;r(i.map(f=>(f.timeOffset-=d,f)),p),i=[],a=null}),s),l=ar(gw(ar(p=>{let d=vw(p),{clientX:f,clientY:h}=M$(p)?p.changedTouches[0]:p;a||(a=Dk()),i.push({x:f,y:h,id:n.getId(d),timeOffset:Dk()-a}),u(typeof DragEvent<"u"&&p instanceof DragEvent?rr.Drag:p instanceof MouseEvent?rr.MouseMove:rr.TouchMove)}),o,{trailing:!1})),c=[us("mousemove",l,e),us("touchmove",l,e),us("drag",l,e)];return ar(()=>{c.forEach(p=>p())})}function ZPe({mouseInteractionCb:r,doc:t,mirror:e,blockClass:n,blockSelector:o,sampling:s}){if(s.mouseInteraction===!1)return()=>{};let i=s.mouseInteraction===!0||s.mouseInteraction===void 0?{}:s.mouseInteraction,a=[],u=null,l=c=>p=>{let d=vw(p);if(ls(d,n,o,!0))return;let f=null,h=c;if("pointerType"in p){switch(p.pointerType){case"mouse":f=Qc.Mouse;break;case"touch":f=Qc.Touch;break;case"pen":f=Qc.Pen;break}f===Qc.Touch?Fs[c]===Fs.MouseDown?h="TouchStart":Fs[c]===Fs.MouseUp&&(h="TouchEnd"):Qc.Pen}else M$(p)&&(f=Qc.Touch);f!==null?(u=f,(h.startsWith("Touch")&&f===Qc.Touch||h.startsWith("Mouse")&&f===Qc.Mouse)&&(f=null)):Fs[c]===Fs.Click&&(f=u,u=null);let m=M$(p)?p.changedTouches[0]:p;if(!m)return;let g=e.getId(d),{clientX:y,clientY:x}=m;ar(r)(Object.assign({type:Fs[h],id:g,x:y,y:x},f!==null&&{pointerType:f}))};return Object.keys(Fs).filter(c=>Number.isNaN(Number(c))&&!c.endsWith("_Departed")&&i[c]!==!1).forEach(c=>{let p=im(c),d=l(c);if(window.PointerEvent)switch(Fs[c]){case Fs.MouseDown:case Fs.MouseUp:p=p.replace("mouse","pointer");break;case Fs.TouchStart:case Fs.TouchEnd:return}a.push(us(p,d,t))}),ar(()=>{a.forEach(c=>c())})}function Qoe({scrollCb:r,doc:t,mirror:e,blockClass:n,blockSelector:o,sampling:s}){let i=ar(gw(ar(a=>{let u=vw(a);if(!u||ls(u,n,o,!0))return;let l=e.getId(u);if(u===t&&t.defaultView){let c=Boe(t.defaultView);r({id:l,x:c.left,y:c.top})}else r({id:l,x:u.scrollLeft,y:u.scrollTop})}),s.scroll||100));return us("scroll",i,t)}function QPe({viewportResizeCb:r},{win:t}){let e=-1,n=-1,o=ar(gw(ar(()=>{let s=Voe(),i=Uoe();(e!==s||n!==i)&&(r({width:Number(i),height:Number(s)}),e=s,n=i)}),200));return us("resize",o,t)}var JPe=["INPUT","TEXTAREA","SELECT"],boe=new WeakMap;function eLe({inputCb:r,doc:t,mirror:e,blockClass:n,blockSelector:o,ignoreClass:s,ignoreSelector:i,maskInputOptions:a,maskInputFn:u,sampling:l,userTriggeredOnInput:c}){function p(x){let w=vw(x),C=x.isTrusted,I=w&&w.tagName;if(w&&I==="OPTION"&&(w=w.parentElement),!w||!I||JPe.indexOf(I)<0||ls(w,n,o,!0)||w.classList.contains(s)||i&&w.matches(i))return;let N=w.value,A=!1,O=K$(w)||"";O==="radio"||O==="checkbox"?A=w.checked:(a[I.toLowerCase()]||a[O])&&(N=q$({element:w,maskInputOptions:a,tagName:I,type:O,value:N,maskInputFn:u})),d(w,c?{text:N,isChecked:A,userTriggered:C}:{text:N,isChecked:A});let $=w.name;O==="radio"&&$&&A&&t.querySelectorAll(`input[type="radio"][name="${$}"]`).forEach(z=>{if(z!==w){let G=z.value;d(z,c?{text:G,isChecked:!A,userTriggered:!1}:{text:G,isChecked:!A})}})}function d(x,w){let C=boe.get(x);if(!C||C.text!==w.text||C.isChecked!==w.isChecked){boe.set(x,w);let I=e.getId(x);ar(r)(Object.assign(Object.assign({},w),{id:I}))}}let h=(l.input==="last"?["change"]:["input","change"]).map(x=>us(x,ar(p),t)),m=t.defaultView;if(!m)return()=>{h.forEach(x=>x())};let g=m.Object.getOwnPropertyDescriptor(m.HTMLInputElement.prototype,"value"),y=[[m.HTMLInputElement.prototype,"value"],[m.HTMLInputElement.prototype,"checked"],[m.HTMLSelectElement.prototype,"value"],[m.HTMLTextAreaElement.prototype,"value"],[m.HTMLSelectElement.prototype,"selectedIndex"],[m.HTMLOptionElement.prototype,"selected"]];return g&&g.set&&h.push(...y.map(x=>Bk(x[0],x[1],{set(){ar(p)({target:this,isTrusted:!1})}},!1,m))),ar(()=>{h.forEach(x=>x())})}function Ak(r){let t=[];function e(n,o){if(wk("CSSGroupingRule")&&n.parentRule instanceof CSSGroupingRule||wk("CSSMediaRule")&&n.parentRule instanceof CSSMediaRule||wk("CSSSupportsRule")&&n.parentRule instanceof CSSSupportsRule||wk("CSSConditionRule")&&n.parentRule instanceof CSSConditionRule){let i=Array.from(n.parentRule.cssRules).indexOf(n);o.unshift(i)}else if(n.parentStyleSheet){let i=Array.from(n.parentStyleSheet.cssRules).indexOf(n);o.unshift(i)}return o}return e(r,t)}function cf(r,t,e){let n,o;return r?(r.ownerNode?n=t.getId(r.ownerNode):o=e.getId(r),{styleId:o,id:n}):{}}function tLe({styleSheetRuleCb:r,mirror:t,stylesheetManager:e},{win:n}){if(!n.CSSStyleSheet||!n.CSSStyleSheet.prototype)return()=>{};let o=n.CSSStyleSheet.prototype.insertRule;n.CSSStyleSheet.prototype.insertRule=new Proxy(o,{apply:ar((c,p,d)=>{let[f,h]=d,{id:m,styleId:g}=cf(p,t,e.styleMirror);return(m&&m!==-1||g&&g!==-1)&&r({id:m,styleId:g,adds:[{rule:f,index:h}]}),c.apply(p,d)})});let s=n.CSSStyleSheet.prototype.deleteRule;n.CSSStyleSheet.prototype.deleteRule=new Proxy(s,{apply:ar((c,p,d)=>{let[f]=d,{id:h,styleId:m}=cf(p,t,e.styleMirror);return(h&&h!==-1||m&&m!==-1)&&r({id:h,styleId:m,removes:[{index:f}]}),c.apply(p,d)})});let i;n.CSSStyleSheet.prototype.replace&&(i=n.CSSStyleSheet.prototype.replace,n.CSSStyleSheet.prototype.replace=new Proxy(i,{apply:ar((c,p,d)=>{let[f]=d,{id:h,styleId:m}=cf(p,t,e.styleMirror);return(h&&h!==-1||m&&m!==-1)&&r({id:h,styleId:m,replace:f}),c.apply(p,d)})}));let a;n.CSSStyleSheet.prototype.replaceSync&&(a=n.CSSStyleSheet.prototype.replaceSync,n.CSSStyleSheet.prototype.replaceSync=new Proxy(a,{apply:ar((c,p,d)=>{let[f]=d,{id:h,styleId:m}=cf(p,t,e.styleMirror);return(h&&h!==-1||m&&m!==-1)&&r({id:h,styleId:m,replaceSync:f}),c.apply(p,d)})}));let u={};Ck("CSSGroupingRule")?u.CSSGroupingRule=n.CSSGroupingRule:(Ck("CSSMediaRule")&&(u.CSSMediaRule=n.CSSMediaRule),Ck("CSSConditionRule")&&(u.CSSConditionRule=n.CSSConditionRule),Ck("CSSSupportsRule")&&(u.CSSSupportsRule=n.CSSSupportsRule));let l={};return Object.entries(u).forEach(([c,p])=>{l[c]={insertRule:p.prototype.insertRule,deleteRule:p.prototype.deleteRule},p.prototype.insertRule=new Proxy(l[c].insertRule,{apply:ar((d,f,h)=>{let[m,g]=h,{id:y,styleId:x}=cf(f.parentStyleSheet,t,e.styleMirror);return(y&&y!==-1||x&&x!==-1)&&r({id:y,styleId:x,adds:[{rule:m,index:[...Ak(f),g||0]}]}),d.apply(f,h)})}),p.prototype.deleteRule=new Proxy(l[c].deleteRule,{apply:ar((d,f,h)=>{let[m]=h,{id:g,styleId:y}=cf(f.parentStyleSheet,t,e.styleMirror);return(g&&g!==-1||y&&y!==-1)&&r({id:g,styleId:y,removes:[{index:[...Ak(f),m]}]}),d.apply(f,h)})})}),ar(()=>{n.CSSStyleSheet.prototype.insertRule=o,n.CSSStyleSheet.prototype.deleteRule=s,i&&(n.CSSStyleSheet.prototype.replace=i),a&&(n.CSSStyleSheet.prototype.replaceSync=a),Object.entries(u).forEach(([c,p])=>{p.prototype.insertRule=l[c].insertRule,p.prototype.deleteRule=l[c].deleteRule})})}function Joe({mirror:r,stylesheetManager:t},e){var n,o,s;let i=null;e.nodeName==="#document"?i=r.getId(e):i=r.getId(e.host);let a=e.nodeName==="#document"?(n=e.defaultView)===null||n===void 0?void 0:n.Document:(s=(o=e.ownerDocument)===null||o===void 0?void 0:o.defaultView)===null||s===void 0?void 0:s.ShadowRoot,u=a?.prototype?Object.getOwnPropertyDescriptor(a?.prototype,"adoptedStyleSheets"):void 0;return i===null||i===-1||!a||!u?()=>{}:(Object.defineProperty(e,"adoptedStyleSheets",{configurable:u.configurable,enumerable:u.enumerable,get(){var l;return(l=u.get)===null||l===void 0?void 0:l.call(this)},set(l){var c;let p=(c=u.set)===null||c===void 0?void 0:c.call(this,l);if(i!==null&&i!==-1)try{t.adoptStyleSheets(l,i)}catch{}return p}}),ar(()=>{Object.defineProperty(e,"adoptedStyleSheets",{configurable:u.configurable,enumerable:u.enumerable,get:u.get,set:u.set})}))}function rLe({styleDeclarationCb:r,mirror:t,ignoreCSSAttributes:e,stylesheetManager:n},{win:o}){let s=o.CSSStyleDeclaration.prototype.setProperty;o.CSSStyleDeclaration.prototype.setProperty=new Proxy(s,{apply:ar((a,u,l)=>{var c;let[p,d,f]=l;if(e.has(p))return s.apply(u,[p,d,f]);let{id:h,styleId:m}=cf((c=u.parentRule)===null||c===void 0?void 0:c.parentStyleSheet,t,n.styleMirror);return(h&&h!==-1||m&&m!==-1)&&r({id:h,styleId:m,set:{property:p,value:d,priority:f},index:Ak(u.parentRule)}),a.apply(u,l)})});let i=o.CSSStyleDeclaration.prototype.removeProperty;return o.CSSStyleDeclaration.prototype.removeProperty=new Proxy(i,{apply:ar((a,u,l)=>{var c;let[p]=l;if(e.has(p))return i.apply(u,[p]);let{id:d,styleId:f}=cf((c=u.parentRule)===null||c===void 0?void 0:c.parentStyleSheet,t,n.styleMirror);return(d&&d!==-1||f&&f!==-1)&&r({id:d,styleId:f,remove:{property:p},index:Ak(u.parentRule)}),a.apply(u,l)})}),ar(()=>{o.CSSStyleDeclaration.prototype.setProperty=s,o.CSSStyleDeclaration.prototype.removeProperty=i})}function nLe({mediaInteractionCb:r,blockClass:t,blockSelector:e,mirror:n,sampling:o,doc:s}){let i=ar(u=>gw(ar(l=>{let c=vw(l);if(!c||ls(c,t,e,!0))return;let{currentTime:p,volume:d,muted:f,playbackRate:h,loop:m}=c;r({type:u,id:n.getId(c),currentTime:p,volume:d,muted:f,playbackRate:h,loop:m})}),o.media||500)),a=[us("play",i(0),s),us("pause",i(1),s),us("seeked",i(2),s),us("volumechange",i(3),s),us("ratechange",i(4),s)];return ar(()=>{a.forEach(u=>u())})}function oLe({fontCb:r,doc:t}){let e=t.defaultView;if(!e)return()=>{};let n=[],o=new WeakMap,s=e.FontFace;e.FontFace=function(u,l,c){let p=new s(u,l,c);return o.set(p,{family:u,buffer:typeof l!="string",descriptors:c,fontSource:typeof l=="string"?l:JSON.stringify(Array.from(new Uint8Array(l)))}),p};let i=wx(t.fonts,"add",function(a){return function(u){return setTimeout(ar(()=>{let l=o.get(u);l&&(r(l),o.delete(u))}),0),a.apply(this,[u])}});return n.push(()=>{e.FontFace=s}),n.push(i),ar(()=>{n.forEach(a=>a())})}function sLe(r){let{doc:t,mirror:e,blockClass:n,blockSelector:o,selectionCb:s}=r,i=!0,a=ar(()=>{let u=t.getSelection();if(!u||i&&u?.isCollapsed)return;i=u.isCollapsed||!1;let l=[],c=u.rangeCount||0;for(let p=0;p<c;p++){let d=u.getRangeAt(p),{startContainer:f,startOffset:h,endContainer:m,endOffset:g}=d;ls(f,n,o,!0)||ls(m,n,o,!0)||l.push({start:e.getId(f),startOffset:h,end:e.getId(m),endOffset:g})}s({ranges:l})});return a(),us("selectionchange",a)}function iLe({doc:r,customElementCb:t}){let e=r.defaultView;return!e||!e.customElements?()=>{}:wx(e.customElements,"define",function(o){return function(s,i,a){try{t({define:{name:s}})}catch{console.warn(`Custom element callback failed for ${s}`)}return o.apply(this,[s,i,a])}})}function aLe(r,t){let{mutationCb:e,mousemoveCb:n,mouseInteractionCb:o,scrollCb:s,viewportResizeCb:i,inputCb:a,mediaInteractionCb:u,styleSheetRuleCb:l,styleDeclarationCb:c,canvasMutationCb:p,fontCb:d,selectionCb:f,customElementCb:h}=r;r.mutationCb=(...m)=>{t.mutation&&t.mutation(...m),e(...m)},r.mousemoveCb=(...m)=>{t.mousemove&&t.mousemove(...m),n(...m)},r.mouseInteractionCb=(...m)=>{t.mouseInteraction&&t.mouseInteraction(...m),o(...m)},r.scrollCb=(...m)=>{t.scroll&&t.scroll(...m),s(...m)},r.viewportResizeCb=(...m)=>{t.viewportResize&&t.viewportResize(...m),i(...m)},r.inputCb=(...m)=>{t.input&&t.input(...m),a(...m)},r.mediaInteractionCb=(...m)=>{t.mediaInteaction&&t.mediaInteaction(...m),u(...m)},r.styleSheetRuleCb=(...m)=>{t.styleSheetRule&&t.styleSheetRule(...m),l(...m)},r.styleDeclarationCb=(...m)=>{t.styleDeclaration&&t.styleDeclaration(...m),c(...m)},r.canvasMutationCb=(...m)=>{t.canvasMutation&&t.canvasMutation(...m),p(...m)},r.fontCb=(...m)=>{t.font&&t.font(...m),d(...m)},r.selectionCb=(...m)=>{t.selection&&t.selection(...m),f(...m)},r.customElementCb=(...m)=>{t.customElement&&t.customElement(...m),h(...m)}}function uLe(r,t={}){let e=r.doc.defaultView;if(!e)return()=>{};aLe(r,t);let n;r.recordDOM&&(n=Zoe(r,r.doc));let o=YPe(r),s=ZPe(r),i=Qoe(r),a=QPe(r,{win:e}),u=eLe(r),l=nLe(r),c=()=>{},p=()=>{},d=()=>{},f=()=>{};r.recordDOM&&(c=tLe(r,{win:e}),p=Joe(r,r.doc),d=rLe(r,{win:e}),r.collectFonts&&(f=oLe(r)));let h=sLe(r),m=iLe(r),g=[];for(let y of r.plugins)g.push(y.observer(y.callback,e,y.options));return ar(()=>{om.forEach(y=>y.reset()),n?.disconnect(),o(),s(),i(),a(),u(),l(),c(),p(),d(),f(),h(),m(),g.forEach(y=>y())})}function wk(r){return typeof window[r]<"u"}function Ck(r){return!!(typeof window[r]<"u"&&window[r].prototype&&"insertRule"in window[r].prototype&&"deleteRule"in window[r].prototype)}var Rk=class{constructor(t){this.generateIdFn=t,this.iframeIdToRemoteIdMap=new WeakMap,this.iframeRemoteIdToIdMap=new WeakMap}getId(t,e,n,o){let s=n||this.getIdToRemoteIdMap(t),i=o||this.getRemoteIdToIdMap(t),a=s.get(e);return a||(a=this.generateIdFn(),s.set(e,a),i.set(a,e)),a}getIds(t,e){let n=this.getIdToRemoteIdMap(t),o=this.getRemoteIdToIdMap(t);return e.map(s=>this.getId(t,s,n,o))}getRemoteId(t,e,n){let o=n||this.getRemoteIdToIdMap(t);if(typeof e!="number")return e;let s=o.get(e);return s||-1}getRemoteIds(t,e){let n=this.getRemoteIdToIdMap(t);return e.map(o=>this.getRemoteId(t,o,n))}reset(t){if(!t){this.iframeIdToRemoteIdMap=new WeakMap,this.iframeRemoteIdToIdMap=new WeakMap;return}this.iframeIdToRemoteIdMap.delete(t),this.iframeRemoteIdToIdMap.delete(t)}getIdToRemoteIdMap(t){let e=this.iframeIdToRemoteIdMap.get(t);return e||(e=new Map,this.iframeIdToRemoteIdMap.set(t,e)),e}getRemoteIdToIdMap(t){let e=this.iframeRemoteIdToIdMap.get(t);return e||(e=new Map,this.iframeRemoteIdToIdMap.set(t,e)),e}},B$=class{constructor(t){this.iframes=new WeakMap,this.crossOriginIframeMap=new WeakMap,this.crossOriginIframeMirror=new Rk($oe),this.crossOriginIframeRootIdMap=new WeakMap,this.mutationCb=t.mutationCb,this.wrappedEmit=t.wrappedEmit,this.stylesheetManager=t.stylesheetManager,this.recordCrossOriginIframes=t.recordCrossOriginIframes,this.crossOriginIframeStyleMirror=new Rk(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror)),this.mirror=t.mirror,this.recordCrossOriginIframes&&window.addEventListener("message",this.handleMessage.bind(this))}addIframe(t){this.iframes.set(t,!0),t.contentWindow&&this.crossOriginIframeMap.set(t.contentWindow,t)}addLoadListener(t){this.loadListener=t}attachIframe(t,e){var n;this.mutationCb({adds:[{parentId:this.mirror.getId(t),nextId:null,node:e}],removes:[],texts:[],attributes:[],isAttachIframe:!0}),(n=this.loadListener)===null||n===void 0||n.call(this,t),t.contentDocument&&t.contentDocument.adoptedStyleSheets&&t.contentDocument.adoptedStyleSheets.length>0&&this.stylesheetManager.adoptStyleSheets(t.contentDocument.adoptedStyleSheets,this.mirror.getId(t.contentDocument))}handleMessage(t){let e=t;if(e.data.type!=="rrweb"||e.origin!==e.data.origin||!t.source)return;let o=this.crossOriginIframeMap.get(t.source);if(!o)return;let s=this.transformCrossOriginEvent(o,e.data.event);s&&this.wrappedEmit(s,e.data.isCheckout)}transformCrossOriginEvent(t,e){var n;switch(e.type){case dr.FullSnapshot:{this.crossOriginIframeMirror.reset(t),this.crossOriginIframeStyleMirror.reset(t),this.replaceIdOnNode(e.data.node,t);let o=e.data.node.id;return this.crossOriginIframeRootIdMap.set(t,o),this.patchRootIdOnNode(e.data.node,o),{timestamp:e.timestamp,type:dr.IncrementalSnapshot,data:{source:rr.Mutation,adds:[{parentId:this.mirror.getId(t),nextId:null,node:e.data.node}],removes:[],texts:[],attributes:[],isAttachIframe:!0}}}case dr.Meta:case dr.Load:case dr.DomContentLoaded:return!1;case dr.Plugin:return e;case dr.Custom:return this.replaceIds(e.data.payload,t,["id","parentId","previousId","nextId"]),e;case dr.IncrementalSnapshot:switch(e.data.source){case rr.Mutation:return e.data.adds.forEach(o=>{this.replaceIds(o,t,["parentId","nextId","previousId"]),this.replaceIdOnNode(o.node,t);let s=this.crossOriginIframeRootIdMap.get(t);s&&this.patchRootIdOnNode(o.node,s)}),e.data.removes.forEach(o=>{this.replaceIds(o,t,["parentId","id"])}),e.data.attributes.forEach(o=>{this.replaceIds(o,t,["id"])}),e.data.texts.forEach(o=>{this.replaceIds(o,t,["id"])}),e;case rr.Drag:case rr.TouchMove:case rr.MouseMove:return e.data.positions.forEach(o=>{this.replaceIds(o,t,["id"])}),e;case rr.ViewportResize:return!1;case rr.MediaInteraction:case rr.MouseInteraction:case rr.Scroll:case rr.CanvasMutation:case rr.Input:return this.replaceIds(e.data,t,["id"]),e;case rr.StyleSheetRule:case rr.StyleDeclaration:return this.replaceIds(e.data,t,["id"]),this.replaceStyleIds(e.data,t,["styleId"]),e;case rr.Font:return e;case rr.Selection:return e.data.ranges.forEach(o=>{this.replaceIds(o,t,["start","end"])}),e;case rr.AdoptedStyleSheet:return this.replaceIds(e.data,t,["id"]),this.replaceStyleIds(e.data,t,["styleIds"]),(n=e.data.styles)===null||n===void 0||n.forEach(o=>{this.replaceStyleIds(o,t,["styleId"])}),e}}return!1}replace(t,e,n,o){for(let s of o)!Array.isArray(e[s])&&typeof e[s]!="number"||(Array.isArray(e[s])?e[s]=t.getIds(n,e[s]):e[s]=t.getId(n,e[s]));return e}replaceIds(t,e,n){return this.replace(this.crossOriginIframeMirror,t,e,n)}replaceStyleIds(t,e,n){return this.replace(this.crossOriginIframeStyleMirror,t,e,n)}replaceIdOnNode(t,e){this.replaceIds(t,e,["id","rootId"]),"childNodes"in t&&t.childNodes.forEach(n=>{this.replaceIdOnNode(n,e)})}patchRootIdOnNode(t,e){t.type!==oo.Document&&!t.rootId&&(t.rootId=e),"childNodes"in t&&t.childNodes.forEach(n=>{this.patchRootIdOnNode(n,e)})}},V$=class{constructor(t){this.shadowDoms=new WeakSet,this.restoreHandlers=[],this.mutationCb=t.mutationCb,this.scrollCb=t.scrollCb,this.bypassOptions=t.bypassOptions,this.mirror=t.mirror,this.init()}init(){this.reset(),this.patchAttachShadow(Element,document)}addShadowRoot(t,e){if(!pw(t)||this.shadowDoms.has(t))return;this.shadowDoms.add(t);let n=Zoe(Object.assign(Object.assign({},this.bypassOptions),{doc:e,mutationCb:this.mutationCb,mirror:this.mirror,shadowDomManager:this}),t);this.restoreHandlers.push(()=>n.disconnect()),this.restoreHandlers.push(Qoe(Object.assign(Object.assign({},this.bypassOptions),{scrollCb:this.scrollCb,doc:t,mirror:this.mirror}))),setTimeout(()=>{t.adoptedStyleSheets&&t.adoptedStyleSheets.length>0&&this.bypassOptions.stylesheetManager.adoptStyleSheets(t.adoptedStyleSheets,this.mirror.getId(t.host)),this.restoreHandlers.push(Joe({mirror:this.mirror,stylesheetManager:this.bypassOptions.stylesheetManager},t))},0)}observeAttachShadow(t){!t.contentWindow||!t.contentDocument||this.patchAttachShadow(t.contentWindow.Element,t.contentDocument)}patchAttachShadow(t,e){let n=this;this.restoreHandlers.push(wx(t.prototype,"attachShadow",function(o){return function(s){let i=o.call(this,s);return this.shadowRoot&&Koe(this)&&n.addShadowRoot(this.shadowRoot,e),i}}))}reset(){this.restoreHandlers.forEach(t=>{try{t()}catch{}}),this.restoreHandlers=[],this.shadowDoms=new WeakSet}};function lLe(r,t){var e={};for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&t.indexOf(n)<0&&(e[n]=r[n]);if(r!=null&&typeof Object.getOwnPropertySymbols=="function")for(var o=0,n=Object.getOwnPropertySymbols(r);o<n.length;o++)t.indexOf(n[o])<0&&Object.prototype.propertyIsEnumerable.call(r,n[o])&&(e[n[o]]=r[n[o]]);return e}function cLe(r,t,e,n){function o(s){return s instanceof e?s:new e(function(i){i(s)})}return new(e||(e=Promise))(function(s,i){function a(c){try{l(n.next(c))}catch(p){i(p)}}function u(c){try{l(n.throw(c))}catch(p){i(p)}}function l(c){c.done?s(c.value):o(c.value).then(a,u)}l((n=n.apply(r,t||[])).next())})}var mx="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",pLe=typeof Uint8Array>"u"?[]:new Uint8Array(256);for(lw=0;lw<mx.length;lw++)pLe[mx.charCodeAt(lw)]=lw;var lw,dLe=function(r){var t=new Uint8Array(r),e,n=t.length,o="";for(e=0;e<n;e+=3)o+=mx[t[e]>>2],o+=mx[(t[e]&3)<<4|t[e+1]>>4],o+=mx[(t[e+1]&15)<<2|t[e+2]>>6],o+=mx[t[e+2]&63];return n%3===2?o=o.substring(0,o.length-1)+"=":n%3===1&&(o=o.substring(0,o.length-2)+"=="),o},woe=new Map;function fLe(r,t){let e=woe.get(r);return e||(e=new Map,woe.set(r,e)),e.has(t)||e.set(t,[]),e.get(t)}var ese=(r,t,e)=>{if(!r||!(rse(r,t)||typeof r=="object"))return;let n=r.constructor.name,o=fLe(e,n),s=o.indexOf(r);return s===-1&&(s=o.length,o.push(r)),s};function Ik(r,t,e){if(r instanceof Array)return r.map(n=>Ik(n,t,e));if(r===null)return r;if(r instanceof Float32Array||r instanceof Float64Array||r instanceof Int32Array||r instanceof Uint32Array||r instanceof Uint8Array||r instanceof Uint16Array||r instanceof Int16Array||r instanceof Int8Array||r instanceof Uint8ClampedArray)return{rr_type:r.constructor.name,args:[Object.values(r)]};if(r instanceof ArrayBuffer){let n=r.constructor.name,o=dLe(r);return{rr_type:n,base64:o}}else{if(r instanceof DataView)return{rr_type:r.constructor.name,args:[Ik(r.buffer,t,e),r.byteOffset,r.byteLength]};if(r instanceof HTMLImageElement){let n=r.constructor.name,{src:o}=r;return{rr_type:n,src:o}}else if(r instanceof HTMLCanvasElement){let n="HTMLImageElement",o=r.toDataURL();return{rr_type:n,src:o}}else{if(r instanceof ImageData)return{rr_type:r.constructor.name,args:[Ik(r.data,t,e),r.width,r.height]};if(rse(r,t)||typeof r=="object"){let n=r.constructor.name,o=ese(r,t,e);return{rr_type:n,index:o}}}}return r}var tse=(r,t,e)=>r.map(n=>Ik(n,t,e)),rse=(r,t)=>!!["WebGLActiveInfo","WebGLBuffer","WebGLFramebuffer","WebGLProgram","WebGLRenderbuffer","WebGLShader","WebGLShaderPrecisionFormat","WebGLTexture","WebGLUniformLocation","WebGLVertexArrayObject","WebGLVertexArrayObjectOES"].filter(o=>typeof t[o]=="function").find(o=>r instanceof t[o]);function hLe(r,t,e,n){let o=[],s=Object.getOwnPropertyNames(t.CanvasRenderingContext2D.prototype);for(let i of s)try{if(typeof t.CanvasRenderingContext2D.prototype[i]!="function")continue;let a=wx(t.CanvasRenderingContext2D.prototype,i,function(u){return function(...l){return ls(this.canvas,e,n,!0)||setTimeout(()=>{let c=tse(l,t,this);r(this.canvas,{type:xx["2D"],property:i,args:c})},0),u.apply(this,l)}});o.push(a)}catch{let u=Bk(t.CanvasRenderingContext2D.prototype,i,{set(l){r(this.canvas,{type:xx["2D"],property:i,args:[l],setter:!0})}});o.push(u)}return()=>{o.forEach(i=>i())}}function mLe(r){return r==="experimental-webgl"?"webgl":r}function Coe(r,t,e,n){let o=[];try{let s=wx(r.HTMLCanvasElement.prototype,"getContext",function(i){return function(a,...u){if(!ls(this,t,e,!0)){let l=mLe(a);if("__context"in this||(this.__context=l),n&&["webgl","webgl2"].includes(l))if(u[0]&&typeof u[0]=="object"){let c=u[0];c.preserveDrawingBuffer||(c.preserveDrawingBuffer=!0)}else u.splice(0,1,{preserveDrawingBuffer:!0})}return i.apply(this,[a,...u])}});o.push(s)}catch{console.error("failed to patch HTMLCanvasElement.prototype.getContext")}return()=>{o.forEach(s=>s())}}function Soe(r,t,e,n,o,s,i){let a=[],u=Object.getOwnPropertyNames(r);for(let l of u)if(!["isContextLost","canvas","drawingBufferWidth","drawingBufferHeight"].includes(l))try{if(typeof r[l]!="function")continue;let c=wx(r,l,function(p){return function(...d){let f=p.apply(this,d);if(ese(f,i,this),"tagName"in this.canvas&&!ls(this.canvas,n,o,!0)){let h=tse(d,i,this),m={type:t,property:l,args:h};e(this.canvas,m)}return f}});a.push(c)}catch{let p=Bk(r,l,{set(d){e(this.canvas,{type:t,property:l,args:[d],setter:!0})}});a.push(p)}return a}function gLe(r,t,e,n,o){let s=[];return s.push(...Soe(t.WebGLRenderingContext.prototype,xx.WebGL,r,e,n,o,t)),typeof t.WebGL2RenderingContext<"u"&&s.push(...Soe(t.WebGL2RenderingContext.prototype,xx.WebGL2,r,e,n,o,t)),()=>{s.forEach(i=>i())}}function yLe(r,t){var e=t===void 0?null:t,n=r.toString(),o=n.split(`
`);o.pop(),o.shift();for(var s=o[0].search(/\S/),i=/(['"])__worker_loader_strict__(['"])/g,a=0,u=o.length;a<u;++a)o[a]=o[a].substring(s).replace(i,"$1use strict$2")+`
`;return e&&o.push("//# sourceMappingURL="+e+`
`),o}function xLe(r,t){var e=yLe(r,t),n=new Blob(e,{type:"application/javascript"});return URL.createObjectURL(n)}function vLe(r,t){var e;return function(o){return e=e||xLe(r,t),new Worker(e,o)}}var bLe=vLe(function(){(function(){"__worker_loader_strict__";function r(l,c,p,d){function f(h){return h instanceof p?h:new p(function(m){m(h)})}return new(p||(p=Promise))(function(h,m){function g(w){try{x(d.next(w))}catch(C){m(C)}}function y(w){try{x(d.throw(w))}catch(C){m(C)}}function x(w){w.done?h(w.value):f(w.value).then(g,y)}x((d=d.apply(l,c||[])).next())})}for(var t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",e=typeof Uint8Array>"u"?[]:new Uint8Array(256),n=0;n<t.length;n++)e[t.charCodeAt(n)]=n;var o=function(l){var c=new Uint8Array(l),p,d=c.length,f="";for(p=0;p<d;p+=3)f+=t[c[p]>>2],f+=t[(c[p]&3)<<4|c[p+1]>>4],f+=t[(c[p+1]&15)<<2|c[p+2]>>6],f+=t[c[p+2]&63];return d%3===2?f=f.substring(0,f.length-1)+"=":d%3===1&&(f=f.substring(0,f.length-2)+"=="),f};let s=new Map,i=new Map;function a(l,c,p){return r(this,void 0,void 0,function*(){let d=`${l}-${c}`;if("OffscreenCanvas"in globalThis){if(i.has(d))return i.get(d);let f=new OffscreenCanvas(l,c);f.getContext("2d");let m=yield(yield f.convertToBlob(p)).arrayBuffer(),g=o(m);return i.set(d,g),g}else return""})}let u=self;u.onmessage=function(l){return r(this,void 0,void 0,function*(){if("OffscreenCanvas"in globalThis){let{id:c,bitmap:p,width:d,height:f,dataURLOptions:h}=l.data,m=a(d,f,h),g=new OffscreenCanvas(d,f);g.getContext("2d").drawImage(p,0,0),p.close();let x=yield g.convertToBlob(h),w=x.type,C=yield x.arrayBuffer(),I=o(C);if(!s.has(c)&&(yield m)===I)return s.set(c,I),u.postMessage({id:c});if(s.get(c)===I)return u.postMessage({id:c});u.postMessage({id:c,type:w,base64:I,width:d,height:f}),s.set(c,I)}else return u.postMessage({id:l.data.id})})}})()},null),U$=class{reset(){this.pendingCanvasMutations.clear(),this.resetObservers&&this.resetObservers()}freeze(){this.frozen=!0}unfreeze(){this.frozen=!1}lock(){this.locked=!0}unlock(){this.locked=!1}constructor(t){this.pendingCanvasMutations=new Map,this.rafStamps={latestId:0,invokeId:null},this.frozen=!1,this.locked=!1,this.processMutation=(u,l)=>{(this.rafStamps.invokeId&&this.rafStamps.latestId!==this.rafStamps.invokeId||!this.rafStamps.invokeId)&&(this.rafStamps.invokeId=this.rafStamps.latestId),this.pendingCanvasMutations.has(u)||this.pendingCanvasMutations.set(u,[]),this.pendingCanvasMutations.get(u).push(l)};let{sampling:e="all",win:n,blockClass:o,blockSelector:s,recordCanvas:i,dataURLOptions:a}=t;this.mutationCb=t.mutationCb,this.mirror=t.mirror,i&&e==="all"&&this.initCanvasMutationObserver(n,o,s),i&&typeof e=="number"&&this.initCanvasFPSObserver(e,n,o,s,{dataURLOptions:a})}initCanvasFPSObserver(t,e,n,o,s){let i=Coe(e,n,o,!0),a=new Map,u=new bLe;u.onmessage=h=>{let{id:m}=h.data;if(a.set(m,!1),!("base64"in h.data))return;let{base64:g,type:y,width:x,height:w}=h.data;this.mutationCb({id:m,type:xx["2D"],commands:[{property:"clearRect",args:[0,0,x,w]},{property:"drawImage",args:[{rr_type:"ImageBitmap",args:[{rr_type:"Blob",data:[{rr_type:"ArrayBuffer",base64:g}],type:y}]},0,0]}]})};let l=1e3/t,c=0,p,d=()=>{let h=[];return e.document.querySelectorAll("canvas").forEach(m=>{ls(m,n,o,!0)||h.push(m)}),h},f=h=>{if(c&&h-c<l){p=requestAnimationFrame(f);return}c=h,d().forEach(m=>cLe(this,void 0,void 0,function*(){var g;let y=this.mirror.getId(m);if(a.get(y)||m.width===0||m.height===0)return;if(a.set(y,!0),["webgl","webgl2"].includes(m.__context)){let w=m.getContext(m.__context);((g=w?.getContextAttributes())===null||g===void 0?void 0:g.preserveDrawingBuffer)===!1&&w.clear(w.COLOR_BUFFER_BIT)}let x=yield createImageBitmap(m);u.postMessage({id:y,bitmap:x,width:m.width,height:m.height,dataURLOptions:s.dataURLOptions},[x])})),p=requestAnimationFrame(f)};p=requestAnimationFrame(f),this.resetObservers=()=>{i(),cancelAnimationFrame(p)}}initCanvasMutationObserver(t,e,n){this.startRAFTimestamping(),this.startPendingCanvasMutationFlusher();let o=Coe(t,e,n,!1),s=hLe(this.processMutation.bind(this),t,e,n),i=gLe(this.processMutation.bind(this),t,e,n,this.mirror);this.resetObservers=()=>{o(),s(),i()}}startPendingCanvasMutationFlusher(){requestAnimationFrame(()=>this.flushPendingCanvasMutations())}startRAFTimestamping(){let t=e=>{this.rafStamps.latestId=e,requestAnimationFrame(t)};requestAnimationFrame(t)}flushPendingCanvasMutations(){this.pendingCanvasMutations.forEach((t,e)=>{let n=this.mirror.getId(e);this.flushPendingCanvasMutationFor(e,n)}),requestAnimationFrame(()=>this.flushPendingCanvasMutations())}flushPendingCanvasMutationFor(t,e){if(this.frozen||this.locked)return;let n=this.pendingCanvasMutations.get(t);if(!n||e===-1)return;let o=n.map(i=>lLe(i,["type"])),{type:s}=n[0];this.mutationCb({id:e,type:s,commands:o}),this.pendingCanvasMutations.delete(t)}},G$=class{constructor(t){this.trackedLinkElements=new WeakSet,this.styleMirror=new $$,this.mutationCb=t.mutationCb,this.adoptedStyleSheetCb=t.adoptedStyleSheetCb}attachLinkElement(t,e){"_cssText"in e.attributes&&this.mutationCb({adds:[],removes:[],texts:[],attributes:[{id:e.id,attributes:e.attributes}]}),this.trackLinkElement(t)}trackLinkElement(t){this.trackedLinkElements.has(t)||(this.trackedLinkElements.add(t),this.trackStylesheetInLinkElement(t))}adoptStyleSheets(t,e){if(t.length===0)return;let n={id:e,styleIds:[]},o=[];for(let s of t){let i;this.styleMirror.has(s)?i=this.styleMirror.getId(s):(i=this.styleMirror.add(s),o.push({styleId:i,rules:Array.from(s.rules||CSSRule,(a,u)=>({rule:Moe(a),index:u}))})),n.styleIds.push(i)}o.length>0&&(n.styles=o),this.adoptedStyleSheetCb(n)}reset(){this.styleMirror.reset(),this.trackedLinkElements=new WeakSet}trackStylesheetInLinkElement(t){}},W$=class{constructor(){this.nodeMap=new WeakMap,this.loop=!0,this.periodicallyClear()}periodicallyClear(){requestAnimationFrame(()=>{this.clear(),this.loop&&this.periodicallyClear()})}inOtherBuffer(t,e){let n=this.nodeMap.get(t);return n&&Array.from(n).some(o=>o!==e)}add(t,e){this.nodeMap.set(t,(this.nodeMap.get(t)||new Set).add(e))}clear(){this.nodeMap=new WeakMap}destroy(){this.loop=!1}};function Hn(r){return Object.assign(Object.assign({},r),{timestamp:Dk()})}var Nn,Tk,k$,Ok=!1,pu=wPe();function bw(r={}){let{emit:t,checkoutEveryNms:e,checkoutEveryNth:n,blockClass:o="rr-block",blockSelector:s=null,ignoreClass:i="rr-ignore",ignoreSelector:a=null,maskTextClass:u="rr-mask",maskTextSelector:l=null,inlineStylesheet:c=!0,maskAllInputs:p,maskInputOptions:d,slimDOMOptions:f,maskInputFn:h,maskTextFn:m,hooks:g,packFn:y,sampling:x={},dataURLOptions:w={},mousemoveWait:C,recordDOM:I=!0,recordCanvas:N=!1,recordCrossOriginIframes:A=!1,recordAfter:O=r.recordAfter==="DOMContentLoaded"?r.recordAfter:"load",userTriggeredOnInput:$=!1,collectFonts:z=!1,inlineImages:G=!1,plugins:K,keepIframeSrcFn:Z=()=>!1,ignoreCSSAttributes:Q=new Set([]),errorHandler:J}=r;KPe(J);let te=A?window.parent===window:!0,ie=!1;if(!te)try{window.parent.document&&(ie=!1)}catch{ie=!0}if(te&&!t)throw new Error("emit function is required");C!==void 0&&x.mousemove===void 0&&(x.mousemove=C),pu.reset();let ne=p===!0?{color:!0,date:!0,"datetime-local":!0,email:!0,month:!0,number:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0,textarea:!0,select:!0,password:!0}:d!==void 0?d:{password:!0},ae=f===!0||f==="all"?{script:!0,comment:!0,headFavicon:!0,headWhitespace:!0,headMetaSocial:!0,headMetaRobots:!0,headMetaHttpEquiv:!0,headMetaVerification:!0,headMetaAuthorship:f==="all",headMetaDescKeywords:f==="all"}:f||{};jPe();let ye,ge=0,Se=_e=>{for(let Ct of K||[])Ct.eventProcessor&&(_e=Ct.eventProcessor(_e));return y&&!ie&&(_e=y(_e)),_e};Nn=(_e,Ct)=>{var ze;if(!((ze=om[0])===null||ze===void 0)&&ze.isFrozen()&&_e.type!==dr.FullSnapshot&&!(_e.type===dr.IncrementalSnapshot&&_e.data.source===rr.Mutation)&&om.forEach(nt=>nt.unfreeze()),te)t?.(Se(_e),Ct);else if(ie){let nt={type:"rrweb",event:Se(_e),origin:window.location.origin,isCheckout:Ct};window.parent.postMessage(nt,"*")}if(_e.type===dr.FullSnapshot)ye=_e,ge=0;else if(_e.type===dr.IncrementalSnapshot){if(_e.data.source===rr.Mutation&&_e.data.isAttachIframe)return;ge++;let nt=n&&ge>=n,Lt=e&&_e.timestamp-ye.timestamp>e;(nt||Lt)&&Tk(!0)}};let be=_e=>{Nn(Hn({type:dr.IncrementalSnapshot,data:Object.assign({source:rr.Mutation},_e)}))},ke=_e=>Nn(Hn({type:dr.IncrementalSnapshot,data:Object.assign({source:rr.Scroll},_e)})),Te=_e=>Nn(Hn({type:dr.IncrementalSnapshot,data:Object.assign({source:rr.CanvasMutation},_e)})),Oe=_e=>Nn(Hn({type:dr.IncrementalSnapshot,data:Object.assign({source:rr.AdoptedStyleSheet},_e)})),Ge=new G$({mutationCb:be,adoptedStyleSheetCb:Oe}),Ke=new B$({mirror:pu,mutationCb:be,stylesheetManager:Ge,recordCrossOriginIframes:A,wrappedEmit:Nn});for(let _e of K||[])_e.getMirror&&_e.getMirror({nodeMirror:pu,crossOriginIframeMirror:Ke.crossOriginIframeMirror,crossOriginIframeStyleMirror:Ke.crossOriginIframeStyleMirror});let Ze=new W$;k$=new U$({recordCanvas:N,mutationCb:Te,win:window,blockClass:o,blockSelector:s,mirror:pu,sampling:x.canvas,dataURLOptions:w});let lt=new V$({mutationCb:be,scrollCb:ke,bypassOptions:{blockClass:o,blockSelector:s,maskTextClass:u,maskTextSelector:l,inlineStylesheet:c,maskInputOptions:ne,dataURLOptions:w,maskTextFn:m,maskInputFn:h,recordCanvas:N,inlineImages:G,sampling:x,slimDOMOptions:ae,iframeManager:Ke,stylesheetManager:Ge,canvasManager:k$,keepIframeSrcFn:Z,processedNodeManager:Ze},mirror:pu});Tk=(_e=!1)=>{if(!I)return;Nn(Hn({type:dr.Meta,data:{href:window.location.href,width:Uoe(),height:Voe()}}),_e),Ge.reset(),lt.init(),om.forEach(ze=>ze.lock());let Ct=GPe(document,{mirror:pu,blockClass:o,blockSelector:s,maskTextClass:u,maskTextSelector:l,inlineStylesheet:c,maskAllInputs:ne,maskTextFn:m,slimDOM:ae,dataURLOptions:w,recordCanvas:N,inlineImages:G,onSerialize:ze=>{joe(ze,pu)&&Ke.addIframe(ze),Hoe(ze,pu)&&Ge.trackLinkElement(ze),F$(ze)&&lt.addShadowRoot(ze.shadowRoot,document)},onIframeLoad:(ze,nt)=>{Ke.attachIframe(ze,nt),lt.observeAttachShadow(ze)},onStylesheetLoad:(ze,nt)=>{Ge.attachLinkElement(ze,nt)},keepIframeSrcFn:Z});if(!Ct)return console.warn("Failed to snapshot the document");Nn(Hn({type:dr.FullSnapshot,data:{node:Ct,initialOffset:Boe(window)}}),_e),om.forEach(ze=>ze.unlock()),document.adoptedStyleSheets&&document.adoptedStyleSheets.length>0&&Ge.adoptStyleSheets(document.adoptedStyleSheets,pu.getId(document))};try{let _e=[],Ct=nt=>{var Lt;return ar(uLe)({mutationCb:be,mousemoveCb:(tt,vr)=>Nn(Hn({type:dr.IncrementalSnapshot,data:{source:vr,positions:tt}})),mouseInteractionCb:tt=>Nn(Hn({type:dr.IncrementalSnapshot,data:Object.assign({source:rr.MouseInteraction},tt)})),scrollCb:ke,viewportResizeCb:tt=>Nn(Hn({type:dr.IncrementalSnapshot,data:Object.assign({source:rr.ViewportResize},tt)})),inputCb:tt=>Nn(Hn({type:dr.IncrementalSnapshot,data:Object.assign({source:rr.Input},tt)})),mediaInteractionCb:tt=>Nn(Hn({type:dr.IncrementalSnapshot,data:Object.assign({source:rr.MediaInteraction},tt)})),styleSheetRuleCb:tt=>Nn(Hn({type:dr.IncrementalSnapshot,data:Object.assign({source:rr.StyleSheetRule},tt)})),styleDeclarationCb:tt=>Nn(Hn({type:dr.IncrementalSnapshot,data:Object.assign({source:rr.StyleDeclaration},tt)})),canvasMutationCb:Te,fontCb:tt=>Nn(Hn({type:dr.IncrementalSnapshot,data:Object.assign({source:rr.Font},tt)})),selectionCb:tt=>{Nn(Hn({type:dr.IncrementalSnapshot,data:Object.assign({source:rr.Selection},tt)}))},customElementCb:tt=>{Nn(Hn({type:dr.IncrementalSnapshot,data:Object.assign({source:rr.CustomElement},tt)}))},blockClass:o,ignoreClass:i,ignoreSelector:a,maskTextClass:u,maskTextSelector:l,maskInputOptions:ne,inlineStylesheet:c,sampling:x,recordDOM:I,recordCanvas:N,inlineImages:G,userTriggeredOnInput:$,collectFonts:z,doc:nt,maskInputFn:h,maskTextFn:m,keepIframeSrcFn:Z,blockSelector:s,slimDOMOptions:ae,dataURLOptions:w,mirror:pu,iframeManager:Ke,stylesheetManager:Ge,shadowDomManager:lt,processedNodeManager:Ze,canvasManager:k$,ignoreCSSAttributes:Q,plugins:((Lt=K?.filter(tt=>tt.observer))===null||Lt===void 0?void 0:Lt.map(tt=>({observer:tt.observer,options:tt.options,callback:vr=>Nn(Hn({type:dr.Plugin,data:{plugin:tt.name,payload:vr}}))})))||[]},g)};Ke.addLoadListener(nt=>{try{_e.push(Ct(nt.contentDocument))}catch(Lt){console.warn(Lt)}});let ze=()=>{Tk(),_e.push(Ct(document)),Ok=!0};return document.readyState==="interactive"||document.readyState==="complete"?ze():(_e.push(us("DOMContentLoaded",()=>{Nn(Hn({type:dr.DomContentLoaded,data:{}})),O==="DOMContentLoaded"&&ze()})),_e.push(us("load",()=>{Nn(Hn({type:dr.Load,data:{}})),O==="load"&&ze()},window))),()=>{_e.forEach(nt=>nt()),Ze.destroy(),Ok=!1,XPe()}}catch(_e){console.warn(_e)}}bw.addCustomEvent=(r,t)=>{if(!Ok)throw new Error("please add custom event after start recording");Nn(Hn({type:dr.Custom,data:{tag:r,payload:t}}))};bw.freezePage=()=>{om.forEach(r=>r.freeze())};bw.takeFullSnapshot=r=>{if(!Ok)throw new Error("please take full snapshot after start recording");Tk(r)};bw.mirror=pu;var nse=(r=>(r[r.DomContentLoaded=0]="DomContentLoaded",r[r.Load=1]="Load",r[r.FullSnapshot=2]="FullSnapshot",r[r.IncrementalSnapshot=3]="IncrementalSnapshot",r[r.Meta=4]="Meta",r[r.Custom=5]="Custom",r[r.Plugin=6]="Plugin",r))(nse||{}),Xl=(r=>(r[r.Mutation=0]="Mutation",r[r.MouseMove=1]="MouseMove",r[r.MouseInteraction=2]="MouseInteraction",r[r.Scroll=3]="Scroll",r[r.ViewportResize=4]="ViewportResize",r[r.Input=5]="Input",r[r.TouchMove=6]="TouchMove",r[r.MediaInteraction=7]="MediaInteraction",r[r.StyleSheetRule=8]="StyleSheetRule",r[r.CanvasMutation=9]="CanvasMutation",r[r.Font=10]="Font",r[r.Log=11]="Log",r[r.Drag=12]="Drag",r[r.StyleDeclaration=13]="StyleDeclaration",r[r.Selection=14]="Selection",r[r.AdoptedStyleSheet=15]="AdoptedStyleSheet",r[r.CustomElement=16]="CustomElement",r))(Xl||{}),Jc={DEBUG:!1,LIB_VERSION:"2.55.1"},Et;typeof window>"u"?(N$={hostname:""},Et={navigator:{userAgent:"",onLine:!0},document:{location:N$,referrer:""},screen:{width:0,height:0},location:N$}):Et=window;var N$,fw=24*60*60*1e3,D$=8*1e3,Vk=Array.prototype,wLe=Function.prototype,ose=Object.prototype,pf=Vk.slice,ww=ose.toString,Uk=ose.hasOwnProperty,jn=Et.console,df=Et.navigator,Yr=Et.document,Sk=Et.opera,Mk=Et.screen,Yl=df.userAgent,A$=wLe.bind,Ioe=Vk.forEach,Toe=Vk.indexOf,_oe=Vk.map,CLe=Array.isArray,j$={},P={trim:function(r){return r.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")}},_r={log:function(){if(Jc.DEBUG&&!P.isUndefined(jn)&&jn)try{jn.log.apply(jn,arguments)}catch{P.each(arguments,function(t){jn.log(t)})}},warn:function(){if(Jc.DEBUG&&!P.isUndefined(jn)&&jn){var r=["Mixpanel warning:"].concat(P.toArray(arguments));try{jn.warn.apply(jn,r)}catch{P.each(r,function(e){jn.warn(e)})}}},error:function(){if(Jc.DEBUG&&!P.isUndefined(jn)&&jn){var r=["Mixpanel error:"].concat(P.toArray(arguments));try{jn.error.apply(jn,r)}catch{P.each(r,function(e){jn.error(e)})}}},critical:function(){if(!P.isUndefined(jn)&&jn){var r=["Mixpanel error:"].concat(P.toArray(arguments));try{jn.error.apply(jn,r)}catch{P.each(r,function(e){jn.error(e)})}}}},R$=function(r,t){return function(){return arguments[0]="["+t+"] "+arguments[0],r.apply(_r,arguments)}},Gk=function(r){return{log:R$(_r.log,r),error:R$(_r.error,r),critical:R$(_r.critical,r)}};P.bind=function(r,t){var e,n;if(A$&&r.bind===A$)return A$.apply(r,pf.call(arguments,1));if(!P.isFunction(r))throw new TypeError;return e=pf.call(arguments,2),n=function(){if(!(this instanceof n))return r.apply(t,e.concat(pf.call(arguments)));var o={};o.prototype=r.prototype;var s=new o;o.prototype=null;var i=r.apply(s,e.concat(pf.call(arguments)));return Object(i)===i?i:s},n};P.each=function(r,t,e){if(r!=null){if(Ioe&&r.forEach===Ioe)r.forEach(t,e);else if(r.length===+r.length){for(var n=0,o=r.length;n<o;n++)if(n in r&&t.call(e,r[n],n,r)===j$)return}else for(var s in r)if(Uk.call(r,s)&&t.call(e,r[s],s,r)===j$)return}};P.extend=function(r){return P.each(pf.call(arguments,1),function(t){for(var e in t)t[e]!==void 0&&(r[e]=t[e])}),r};P.isArray=CLe||function(r){return ww.call(r)==="[object Array]"};P.isFunction=function(r){try{return/^\s*\bfunction\b/.test(r)}catch{return!1}};P.isArguments=function(r){return!!(r&&Uk.call(r,"callee"))};P.toArray=function(r){return r?r.toArray?r.toArray():P.isArray(r)||P.isArguments(r)?pf.call(r):P.values(r):[]};P.map=function(r,t,e){if(_oe&&r.map===_oe)return r.map(t,e);var n=[];return P.each(r,function(o){n.push(t.call(e,o))}),n};P.keys=function(r){var t=[];return r===null||P.each(r,function(e,n){t[t.length]=n}),t};P.values=function(r){var t=[];return r===null||P.each(r,function(e){t[t.length]=e}),t};P.include=function(r,t){var e=!1;return r===null?e:Toe&&r.indexOf===Toe?r.indexOf(t)!=-1:(P.each(r,function(n){if(e||(e=n===t))return j$}),e)};P.includes=function(r,t){return r.indexOf(t)!==-1};P.inherit=function(r,t){return r.prototype=new t,r.prototype.constructor=r,r.superclass=t.prototype,r};P.isObject=function(r){return r===Object(r)&&!P.isArray(r)};P.isEmptyObject=function(r){if(P.isObject(r)){for(var t in r)if(Uk.call(r,t))return!1;return!0}return!1};P.isUndefined=function(r){return r===void 0};P.isString=function(r){return ww.call(r)=="[object String]"};P.isDate=function(r){return ww.call(r)=="[object Date]"};P.isNumber=function(r){return ww.call(r)=="[object Number]"};P.isElement=function(r){return!!(r&&r.nodeType===1)};P.encodeDates=function(r){return P.each(r,function(t,e){P.isDate(t)?r[e]=P.formatDate(t):P.isObject(t)&&(r[e]=P.encodeDates(t))}),r};P.timestamp=function(){return Date.now=Date.now||function(){return+new Date},Date.now()};P.formatDate=function(r){function t(e){return e<10?"0"+e:e}return r.getUTCFullYear()+"-"+t(r.getUTCMonth()+1)+"-"+t(r.getUTCDate())+"T"+t(r.getUTCHours())+":"+t(r.getUTCMinutes())+":"+t(r.getUTCSeconds())};P.strip_empty_properties=function(r){var t={};return P.each(r,function(e,n){P.isString(e)&&e.length>0&&(t[n]=e)}),t};P.truncate=function(r,t){var e;return typeof r=="string"?e=r.slice(0,t):P.isArray(r)?(e=[],P.each(r,function(n){e.push(P.truncate(n,t))})):P.isObject(r)?(e={},P.each(r,function(n,o){e[o]=P.truncate(n,t)})):e=r,e};P.JSONEncode=function(){return function(r){var t=r,e=function(o){var s=/[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,i={"\b":"\\b","	":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"};return s.lastIndex=0,s.test(o)?'"'+o.replace(s,function(a){var u=i[a];return typeof u=="string"?u:"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)})+'"':'"'+o+'"'},n=function(o,s){var i="",a="    ",u=0,l="",c="",p=0,d=i,f=[],h=s[o];switch(h&&typeof h=="object"&&typeof h.toJSON=="function"&&(h=h.toJSON(o)),typeof h){case"string":return e(h);case"number":return isFinite(h)?String(h):"null";case"boolean":case"null":return String(h);case"object":if(!h)return"null";if(i+=a,f=[],ww.apply(h)==="[object Array]"){for(p=h.length,u=0;u<p;u+=1)f[u]=n(u,h)||"null";return c=f.length===0?"[]":i?`[
`+i+f.join(`,
`+i)+`
`+d+"]":"["+f.join(",")+"]",i=d,c}for(l in h)Uk.call(h,l)&&(c=n(l,h),c&&f.push(e(l)+(i?": ":":")+c));return c=f.length===0?"{}":i?"{"+f.join(",")+d+"}":"{"+f.join(",")+"}",i=d,c}};return n("",{"":t})}}();P.JSONDecode=function(){var r,t,e={'"':'"',"\\":"\\","/":"/",b:"\b",f:"\f",n:`
`,r:"\r",t:"	"},n,o=function(f){var h=new SyntaxError(f);throw h.at=r,h.text=n,h},s=function(f){return f&&f!==t&&o("Expected '"+f+"' instead of '"+t+"'"),t=n.charAt(r),r+=1,t},i=function(){var f,h="";for(t==="-"&&(h="-",s("-"));t>="0"&&t<="9";)h+=t,s();if(t===".")for(h+=".";s()&&t>="0"&&t<="9";)h+=t;if(t==="e"||t==="E")for(h+=t,s(),(t==="-"||t==="+")&&(h+=t,s());t>="0"&&t<="9";)h+=t,s();if(f=+h,!isFinite(f))o("Bad number");else return f},a=function(){var f,h,m="",g;if(t==='"')for(;s();){if(t==='"')return s(),m;if(t==="\\")if(s(),t==="u"){for(g=0,h=0;h<4&&(f=parseInt(s(),16),!!isFinite(f));h+=1)g=g*16+f;m+=String.fromCharCode(g)}else if(typeof e[t]=="string")m+=e[t];else break;else m+=t}o("Bad string")},u=function(){for(;t&&t<=" ";)s()},l=function(){switch(t){case"t":return s("t"),s("r"),s("u"),s("e"),!0;case"f":return s("f"),s("a"),s("l"),s("s"),s("e"),!1;case"n":return s("n"),s("u"),s("l"),s("l"),null}o('Unexpected "'+t+'"')},c,p=function(){var f=[];if(t==="["){if(s("["),u(),t==="]")return s("]"),f;for(;t;){if(f.push(c()),u(),t==="]")return s("]"),f;s(","),u()}}o("Bad array")},d=function(){var f,h={};if(t==="{"){if(s("{"),u(),t==="}")return s("}"),h;for(;t;){if(f=a(),u(),s(":"),Object.hasOwnProperty.call(h,f)&&o('Duplicate key "'+f+'"'),h[f]=c(),u(),t==="}")return s("}"),h;s(","),u()}}o("Bad object")};return c=function(){switch(u(),t){case"{":return d();case"[":return p();case'"':return a();case"-":return i();default:return t>="0"&&t<="9"?i():l()}},function(f){var h;return n=f,r=0,t=" ",h=c(),u(),t&&o("Syntax error"),h}}();P.base64Encode=function(r){var t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",e,n,o,s,i,a,u,l,c=0,p=0,d="",f=[];if(!r)return r;r=P.utf8Encode(r);do e=r.charCodeAt(c++),n=r.charCodeAt(c++),o=r.charCodeAt(c++),l=e<<16|n<<8|o,s=l>>18&63,i=l>>12&63,a=l>>6&63,u=l&63,f[p++]=t.charAt(s)+t.charAt(i)+t.charAt(a)+t.charAt(u);while(c<r.length);switch(d=f.join(""),r.length%3){case 1:d=d.slice(0,-2)+"==";break;case 2:d=d.slice(0,-1)+"=";break}return d};P.utf8Encode=function(r){r=(r+"").replace(/\r\n/g,`
`).replace(/\r/g,`
`);var t="",e,n,o=0,s;for(e=n=0,o=r.length,s=0;s<o;s++){var i=r.charCodeAt(s),a=null;i<128?n++:i>127&&i<2048?a=String.fromCharCode(i>>6|192,i&63|128):a=String.fromCharCode(i>>12|224,i>>6&63|128,i&63|128),a!==null&&(n>e&&(t+=r.substring(e,n)),t+=a,e=n=s+1)}return n>e&&(t+=r.substring(e,r.length)),t};P.UUID=function(){var r=function(){var n=1*new Date,o;if(Et.performance&&Et.performance.now)o=Et.performance.now();else for(o=0;n==1*new Date;)o++;return n.toString(16)+Math.floor(o).toString(16)},t=function(){return Math.random().toString(16).replace(".","")},e=function(){var n=Yl,o,s,i=[],a=0;function u(l,c){var p,d=0;for(p=0;p<c.length;p++)d|=i[p]<<p*8;return l^d}for(o=0;o<n.length;o++)s=n.charCodeAt(o),i.unshift(s&255),i.length>=4&&(a=u(a,i),i=[]);return i.length>0&&(a=u(a,i)),a.toString(16)};return function(){var n=(Mk.height*Mk.width).toString(16);return r()+"-"+t()+"-"+e()+"-"+n+"-"+r()}}();var Eoe=["ahrefsbot","ahrefssiteaudit","baiduspider","bingbot","bingpreview","chrome-lighthouse","facebookexternal","petalbot","pinterest","screaming frog","yahoo! slurp","yandexbot","adsbot-google","apis-google","duplexweb-google","feedfetcher-google","google favicon","google web preview","google-read-aloud","googlebot","googleweblight","mediapartners-google","storebot-google"];P.isBlockedUA=function(r){var t;for(r=r.toLowerCase(),t=0;t<Eoe.length;t++)if(r.indexOf(Eoe[t])!==-1)return!0;return!1};P.HTTPBuildQuery=function(r,t){var e,n,o=[];return P.isUndefined(t)&&(t="&"),P.each(r,function(s,i){e=encodeURIComponent(s.toString()),n=encodeURIComponent(i),o[o.length]=n+"="+e}),o.join(t)};P.getQueryParam=function(r,t){t=t.replace(/[[]/g,"\\[").replace(/[\]]/g,"\\]");var e="[\\?&]"+t+"=([^&#]*)",n=new RegExp(e),o=n.exec(r);if(o===null||o&&typeof o[1]!="string"&&o[1].length)return"";var s=o[1];try{s=decodeURIComponent(s)}catch{_r.error("Skipping decoding for malformed query param: "+s)}return s.replace(/\+/g," ")};P.cookie={get:function(r){for(var t=r+"=",e=Yr.cookie.split(";"),n=0;n<e.length;n++){for(var o=e[n];o.charAt(0)==" ";)o=o.substring(1,o.length);if(o.indexOf(t)===0)return decodeURIComponent(o.substring(t.length,o.length))}return null},parse:function(r){var t;try{t=P.JSONDecode(P.cookie.get(r))||{}}catch{}return t},set_seconds:function(r,t,e,n,o,s,i){var a="",u="",l="";if(i)a="; domain="+i;else if(n){var c=koe(Yr.location.hostname);a=c?"; domain=."+c:""}if(e){var p=new Date;p.setTime(p.getTime()+e*1e3),u="; expires="+p.toGMTString()}s&&(o=!0,l="; SameSite=None"),o&&(l+="; secure"),Yr.cookie=r+"="+encodeURIComponent(t)+u+"; path=/"+a+l},set:function(r,t,e,n,o,s,i){var a="",u="",l="";if(i)a="; domain="+i;else if(n){var c=koe(Yr.location.hostname);a=c?"; domain=."+c:""}if(e){var p=new Date;p.setTime(p.getTime()+e*24*60*60*1e3),u="; expires="+p.toGMTString()}s&&(o=!0,l="; SameSite=None"),o&&(l+="; secure");var d=r+"="+encodeURIComponent(t)+u+"; path=/"+a+l;return Yr.cookie=d,d},remove:function(r,t,e){P.cookie.set(r,"",-1,t,!1,!1,e)}};var O$=null,Fk=function(r,t){if(O$!==null&&!t)return O$;var e=!0;try{r=r||window.localStorage;var n="__mplss_"+Y$(8),o="xyz";r.setItem(n,o),r.getItem(n)!==o&&(e=!1),r.removeItem(n)}catch{e=!1}return O$=e,e};P.localStorage={is_supported:function(r){var t=Fk(null,r);return t||_r.error("localStorage unsupported; falling back to cookie store"),t},error:function(r){_r.error("localStorage error: "+r)},get:function(r){try{return window.localStorage.getItem(r)}catch(t){P.localStorage.error(t)}return null},parse:function(r){try{return P.JSONDecode(P.localStorage.get(r))||{}}catch{}return null},set:function(r,t){try{window.localStorage.setItem(r,t)}catch(e){P.localStorage.error(e)}},remove:function(r){try{window.localStorage.removeItem(r)}catch(t){P.localStorage.error(t)}}};P.register_event=function(){var r=function(n,o,s,i,a){if(!n){_r.error("No valid element provided to register_event");return}if(n.addEventListener&&!i)n.addEventListener(o,s,!!a);else{var u="on"+o,l=n[u];n[u]=t(n,s,l)}};function t(n,o,s){var i=function(a){if(a=a||e(window.event),!!a){var u=!0,l,c;return P.isFunction(s)&&(l=s(a)),c=o.call(n,a),(l===!1||c===!1)&&(u=!1),u}};return i}function e(n){return n&&(n.preventDefault=e.preventDefault,n.stopPropagation=e.stopPropagation),n}return e.preventDefault=function(){this.returnValue=!1},e.stopPropagation=function(){this.cancelBubble=!0},r}();var SLe=new RegExp('^(\\w*)\\[(\\w+)([=~\\|\\^\\$\\*]?)=?"?([^\\]"]*)"?\\]$');P.dom_query=function(){function r(o){return o.all?o.all:o.getElementsByTagName("*")}var t=/[\t\r\n]/g;function e(o,s){var i=" "+s+" ";return(" "+o.className+" ").replace(t," ").indexOf(i)>=0}function n(o){if(!Yr.getElementsByTagName)return[];var s=o.split(" "),i,a,u,l,c,p,d,f,h,m,g=[Yr];for(p=0;p<s.length;p++){if(i=s[p].replace(/^\s+/,"").replace(/\s+$/,""),i.indexOf("#")>-1){a=i.split("#"),u=a[0];var y=a[1],x=Yr.getElementById(y);if(!x||u&&x.nodeName.toLowerCase()!=u)return[];g=[x];continue}if(i.indexOf(".")>-1){a=i.split("."),u=a[0];var w=a[1];for(u||(u="*"),l=[],c=0,d=0;d<g.length;d++)for(u=="*"?h=r(g[d]):h=g[d].getElementsByTagName(u),f=0;f<h.length;f++)l[c++]=h[f];for(g=[],m=0,d=0;d<l.length;d++)l[d].className&&P.isString(l[d].className)&&e(l[d],w)&&(g[m++]=l[d]);continue}var C=i.match(SLe);if(C){u=C[1];var I=C[2],N=C[3],A=C[4];for(u||(u="*"),l=[],c=0,d=0;d<g.length;d++)for(u=="*"?h=r(g[d]):h=g[d].getElementsByTagName(u),f=0;f<h.length;f++)l[c++]=h[f];g=[],m=0;var O;switch(N){case"=":O=function($){return $.getAttribute(I)==A};break;case"~":O=function($){return $.getAttribute(I).match(new RegExp("\\b"+A+"\\b"))};break;case"|":O=function($){return $.getAttribute(I).match(new RegExp("^"+A+"-?"))};break;case"^":O=function($){return $.getAttribute(I).indexOf(A)===0};break;case"$":O=function($){return $.getAttribute(I).lastIndexOf(A)==$.getAttribute(I).length-A.length};break;case"*":O=function($){return $.getAttribute(I).indexOf(A)>-1};break;default:O=function($){return $.getAttribute(I)}}for(g=[],m=0,d=0;d<l.length;d++)O(l[d])&&(g[m++]=l[d]);continue}for(u=i,l=[],c=0,d=0;d<g.length;d++)for(h=g[d].getElementsByTagName(u),f=0;f<h.length;f++)l[c++]=h[f];g=l}return g}return function(o){return P.isElement(o)?[o]:P.isObject(o)&&!P.isUndefined(o.length)?o:n.call(this,o)}}();var ILe=["utm_source","utm_medium","utm_campaign","utm_content","utm_term","utm_id","utm_source_platform","utm_campaign_id","utm_creative_format","utm_marketing_tactic"],TLe=["dclid","fbclid","gclid","ko_click_id","li_fat_id","msclkid","sccid","ttclid","twclid","wbraid"];P.info={campaignParams:function(r){var t="",e={};return P.each(ILe,function(n){t=P.getQueryParam(Yr.URL,n),t.length?e[n]=t:r!==void 0&&(e[n]=r)}),e},clickParams:function(){var r="",t={};return P.each(TLe,function(e){r=P.getQueryParam(Yr.URL,e),r.length&&(t[e]=r)}),t},marketingParams:function(){return P.extend(P.info.campaignParams(),P.info.clickParams())},searchEngine:function(r){return r.search("https?://(.*)google.([^/?]*)")===0?"google":r.search("https?://(.*)bing.com")===0?"bing":r.search("https?://(.*)yahoo.com")===0?"yahoo":r.search("https?://(.*)duckduckgo.com")===0?"duckduckgo":null},searchInfo:function(r){var t=P.info.searchEngine(r),e=t!="yahoo"?"q":"p",n={};if(t!==null){n.$search_engine=t;var o=P.getQueryParam(r,e);o.length&&(n.mp_keyword=o)}return n},browser:function(r,t,e){return t=t||"",e||P.includes(r," OPR/")?P.includes(r,"Mini")?"Opera Mini":"Opera":/(BlackBerry|PlayBook|BB10)/i.test(r)?"BlackBerry":P.includes(r,"IEMobile")||P.includes(r,"WPDesktop")?"Internet Explorer Mobile":P.includes(r,"SamsungBrowser/")?"Samsung Internet":P.includes(r,"Edge")||P.includes(r,"Edg/")?"Microsoft Edge":P.includes(r,"FBIOS")?"Facebook Mobile":P.includes(r,"Chrome")?"Chrome":P.includes(r,"CriOS")?"Chrome iOS":P.includes(r,"UCWEB")||P.includes(r,"UCBrowser")?"UC Browser":P.includes(r,"FxiOS")?"Firefox iOS":P.includes(t,"Apple")?P.includes(r,"Mobile")?"Mobile Safari":"Safari":P.includes(r,"Android")?"Android Mobile":P.includes(r,"Konqueror")?"Konqueror":P.includes(r,"Firefox")?"Firefox":P.includes(r,"MSIE")||P.includes(r,"Trident/")?"Internet Explorer":P.includes(r,"Gecko")?"Mozilla":""},browserVersion:function(r,t,e){var n=P.info.browser(r,t,e),o={"Internet Explorer Mobile":/rv:(\d+(\.\d+)?)/,"Microsoft Edge":/Edge?\/(\d+(\.\d+)?)/,Chrome:/Chrome\/(\d+(\.\d+)?)/,"Chrome iOS":/CriOS\/(\d+(\.\d+)?)/,"UC Browser":/(UCBrowser|UCWEB)\/(\d+(\.\d+)?)/,Safari:/Version\/(\d+(\.\d+)?)/,"Mobile Safari":/Version\/(\d+(\.\d+)?)/,Opera:/(Opera|OPR)\/(\d+(\.\d+)?)/,Firefox:/Firefox\/(\d+(\.\d+)?)/,"Firefox iOS":/FxiOS\/(\d+(\.\d+)?)/,Konqueror:/Konqueror:(\d+(\.\d+)?)/,BlackBerry:/BlackBerry (\d+(\.\d+)?)/,"Android Mobile":/android\s(\d+(\.\d+)?)/,"Samsung Internet":/SamsungBrowser\/(\d+(\.\d+)?)/,"Internet Explorer":/(rv:|MSIE )(\d+(\.\d+)?)/,Mozilla:/rv:(\d+(\.\d+)?)/},s=o[n];if(s===void 0)return null;var i=r.match(s);return i?parseFloat(i[i.length-2]):null},os:function(){var r=Yl;return/Windows/i.test(r)?/Phone/.test(r)||/WPDesktop/.test(r)?"Windows Phone":"Windows":/(iPhone|iPad|iPod)/.test(r)?"iOS":/Android/.test(r)?"Android":/(BlackBerry|PlayBook|BB10)/i.test(r)?"BlackBerry":/Mac/i.test(r)?"Mac OS X":/Linux/.test(r)?"Linux":/CrOS/.test(r)?"Chrome OS":""},device:function(r){return/Windows Phone/i.test(r)||/WPDesktop/.test(r)?"Windows Phone":/iPad/.test(r)?"iPad":/iPod/.test(r)?"iPod Touch":/iPhone/.test(r)?"iPhone":/(BlackBerry|PlayBook|BB10)/i.test(r)?"BlackBerry":/Android/.test(r)?"Android":""},referringDomain:function(r){var t=r.split("/");return t.length>=3?t[2]:""},currentUrl:function(){return Et.location.href},properties:function(r){return typeof r!="object"&&(r={}),P.extend(P.strip_empty_properties({$os:P.info.os(),$browser:P.info.browser(Yl,df.vendor,Sk),$referrer:Yr.referrer,$referring_domain:P.info.referringDomain(Yr.referrer),$device:P.info.device(Yl)}),{$current_url:P.info.currentUrl(),$browser_version:P.info.browserVersion(Yl,df.vendor,Sk),$screen_height:Mk.height,$screen_width:Mk.width,mp_lib:"web",$lib_version:Jc.LIB_VERSION,$insert_id:Y$(),time:P.timestamp()/1e3},P.strip_empty_properties(r))},people_properties:function(){return P.extend(P.strip_empty_properties({$os:P.info.os(),$browser:P.info.browser(Yl,df.vendor,Sk)}),{$browser_version:P.info.browserVersion(Yl,df.vendor,Sk)})},mpPageViewProperties:function(){return P.strip_empty_properties({current_page_title:Yr.title,current_domain:Et.location.hostname,current_url_path:Et.location.pathname,current_url_protocol:Et.location.protocol,current_url_search:Et.location.search})}};var Y$=function(r){var t=Math.random().toString(36).substring(2,10)+Math.random().toString(36).substring(2,10);return r?t.substring(0,r):t},_Le=/[a-z0-9][a-z0-9-]*\.[a-z]+$/i,ELe=/[a-z0-9][a-z0-9-]+\.[a-z.]{2,6}$/i,koe=function(r){var t=ELe,e=r.split("."),n=e[e.length-1];(n.length>4||n==="com"||n==="org")&&(t=_Le);var o=r.match(t);return o?o[0]:""},kLe=function(){var r=Et.navigator.onLine;return P.isUndefined(r)||r},$k=null,Pk=null;typeof JSON<"u"&&($k=JSON.stringify,Pk=JSON.parse);$k=$k||P.JSONEncode;Pk=Pk||P.JSONDecode;P.toArray=P.toArray;P.isObject=P.isObject;P.JSONEncode=P.JSONEncode;P.JSONDecode=P.JSONDecode;P.isBlockedUA=P.isBlockedUA;P.isEmptyObject=P.isEmptyObject;P.info=P.info;P.info.device=P.info.device;P.info.browser=P.info.browser;P.info.browserVersion=P.info.browserVersion;P.info.properties=P.info.properties;var NLe="__mp_opt_in_out_";function DLe(r,t){ase(!0,r,t)}function ALe(r,t){ase(!1,r,t)}function RLe(r,t){return ise(r,t)==="1"}function sse(r,t){if(MLe(t))return _r.warn('This browser has "Do Not Track" enabled. This will prevent the Mixpanel SDK from sending any data. To ignore the "Do Not Track" browser setting, initialize the Mixpanel instance with the config "ignore_dnt: true"'),!0;var e=ise(r,t)==="0";return e&&_r.warn("You are opted out of Mixpanel tracking. This will prevent the Mixpanel SDK from sending any data."),e}function hf(r){return J$(r,function(t){return this.get_config(t)})}function mf(r){return J$(r,function(t){return this._get_config(t)})}function Cx(r){return J$(r,function(t){return this._get_config(t)})}function OLe(r,t){t=t||{},Z$(t).remove(Q$(r,t),!!t.crossSubdomainCookie,t.cookieDomain)}function Z$(r){return r=r||{},r.persistenceType==="localStorage"?P.localStorage:P.cookie}function Q$(r,t){return t=t||{},(t.persistencePrefix||NLe)+r}function ise(r,t){return Z$(t).get(Q$(r,t))}function MLe(r){if(r&&r.ignoreDnt)return!1;var t=r&&r.window||Et,e=t.navigator||{},n=!1;return P.each([e.doNotTrack,e.msDoNotTrack,t.doNotTrack],function(o){P.includes([!0,1,"1","yes"],o)&&(n=!0)}),n}function ase(r,t,e){if(!P.isString(t)||!t.length){_r.error("gdpr."+(r?"optIn":"optOut")+" called with an invalid token");return}e=e||{},Z$(e).set(Q$(t,e),r?1:0,P.isNumber(e.cookieExpiration)?e.cookieExpiration:null,!!e.crossSubdomainCookie,!!e.secureCookie,!!e.crossSiteCookie,e.cookieDomain),e.track&&r&&e.track(e.trackEventName||"$opt_in",e.trackProperties,{send_immediately:!0})}function J$(r,t){return function(){var e=!1;try{var n=t.call(this,"token"),o=t.call(this,"ignore_dnt"),s=t.call(this,"opt_out_tracking_persistence_type"),i=t.call(this,"opt_out_tracking_cookie_prefix"),a=t.call(this,"window");n&&(e=sse(n,{ignoreDnt:o,persistenceType:s,persistencePrefix:i,window:a}))}catch(l){_r.error("Unexpected error when checking tracking opt-out status: "+l)}if(!e)return r.apply(this,arguments);var u=arguments[arguments.length-1];typeof u=="function"&&u(0)}}var FLe=Gk("lock"),use=function(r,t){t=t||{},this.storageKey=r,this.storage=t.storage||window.localStorage,this.pollIntervalMS=t.pollIntervalMS||100,this.timeoutMS=t.timeoutMS||2e3};use.prototype.withLock=function(r,t,e){!e&&typeof t!="function"&&(e=t,t=null);var n=e||new Date().getTime()+"|"+Math.random(),o=new Date().getTime(),s=this.storageKey,i=this.pollIntervalMS,a=this.timeoutMS,u=this.storage,l=s+":X",c=s+":Y",p=s+":Z",d=function(x){t&&t(x)},f=function(x){if(new Date().getTime()-o>a){FLe.error("Timeout waiting for mutex on "+s+"; clearing lock. ["+n+"]"),u.removeItem(p),u.removeItem(c),g();return}setTimeout(function(){try{x()}catch(w){d(w)}},i*(Math.random()+.1))},h=function(x,w){x()?w():f(function(){h(x,w)})},m=function(){var x=u.getItem(c);if(x&&x!==n)return!1;if(u.setItem(c,n),u.getItem(c)===n)return!0;if(!Fk(u,!0))throw new Error("localStorage support dropped while acquiring lock");return!1},g=function(){u.setItem(l,n),h(m,function(){if(u.getItem(l)===n){y();return}f(function(){if(u.getItem(c)!==n){g();return}h(function(){return!u.getItem(p)},y)})})},y=function(){u.setItem(p,"1");try{r()}finally{u.removeItem(p),u.getItem(c)===n&&u.removeItem(c),u.getItem(l)===n&&u.removeItem(l)}};try{if(Fk(u,!0))g();else throw new Error("localStorage support check failed")}catch(x){d(x)}};var Noe=Gk("batch"),gf=function(r,t){t=t||{},this.storageKey=r,this.storage=t.storage||window.localStorage,this.reportError=t.errorReporter||P.bind(Noe.error,Noe),this.lock=new use(r,{storage:this.storage}),this.usePersistence=t.usePersistence,this.pid=t.pid||null,this.memQueue=[]};gf.prototype.enqueue=function(r,t,e){var n={id:Y$(),flushAfter:new Date().getTime()+t*2,payload:r};this.usePersistence?this.lock.withLock(P.bind(function(){var s;try{var i=this.readFromStorage();i.push(n),s=this.saveToStorage(i),s&&this.memQueue.push(n)}catch{this.reportError("Error enqueueing item",r),s=!1}e&&e(s)},this),P.bind(function(s){this.reportError("Error acquiring storage lock",s),e&&e(!1)},this),this.pid):(this.memQueue.push(n),e&&e(!0))};gf.prototype.fillBatch=function(r){var t=this.memQueue.slice(0,r);if(this.usePersistence&&t.length<r){var e=this.readFromStorage();if(e.length){var n={};P.each(t,function(i){n[i.id]=!0});for(var o=0;o<e.length;o++){var s=e[o];if(new Date().getTime()>s.flushAfter&&!n[s.id]&&(s.orphaned=!0,t.push(s),t.length>=r))break}}}return t};var Doe=function(r,t){var e=[];return P.each(r,function(n){n.id&&!t[n.id]&&e.push(n)}),e};gf.prototype.removeItemsByID=function(r,t){var e={};if(P.each(r,function(o){e[o]=!0}),this.memQueue=Doe(this.memQueue,e),!this.usePersistence)t&&t(!0);else{var n=P.bind(function(){var o;try{var s=this.readFromStorage();if(s=Doe(s,e),o=this.saveToStorage(s),o){s=this.readFromStorage();for(var i=0;i<s.length;i++){var a=s[i];if(a.id&&e[a.id])return this.reportError("Item not removed from storage"),!1}}}catch{this.reportError("Error removing items",r),o=!1}return o},this);this.lock.withLock(function(){var s=n();t&&t(s)},P.bind(function(s){var i=!1;if(this.reportError("Error acquiring storage lock",s),!Fk(this.storage,!0)&&(i=n(),!i))try{this.storage.removeItem(this.storageKey)}catch(a){this.reportError("Error clearing queue",a)}t&&t(i)},this),this.pid)}};var Aoe=function(r,t){var e=[];return P.each(r,function(n){var o=n.id;if(o in t){var s=t[o];s!==null&&(n.payload=s,e.push(n))}else e.push(n)}),e};gf.prototype.updatePayloads=function(r,t){this.memQueue=Aoe(this.memQueue,r),this.usePersistence?this.lock.withLock(P.bind(function(){var n;try{var o=this.readFromStorage();o=Aoe(o,r),n=this.saveToStorage(o)}catch{this.reportError("Error updating items",r),n=!1}t&&t(n)},this),P.bind(function(n){this.reportError("Error acquiring storage lock",n),t&&t(!1)},this),this.pid):t&&t(!0)};gf.prototype.readFromStorage=function(){var r;try{r=this.storage.getItem(this.storageKey),r&&(r=Pk(r),P.isArray(r)||(this.reportError("Invalid storage entry:",r),r=null))}catch(t){this.reportError("Error retrieving queue",t),r=null}return r||[]};gf.prototype.saveToStorage=function(r){try{return this.storage.setItem(this.storageKey,$k(r)),!0}catch(t){return this.reportError("Error saving queue",t),!1}};gf.prototype.clear=function(){this.memQueue=[],this.usePersistence&&this.storage.removeItem(this.storageKey)};var $Le=10*60*1e3,hw=Gk("batch"),fu=function(r,t){this.errorReporter=t.errorReporter,this.queue=new gf(r,{errorReporter:P.bind(this.reportError,this),storage:t.storage,usePersistence:t.usePersistence}),this.libConfig=t.libConfig,this.sendRequest=t.sendRequestFunc,this.beforeSendHook=t.beforeSendHook,this.stopAllBatching=t.stopAllBatchingFunc,this.batchSize=this.libConfig.batch_size,this.flushInterval=this.libConfig.batch_flush_interval_ms,this.stopped=!this.libConfig.batch_autostart,this.consecutiveRemovalFailures=0,this.itemIdsSentSuccessfully={},this.flushOnlyOnInterval=t.flushOnlyOnInterval||!1};fu.prototype.enqueue=function(r,t){this.queue.enqueue(r,this.flushInterval,t)};fu.prototype.start=function(){this.stopped=!1,this.consecutiveRemovalFailures=0,this.flush()};fu.prototype.stop=function(){this.stopped=!0,this.timeoutID&&(clearTimeout(this.timeoutID),this.timeoutID=null)};fu.prototype.clear=function(){this.queue.clear()};fu.prototype.resetBatchSize=function(){this.batchSize=this.libConfig.batch_size};fu.prototype.resetFlush=function(){this.scheduleFlush(this.libConfig.batch_flush_interval_ms)};fu.prototype.scheduleFlush=function(r){this.flushInterval=r,this.stopped||(this.timeoutID=setTimeout(P.bind(function(){this.stopped||this.flush()},this),this.flushInterval))};fu.prototype.flush=function(r){try{if(this.requestInProgress){hw.log("Flush: Request already in progress");return}r=r||{};var t=this.libConfig.batch_request_timeout_ms,e=new Date().getTime(),n=this.batchSize,o=this.queue.fillBatch(n),s=o.length===n,i=[],a={};if(P.each(o,function(c){var p=c.payload;if(this.beforeSendHook&&!c.orphaned&&(p=this.beforeSendHook(p)),p){p.event&&p.properties&&(p.properties=P.extend({},p.properties,{mp_sent_by_lib_version:Jc.LIB_VERSION}));var d=!0,f=c.id;f?(this.itemIdsSentSuccessfully[f]||0)>5&&(this.reportError("[dupe] item ID sent too many times, not sending",{item:c,batchSize:o.length,timesSent:this.itemIdsSentSuccessfully[f]}),d=!1):this.reportError("[dupe] found item with no ID",{item:c}),d&&i.push(p)}a[c.id]=p},this),i.length<1){this.resetFlush();return}this.requestInProgress=!0;var u=P.bind(function(c){this.requestInProgress=!1;try{var p=!1;if(r.unloading)this.queue.updatePayloads(a);else if(P.isObject(c)&&c.error==="timeout"&&new Date().getTime()-e>=t)this.reportError("Network timeout; retrying"),this.flush();else if(P.isObject(c)&&(c.httpStatusCode>=500||c.httpStatusCode===429||c.httpStatusCode<=0&&!kLe()||c.error==="timeout")){var d=this.flushInterval*2;c.retryAfter&&(d=parseInt(c.retryAfter,10)*1e3||d),d=Math.min($Le,d),this.reportError("Error; retry in "+d+" ms"),this.scheduleFlush(d)}else if(P.isObject(c)&&c.httpStatusCode===413)if(o.length>1){var f=Math.max(1,Math.floor(n/2));this.batchSize=Math.min(this.batchSize,f,o.length-1),this.reportError("413 response; reducing batch size to "+this.batchSize),this.resetFlush()}else this.reportError("Single-event request too large; dropping",o),this.resetBatchSize(),p=!0;else p=!0;p&&(this.queue.removeItemsByID(P.map(o,function(h){return h.id}),P.bind(function(h){h?(this.consecutiveRemovalFailures=0,this.flushOnlyOnInterval&&!s?this.resetFlush():this.flush()):(this.reportError("Failed to remove items from queue"),++this.consecutiveRemovalFailures>5?(this.reportError("Too many queue failures; disabling batching system."),this.stopAllBatching()):this.resetFlush())},this)),P.each(o,P.bind(function(h){var m=h.id;m?(this.itemIdsSentSuccessfully[m]=this.itemIdsSentSuccessfully[m]||0,this.itemIdsSentSuccessfully[m]++,this.itemIdsSentSuccessfully[m]>5&&this.reportError("[dupe] item ID sent too many times",{item:h,batchSize:o.length,timesSent:this.itemIdsSentSuccessfully[m]})):this.reportError("[dupe] found item with no ID while removing",{item:h})},this)))}catch(h){this.reportError("Error handling API response",h),this.resetFlush()}},this),l={method:"POST",verbose:!0,ignore_json_errors:!0,timeout_ms:t};r.unloading&&(l.transport="sendBeacon"),hw.log("MIXPANEL REQUEST:",i),this.sendRequest(i,l,u)}catch(c){this.reportError("Error flushing request queue",c),this.resetFlush()}};fu.prototype.reportError=function(r,t){if(hw.error.apply(hw.error,arguments),this.errorReporter)try{t instanceof Error||(t=new Error(r)),this.errorReporter(r,t)}catch(e){hw.error(e)}};var sm=Gk("recorder"),Roe=Et.CompressionStream,PLe={batch_size:1e3,batch_flush_interval_ms:10*1e3,batch_request_timeout_ms:90*1e3,batch_autostart:!0},LLe=new Set([Xl.MouseMove,Xl.MouseInteraction,Xl.Scroll,Xl.ViewportResize,Xl.Input,Xl.TouchMove,Xl.MediaInteraction,Xl.Drag,Xl.Selection]);function zLe(r){return r.type===nse.IncrementalSnapshot&&LLe.has(r.data.source)}var hu=function(r){this._mixpanel=r,this._stopRecording=null,this.recEvents=[],this.seqNo=0,this.replayId=null,this.replayStartTime=null,this.sendBatchId=null,this.idleTimeoutId=null,this.maxTimeoutId=null,this.recordMaxMs=fw,this.recordMinMs=0,this._initBatcher()};hu.prototype._initBatcher=function(){this.batcher=new fu("__mprec",{libConfig:PLe,sendRequestFunc:P.bind(this.flushEventsWithOptOut,this),errorReporter:P.bind(this.reportError,this),flushOnlyOnInterval:!0,usePersistence:!1})};hu.prototype.get_config=function(r){return this._mixpanel.get_config(r)};hu.prototype.startRecording=function(r){if(this._stopRecording!==null){sm.log("Recording already in progress, skipping startRecording.");return}this.recordMaxMs=this.get_config("record_max_ms"),this.recordMaxMs>fw&&(this.recordMaxMs=fw,sm.critical("record_max_ms cannot be greater than "+fw+"ms. Capping value.")),this.recordMinMs=this.get_config("record_min_ms"),this.recordMinMs>D$&&(this.recordMinMs=D$,sm.critical("record_min_ms cannot be greater than "+D$+"ms. Capping value.")),this.recEvents=[],this.seqNo=0,this.replayStartTime=new Date().getTime(),this.replayId=P.UUID(),r||this.recordMinMs>0?this.batcher.stop():this.batcher.start();var t=P.bind(function(){clearTimeout(this.idleTimeoutId),this.idleTimeoutId=setTimeout(P.bind(function(){sm.log("Idle timeout reached, restarting recording."),this.resetRecording()},this),this.get_config("record_idle_timeout_ms"))},this),e=this.get_config("record_block_selector");(e===""||e===null)&&(e=void 0),this._stopRecording=bw({emit:P.bind(function(n){this.batcher.enqueue(n),zLe(n)&&(this.batcher.stopped&&new Date().getTime()-this.replayStartTime>=this.recordMinMs&&this.batcher.start(),t())},this),blockClass:this.get_config("record_block_class"),blockSelector:e,collectFonts:this.get_config("record_collect_fonts"),inlineImages:this.get_config("record_inline_images"),maskAllInputs:!0,maskTextClass:this.get_config("record_mask_text_class"),maskTextSelector:this.get_config("record_mask_text_selector")}),t(),this.maxTimeoutId=setTimeout(P.bind(this.resetRecording,this),this.recordMaxMs)};hu.prototype.resetRecording=function(){this.stopRecording(),this.startRecording(!0)};hu.prototype.stopRecording=function(){this._stopRecording!==null&&(this._stopRecording(),this._stopRecording=null),this.batcher.stopped?this.batcher.clear():(this.batcher.flush(),this.batcher.stop()),this.replayId=null,clearTimeout(this.idleTimeoutId),clearTimeout(this.maxTimeoutId)};hu.prototype.flushEventsWithOptOut=function(r,t,e){this._flushEvents(r,t,e,P.bind(this._onOptOut,this))};hu.prototype._onOptOut=function(r){r===0&&(this.recEvents=[],this.stopRecording())};hu.prototype._sendRequest=function(r,t,e,n){var o=P.bind(function(s,i){s.status===200&&this.replayId===r&&this.seqNo++,n({status:0,httpStatusCode:s.status,responseBody:i,retryAfter:s.headers.get("Retry-After")})},this);Et.fetch(this.get_config("api_host")+"/"+this.get_config("api_routes").record+"?"+new URLSearchParams(t),{method:"POST",headers:{Authorization:"Basic "+btoa(this.get_config("token")+":"),"Content-Type":"application/octet-stream"},body:e}).then(function(s){s.json().then(function(i){o(s,i)}).catch(function(i){n({error:i})})}).catch(function(s){n({error:s,httpStatusCode:0})})};hu.prototype._flushEvents=hf(function(r,t,e){let n=r.length;if(n>0){var o=this.replayId,s=r[0].timestamp;(this.seqNo===0||!this.replayStartTime)&&(this.seqNo!==0&&this.reportError("Replay start time not set but seqNo is not 0. Using current batch start time as a fallback."),this.replayStartTime=s);var i=r[n-1].timestamp-this.replayStartTime,a={distinct_id:String(this._mixpanel.get_distinct_id()),seq:this.seqNo,batch_start_time:s/1e3,replay_id:o,replay_length_ms:i,replay_start_time:this.replayStartTime/1e3},u=P.JSONEncode(r),l=this._mixpanel.get_property("$device_id");l&&(a.$device_id=l);var c=this._mixpanel.get_property("$user_id");if(c&&(a.$user_id=c),Roe){var p=new Blob([u],{type:"application/json"}).stream(),d=p.pipeThrough(new Roe("gzip"));new Response(d).blob().then(P.bind(function(f){a.format="gzip",this._sendRequest(o,a,f,e)},this))}else a.format="body",this._sendRequest(o,a,u,e)}});hu.prototype.reportError=function(r,t){sm.error.apply(sm.error,arguments);try{!t&&!(r instanceof Error)&&(r=new Error(r)),this.get_config("error_reporter")(r,t)}catch(e){sm.error(e)}};Et.__mp_recorder=hu;var tp=function(){};tp.prototype.create_properties=function(){};tp.prototype.event_handler=function(){};tp.prototype.after_track_handler=function(){};tp.prototype.init=function(r){return this.mp=r,this};tp.prototype.track=function(r,t,e,n){var o=this,s=P.dom_query(r);if(s.length===0){_r.error("The DOM query ("+r+") returned 0 elements");return}return P.each(s,function(i){P.register_event(i,this.override_event,function(a){var u={},l=o.create_properties(e,this),c=o.mp.get_config("track_links_timeout");o.event_handler(a,this,u),window.setTimeout(o.track_callback(n,l,u,!0),c),o.mp.track(t,l,o.track_callback(n,l,u))})},this),!0};tp.prototype.track_callback=function(r,t,e,n){n=n||!1;var o=this;return function(){e.callback_fired||(e.callback_fired=!0,!(r&&r(n,t)===!1)&&o.after_track_handler(t,e,n))}};tp.prototype.create_properties=function(r,t){var e;return typeof r=="function"?e=r(t):e=P.extend({},r),e};var vx=function(){this.override_event="click"};P.inherit(vx,tp);vx.prototype.create_properties=function(r,t){var e=vx.superclass.create_properties.apply(this,arguments);return t.href&&(e.url=t.href),e};vx.prototype.event_handler=function(r,t,e){e.new_tab=r.which===2||r.metaKey||r.ctrlKey||t.target==="_blank",e.href=t.href,e.new_tab||r.preventDefault()};vx.prototype.after_track_handler=function(r,t){t.new_tab||setTimeout(function(){window.location=t.href},0)};var Wk=function(){this.override_event="submit"};P.inherit(Wk,tp);Wk.prototype.event_handler=function(r,t,e){e.element=t,r.preventDefault()};Wk.prototype.after_track_handler=function(r,t){setTimeout(function(){t.element.submit()},0)};var ff="$set",bx="$set_once",du="$unset",am="$add",Zl="$append",um="$union",ep="$remove",BLe="$delete",lse={set_action:function(r,t){var e={},n={};return P.isObject(r)?P.each(r,function(o,s){this._is_reserved_property(s)||(n[s]=o)},this):n[r]=t,e[ff]=n,e},unset_action:function(r){var t={},e=[];return P.isArray(r)||(r=[r]),P.each(r,function(n){this._is_reserved_property(n)||e.push(n)},this),t[du]=e,t},set_once_action:function(r,t){var e={},n={};return P.isObject(r)?P.each(r,function(o,s){this._is_reserved_property(s)||(n[s]=o)},this):n[r]=t,e[bx]=n,e},union_action:function(r,t){var e={},n={};return P.isObject(r)?P.each(r,function(o,s){this._is_reserved_property(s)||(n[s]=P.isArray(o)?o:[o])},this):n[r]=P.isArray(t)?t:[t],e[um]=n,e},append_action:function(r,t){var e={},n={};return P.isObject(r)?P.each(r,function(o,s){this._is_reserved_property(s)||(n[s]=o)},this):n[r]=t,e[Zl]=n,e},remove_action:function(r,t){var e={},n={};return P.isObject(r)?P.each(r,function(o,s){this._is_reserved_property(s)||(n[s]=o)},this):n[r]=t,e[ep]=n,e},delete_action:function(){var r={};return r[BLe]="",r}},cn=function(){};P.extend(cn.prototype,lse);cn.prototype._init=function(r,t,e){this._mixpanel=r,this._group_key=t,this._group_id=e};cn.prototype.set=Cx(function(r,t,e){var n=this.set_action(r,t);return P.isObject(r)&&(e=t),this._send_request(n,e)});cn.prototype.set_once=Cx(function(r,t,e){var n=this.set_once_action(r,t);return P.isObject(r)&&(e=t),this._send_request(n,e)});cn.prototype.unset=Cx(function(r,t){var e=this.unset_action(r);return this._send_request(e,t)});cn.prototype.union=Cx(function(r,t,e){P.isObject(r)&&(e=t);var n=this.union_action(r,t);return this._send_request(n,e)});cn.prototype.delete=Cx(function(r){var t=this.delete_action();return this._send_request(t,r)});cn.prototype.remove=Cx(function(r,t,e){var n=this.remove_action(r,t);return this._send_request(n,e)});cn.prototype._send_request=function(r,t){r.$group_key=this._group_key,r.$group_id=this._group_id,r.$token=this._get_config("token");var e=P.encodeDates(r);return this._mixpanel._track_or_batch({type:"groups",data:e,endpoint:this._get_config("api_host")+"/"+this._get_config("api_routes").groups,batcher:this._mixpanel.request_batchers.groups},t)};cn.prototype._is_reserved_property=function(r){return r==="$group_key"||r==="$group_id"};cn.prototype._get_config=function(r){return this._mixpanel.get_config(r)};cn.prototype.toString=function(){return this._mixpanel.toString()+".group."+this._group_key+"."+this._group_id};cn.prototype.remove=cn.prototype.remove;cn.prototype.set=cn.prototype.set;cn.prototype.set_once=cn.prototype.set_once;cn.prototype.union=cn.prototype.union;cn.prototype.unset=cn.prototype.unset;cn.prototype.toString=cn.prototype.toString;var kt=function(){};P.extend(kt.prototype,lse);kt.prototype._init=function(r){this._mixpanel=r};kt.prototype.set=mf(function(r,t,e){var n=this.set_action(r,t);return P.isObject(r)&&(e=t),this._get_config("save_referrer")&&this._mixpanel.persistence.update_referrer_info(document.referrer),n[ff]=P.extend({},P.info.people_properties(),n[ff]),this._send_request(n,e)});kt.prototype.set_once=mf(function(r,t,e){var n=this.set_once_action(r,t);return P.isObject(r)&&(e=t),this._send_request(n,e)});kt.prototype.unset=mf(function(r,t){var e=this.unset_action(r);return this._send_request(e,t)});kt.prototype.increment=mf(function(r,t,e){var n={},o={};return P.isObject(r)?(P.each(r,function(s,i){if(!this._is_reserved_property(i))if(isNaN(parseFloat(s))){_r.error("Invalid increment value passed to mixpanel.people.increment - must be a number");return}else o[i]=s},this),e=t):(P.isUndefined(t)&&(t=1),o[r]=t),n[am]=o,this._send_request(n,e)});kt.prototype.append=mf(function(r,t,e){P.isObject(r)&&(e=t);var n=this.append_action(r,t);return this._send_request(n,e)});kt.prototype.remove=mf(function(r,t,e){P.isObject(r)&&(e=t);var n=this.remove_action(r,t);return this._send_request(n,e)});kt.prototype.union=mf(function(r,t,e){P.isObject(r)&&(e=t);var n=this.union_action(r,t);return this._send_request(n,e)});kt.prototype.track_charge=mf(function(r,t,e){if(!P.isNumber(r)&&(r=parseFloat(r),isNaN(r))){_r.error("Invalid value passed to mixpanel.people.track_charge - must be a number");return}return this.append("$transactions",P.extend({$amount:r},t),e)});kt.prototype.clear_charges=function(r){return this.set("$transactions",[],r)};kt.prototype.delete_user=function(){if(!this._identify_called()){_r.error("mixpanel.people.delete_user() requires you to call identify() first");return}var r={$delete:this._mixpanel.get_distinct_id()};return this._send_request(r)};kt.prototype.toString=function(){return this._mixpanel.toString()+".people"};kt.prototype._send_request=function(r,t){r.$token=this._get_config("token"),r.$distinct_id=this._mixpanel.get_distinct_id();var e=this._mixpanel.get_property("$device_id"),n=this._mixpanel.get_property("$user_id"),o=this._mixpanel.get_property("$had_persisted_distinct_id");e&&(r.$device_id=e),n&&(r.$user_id=n),o&&(r.$had_persisted_distinct_id=o);var s=P.encodeDates(r);return this._identify_called()?this._mixpanel._track_or_batch({type:"people",data:s,endpoint:this._get_config("api_host")+"/"+this._get_config("api_routes").engage,batcher:this._mixpanel.request_batchers.people},t):(this._enqueue(r),P.isUndefined(t)||(this._get_config("verbose")?t({status:-1,error:null}):t(-1)),P.truncate(s,255))};kt.prototype._get_config=function(r){return this._mixpanel.get_config(r)};kt.prototype._identify_called=function(){return this._mixpanel._flags.identify_called===!0};kt.prototype._enqueue=function(r){ff in r?this._mixpanel.persistence._add_to_people_queue(ff,r):bx in r?this._mixpanel.persistence._add_to_people_queue(bx,r):du in r?this._mixpanel.persistence._add_to_people_queue(du,r):am in r?this._mixpanel.persistence._add_to_people_queue(am,r):Zl in r?this._mixpanel.persistence._add_to_people_queue(Zl,r):ep in r?this._mixpanel.persistence._add_to_people_queue(ep,r):um in r?this._mixpanel.persistence._add_to_people_queue(um,r):_r.error("Invalid call to _enqueue():",r)};kt.prototype._flush_one_queue=function(r,t,e,n){var o=this,s=P.extend({},this._mixpanel.persistence.load_queue(r)),i=s;!P.isUndefined(s)&&P.isObject(s)&&!P.isEmptyObject(s)&&(o._mixpanel.persistence._pop_from_people_queue(r,s),o._mixpanel.persistence.save(),n&&(i=n(s)),t.call(o,i,function(a,u){a===0&&o._mixpanel.persistence._add_to_people_queue(r,s),P.isUndefined(e)||e(a,u)}))};kt.prototype._flush=function(r,t,e,n,o,s,i){var a=this;this._flush_one_queue(ff,this.set,r),this._flush_one_queue(bx,this.set_once,n),this._flush_one_queue(du,this.unset,s,function(g){return P.keys(g)}),this._flush_one_queue(am,this.increment,t),this._flush_one_queue(um,this.union,o);var u=this._mixpanel.persistence.load_queue(Zl);if(!P.isUndefined(u)&&P.isArray(u)&&u.length)for(var l,c=function(g,y){g===0&&a._mixpanel.persistence._add_to_people_queue(Zl,l),P.isUndefined(e)||e(g,y)},p=u.length-1;p>=0;p--)u=this._mixpanel.persistence.load_queue(Zl),l=u.pop(),a._mixpanel.persistence.save(),P.isEmptyObject(l)||a.append(l,c);var d=this._mixpanel.persistence.load_queue(ep);if(!P.isUndefined(d)&&P.isArray(d)&&d.length)for(var f,h=function(g,y){g===0&&a._mixpanel.persistence._add_to_people_queue(ep,f),P.isUndefined(i)||i(g,y)},m=d.length-1;m>=0;m--)d=this._mixpanel.persistence.load_queue(ep),f=d.pop(),a._mixpanel.persistence.save(),P.isEmptyObject(f)||a.remove(f,h)};kt.prototype._is_reserved_property=function(r){return r==="$distinct_id"||r==="$token"||r==="$device_id"||r==="$user_id"||r==="$had_persisted_distinct_id"};kt.prototype.set=kt.prototype.set;kt.prototype.set_once=kt.prototype.set_once;kt.prototype.unset=kt.prototype.unset;kt.prototype.increment=kt.prototype.increment;kt.prototype.append=kt.prototype.append;kt.prototype.remove=kt.prototype.remove;kt.prototype.union=kt.prototype.union;kt.prototype.track_charge=kt.prototype.track_charge;kt.prototype.clear_charges=kt.prototype.clear_charges;kt.prototype.delete_user=kt.prototype.delete_user;kt.prototype.toString=kt.prototype.toString;var eP="__mps",tP="__mpso",rP="__mpus",nP="__mpa",oP="__mpap",sP="__mpr",iP="__mpu",cse="$people_distinct_id",Lk="__alias",yw="__timers",VLe=[eP,tP,rP,nP,oP,sP,iP,cse,Lk,yw],Ut=function(r){this.props={},this.campaign_params_saved=!1,r.persistence_name?this.name="mp_"+r.persistence_name:this.name="mp_"+r.token+"_mixpanel";var t=r.persistence;t!=="cookie"&&t!=="localStorage"&&(_r.critical("Unknown persistence type "+t+"; falling back to cookie"),t=r.persistence="cookie"),t==="localStorage"&&P.localStorage.is_supported()?this.storage=P.localStorage:this.storage=P.cookie,this.load(),this.update_config(r),this.upgrade(),this.save()};Ut.prototype.properties=function(){var r={};return this.load(),P.each(this.props,function(t,e){P.include(VLe,e)||(r[e]=t)}),r};Ut.prototype.load=function(){if(!this.disabled){var r=this.storage.parse(this.name);r&&(this.props=P.extend({},r))}};Ut.prototype.upgrade=function(){var r,t;this.storage===P.localStorage?(r=P.cookie.parse(this.name),P.cookie.remove(this.name),P.cookie.remove(this.name,!0),r&&this.register_once(r)):this.storage===P.cookie&&(t=P.localStorage.parse(this.name),P.localStorage.remove(this.name),t&&this.register_once(t))};Ut.prototype.save=function(){this.disabled||this.storage.set(this.name,P.JSONEncode(this.props),this.expire_days,this.cross_subdomain,this.secure,this.cross_site,this.cookie_domain)};Ut.prototype.load_prop=function(r){return this.load(),this.props[r]};Ut.prototype.remove=function(){this.storage.remove(this.name,!1,this.cookie_domain),this.storage.remove(this.name,!0,this.cookie_domain)};Ut.prototype.clear=function(){this.remove(),this.props={}};Ut.prototype.register_once=function(r,t,e){return P.isObject(r)?(typeof t>"u"&&(t="None"),this.expire_days=typeof e>"u"?this.default_expiry:e,this.load(),P.each(r,function(n,o){(!this.props.hasOwnProperty(o)||this.props[o]===t)&&(this.props[o]=n)},this),this.save(),!0):!1};Ut.prototype.register=function(r,t){return P.isObject(r)?(this.expire_days=typeof t>"u"?this.default_expiry:t,this.load(),P.extend(this.props,r),this.save(),!0):!1};Ut.prototype.unregister=function(r){this.load(),r in this.props&&(delete this.props[r],this.save())};Ut.prototype.update_search_keyword=function(r){this.register(P.info.searchInfo(r))};Ut.prototype.update_referrer_info=function(r){this.register_once({$initial_referrer:r||"$direct",$initial_referring_domain:P.info.referringDomain(r)||"$direct"},"")};Ut.prototype.get_referrer_info=function(){return P.strip_empty_properties({$initial_referrer:this.props.$initial_referrer,$initial_referring_domain:this.props.$initial_referring_domain})};Ut.prototype.update_config=function(r){this.default_expiry=this.expire_days=r.cookie_expiration,this.set_disabled(r.disable_persistence),this.set_cookie_domain(r.cookie_domain),this.set_cross_site(r.cross_site_cookie),this.set_cross_subdomain(r.cross_subdomain_cookie),this.set_secure(r.secure_cookie)};Ut.prototype.set_disabled=function(r){this.disabled=r,this.disabled?this.remove():this.save()};Ut.prototype.set_cookie_domain=function(r){r!==this.cookie_domain&&(this.remove(),this.cookie_domain=r,this.save())};Ut.prototype.set_cross_site=function(r){r!==this.cross_site&&(this.cross_site=r,this.remove(),this.save())};Ut.prototype.set_cross_subdomain=function(r){r!==this.cross_subdomain&&(this.cross_subdomain=r,this.remove(),this.save())};Ut.prototype.get_cross_subdomain=function(){return this.cross_subdomain};Ut.prototype.set_secure=function(r){r!==this.secure&&(this.secure=!!r,this.remove(),this.save())};Ut.prototype._add_to_people_queue=function(r,t){var e=this._get_queue_key(r),n=t[r],o=this._get_or_create_queue(ff),s=this._get_or_create_queue(bx),i=this._get_or_create_queue(du),a=this._get_or_create_queue(am),u=this._get_or_create_queue(um),l=this._get_or_create_queue(ep,[]),c=this._get_or_create_queue(Zl,[]);e===eP?(P.extend(o,n),this._pop_from_people_queue(am,n),this._pop_from_people_queue(um,n),this._pop_from_people_queue(du,n)):e===tP?(P.each(n,function(p,d){d in s||(s[d]=p)}),this._pop_from_people_queue(du,n)):e===rP?P.each(n,function(p){P.each([o,s,a,u],function(d){p in d&&delete d[p]}),P.each(c,function(d){p in d&&delete d[p]}),i[p]=!0}):e===nP?(P.each(n,function(p,d){d in o?o[d]+=p:(d in a||(a[d]=0),a[d]+=p)},this),this._pop_from_people_queue(du,n)):e===iP?(P.each(n,function(p,d){P.isArray(p)&&(d in u||(u[d]=[]),u[d]=u[d].concat(p))}),this._pop_from_people_queue(du,n)):e===sP?(l.push(n),this._pop_from_people_queue(Zl,n)):e===oP&&(c.push(n),this._pop_from_people_queue(du,n)),_r.log("MIXPANEL PEOPLE REQUEST (QUEUED, PENDING IDENTIFY):"),_r.log(t),this.save()};Ut.prototype._pop_from_people_queue=function(r,t){var e=this.props[this._get_queue_key(r)];P.isUndefined(e)||P.each(t,function(n,o){r===Zl||r===ep?P.each(e,function(s){s[o]===n&&delete s[o]}):delete e[o]},this)};Ut.prototype.load_queue=function(r){return this.load_prop(this._get_queue_key(r))};Ut.prototype._get_queue_key=function(r){if(r===ff)return eP;if(r===bx)return tP;if(r===du)return rP;if(r===am)return nP;if(r===Zl)return oP;if(r===ep)return sP;if(r===um)return iP;_r.error("Invalid queue:",r)};Ut.prototype._get_or_create_queue=function(r,t){var e=this._get_queue_key(r);return t=P.isUndefined(t)?{}:t,this.props[e]||(this.props[e]=t)};Ut.prototype.set_event_timer=function(r,t){var e=this.load_prop(yw)||{};e[r]=t,this.props[yw]=e,this.save()};Ut.prototype.remove_event_timer=function(r){var t=this.load_prop(yw)||{},e=t[r];return P.isUndefined(e)||(delete this.props[yw][r],this.save()),e};var aP,pse=function(r,t){throw new Error(r+" not available in this build.")},jo,dse=0,ULe=1,GLe=function(r){return r},xw=function(){},Pi="mixpanel",fse="base64",WLe="json",uP="$device:",yx=Et.XMLHttpRequest&&"withCredentials"in new XMLHttpRequest,hse=!yx&&Yl.indexOf("MSIE")===-1&&Yl.indexOf("Mozilla")===-1,zk=null;df.sendBeacon&&(zk=function(){return df.sendBeacon.apply(df,arguments)});var mse={track:"track/",engage:"engage/",groups:"groups/",record:"record/"},Ooe={api_host:"https://api-js.mixpanel.com",api_routes:mse,api_method:"POST",api_transport:"XHR",api_payload_format:fse,app_host:"https://mixpanel.com",cdn:"https://cdn.mxpnl.com",cross_site_cookie:!1,cross_subdomain_cookie:!0,error_reporter:xw,persistence:"cookie",persistence_name:"",cookie_domain:"",cookie_name:"",loaded:xw,mp_loader:null,track_marketing:!0,track_pageview:!1,skip_first_touch_marketing:!1,store_google:!0,stop_utm_persistence:!1,save_referrer:!0,test:!1,verbose:!1,img:!1,debug:!1,track_links_timeout:300,cookie_expiration:365,upgrade:!1,disable_persistence:!1,disable_cookie:!1,secure_cookie:!1,ip:!0,opt_out_tracking_by_default:!1,opt_out_persistence_by_default:!1,opt_out_tracking_persistence_type:"localStorage",opt_out_tracking_cookie_prefix:null,property_blacklist:[],xhr_headers:{},ignore_dnt:!1,batch_requests:!0,batch_size:50,batch_flush_interval_ms:5e3,batch_request_timeout_ms:9e4,batch_autostart:!0,hooks:{},record_block_class:new RegExp("^(mp-block|fs-exclude|amp-block|rr-block|ph-no-capture)$"),record_block_selector:"img, video",record_collect_fonts:!1,record_idle_timeout_ms:30*60*1e3,record_inline_images:!1,record_mask_text_class:new RegExp("^(mp-mask|fs-mask|amp-mask|rr-mask|ph-mask)$"),record_mask_text_selector:"*",record_max_ms:fw,record_min_ms:0,record_sessions_percent:0,recorder_src:"https://cdn.mxpnl.com/libs/mixpanel-recorder.min.js"},gse=!1,he=function(){},H$=function(r,t,e){var n,o=e===Pi?jo:jo[e];if(o&&aP===dse)n=o;else{if(o&&!P.isArray(o)){_r.error("You have already initialized "+e);return}n=new he}if(n._cached_groups={},n._init(r,t,e),n.people=new kt,n.people._init(n),!n.get_config("skip_first_touch_marketing")){var s=P.info.campaignParams(null),i={},a=!1;P.each(s,function(u,l){i["initial_"+l]=u,u&&(a=!0)}),a&&n.people.set_once(i)}return Jc.DEBUG=Jc.DEBUG||n.get_config("debug"),!P.isUndefined(o)&&P.isArray(o)&&(n._execute_array.call(n.people,o.people),n._execute_array(o)),n};he.prototype.init=function(r,t,e){if(P.isUndefined(e)){this.report_error("You must name your new library: init(token, config, name)");return}if(e===Pi){this.report_error("You must initialize the main mixpanel object right after you include the Mixpanel js snippet");return}var n=H$(r,t,e);return jo[e]=n,n._loaded(),n};he.prototype._init=function(r,t,e){t=t||{},this.__loaded=!0,this.config={};var n={};if(!("api_payload_format"in t)){var o=t.api_host||Ooe.api_host;o.match(/\.mixpanel\.com/)&&(n.api_payload_format=WLe)}if(this.set_config(P.extend({},Ooe,n,t,{name:e,token:r,callback_fn:(e===Pi?e:Pi+"."+e)+"._jsc"})),this._jsc=xw,this.__dom_loaded_queue=[],this.__request_queue=[],this.__disabled_events=[],this._flags={disable_all_events:!1,identify_called:!1},this.request_batchers={},this._batch_requests=this.get_config("batch_requests"),this._batch_requests){if(!P.localStorage.is_supported(!0)||!yx)this._batch_requests=!1,_r.log("Turning off Mixpanel request-queueing; needs XHR and localStorage support"),P.each(this.get_batcher_configs(),function(u){_r.log("Clearing batch queue "+u.queue_key),P.localStorage.remove(u.queue_key)});else if(this.init_batchers(),zk&&Et.addEventListener){var s=P.bind(function(){this.request_batchers.events.stopped||this.request_batchers.events.flush({unloading:!0})},this);Et.addEventListener("pagehide",function(u){u.persisted&&s()}),Et.addEventListener("visibilitychange",function(){Yr.visibilityState==="hidden"&&s()})}}this.persistence=this.cookie=new Ut(this.config),this.unpersisted_superprops={},this._gdpr_init();var i=P.UUID();this.get_distinct_id()||this.register_once({distinct_id:uP+i,$device_id:i},"");var a=this.get_config("track_pageview");a&&this._init_url_change_tracking(a),this.get_config("record_sessions_percent")>0&&Math.random()*100<=this.get_config("record_sessions_percent")&&this.start_session_recording()};he.prototype.start_session_recording=hf(function(){if(!Et.MutationObserver){_r.critical("Browser does not support MutationObserver; skipping session recording");return}var r=P.bind(function(){this._recorder=this._recorder||new Et.__mp_recorder(this),this._recorder.startRecording()},this);P.isUndefined(Et.__mp_recorder)?pse(this.get_config("recorder_src"),r):r()});he.prototype.stop_session_recording=function(){this._recorder?this._recorder.stopRecording():_r.critical("Session recorder module not loaded")};he.prototype.get_session_recording_properties=function(){var r={};if(this._recorder){var t=this._recorder.replayId;t&&(r.$mp_replay_id=t)}return r};he.prototype._loaded=function(){if(this.get_config("loaded")(this),this._set_default_superprops(),this.people.set_once(this.persistence.get_referrer_info()),this.get_config("store_google")&&this.get_config("stop_utm_persistence")){var r=P.info.campaignParams(null);P.each(r,(function(t,e){this.unregister(e)}).bind(this))}};he.prototype._set_default_superprops=function(){this.persistence.update_search_keyword(Yr.referrer),this.get_config("store_google")&&!this.get_config("stop_utm_persistence")&&this.register(P.info.campaignParams()),this.get_config("save_referrer")&&this.persistence.update_referrer_info(Yr.referrer)};he.prototype._dom_loaded=function(){P.each(this.__dom_loaded_queue,function(r){this._track_dom.apply(this,r)},this),this.has_opted_out_tracking()||P.each(this.__request_queue,function(r){this._send_request.apply(this,r)},this),delete this.__dom_loaded_queue,delete this.__request_queue};he.prototype._track_dom=function(r,t){if(this.get_config("img"))return this.report_error("You can't use DOM tracking functions with img = true."),!1;if(!gse)return this.__dom_loaded_queue.push([r,t]),!1;var e=new r().init(this);return e.track.apply(e,t)};he.prototype._init_url_change_tracking=function(r){var t="",e=this.track_pageview();if(e&&(t=P.info.currentUrl()),P.include(["full-url","url-with-path-and-query-string","url-with-path"],r)){Et.addEventListener("popstate",function(){Et.dispatchEvent(new Event("mp_locationchange"))}),Et.addEventListener("hashchange",function(){Et.dispatchEvent(new Event("mp_locationchange"))});var n=Et.history.pushState;typeof n=="function"&&(Et.history.pushState=function(s,i,a){n.call(Et.history,s,i,a),Et.dispatchEvent(new Event("mp_locationchange"))});var o=Et.history.replaceState;typeof o=="function"&&(Et.history.replaceState=function(s,i,a){o.call(Et.history,s,i,a),Et.dispatchEvent(new Event("mp_locationchange"))}),Et.addEventListener("mp_locationchange",(function(){var s=P.info.currentUrl(),i=!1;if(r==="full-url"?i=s!==t:r==="url-with-path-and-query-string"?i=s.split("#")[0]!==t.split("#")[0]:r==="url-with-path"&&(i=s.split("#")[0].split("?")[0]!==t.split("#")[0].split("?")[0]),i){var a=this.track_pageview();a&&(t=s)}}).bind(this))}};he.prototype._prepare_callback=function(r,t){if(P.isUndefined(r))return null;if(yx){var e=function(i){r(i,t)};return e}else{var n=this._jsc,o=""+Math.floor(Math.random()*1e8),s=this.get_config("callback_fn")+"["+o+"]";return n[o]=function(i){delete n[o],r(i,t)},s}};he.prototype._send_request=function(r,t,e,n){var o=!0;if(hse)return this.__request_queue.push(arguments),o;var s={method:this.get_config("api_method"),transport:this.get_config("api_transport"),verbose:this.get_config("verbose")},i=null;!n&&(P.isFunction(e)||typeof e=="string")&&(n=e,e=null),e=P.extend(s,e||{}),yx||(e.method="GET");var a=e.method==="POST",u=zk&&a&&e.transport.toLowerCase()==="sendbeacon",l=e.verbose;t.verbose&&(l=!0),this.get_config("test")&&(t.test=1),l&&(t.verbose=1),this.get_config("img")&&(t.img=1),yx||(n?t.callback=n:(l||this.get_config("test"))&&(t.callback="(function(){})")),t.ip=this.get_config("ip")?1:0,t._=new Date().getTime().toString(),a&&(i="data="+encodeURIComponent(t.data),delete t.data),r+="?"+P.HTTPBuildQuery(t);var c=this;if("img"in t){var p=Yr.createElement("img");p.src=r,Yr.body.appendChild(p)}else if(u){try{o=zk(r,i)}catch(y){c.report_error(y),o=!1}try{n&&n(o?1:0)}catch(y){c.report_error(y)}}else if(yx)try{var d=new XMLHttpRequest;d.open(e.method,r,!0);var f=this.get_config("xhr_headers");if(a&&(f["Content-Type"]="application/x-www-form-urlencoded"),P.each(f,function(y,x){d.setRequestHeader(x,y)}),e.timeout_ms&&typeof d.timeout<"u"){d.timeout=e.timeout_ms;var h=new Date().getTime()}d.withCredentials=!0,d.onreadystatechange=function(){if(d.readyState===4)if(d.status===200){if(n)if(l){var y;try{y=P.JSONDecode(d.responseText)}catch(C){if(c.report_error(C),e.ignore_json_errors)y=d.responseText;else return}n(y)}else n(Number(d.responseText))}else{var x;if(d.timeout&&!d.status&&new Date().getTime()-h>=d.timeout?x="timeout":x="Bad HTTP status: "+d.status+" "+d.statusText,c.report_error(x),n)if(l){var w=d.responseHeaders||{};n({status:0,httpStatusCode:d.status,error:x,retryAfter:w["Retry-After"]})}else n(0)}},d.send(i)}catch(y){c.report_error(y),o=!1}else{var m=Yr.createElement("script");m.type="text/javascript",m.async=!0,m.defer=!0,m.src=r;var g=Yr.getElementsByTagName("script")[0];g.parentNode.insertBefore(m,g)}return o};he.prototype._execute_array=function(r){var t,e=[],n=[],o=[];P.each(r,function(i){i&&(t=i[0],P.isArray(t)?o.push(i):typeof i=="function"?i.call(this):P.isArray(i)&&t==="alias"?e.push(i):P.isArray(i)&&t.indexOf("track")!==-1&&typeof this[t]=="function"?o.push(i):n.push(i))},this);var s=function(i,a){P.each(i,function(u){if(P.isArray(u[0])){var l=a;P.each(u,function(c){l=l[c[0]].apply(l,c.slice(1))})}else this[u[0]].apply(this,u.slice(1))},a)};s(e,this),s(n,this),s(o,this)};he.prototype.are_batchers_initialized=function(){return!!this.request_batchers.events};he.prototype.get_batcher_configs=function(){var r="__mpq_"+this.get_config("token"),t=this.get_config("api_routes");return this._batcher_configs=this._batcher_configs||{events:{type:"events",endpoint:"/"+t.track,queue_key:r+"_ev"},people:{type:"people",endpoint:"/"+t.engage,queue_key:r+"_pp"},groups:{type:"groups",endpoint:"/"+t.groups,queue_key:r+"_gr"}},this._batcher_configs};he.prototype.init_batchers=function(){if(!this.are_batchers_initialized()){var r=P.bind(function(e){return new fu(e.queue_key,{libConfig:this.config,errorReporter:this.get_config("error_reporter"),sendRequestFunc:P.bind(function(n,o,s){this._send_request(this.get_config("api_host")+e.endpoint,this._encode_data_for_request(n),o,this._prepare_callback(s,n))},this),beforeSendHook:P.bind(function(n){return this._run_hook("before_send_"+e.type,n)},this),stopAllBatchingFunc:P.bind(this.stop_batch_senders,this),usePersistence:!0})},this),t=this.get_batcher_configs();this.request_batchers={events:r(t.events),people:r(t.people),groups:r(t.groups)}}this.get_config("batch_autostart")&&this.start_batch_senders()};he.prototype.start_batch_senders=function(){this._batchers_were_started=!0,this.are_batchers_initialized()&&(this._batch_requests=!0,P.each(this.request_batchers,function(r){r.start()}))};he.prototype.stop_batch_senders=function(){this._batch_requests=!1,P.each(this.request_batchers,function(r){r.stop(),r.clear()})};he.prototype.push=function(r){this._execute_array([r])};he.prototype.disable=function(r){typeof r>"u"?this._flags.disable_all_events=!0:this.__disabled_events=this.__disabled_events.concat(r)};he.prototype._encode_data_for_request=function(r){var t=P.JSONEncode(r);return this.get_config("api_payload_format")===fse&&(t=P.base64Encode(t)),{data:t}};he.prototype._track_or_batch=function(r,t){var e=P.truncate(r.data,255),n=r.endpoint,o=r.batcher,s=r.should_send_immediately,i=r.send_request_options||{};t=t||xw;var a=!0,u=P.bind(function(){return i.skip_hooks||(e=this._run_hook("before_send_"+r.type,e)),e?(_r.log("MIXPANEL REQUEST:"),_r.log(e),this._send_request(n,this._encode_data_for_request(e),i,this._prepare_callback(t,e))):null},this);return this._batch_requests&&!s?o.enqueue(e,function(l){l?t(1,e):u()}):a=u(),a&&e};he.prototype.track=hf(function(r,t,e,n){!n&&typeof e=="function"&&(n=e,e=null),e=e||{};var o=e.transport;o&&(e.transport=o);var s=e.send_immediately;if(typeof n!="function"&&(n=xw),P.isUndefined(r)){this.report_error("No event name provided to mixpanel.track");return}if(this._event_is_disabled(r)){n(0);return}t=P.extend({},t),t.token=this.get_config("token");var i=this.persistence.remove_event_timer(r);if(!P.isUndefined(i)){var a=new Date().getTime()-i;t.$duration=parseFloat((a/1e3).toFixed(3))}this._set_default_superprops();var u=this.get_config("track_marketing")?P.info.marketingParams():{};t=P.extend({},P.info.properties({mp_loader:this.get_config("mp_loader")}),u,this.persistence.properties(),this.unpersisted_superprops,this.get_session_recording_properties(),t);var l=this.get_config("property_blacklist");P.isArray(l)?P.each(l,function(d){delete t[d]}):this.report_error("Invalid value for property_blacklist config: "+l);var c={event:r,properties:t},p=this._track_or_batch({type:"events",data:c,endpoint:this.get_config("api_host")+"/"+this.get_config("api_routes").track,batcher:this.request_batchers.events,should_send_immediately:s,send_request_options:e},n);return p});he.prototype.set_group=hf(function(r,t,e){P.isArray(t)||(t=[t]);var n={};return n[r]=t,this.register(n),this.people.set(r,t,e)});he.prototype.add_group=hf(function(r,t,e){var n=this.get_property(r),o={};return n===void 0?(o[r]=[t],this.register(o)):n.indexOf(t)===-1&&(n.push(t),o[r]=n,this.register(o)),this.people.union(r,t,e)});he.prototype.remove_group=hf(function(r,t,e){var n=this.get_property(r);if(n!==void 0){var o=n.indexOf(t);o>-1&&(n.splice(o,1),this.register({group_key:n})),n.length===0&&this.unregister(r)}return this.people.remove(r,t,e)});he.prototype.track_with_groups=hf(function(r,t,e,n){var o=P.extend({},t||{});return P.each(e,function(s,i){s!=null&&(o[i]=s)}),this.track(r,o,n)});he.prototype._create_map_key=function(r,t){return r+"_"+JSON.stringify(t)};he.prototype._remove_group_from_cache=function(r,t){delete this._cached_groups[this._create_map_key(r,t)]};he.prototype.get_group=function(r,t){var e=this._create_map_key(r,t),n=this._cached_groups[e];return(n===void 0||n._group_key!==r||n._group_id!==t)&&(n=new cn,n._init(this,r,t),this._cached_groups[e]=n),n};he.prototype.track_pageview=hf(function(r,t){typeof r!="object"&&(r={}),t=t||{};var e=t.event_name||"$mp_web_page_view",n=P.extend(P.info.mpPageViewProperties(),P.info.campaignParams(),P.info.clickParams()),o=P.extend({},n,r);return this.track(e,o)});he.prototype.track_links=function(){return this._track_dom.call(this,vx,arguments)};he.prototype.track_forms=function(){return this._track_dom.call(this,Wk,arguments)};he.prototype.time_event=function(r){if(P.isUndefined(r)){this.report_error("No event name provided to mixpanel.time_event");return}this._event_is_disabled(r)||this.persistence.set_event_timer(r,new Date().getTime())};var jLe={persistent:!0},lP=function(r){var t;return P.isObject(r)?t=r:P.isUndefined(r)?t={}:t={days:r},P.extend({},jLe,t)};he.prototype.register=function(r,t){var e=lP(t);e.persistent?this.persistence.register(r,e.days):P.extend(this.unpersisted_superprops,r)};he.prototype.register_once=function(r,t,e){var n=lP(e);n.persistent?this.persistence.register_once(r,t,n.days):(typeof t>"u"&&(t="None"),P.each(r,function(o,s){(!this.unpersisted_superprops.hasOwnProperty(s)||this.unpersisted_superprops[s]===t)&&(this.unpersisted_superprops[s]=o)},this))};he.prototype.unregister=function(r,t){t=lP(t),t.persistent?this.persistence.unregister(r):delete this.unpersisted_superprops[r]};he.prototype._register_single=function(r,t){var e={};e[r]=t,this.register(e)};he.prototype.identify=function(r,t,e,n,o,s,i,a){var u=this.get_distinct_id();if(r&&u!==r){if(typeof r=="string"&&r.indexOf(uP)===0)return this.report_error("distinct_id cannot have $device: prefix"),-1;this.register({$user_id:r})}if(!this.get_property("$device_id")){var l=u;this.register_once({$had_persisted_distinct_id:!0,$device_id:l},"")}r!==u&&r!==this.get_property(Lk)&&(this.unregister(Lk),this.register({distinct_id:r})),this._flags.identify_called=!0,this.people._flush(t,e,n,o,s,i,a),r!==u&&this.track("$identify",{distinct_id:r,$anon_distinct_id:u},{skip_hooks:!0})};he.prototype.reset=function(){this.persistence.clear(),this._flags.identify_called=!1;var r=P.UUID();this.register_once({distinct_id:uP+r,$device_id:r},"")};he.prototype.get_distinct_id=function(){return this.get_property("distinct_id")};he.prototype.alias=function(r,t){if(r===this.get_property(cse))return this.report_error("Attempting to create alias for existing People user - aborting."),-2;var e=this;return P.isUndefined(t)&&(t=this.get_distinct_id()),r!==t?(this._register_single(Lk,r),this.track("$create_alias",{alias:r,distinct_id:t},{skip_hooks:!0},function(){e.identify(r)})):(this.report_error("alias matches current distinct_id - skipping api call."),this.identify(r),-1)};he.prototype.name_tag=function(r){this._register_single("mp_name_tag",r)};he.prototype.set_config=function(r){if(P.isObject(r)){P.extend(this.config,r);var t=r.batch_size;t&&P.each(this.request_batchers,function(e){e.resetBatchSize()}),this.get_config("persistence_name")||(this.config.persistence_name=this.config.cookie_name),this.get_config("disable_persistence")||(this.config.disable_persistence=this.config.disable_cookie),this.persistence&&this.persistence.update_config(this.config),Jc.DEBUG=Jc.DEBUG||this.get_config("debug")}};he.prototype.get_config=function(r){return this.config[r]};he.prototype._run_hook=function(r){var t=(this.config.hooks[r]||GLe).apply(this,pf.call(arguments,1));return typeof t>"u"&&(this.report_error(r+" hook did not return a value"),t=null),t};he.prototype.get_property=function(r){return this.persistence.load_prop([r])};he.prototype.toString=function(){var r=this.get_config("name");return r!==Pi&&(r=Pi+"."+r),r};he.prototype._event_is_disabled=function(r){return P.isBlockedUA(Yl)||this._flags.disable_all_events||P.include(this.__disabled_events,r)};he.prototype._gdpr_init=function(){var r=this.get_config("opt_out_tracking_persistence_type")==="localStorage";r&&P.localStorage.is_supported()&&(!this.has_opted_in_tracking()&&this.has_opted_in_tracking({persistence_type:"cookie"})&&this.opt_in_tracking({enable_persistence:!1}),!this.has_opted_out_tracking()&&this.has_opted_out_tracking({persistence_type:"cookie"})&&this.opt_out_tracking({clear_persistence:!1}),this.clear_opt_in_out_tracking({persistence_type:"cookie",enable_persistence:!1})),this.has_opted_out_tracking()?this._gdpr_update_persistence({clear_persistence:!0}):!this.has_opted_in_tracking()&&(this.get_config("opt_out_tracking_by_default")||P.cookie.get("mp_optout"))&&(P.cookie.remove("mp_optout"),this.opt_out_tracking({clear_persistence:this.get_config("opt_out_persistence_by_default")}))};he.prototype._gdpr_update_persistence=function(r){var t;if(r&&r.clear_persistence)t=!0;else if(r&&r.enable_persistence)t=!1;else return;!this.get_config("disable_persistence")&&this.persistence.disabled!==t&&this.persistence.set_disabled(t),t?this.stop_batch_senders():this._batchers_were_started&&this.start_batch_senders()};he.prototype._gdpr_call_func=function(r,t){return t=P.extend({track:P.bind(this.track,this),persistence_type:this.get_config("opt_out_tracking_persistence_type"),cookie_prefix:this.get_config("opt_out_tracking_cookie_prefix"),cookie_expiration:this.get_config("cookie_expiration"),cross_site_cookie:this.get_config("cross_site_cookie"),cross_subdomain_cookie:this.get_config("cross_subdomain_cookie"),cookie_domain:this.get_config("cookie_domain"),secure_cookie:this.get_config("secure_cookie"),ignore_dnt:this.get_config("ignore_dnt")},t),P.localStorage.is_supported()||(t.persistence_type="cookie"),r(this.get_config("token"),{track:t.track,trackEventName:t.track_event_name,trackProperties:t.track_properties,persistenceType:t.persistence_type,persistencePrefix:t.cookie_prefix,cookieDomain:t.cookie_domain,cookieExpiration:t.cookie_expiration,crossSiteCookie:t.cross_site_cookie,crossSubdomainCookie:t.cross_subdomain_cookie,secureCookie:t.secure_cookie,ignoreDnt:t.ignore_dnt})};he.prototype.opt_in_tracking=function(r){r=P.extend({enable_persistence:!0},r),this._gdpr_call_func(DLe,r),this._gdpr_update_persistence(r)};he.prototype.opt_out_tracking=function(r){r=P.extend({clear_persistence:!0,delete_user:!0},r),r.delete_user&&this.people&&this.people._identify_called()&&(this.people.delete_user(),this.people.clear_charges()),this._gdpr_call_func(ALe,r),this._gdpr_update_persistence(r)};he.prototype.has_opted_in_tracking=function(r){return this._gdpr_call_func(RLe,r)};he.prototype.has_opted_out_tracking=function(r){return this._gdpr_call_func(sse,r)};he.prototype.clear_opt_in_out_tracking=function(r){r=P.extend({enable_persistence:!0},r),this._gdpr_call_func(OLe,r),this._gdpr_update_persistence(r)};he.prototype.report_error=function(r,t){_r.error.apply(_r.error,arguments);try{!t&&!(r instanceof Error)&&(r=new Error(r)),this.get_config("error_reporter")(r,t)}catch(e){_r.error(e)}};he.prototype.init=he.prototype.init;he.prototype.reset=he.prototype.reset;he.prototype.disable=he.prototype.disable;he.prototype.time_event=he.prototype.time_event;he.prototype.track=he.prototype.track;he.prototype.track_links=he.prototype.track_links;he.prototype.track_forms=he.prototype.track_forms;he.prototype.track_pageview=he.prototype.track_pageview;he.prototype.register=he.prototype.register;he.prototype.register_once=he.prototype.register_once;he.prototype.unregister=he.prototype.unregister;he.prototype.identify=he.prototype.identify;he.prototype.alias=he.prototype.alias;he.prototype.name_tag=he.prototype.name_tag;he.prototype.set_config=he.prototype.set_config;he.prototype.get_config=he.prototype.get_config;he.prototype.get_property=he.prototype.get_property;he.prototype.get_distinct_id=he.prototype.get_distinct_id;he.prototype.toString=he.prototype.toString;he.prototype.opt_out_tracking=he.prototype.opt_out_tracking;he.prototype.opt_in_tracking=he.prototype.opt_in_tracking;he.prototype.has_opted_out_tracking=he.prototype.has_opted_out_tracking;he.prototype.has_opted_in_tracking=he.prototype.has_opted_in_tracking;he.prototype.clear_opt_in_out_tracking=he.prototype.clear_opt_in_out_tracking;he.prototype.get_group=he.prototype.get_group;he.prototype.set_group=he.prototype.set_group;he.prototype.add_group=he.prototype.add_group;he.prototype.remove_group=he.prototype.remove_group;he.prototype.track_with_groups=he.prototype.track_with_groups;he.prototype.start_batch_senders=he.prototype.start_batch_senders;he.prototype.stop_batch_senders=he.prototype.stop_batch_senders;he.prototype.start_session_recording=he.prototype.start_session_recording;he.prototype.stop_session_recording=he.prototype.stop_session_recording;he.prototype.get_session_recording_properties=he.prototype.get_session_recording_properties;he.prototype.DEFAULT_API_ROUTES=mse;Ut.prototype.properties=Ut.prototype.properties;Ut.prototype.update_search_keyword=Ut.prototype.update_search_keyword;Ut.prototype.update_referrer_info=Ut.prototype.update_referrer_info;Ut.prototype.get_cross_subdomain=Ut.prototype.get_cross_subdomain;Ut.prototype.clear=Ut.prototype.clear;var gx={},HLe=function(){P.each(gx,function(r,t){t!==Pi&&(jo[t]=r)}),jo._=P},qLe=function(){jo.init=function(r,t,e){if(e)return jo[e]||(jo[e]=gx[e]=H$(r,t,e),jo[e]._loaded()),jo[e];var n=jo;gx[Pi]?n=gx[Pi]:r&&(n=H$(r,t,Pi),n._loaded(),gx[Pi]=n),jo=n,aP===ULe&&(Et[Pi]=jo),HLe()}},KLe=function(){function r(){r.done||(r.done=!0,gse=!0,hse=!1,P.each(gx,function(n){n._dom_loaded()}))}function t(){try{Yr.documentElement.doScroll("left")}catch{setTimeout(t,1);return}r()}if(Yr.addEventListener)Yr.readyState==="complete"?r():Yr.addEventListener("DOMContentLoaded",r,!1);else if(Yr.attachEvent){Yr.attachEvent("onreadystatechange",r);var e=!1;try{e=Et.frameElement===null}catch{}Yr.documentElement.doScroll&&e&&t()}P.register_event(Et,"load",r,!0)};function XLe(r){return pse=r,aP=dse,jo=new he,qLe(),jo.init(),KLe(),jo}function YLe(r,t){t()}var Cw=XLe(YLe);var Ql=class r{currentUserId="";mixpanelService;constructor(){Cw.init(nm.mixpanelApiKey)}track(t,e){e=mn(et({},e),{version:W0}),console.log("[events.track]",t,e),Cw.track(t,e)}identify(t){console.log("[events.identify]",t),Cw.identify(t),Cw.people.set({$name:t})}static \u0275fac=function(e){return new(e||r)};static \u0275prov=Qe({token:r,factory:r.\u0275fac,providedIn:"root"})};var cP=class{average=new Mr;events=[];start=0;seconds2Track;milisecs2Track;constructor(t){this.seconds2Track=t,this.milisecs2Track=t*1e3}track(t){if(this.events.push(t),this.start==0&&(this.start=performance.now()),performance.now()-this.start>this.milisecs2Track){let n=this.events.reduce((o,s)=>o+s,0)/this.events.length;this.average.next(n),this.events=[],this.start=performance.now()}}},Hk=class r{constructor(t){this.events=t}detector=null;tracker=new cP(180);modelName4Event="MoveNet.MultiPose.Lightning";isReady(){return!!this.detector}buildMoveNetPoseDetector(){return L(this,null,function*(){let t=To.MoveNet;return yield B8(t,{modelType:"MultiPose.Lightning"})})}initPoseDetection(){return L(this,null,function*(){return this.events.track("pose.detection.init",{step:0,name:"start"}),yield zU(),this.events.track("pose.detection.init",{step:1,name:"tensorflow.ready",tensorflowBackend:El()}),this.detector||(this.events.track("pose.detection.init",{step:2,name:"no.detector.found"}),this.detector=yield this.buildMoveNetPoseDetector(),this.events.track("pose.detection.init",{step:3,model:this.modelName4Event,name:"detector.created"})),this.tracker.average.subscribe(t=>{this.events.track("pose.detection.stats",{seconds:this.tracker.seconds2Track,average:t,model:this.modelName4Event,tensorflowBackend:El()})}),this.detector})}detect(t){return L(this,null,function*(){if(!this.detector)throw this.events.track("error",{name:"no.pose.detector.found"}),new Error("Pose detector is not initialized. Call initPoseDetection() first.");let e=performance.now(),n=yield this.detector.estimatePoses(t,{maxPoses:1,flipHorizontal:!1,scoreThreshold:.5}),o=this.flipPosesHorizontally(t,n),s=performance.now();return this.tracker.track(s-e),o})}flipPosesHorizontally(t,e){let n=t.videoWidth;return e.forEach(o=>{o.keypoints.forEach(s=>{s.x=n-s.x})}),e}static \u0275fac=function(e){return new(e||r)(St(Ql))};static \u0275prov=Qe({token:r,factory:r.\u0275fac,providedIn:"root"})};var Sx=class r{constructor(t,e){this.poseDectectorService=t;this.notification=e;this.refresh=Ip.getInstance()}video=null;videoElement=null;output=null;poses=[];refresh;ngOnInit(){return L(this,null,function*(){this.video&&this.video.subscribe(t=>L(this,null,function*(){this.videoElement=t})),yield this.poseDectectorService.initPoseDetection(),this.startPreview()})}startPreview(){this.refresh.setup(20),this.refresh.render.subscribe(()=>{this.previewPose()}),this.refresh.start()}previewPose(){return L(this,null,function*(){this.check4Errors(),this.videoElement&&this.poseDectectorService.isReady()&&(this.poses=yield this.poseDectectorService.detect(this.videoElement))})}check4Errors(){this.notification.clear();let t=[];this.videoElement||t.push("No video found to estimate poses"),this.poseDectectorService.isReady()||t.push("Pose detector is not ready"),t.length>0&&this.notification.warning(t.join("<br>"))}static \u0275fac=function(e){return new(e||r)(it(Hk),it(Au))};static \u0275cmp=or({type:r,selectors:[["app-pose-preview"]],inputs:{video:"video"},standalone:!0,features:[sr],decls:2,vars:1,consts:[[3,"poses"]],template:function(e,n){e&1&&(Me(0,"div"),Wt(1,"app-pose-drawer",0),Fe()),e&2&&(qt(),Er("poses",n.poses))},dependencies:[Ko,K0]})};var QLe=["videoPlayer"],Ix=class r{constructor(t){this.notification=t}videoRef=null;selectedCameraID=null;videoReady=new dn;ngAfterViewInit(){return L(this,null,function*(){return this.startVideoStream()})}ngOnChanges(t){return L(this,null,function*(){t.selectedCameraID&&!t.selectedCameraID.isFirstChange()&&(yield this.startVideoStream())})}startVideoStream(){return L(this,null,function*(){if(this.notification.clear(),!this.videoRef||!this.videoRef.nativeElement)return this.notification.warning("Not able to initialize video element"),!1;if(!this.selectedCameraID)return this.notification.warning("No camera selected"),!1;try{let t=this.videoRef.nativeElement,e=yield navigator.mediaDevices.getUserMedia({video:{deviceId:{exact:this.selectedCameraID},width:{ideal:640},height:{ideal:480}},audio:!1}),n=new Promise(o=>{t.onloadedmetadata=()=>{this.videoReady.emit(t),o(!0)}});return t.srcObject=e,n}catch(t){let e="Unable to access the selected camera";return this.notification.warning(e),console.warn(e,t),!1}})}static \u0275fac=function(e){return new(e||r)(it(Au))};static \u0275cmp=or({type:r,selectors:[["app-video-preview"]],viewQuery:function(e,n){if(e&1&&v0(QLe,5),e&2){let o;pv(o=dv())&&(n.videoRef=o.first)}},inputs:{selectedCameraID:"selectedCameraID"},outputs:{videoReady:"videoReady"},standalone:!0,features:[yp,sr],decls:2,vars:0,consts:[["videoPlayer",""],["playsinline","","autoplay","true","width","640","height","480"]],template:function(e,n){e&1&&Wt(0,"video",1,0)},dependencies:[Ko],styles:["video[_ngcontent-%COMP%]{transform:scaleX(-1)}"]})};var JLe=r=>({"is-primary":r});function e3e(r,t){if(r&1){let e=Xm();Me(0,"button",1),zr("click",function(){let o=Bf(e).$implicit,s=vo();return Vf(s.selectCamera(o.deviceId))}),ot(1),Fe()}if(r&2){let e=t.$implicit,n=vo();Er("ngClass",b0(2,JLe,e.deviceId===n.selectedCameraID)),qt(),ci(" ",e.label," ")}}var Tx=class r{constructor(t){this.notification=t}selectedCameraID=null;cameras=[];cameraSelected=new dn;ngOnInit(){return L(this,null,function*(){try{let t=yield navigator.mediaDevices.enumerateDevices();this.cameras=t.filter(e=>e.kind==="videoinput"),this.selectedCameraID||(console.log("No camera selected, preselecting first camera from list"),this.selectCamera(this.cameras[0].deviceId))}catch(t){let e="Not able to initialize video element";this.notification.warning(e),console.warn(e,t)}})}selectCamera(t){this.selectedCameraID=t,this.cameraSelected.emit(t)}static \u0275fac=function(e){return new(e||r)(it(Au))};static \u0275cmp=or({type:r,selectors:[["app-video-source-selector"]],inputs:{selectedCameraID:"selectedCameraID"},outputs:{cameraSelected:"cameraSelected"},standalone:!0,features:[sr],decls:2,vars:1,consts:[["class","button",3,"ngClass","click",4,"ngFor","ngForOf"],[1,"button",3,"click","ngClass"]],template:function(e,n){e&1&&(Me(0,"div"),qo(1,e3e,2,4,"button",0),Fe()),e&2&&(qt(),Er("ngForOf",n.cameras))},dependencies:[Ko,T0,tV]})};var yf=class r{SELECTED_CAMERA_KEY="selectedCamera";PARTICIPANT_ID_KEY="gameParticipantId";constructor(){}saveSelectedCamera(t){localStorage.setItem(this.SELECTED_CAMERA_KEY,t)}getSelectedCamera(){return localStorage.getItem(this.SELECTED_CAMERA_KEY)}clearSelectedCamera(){localStorage.removeItem(this.SELECTED_CAMERA_KEY)}saveParticipantId(t){localStorage.setItem(this.PARTICIPANT_ID_KEY,t)}getParticipantId(){let t=localStorage.getItem(this.PARTICIPANT_ID_KEY);return t||(t=crypto.randomUUID(),this.saveParticipantId(t)),t}clearParticipantId(){localStorage.removeItem(this.PARTICIPANT_ID_KEY)}static \u0275fac=function(e){return new(e||r)};static \u0275prov=Qe({token:r,factory:r.\u0275fac,providedIn:"root"})};var qk=class r{constructor(t,e){this.appStateService=t;this.cdr=e}selectedCameraID=null;video=new Mr;time2Show="";redCounter=0;greenCounter=0;ngAfterViewInit(){this.selectedCameraID=this.appStateService.getSelectedCamera(),this.cdr.detectChanges()}onRedBalloon(){this.redCounter++,this.cdr.detectChanges()}onGreenBalloon(){this.greenCounter++,this.cdr.detectChanges()}onTimeUpdate(t){let e=Math.floor(t/1e3);this.time2Show=`Time: ${e} seconds`,this.cdr.detectChanges()}class="green-balloon";onCameraSelected(t){this.selectedCameraID=t,this.appStateService.saveSelectedCamera(t)}onVideoReady(t){console.log("video updated",t),this.video.next(t)}static \u0275fac=function(e){return new(e||r)(it(yf),it(uc))};static \u0275cmp=or({type:r,selectors:[["app-balloons-game-page"]],standalone:!0,features:[sr],decls:17,vars:6,consts:[[1,"section"],[1,"container"],[1,"title"],[3,"cameraSelected","selectedCameraID"],[1,"video-preview",3,"videoReady","selectedCameraID"],[1,"pose-preview",3,"video"],[1,"green-balloon",3,"red","green","time"]],template:function(e,n){e&1&&(Me(0,"section",0)(1,"div",1)(2,"h1",2),ot(3,"Move your hand to the green circles"),Fe(),Me(4,"app-video-source-selector",3),zr("cameraSelected",function(s){return n.onCameraSelected(s)}),Fe()()(),Me(5,"section",0)(6,"div",1)(7,"div"),ot(8),Fe()(),Me(9,"div",1)(10,"app-video-preview",4),zr("videoReady",function(s){return n.onVideoReady(s)}),Fe(),Wt(11,"app-pose-preview",5),Me(12,"app-green-balloon-game",6),zr("red",function(){return n.onRedBalloon()})("green",function(){return n.onGreenBalloon()})("time",function(s){return n.onTimeUpdate(s)}),Fe()()(),Me(13,"section",0)(14,"div",1),Wt(15,"app-notification"),Fe()(),Wt(16,"app-footer")),e&2&&(qt(4),Er("selectedCameraID",n.selectedCameraID),qt(4),rR("GREEN: ",n.greenCounter,", RED: ",n.redCounter,", ",n.time2Show,""),qt(2),Er("selectedCameraID",n.selectedCameraID),qt(),Er("video",n.video))},dependencies:[Ix,Tx,Sx,ig,H0,Ao],styles:[".video-preview[_ngcontent-%COMP%], .pose-preview[_ngcontent-%COMP%], .green-balloon[_ngcontent-%COMP%]{position:absolute;top:0;left:0}"]})};var Kk=class r{constructor(t){this.router=t}home(){this.router.navigate(["/"])}static \u0275fac=function(e){return new(e||r)(it(Do))};static \u0275cmp=or({type:r,selectors:[["app-not-found-page"]],standalone:!0,features:[sr],decls:11,vars:0,consts:[[1,"section"],[1,"container"],[1,"title"],[3,"click"]],template:function(e,n){e&1&&(Me(0,"section",0)(1,"div",1)(2,"h1",2),ot(3,"MOVE PLAYGROUND"),Fe(),Me(4,"h1"),ot(5,"404 - Page Not Found"),Fe(),Me(6,"p"),ot(7," The page you are looking for does not exist. Please check the URL or return to the homepage. "),Fe(),Me(8,"a",3),zr("click",function(){return n.home()}),ot(9,"Go to Homepage"),Fe()()(),Wt(10,"app-footer"))},dependencies:[Ao]})};var yse=r=>{let t;return r?t=r:typeof fetch>"u"?t=(...e)=>import("./chunk-BX7VDEVO.js").then(({default:n})=>n(...e)):t=fetch,(...e)=>t(...e)};var Sw=class extends Error{constructor(t,e="FunctionsError",n){super(t),this.name=e,this.context=n}},Xk=class extends Sw{constructor(t){super("Failed to send a request to the Edge Function","FunctionsFetchError",t)}},Yk=class extends Sw{constructor(t){super("Relay Error invoking the Edge Function","FunctionsRelayError",t)}},Zk=class extends Sw{constructor(t){super("Edge Function returned a non-2xx status code","FunctionsHttpError",t)}},dP=function(r){return r.Any="any",r.ApNortheast1="ap-northeast-1",r.ApNortheast2="ap-northeast-2",r.ApSouth1="ap-south-1",r.ApSoutheast1="ap-southeast-1",r.ApSoutheast2="ap-southeast-2",r.CaCentral1="ca-central-1",r.EuCentral1="eu-central-1",r.EuWest1="eu-west-1",r.EuWest2="eu-west-2",r.EuWest3="eu-west-3",r.SaEast1="sa-east-1",r.UsEast1="us-east-1",r.UsWest1="us-west-1",r.UsWest2="us-west-2",r}(dP||{});var t3e=function(r,t,e,n){function o(s){return s instanceof e?s:new e(function(i){i(s)})}return new(e||(e=Promise))(function(s,i){function a(c){try{l(n.next(c))}catch(p){i(p)}}function u(c){try{l(n.throw(c))}catch(p){i(p)}}function l(c){c.done?s(c.value):o(c.value).then(a,u)}l((n=n.apply(r,t||[])).next())})},Iw=class{constructor(t,{headers:e={},customFetch:n,region:o=dP.Any}={}){this.url=t,this.headers=e,this.region=o,this.fetch=yse(n)}setAuth(t){this.headers.Authorization=`Bearer ${t}`}invoke(t,e={}){var n;return t3e(this,void 0,void 0,function*(){try{let{headers:o,method:s,body:i}=e,a={},{region:u}=e;u||(u=this.region),u&&u!=="any"&&(a["x-region"]=u);let l;i&&(o&&!Object.prototype.hasOwnProperty.call(o,"Content-Type")||!o)&&(typeof Blob<"u"&&i instanceof Blob||i instanceof ArrayBuffer?(a["Content-Type"]="application/octet-stream",l=i):typeof i=="string"?(a["Content-Type"]="text/plain",l=i):typeof FormData<"u"&&i instanceof FormData?l=i:(a["Content-Type"]="application/json",l=JSON.stringify(i)));let c=yield this.fetch(`${this.url}/${t}`,{method:s||"POST",headers:Object.assign(Object.assign(Object.assign({},a),this.headers),o),body:l}).catch(h=>{throw new Xk(h)}),p=c.headers.get("x-relay-error");if(p&&p==="true")throw new Yk(c);if(!c.ok)throw new Zk(c);let d=((n=c.headers.get("Content-Type"))!==null&&n!==void 0?n:"text/plain").split(";")[0].trim(),f;return d==="application/json"?f=yield c.json():d==="application/octet-stream"?f=yield c.blob():d==="text/event-stream"?f=c:d==="multipart/form-data"?f=yield c.formData():f=yield c.text(),{data:f,error:null}}catch(o){return{data:null,error:o}}})}};var Dse=If(Nse(),1),{PostgrestClient:Ase,PostgrestQueryBuilder:Jqr,PostgrestFilterBuilder:eKr,PostgrestTransformBuilder:tKr,PostgrestBuilder:rKr}=Dse.default;var Rse="2.10.2";var Ose={"X-Client-Info":`realtime-js/${Rse}`},Mse="1.0.0",tN=1e4,Fse=1e3,_x=function(r){return r[r.connecting=0]="connecting",r[r.open=1]="open",r[r.closing=2]="closing",r[r.closed=3]="closed",r}(_x||{}),Js=function(r){return r.closed="closed",r.errored="errored",r.joined="joined",r.joining="joining",r.leaving="leaving",r}(Js||{}),Li=function(r){return r.close="phx_close",r.error="phx_error",r.join="phx_join",r.reply="phx_reply",r.leave="phx_leave",r.access_token="access_token",r}(Li||{}),SP=function(r){return r.websocket="websocket",r}(SP||{}),lm=function(r){return r.Connecting="connecting",r.Open="open",r.Closing="closing",r.Closed="closed",r}(lm||{});var rN=class{constructor(){this.HEADER_LENGTH=1}decode(t,e){return t.constructor===ArrayBuffer?e(this._binaryDecode(t)):e(typeof t=="string"?JSON.parse(t):{})}_binaryDecode(t){let e=new DataView(t),n=new TextDecoder;return this._decodeBroadcast(t,e,n)}_decodeBroadcast(t,e,n){let o=e.getUint8(1),s=e.getUint8(2),i=this.HEADER_LENGTH+2,a=n.decode(t.slice(i,i+o));i=i+o;let u=n.decode(t.slice(i,i+s));i=i+s;let l=JSON.parse(n.decode(t.slice(i,t.byteLength)));return{ref:null,topic:a,event:u,payload:l}}};var Ex=class{constructor(t,e){this.callback=t,this.timerCalc=e,this.timer=void 0,this.tries=0,this.callback=t,this.timerCalc=e}reset(){this.tries=0,clearTimeout(this.timer)}scheduleTimeout(){clearTimeout(this.timer),this.timer=setTimeout(()=>{this.tries=this.tries+1,this.callback()},this.timerCalc(this.tries+1))}};var pn=function(r){return r.abstime="abstime",r.bool="bool",r.date="date",r.daterange="daterange",r.float4="float4",r.float8="float8",r.int2="int2",r.int4="int4",r.int4range="int4range",r.int8="int8",r.int8range="int8range",r.json="json",r.jsonb="jsonb",r.money="money",r.numeric="numeric",r.oid="oid",r.reltime="reltime",r.text="text",r.time="time",r.timestamp="timestamp",r.timestamptz="timestamptz",r.timetz="timetz",r.tsrange="tsrange",r.tstzrange="tstzrange",r}(pn||{}),TP=(r,t,e={})=>{var n;let o=(n=e.skipTypes)!==null&&n!==void 0?n:[];return Object.keys(t).reduce((s,i)=>(s[i]=f3e(i,r,t,o),s),{})},f3e=(r,t,e,n)=>{let o=t.find(a=>a.name===r),s=o?.type,i=e[r];return s&&!n.includes(s)?$se(s,i):IP(i)},$se=(r,t)=>{if(r.charAt(0)==="_"){let e=r.slice(1,r.length);return y3e(t,e)}switch(r){case pn.bool:return h3e(t);case pn.float4:case pn.float8:case pn.int2:case pn.int4:case pn.int8:case pn.numeric:case pn.oid:return m3e(t);case pn.json:case pn.jsonb:return g3e(t);case pn.timestamp:return x3e(t);case pn.abstime:case pn.date:case pn.daterange:case pn.int4range:case pn.int8range:case pn.money:case pn.reltime:case pn.text:case pn.time:case pn.timestamptz:case pn.timetz:case pn.tsrange:case pn.tstzrange:return IP(t);default:return IP(t)}},IP=r=>r,h3e=r=>{switch(r){case"t":return!0;case"f":return!1;default:return r}},m3e=r=>{if(typeof r=="string"){let t=parseFloat(r);if(!Number.isNaN(t))return t}return r},g3e=r=>{if(typeof r=="string")try{return JSON.parse(r)}catch(t){return console.log(`JSON parse error: ${t}`),r}return r},y3e=(r,t)=>{if(typeof r!="string")return r;let e=r.length-1,n=r[e];if(r[0]==="{"&&n==="}"){let s,i=r.slice(1,e);try{s=JSON.parse("["+i+"]")}catch{s=i?i.split(","):[]}return s.map(a=>$se(t,a))}return r},x3e=r=>typeof r=="string"?r.replace(" ","T"):r,nN=r=>{let t=r;return t=t.replace(/^ws/i,"http"),t=t.replace(/(\/socket\/websocket|\/socket|\/websocket)\/?$/i,""),t.replace(/\/+$/,"")};var kx=class{constructor(t,e,n={},o=tN){this.channel=t,this.event=e,this.payload=n,this.timeout=o,this.sent=!1,this.timeoutTimer=void 0,this.ref="",this.receivedResp=null,this.recHooks=[],this.refEvent=null}resend(t){this.timeout=t,this._cancelRefEvent(),this.ref="",this.refEvent=null,this.receivedResp=null,this.sent=!1,this.send()}send(){this._hasReceived("timeout")||(this.startTimeout(),this.sent=!0,this.channel.socket.push({topic:this.channel.topic,event:this.event,payload:this.payload,ref:this.ref,join_ref:this.channel._joinRef()}))}updatePayload(t){this.payload=Object.assign(Object.assign({},this.payload),t)}receive(t,e){var n;return this._hasReceived(t)&&e((n=this.receivedResp)===null||n===void 0?void 0:n.response),this.recHooks.push({status:t,callback:e}),this}startTimeout(){if(this.timeoutTimer)return;this.ref=this.channel.socket._makeRef(),this.refEvent=this.channel._replyEventName(this.ref);let t=e=>{this._cancelRefEvent(),this._cancelTimeout(),this.receivedResp=e,this._matchReceive(e)};this.channel._on(this.refEvent,{},t),this.timeoutTimer=setTimeout(()=>{this.trigger("timeout",{})},this.timeout)}trigger(t,e){this.refEvent&&this.channel._trigger(this.refEvent,{status:t,response:e})}destroy(){this._cancelRefEvent(),this._cancelTimeout()}_cancelRefEvent(){this.refEvent&&this.channel._off(this.refEvent,{})}_cancelTimeout(){clearTimeout(this.timeoutTimer),this.timeoutTimer=void 0}_matchReceive({status:t,response:e}){this.recHooks.filter(n=>n.status===t).forEach(n=>n.callback(e))}_hasReceived(t){return this.receivedResp&&this.receivedResp.status===t}};var Rw=class r{constructor(t,e){this.channel=t,this.state={},this.pendingDiffs=[],this.joinRef=null,this.caller={onJoin:()=>{},onLeave:()=>{},onSync:()=>{}};let n=e?.events||{state:"presence_state",diff:"presence_diff"};this.channel._on(n.state,{},o=>{let{onJoin:s,onLeave:i,onSync:a}=this.caller;this.joinRef=this.channel._joinRef(),this.state=r.syncState(this.state,o,s,i),this.pendingDiffs.forEach(u=>{this.state=r.syncDiff(this.state,u,s,i)}),this.pendingDiffs=[],a()}),this.channel._on(n.diff,{},o=>{let{onJoin:s,onLeave:i,onSync:a}=this.caller;this.inPendingSyncState()?this.pendingDiffs.push(o):(this.state=r.syncDiff(this.state,o,s,i),a())}),this.onJoin((o,s,i)=>{this.channel._trigger("presence",{event:"join",key:o,currentPresences:s,newPresences:i})}),this.onLeave((o,s,i)=>{this.channel._trigger("presence",{event:"leave",key:o,currentPresences:s,leftPresences:i})}),this.onSync(()=>{this.channel._trigger("presence",{event:"sync"})})}static syncState(t,e,n,o){let s=this.cloneDeep(t),i=this.transformState(e),a={},u={};return this.map(s,(l,c)=>{i[l]||(u[l]=c)}),this.map(i,(l,c)=>{let p=s[l];if(p){let d=c.map(g=>g.presence_ref),f=p.map(g=>g.presence_ref),h=c.filter(g=>f.indexOf(g.presence_ref)<0),m=p.filter(g=>d.indexOf(g.presence_ref)<0);h.length>0&&(a[l]=h),m.length>0&&(u[l]=m)}else a[l]=c}),this.syncDiff(s,{joins:a,leaves:u},n,o)}static syncDiff(t,e,n,o){let{joins:s,leaves:i}={joins:this.transformState(e.joins),leaves:this.transformState(e.leaves)};return n||(n=()=>{}),o||(o=()=>{}),this.map(s,(a,u)=>{var l;let c=(l=t[a])!==null&&l!==void 0?l:[];if(t[a]=this.cloneDeep(u),c.length>0){let p=t[a].map(f=>f.presence_ref),d=c.filter(f=>p.indexOf(f.presence_ref)<0);t[a].unshift(...d)}n(a,c,u)}),this.map(i,(a,u)=>{let l=t[a];if(!l)return;let c=u.map(p=>p.presence_ref);l=l.filter(p=>c.indexOf(p.presence_ref)<0),t[a]=l,o(a,l,u),l.length===0&&delete t[a]}),t}static map(t,e){return Object.getOwnPropertyNames(t).map(n=>e(n,t[n]))}static transformState(t){return t=this.cloneDeep(t),Object.getOwnPropertyNames(t).reduce((e,n)=>{let o=t[n];return"metas"in o?e[n]=o.metas.map(s=>(s.presence_ref=s.phx_ref,delete s.phx_ref,delete s.phx_ref_prev,s)):e[n]=o,e},{})}static cloneDeep(t){return JSON.parse(JSON.stringify(t))}onJoin(t){this.caller.onJoin=t}onLeave(t){this.caller.onLeave=t}onSync(t){this.caller.onSync=t}inPendingSyncState(){return!this.joinRef||this.joinRef!==this.channel._joinRef()}};var Ow=class r{constructor(t,e={config:{}},n){this.topic=t,this.params=e,this.socket=n,this.bindings={},this.state=Js.closed,this.joinedOnce=!1,this.pushBuffer=[],this.subTopic=t.replace(/^realtime:/i,""),this.params.config=Object.assign({broadcast:{ack:!1,self:!1},presence:{key:""},private:!1},e.config),this.timeout=this.socket.timeout,this.joinPush=new kx(this,Li.join,this.params,this.timeout),this.rejoinTimer=new Ex(()=>this._rejoinUntilConnected(),this.socket.reconnectAfterMs),this.joinPush.receive("ok",()=>{this.state=Js.joined,this.rejoinTimer.reset(),this.pushBuffer.forEach(o=>o.send()),this.pushBuffer=[]}),this._onClose(()=>{this.rejoinTimer.reset(),this.socket.log("channel",`close ${this.topic} ${this._joinRef()}`),this.state=Js.closed,this.socket._remove(this)}),this._onError(o=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,o),this.state=Js.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("timeout",()=>{this._isJoining()&&(this.socket.log("channel",`timeout ${this.topic}`,this.joinPush.timeout),this.state=Js.errored,this.rejoinTimer.scheduleTimeout())}),this._on(Li.reply,{},(o,s)=>{this._trigger(this._replyEventName(s),o)}),this.presence=new Rw(this),this.broadcastEndpointURL=nN(this.socket.endPoint)+"/api/broadcast"}subscribe(t,e=this.timeout){var n,o;if(this.socket.isConnected()||this.socket.connect(),this.joinedOnce)throw"tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance";{let{config:{broadcast:s,presence:i,private:a}}=this.params;this._onError(c=>t&&t("CHANNEL_ERROR",c)),this._onClose(()=>t&&t("CLOSED"));let u={},l={broadcast:s,presence:i,postgres_changes:(o=(n=this.bindings.postgres_changes)===null||n===void 0?void 0:n.map(c=>c.filter))!==null&&o!==void 0?o:[],private:a};this.socket.accessToken&&(u.access_token=this.socket.accessToken),this.updateJoinPayload(Object.assign({config:l},u)),this.joinedOnce=!0,this._rejoin(e),this.joinPush.receive("ok",({postgres_changes:c})=>{var p;if(this.socket.accessToken&&this.socket.setAuth(this.socket.accessToken),c===void 0){t&&t("SUBSCRIBED");return}else{let d=this.bindings.postgres_changes,f=(p=d?.length)!==null&&p!==void 0?p:0,h=[];for(let m=0;m<f;m++){let g=d[m],{filter:{event:y,schema:x,table:w,filter:C}}=g,I=c&&c[m];if(I&&I.event===y&&I.schema===x&&I.table===w&&I.filter===C)h.push(Object.assign(Object.assign({},g),{id:I.id}));else{this.unsubscribe(),t&&t("CHANNEL_ERROR",new Error("mismatch between server and client bindings for postgres changes"));return}}this.bindings.postgres_changes=h,t&&t("SUBSCRIBED");return}}).receive("error",c=>{t&&t("CHANNEL_ERROR",new Error(JSON.stringify(Object.values(c).join(", ")||"error")))}).receive("timeout",()=>{t&&t("TIMED_OUT")})}return this}presenceState(){return this.presence.state}track(n){return L(this,arguments,function*(t,e={}){return yield this.send({type:"presence",event:"track",payload:t},e.timeout||this.timeout)})}untrack(){return L(this,arguments,function*(t={}){return yield this.send({type:"presence",event:"untrack"},t)})}on(t,e,n){return this._on(t,e,n)}send(n){return L(this,arguments,function*(t,e={}){var o,s;if(!this._canPush()&&t.type==="broadcast"){let{event:i,payload:a}=t,u={method:"POST",headers:{Authorization:this.socket.accessToken?`Bearer ${this.socket.accessToken}`:"",apikey:this.socket.apiKey?this.socket.apiKey:"","Content-Type":"application/json"},body:JSON.stringify({messages:[{topic:this.subTopic,event:i,payload:a}]})};try{let l=yield this._fetchWithTimeout(this.broadcastEndpointURL,u,(o=e.timeout)!==null&&o!==void 0?o:this.timeout);return yield(s=l.body)===null||s===void 0?void 0:s.cancel(),l.ok?"ok":"error"}catch(l){return l.name==="AbortError"?"timed out":"error"}}else return new Promise(i=>{var a,u,l;let c=this._push(t.type,t,e.timeout||this.timeout);t.type==="broadcast"&&!(!((l=(u=(a=this.params)===null||a===void 0?void 0:a.config)===null||u===void 0?void 0:u.broadcast)===null||l===void 0)&&l.ack)&&i("ok"),c.receive("ok",()=>i("ok")),c.receive("error",()=>i("error")),c.receive("timeout",()=>i("timed out"))})})}updateJoinPayload(t){this.joinPush.updatePayload(t)}unsubscribe(t=this.timeout){this.state=Js.leaving;let e=()=>{this.socket.log("channel",`leave ${this.topic}`),this._trigger(Li.close,"leave",this._joinRef())};return this.rejoinTimer.reset(),this.joinPush.destroy(),new Promise(n=>{let o=new kx(this,Li.leave,{},t);o.receive("ok",()=>{e(),n("ok")}).receive("timeout",()=>{e(),n("timed out")}).receive("error",()=>{n("error")}),o.send(),this._canPush()||o.trigger("ok",{})})}_fetchWithTimeout(t,e,n){return L(this,null,function*(){let o=new AbortController,s=setTimeout(()=>o.abort(),n),i=yield this.socket.fetch(t,Object.assign(Object.assign({},e),{signal:o.signal}));return clearTimeout(s),i})}_push(t,e,n=this.timeout){if(!this.joinedOnce)throw`tried to push '${t}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;let o=new kx(this,t,e,n);return this._canPush()?o.send():(o.startTimeout(),this.pushBuffer.push(o)),o}_onMessage(t,e,n){return e}_isMember(t){return this.topic===t}_joinRef(){return this.joinPush.ref}_trigger(t,e,n){var o,s;let i=t.toLocaleLowerCase(),{close:a,error:u,leave:l,join:c}=Li;if(n&&[a,u,l,c].indexOf(i)>=0&&n!==this._joinRef())return;let d=this._onMessage(i,e,n);if(e&&!d)throw"channel onMessage callbacks must return the payload, modified or unmodified";["insert","update","delete"].includes(i)?(o=this.bindings.postgres_changes)===null||o===void 0||o.filter(f=>{var h,m,g;return((h=f.filter)===null||h===void 0?void 0:h.event)==="*"||((g=(m=f.filter)===null||m===void 0?void 0:m.event)===null||g===void 0?void 0:g.toLocaleLowerCase())===i}).map(f=>f.callback(d,n)):(s=this.bindings[i])===null||s===void 0||s.filter(f=>{var h,m,g,y,x,w;if(["broadcast","presence","postgres_changes"].includes(i))if("id"in f){let C=f.id,I=(h=f.filter)===null||h===void 0?void 0:h.event;return C&&((m=e.ids)===null||m===void 0?void 0:m.includes(C))&&(I==="*"||I?.toLocaleLowerCase()===((g=e.data)===null||g===void 0?void 0:g.type.toLocaleLowerCase()))}else{let C=(x=(y=f?.filter)===null||y===void 0?void 0:y.event)===null||x===void 0?void 0:x.toLocaleLowerCase();return C==="*"||C===((w=e?.event)===null||w===void 0?void 0:w.toLocaleLowerCase())}else return f.type.toLocaleLowerCase()===i}).map(f=>{if(typeof d=="object"&&"ids"in d){let h=d.data,{schema:m,table:g,commit_timestamp:y,type:x,errors:w}=h;d=Object.assign(Object.assign({},{schema:m,table:g,commit_timestamp:y,eventType:x,new:{},old:{},errors:w}),this._getPayloadRecords(h))}f.callback(d,n)})}_isClosed(){return this.state===Js.closed}_isJoined(){return this.state===Js.joined}_isJoining(){return this.state===Js.joining}_isLeaving(){return this.state===Js.leaving}_replyEventName(t){return`chan_reply_${t}`}_on(t,e,n){let o=t.toLocaleLowerCase(),s={type:o,filter:e,callback:n};return this.bindings[o]?this.bindings[o].push(s):this.bindings[o]=[s],this}_off(t,e){let n=t.toLocaleLowerCase();return this.bindings[n]=this.bindings[n].filter(o=>{var s;return!(((s=o.type)===null||s===void 0?void 0:s.toLocaleLowerCase())===n&&r.isEqual(o.filter,e))}),this}static isEqual(t,e){if(Object.keys(t).length!==Object.keys(e).length)return!1;for(let n in t)if(t[n]!==e[n])return!1;return!0}_rejoinUntilConnected(){this.rejoinTimer.scheduleTimeout(),this.socket.isConnected()&&this._rejoin()}_onClose(t){this._on(Li.close,{},t)}_onError(t){this._on(Li.error,{},e=>t(e))}_canPush(){return this.socket.isConnected()&&this._isJoined()}_rejoin(t=this.timeout){this._isLeaving()||(this.socket._leaveOpenTopic(this.topic),this.state=Js.joining,this.joinPush.resend(t))}_getPayloadRecords(t){let e={new:{},old:{}};return(t.type==="INSERT"||t.type==="UPDATE")&&(e.new=TP(t.columns,t.record)),(t.type==="UPDATE"||t.type==="DELETE")&&(e.old=TP(t.columns,t.old_record)),e}};var b3e=()=>{},w3e=typeof WebSocket<"u",Mw=class{constructor(t,e){var n;this.accessToken=null,this.apiKey=null,this.channels=[],this.endPoint="",this.httpEndpoint="",this.headers=Ose,this.params={},this.timeout=tN,this.heartbeatIntervalMs=3e4,this.heartbeatTimer=void 0,this.pendingHeartbeatRef=null,this.ref=0,this.logger=b3e,this.conn=null,this.sendBuffer=[],this.serializer=new rN,this.stateChangeCallbacks={open:[],close:[],error:[],message:[]},this._resolveFetch=s=>{let i;return s?i=s:typeof fetch>"u"?i=(...a)=>import("./chunk-BX7VDEVO.js").then(({default:u})=>u(...a)):i=fetch,(...a)=>i(...a)},this.endPoint=`${t}/${SP.websocket}`,this.httpEndpoint=nN(t),e?.transport?this.transport=e.transport:this.transport=null,e?.params&&(this.params=e.params),e?.headers&&(this.headers=Object.assign(Object.assign({},this.headers),e.headers)),e?.timeout&&(this.timeout=e.timeout),e?.logger&&(this.logger=e.logger),e?.heartbeatIntervalMs&&(this.heartbeatIntervalMs=e.heartbeatIntervalMs);let o=(n=e?.params)===null||n===void 0?void 0:n.apikey;o&&(this.accessToken=o,this.apiKey=o),this.reconnectAfterMs=e?.reconnectAfterMs?e.reconnectAfterMs:s=>[1e3,2e3,5e3,1e4][s-1]||1e4,this.encode=e?.encode?e.encode:(s,i)=>i(JSON.stringify(s)),this.decode=e?.decode?e.decode:this.serializer.decode.bind(this.serializer),this.reconnectTimer=new Ex(()=>L(this,null,function*(){this.disconnect(),this.connect()}),this.reconnectAfterMs),this.fetch=this._resolveFetch(e?.fetch)}connect(){if(!this.conn){if(this.transport){this.conn=new this.transport(this._endPointURL(),void 0,{headers:this.headers});return}if(w3e){this.conn=new WebSocket(this._endPointURL()),this.setupConnection();return}this.conn=new _P(this._endPointURL(),void 0,{close:()=>{this.conn=null}}),import("./chunk-266KHGQI.js").then(({default:t})=>{this.conn=new t(this._endPointURL(),void 0,{headers:this.headers}),this.setupConnection()})}}disconnect(t,e){this.conn&&(this.conn.onclose=function(){},t?this.conn.close(t,e??""):this.conn.close(),this.conn=null,this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.reconnectTimer.reset())}getChannels(){return this.channels}removeChannel(t){return L(this,null,function*(){let e=yield t.unsubscribe();return this.channels.length===0&&this.disconnect(),e})}removeAllChannels(){return L(this,null,function*(){let t=yield Promise.all(this.channels.map(e=>e.unsubscribe()));return this.disconnect(),t})}log(t,e,n){this.logger(t,e,n)}connectionState(){switch(this.conn&&this.conn.readyState){case _x.connecting:return lm.Connecting;case _x.open:return lm.Open;case _x.closing:return lm.Closing;default:return lm.Closed}}isConnected(){return this.connectionState()===lm.Open}channel(t,e={config:{}}){let n=new Ow(`realtime:${t}`,e,this);return this.channels.push(n),n}push(t){let{topic:e,event:n,payload:o,ref:s}=t,i=()=>{this.encode(t,a=>{var u;(u=this.conn)===null||u===void 0||u.send(a)})};this.log("push",`${e} ${n} (${s})`,o),this.isConnected()?i():this.sendBuffer.push(i)}setAuth(t){this.accessToken=t,this.channels.forEach(e=>{t&&e.updateJoinPayload({access_token:t}),e.joinedOnce&&e._isJoined()&&e._push(Li.access_token,{access_token:t})})}_makeRef(){let t=this.ref+1;return t===this.ref?this.ref=0:this.ref=t,this.ref.toString()}_leaveOpenTopic(t){let e=this.channels.find(n=>n.topic===t&&(n._isJoined()||n._isJoining()));e&&(this.log("transport",`leaving duplicate topic "${t}"`),e.unsubscribe())}_remove(t){this.channels=this.channels.filter(e=>e._joinRef()!==t._joinRef())}setupConnection(){this.conn&&(this.conn.binaryType="arraybuffer",this.conn.onopen=()=>this._onConnOpen(),this.conn.onerror=t=>this._onConnError(t),this.conn.onmessage=t=>this._onConnMessage(t),this.conn.onclose=t=>this._onConnClose(t))}_endPointURL(){return this._appendParams(this.endPoint,Object.assign({},this.params,{vsn:Mse}))}_onConnMessage(t){this.decode(t.data,e=>{let{topic:n,event:o,payload:s,ref:i}=e;(i&&i===this.pendingHeartbeatRef||o===s?.type)&&(this.pendingHeartbeatRef=null),this.log("receive",`${s.status||""} ${n} ${o} ${i&&"("+i+")"||""}`,s),this.channels.filter(a=>a._isMember(n)).forEach(a=>a._trigger(o,s,i)),this.stateChangeCallbacks.message.forEach(a=>a(e))})}_onConnOpen(){this.log("transport",`connected to ${this._endPointURL()}`),this._flushSendBuffer(),this.reconnectTimer.reset(),this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.heartbeatTimer=setInterval(()=>this._sendHeartbeat(),this.heartbeatIntervalMs),this.stateChangeCallbacks.open.forEach(t=>t())}_onConnClose(t){this.log("transport","close",t),this._triggerChanError(),this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.reconnectTimer.scheduleTimeout(),this.stateChangeCallbacks.close.forEach(e=>e(t))}_onConnError(t){this.log("transport",t.message),this._triggerChanError(),this.stateChangeCallbacks.error.forEach(e=>e(t))}_triggerChanError(){this.channels.forEach(t=>t._trigger(Li.error))}_appendParams(t,e){if(Object.keys(e).length===0)return t;let n=t.match(/\?/)?"&":"?",o=new URLSearchParams(e);return`${t}${n}${o}`}_flushSendBuffer(){this.isConnected()&&this.sendBuffer.length>0&&(this.sendBuffer.forEach(t=>t()),this.sendBuffer=[])}_sendHeartbeat(){var t;if(this.isConnected()){if(this.pendingHeartbeatRef){this.pendingHeartbeatRef=null,this.log("transport","heartbeat timeout. Attempting to re-establish connection"),(t=this.conn)===null||t===void 0||t.close(Fse,"hearbeat timeout");return}this.pendingHeartbeatRef=this._makeRef(),this.push({topic:"phoenix",event:"heartbeat",payload:{},ref:this.pendingHeartbeatRef}),this.setAuth(this.accessToken)}}};var _P=class{constructor(t,e,n){this.binaryType="arraybuffer",this.onclose=()=>{},this.onerror=()=>{},this.onmessage=()=>{},this.onopen=()=>{},this.readyState=_x.connecting,this.send=()=>{},this.url=null,this.url=t,this.close=n.close}};var Nx=class extends Error{constructor(t){super(t),this.__isStorageError=!0,this.name="StorageError"}};function qn(r){return typeof r=="object"&&r!==null&&"__isStorageError"in r}var oN=class extends Nx{constructor(t,e){super(t),this.name="StorageApiError",this.status=e}toJSON(){return{name:this.name,message:this.message,status:this.status}}},cm=class extends Nx{constructor(t,e){super(t),this.name="StorageUnknownError",this.originalError=e}};var C3e=function(r,t,e,n){function o(s){return s instanceof e?s:new e(function(i){i(s)})}return new(e||(e=Promise))(function(s,i){function a(c){try{l(n.next(c))}catch(p){i(p)}}function u(c){try{l(n.throw(c))}catch(p){i(p)}}function l(c){c.done?s(c.value):o(c.value).then(a,u)}l((n=n.apply(r,t||[])).next())})},iN=r=>{let t;return r?t=r:typeof fetch>"u"?t=(...e)=>import("./chunk-BX7VDEVO.js").then(({default:n})=>n(...e)):t=fetch,(...e)=>t(...e)},Pse=()=>C3e(void 0,void 0,void 0,function*(){return typeof Response>"u"?(yield import("./chunk-BX7VDEVO.js")).Response:Response}),sN=r=>{if(Array.isArray(r))return r.map(e=>sN(e));if(typeof r=="function"||r!==Object(r))return r;let t={};return Object.entries(r).forEach(([e,n])=>{let o=e.replace(/([-_][a-z])/gi,s=>s.toUpperCase().replace(/[-_]/g,""));t[o]=sN(n)}),t};var pm=function(r,t,e,n){function o(s){return s instanceof e?s:new e(function(i){i(s)})}return new(e||(e=Promise))(function(s,i){function a(c){try{l(n.next(c))}catch(p){i(p)}}function u(c){try{l(n.throw(c))}catch(p){i(p)}}function l(c){c.done?s(c.value):o(c.value).then(a,u)}l((n=n.apply(r,t||[])).next())})},EP=r=>r.msg||r.message||r.error_description||r.error||JSON.stringify(r),S3e=(r,t,e)=>pm(void 0,void 0,void 0,function*(){let n=yield Pse();r instanceof n&&!e?.noResolveJson?r.json().then(o=>{t(new oN(EP(o),r.status||500))}).catch(o=>{t(new cm(EP(o),o))}):t(new cm(EP(r),r))}),I3e=(r,t,e,n)=>{let o={method:r,headers:t?.headers||{}};return r==="GET"?o:(o.headers=Object.assign({"Content-Type":"application/json"},t?.headers),n&&(o.body=JSON.stringify(n)),Object.assign(Object.assign({},o),e))};function Fw(r,t,e,n,o,s){return pm(this,void 0,void 0,function*(){return new Promise((i,a)=>{r(e,I3e(t,n,o,s)).then(u=>{if(!u.ok)throw u;return n?.noResolveJson?u:u.json()}).then(u=>i(u)).catch(u=>S3e(u,a,n))})})}function Dx(r,t,e,n){return pm(this,void 0,void 0,function*(){return Fw(r,"GET",t,e,n)})}function Jl(r,t,e,n,o){return pm(this,void 0,void 0,function*(){return Fw(r,"POST",t,n,o,e)})}function Lse(r,t,e,n,o){return pm(this,void 0,void 0,function*(){return Fw(r,"PUT",t,n,o,e)})}function zse(r,t,e,n){return pm(this,void 0,void 0,function*(){return Fw(r,"HEAD",t,Object.assign(Object.assign({},e),{noResolveJson:!0}),n)})}function aN(r,t,e,n,o){return pm(this,void 0,void 0,function*(){return Fw(r,"DELETE",t,n,o,e)})}var $s=function(r,t,e,n){function o(s){return s instanceof e?s:new e(function(i){i(s)})}return new(e||(e=Promise))(function(s,i){function a(c){try{l(n.next(c))}catch(p){i(p)}}function u(c){try{l(n.throw(c))}catch(p){i(p)}}function l(c){c.done?s(c.value):o(c.value).then(a,u)}l((n=n.apply(r,t||[])).next())})},T3e={limit:100,offset:0,sortBy:{column:"name",order:"asc"}},Bse={cacheControl:"3600",contentType:"text/plain;charset=UTF-8",upsert:!1},uN=class{constructor(t,e={},n,o){this.url=t,this.headers=e,this.bucketId=n,this.fetch=iN(o)}uploadOrUpdate(t,e,n,o){return $s(this,void 0,void 0,function*(){try{let s,i=Object.assign(Object.assign({},Bse),o),a=Object.assign(Object.assign({},this.headers),t==="POST"&&{"x-upsert":String(i.upsert)}),u=i.metadata;typeof Blob<"u"&&n instanceof Blob?(s=new FormData,s.append("cacheControl",i.cacheControl),s.append("",n),u&&s.append("metadata",this.encodeMetadata(u))):typeof FormData<"u"&&n instanceof FormData?(s=n,s.append("cacheControl",i.cacheControl),u&&s.append("metadata",this.encodeMetadata(u))):(s=n,a["cache-control"]=`max-age=${i.cacheControl}`,a["content-type"]=i.contentType,u&&(a["x-metadata"]=this.toBase64(this.encodeMetadata(u)))),o?.headers&&(a=Object.assign(Object.assign({},a),o.headers));let l=this._removeEmptyFolders(e),c=this._getFinalPath(l),p=yield this.fetch(`${this.url}/object/${c}`,Object.assign({method:t,body:s,headers:a},i?.duplex?{duplex:i.duplex}:{})),d=yield p.json();return p.ok?{data:{path:l,id:d.Id,fullPath:d.Key},error:null}:{data:null,error:d}}catch(s){if(qn(s))return{data:null,error:s};throw s}})}upload(t,e,n){return $s(this,void 0,void 0,function*(){return this.uploadOrUpdate("POST",t,e,n)})}uploadToSignedUrl(t,e,n,o){return $s(this,void 0,void 0,function*(){let s=this._removeEmptyFolders(t),i=this._getFinalPath(s),a=new URL(this.url+`/object/upload/sign/${i}`);a.searchParams.set("token",e);try{let u,l=Object.assign({upsert:Bse.upsert},o),c=Object.assign(Object.assign({},this.headers),{"x-upsert":String(l.upsert)});typeof Blob<"u"&&n instanceof Blob?(u=new FormData,u.append("cacheControl",l.cacheControl),u.append("",n)):typeof FormData<"u"&&n instanceof FormData?(u=n,u.append("cacheControl",l.cacheControl)):(u=n,c["cache-control"]=`max-age=${l.cacheControl}`,c["content-type"]=l.contentType);let p=yield this.fetch(a.toString(),{method:"PUT",body:u,headers:c}),d=yield p.json();return p.ok?{data:{path:s,fullPath:d.Key},error:null}:{data:null,error:d}}catch(u){if(qn(u))return{data:null,error:u};throw u}})}createSignedUploadUrl(t,e){return $s(this,void 0,void 0,function*(){try{let n=this._getFinalPath(t),o=Object.assign({},this.headers);e?.upsert&&(o["x-upsert"]="true");let s=yield Jl(this.fetch,`${this.url}/object/upload/sign/${n}`,{},{headers:o}),i=new URL(this.url+s.url),a=i.searchParams.get("token");if(!a)throw new Nx("No token returned by API");return{data:{signedUrl:i.toString(),path:t,token:a},error:null}}catch(n){if(qn(n))return{data:null,error:n};throw n}})}update(t,e,n){return $s(this,void 0,void 0,function*(){return this.uploadOrUpdate("PUT",t,e,n)})}move(t,e,n){return $s(this,void 0,void 0,function*(){try{return{data:yield Jl(this.fetch,`${this.url}/object/move`,{bucketId:this.bucketId,sourceKey:t,destinationKey:e,destinationBucket:n?.destinationBucket},{headers:this.headers}),error:null}}catch(o){if(qn(o))return{data:null,error:o};throw o}})}copy(t,e,n){return $s(this,void 0,void 0,function*(){try{return{data:{path:(yield Jl(this.fetch,`${this.url}/object/copy`,{bucketId:this.bucketId,sourceKey:t,destinationKey:e,destinationBucket:n?.destinationBucket},{headers:this.headers})).Key},error:null}}catch(o){if(qn(o))return{data:null,error:o};throw o}})}createSignedUrl(t,e,n){return $s(this,void 0,void 0,function*(){try{let o=this._getFinalPath(t),s=yield Jl(this.fetch,`${this.url}/object/sign/${o}`,Object.assign({expiresIn:e},n?.transform?{transform:n.transform}:{}),{headers:this.headers}),i=n?.download?`&download=${n.download===!0?"":n.download}`:"";return s={signedUrl:encodeURI(`${this.url}${s.signedURL}${i}`)},{data:s,error:null}}catch(o){if(qn(o))return{data:null,error:o};throw o}})}createSignedUrls(t,e,n){return $s(this,void 0,void 0,function*(){try{let o=yield Jl(this.fetch,`${this.url}/object/sign/${this.bucketId}`,{expiresIn:e,paths:t},{headers:this.headers}),s=n?.download?`&download=${n.download===!0?"":n.download}`:"";return{data:o.map(i=>Object.assign(Object.assign({},i),{signedUrl:i.signedURL?encodeURI(`${this.url}${i.signedURL}${s}`):null})),error:null}}catch(o){if(qn(o))return{data:null,error:o};throw o}})}download(t,e){return $s(this,void 0,void 0,function*(){let o=typeof e?.transform<"u"?"render/image/authenticated":"object",s=this.transformOptsToQueryString(e?.transform||{}),i=s?`?${s}`:"";try{let a=this._getFinalPath(t);return{data:yield(yield Dx(this.fetch,`${this.url}/${o}/${a}${i}`,{headers:this.headers,noResolveJson:!0})).blob(),error:null}}catch(a){if(qn(a))return{data:null,error:a};throw a}})}info(t){return $s(this,void 0,void 0,function*(){let e=this._getFinalPath(t);try{let n=yield Dx(this.fetch,`${this.url}/object/info/${e}`,{headers:this.headers});return{data:sN(n),error:null}}catch(n){if(qn(n))return{data:null,error:n};throw n}})}exists(t){return $s(this,void 0,void 0,function*(){let e=this._getFinalPath(t);try{return yield zse(this.fetch,`${this.url}/object/${e}`,{headers:this.headers}),{data:!0,error:null}}catch(n){if(qn(n)&&n instanceof cm){let o=n.originalError;if([400,404].includes(o?.status))return{data:!1,error:n}}throw n}})}getPublicUrl(t,e){let n=this._getFinalPath(t),o=[],s=e?.download?`download=${e.download===!0?"":e.download}`:"";s!==""&&o.push(s);let a=typeof e?.transform<"u"?"render/image":"object",u=this.transformOptsToQueryString(e?.transform||{});u!==""&&o.push(u);let l=o.join("&");return l!==""&&(l=`?${l}`),{data:{publicUrl:encodeURI(`${this.url}/${a}/public/${n}${l}`)}}}remove(t){return $s(this,void 0,void 0,function*(){try{return{data:yield aN(this.fetch,`${this.url}/object/${this.bucketId}`,{prefixes:t},{headers:this.headers}),error:null}}catch(e){if(qn(e))return{data:null,error:e};throw e}})}list(t,e,n){return $s(this,void 0,void 0,function*(){try{let o=Object.assign(Object.assign(Object.assign({},T3e),e),{prefix:t||""});return{data:yield Jl(this.fetch,`${this.url}/object/list/${this.bucketId}`,o,{headers:this.headers},n),error:null}}catch(o){if(qn(o))return{data:null,error:o};throw o}})}encodeMetadata(t){return JSON.stringify(t)}toBase64(t){return typeof Buffer<"u"?Buffer.from(t).toString("base64"):btoa(t)}_getFinalPath(t){return`${this.bucketId}/${t}`}_removeEmptyFolders(t){return t.replace(/^\/|\/$/g,"").replace(/\/+/g,"/")}transformOptsToQueryString(t){let e=[];return t.width&&e.push(`width=${t.width}`),t.height&&e.push(`height=${t.height}`),t.resize&&e.push(`resize=${t.resize}`),t.format&&e.push(`format=${t.format}`),t.quality&&e.push(`quality=${t.quality}`),e.join("&")}};var Vse="2.7.0";var Use={"X-Client-Info":`storage-js/${Vse}`};var Ax=function(r,t,e,n){function o(s){return s instanceof e?s:new e(function(i){i(s)})}return new(e||(e=Promise))(function(s,i){function a(c){try{l(n.next(c))}catch(p){i(p)}}function u(c){try{l(n.throw(c))}catch(p){i(p)}}function l(c){c.done?s(c.value):o(c.value).then(a,u)}l((n=n.apply(r,t||[])).next())})},lN=class{constructor(t,e={},n){this.url=t,this.headers=Object.assign(Object.assign({},Use),e),this.fetch=iN(n)}listBuckets(){return Ax(this,void 0,void 0,function*(){try{return{data:yield Dx(this.fetch,`${this.url}/bucket`,{headers:this.headers}),error:null}}catch(t){if(qn(t))return{data:null,error:t};throw t}})}getBucket(t){return Ax(this,void 0,void 0,function*(){try{return{data:yield Dx(this.fetch,`${this.url}/bucket/${t}`,{headers:this.headers}),error:null}}catch(e){if(qn(e))return{data:null,error:e};throw e}})}createBucket(t,e={public:!1}){return Ax(this,void 0,void 0,function*(){try{return{data:yield Jl(this.fetch,`${this.url}/bucket`,{id:t,name:t,public:e.public,file_size_limit:e.fileSizeLimit,allowed_mime_types:e.allowedMimeTypes},{headers:this.headers}),error:null}}catch(n){if(qn(n))return{data:null,error:n};throw n}})}updateBucket(t,e){return Ax(this,void 0,void 0,function*(){try{return{data:yield Lse(this.fetch,`${this.url}/bucket/${t}`,{id:t,name:t,public:e.public,file_size_limit:e.fileSizeLimit,allowed_mime_types:e.allowedMimeTypes},{headers:this.headers}),error:null}}catch(n){if(qn(n))return{data:null,error:n};throw n}})}emptyBucket(t){return Ax(this,void 0,void 0,function*(){try{return{data:yield Jl(this.fetch,`${this.url}/bucket/${t}/empty`,{},{headers:this.headers}),error:null}}catch(e){if(qn(e))return{data:null,error:e};throw e}})}deleteBucket(t){return Ax(this,void 0,void 0,function*(){try{return{data:yield aN(this.fetch,`${this.url}/bucket/${t}`,{},{headers:this.headers}),error:null}}catch(e){if(qn(e))return{data:null,error:e};throw e}})}};var $w=class extends lN{constructor(t,e={},n){super(t,e,n)}from(t){return new uN(this.url,this.headers,t,this.fetch)}};var Gse="2.45.3";var Pw="";typeof Deno<"u"?Pw="deno":typeof document<"u"?Pw="web":typeof navigator<"u"&&navigator.product==="ReactNative"?Pw="react-native":Pw="node";var _3e={"X-Client-Info":`supabase-js-${Pw}/${Gse}`},Wse={headers:_3e},jse={schema:"public"},Hse={autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,flowType:"implicit"},qse={};xL();var E3e=function(r,t,e,n){function o(s){return s instanceof e?s:new e(function(i){i(s)})}return new(e||(e=Promise))(function(s,i){function a(c){try{l(n.next(c))}catch(p){i(p)}}function u(c){try{l(n.throw(c))}catch(p){i(p)}}function l(c){c.done?s(c.value):o(c.value).then(a,u)}l((n=n.apply(r,t||[])).next())})},k3e=r=>{let t;return r?t=r:typeof fetch>"u"?t=gL:t=fetch,(...e)=>t(...e)},N3e=()=>typeof Headers>"u"?yL:Headers,Kse=(r,t,e)=>{let n=k3e(e),o=N3e();return(s,i)=>E3e(void 0,void 0,void 0,function*(){var a;let u=(a=yield t())!==null&&a!==void 0?a:r,l=new o(i?.headers);return l.has("apikey")||l.set("apikey",r),l.has("Authorization")||l.set("Authorization",`Bearer ${u}`),n(s,Object.assign(Object.assign({},i),{headers:l}))})};var D3e=function(r,t,e,n){function o(s){return s instanceof e?s:new e(function(i){i(s)})}return new(e||(e=Promise))(function(s,i){function a(c){try{l(n.next(c))}catch(p){i(p)}}function u(c){try{l(n.throw(c))}catch(p){i(p)}}function l(c){c.done?s(c.value):o(c.value).then(a,u)}l((n=n.apply(r,t||[])).next())})};function Xse(r){return r.replace(/\/$/,"")}function Yse(r,t){let{db:e,auth:n,realtime:o,global:s}=r,{db:i,auth:a,realtime:u,global:l}=t,c={db:Object.assign(Object.assign({},i),e),auth:Object.assign(Object.assign({},a),n),realtime:Object.assign(Object.assign({},u),o),global:Object.assign(Object.assign({},l),s),accessToken:()=>D3e(this,void 0,void 0,function*(){return""})};return r.accessToken?c.accessToken=r.accessToken:delete c.accessToken,c}function Zse(r){return Math.round(Date.now()/1e3)+r}function Qse(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(r){let t=Math.random()*16|0;return(r=="x"?t:t&3|8).toString(16)})}var mu=()=>typeof document<"u",dm={tested:!1,writable:!1},xf=()=>{if(!mu())return!1;try{if(typeof globalThis.localStorage!="object")return!1}catch{return!1}if(dm.tested)return dm.writable;let r=`lswt-${Math.random()}${Math.random()}`;try{globalThis.localStorage.setItem(r,r),globalThis.localStorage.removeItem(r),dm.tested=!0,dm.writable=!0}catch{dm.tested=!0,dm.writable=!1}return dm.writable};function cN(r){let t={},e=new URL(r);if(e.hash&&e.hash[0]==="#")try{new URLSearchParams(e.hash.substring(1)).forEach((o,s)=>{t[s]=o})}catch{}return e.searchParams.forEach((n,o)=>{t[o]=n}),t}var pN=r=>{let t;return r?t=r:typeof fetch>"u"?t=(...e)=>import("./chunk-BX7VDEVO.js").then(({default:n})=>n(...e)):t=fetch,(...e)=>t(...e)},Jse=r=>typeof r=="object"&&r!==null&&"status"in r&&"ok"in r&&"json"in r&&typeof r.json=="function",vf=(r,t,e)=>L(void 0,null,function*(){yield r.setItem(t,JSON.stringify(e))}),zw=(r,t)=>L(void 0,null,function*(){let e=yield r.getItem(t);if(!e)return null;try{return JSON.parse(e)}catch{return e}}),dN=(r,t)=>L(void 0,null,function*(){yield r.removeItem(t)});function A3e(r){let t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",e="",n,o,s,i,a,u,l,c=0;for(r=r.replace("-","+").replace("_","/");c<r.length;)i=t.indexOf(r.charAt(c++)),a=t.indexOf(r.charAt(c++)),u=t.indexOf(r.charAt(c++)),l=t.indexOf(r.charAt(c++)),n=i<<2|a>>4,o=(a&15)<<4|u>>2,s=(u&3)<<6|l,e=e+String.fromCharCode(n),u!=64&&o!=0&&(e=e+String.fromCharCode(o)),l!=64&&s!=0&&(e=e+String.fromCharCode(s));return e}var Lw=class r{constructor(){this.promise=new r.promiseConstructor((t,e)=>{this.resolve=t,this.reject=e})}};Lw.promiseConstructor=Promise;function kP(r){let t=/^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}=?$|[a-z0-9_-]{2}(==)?$)$/i,e=r.split(".");if(e.length!==3)throw new Error("JWT is not valid: not a JWT structure");if(!t.test(e[1]))throw new Error("JWT is not valid: payload is not in base64url format");let n=e[1];return JSON.parse(A3e(n))}function eie(r){return L(this,null,function*(){return yield new Promise(t=>{setTimeout(()=>t(null),r)})})}function tie(r,t){return new Promise((n,o)=>{L(this,null,function*(){for(let s=0;s<1/0;s++)try{let i=yield r(s);if(!t(s,null,i)){n(i);return}}catch(i){if(!t(s,i)){o(i);return}}})})}function R3e(r){return("0"+r.toString(16)).substr(-2)}function fm(){let t=new Uint32Array(56);if(typeof crypto>"u"){let e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",n=e.length,o="";for(let s=0;s<56;s++)o+=e.charAt(Math.floor(Math.random()*n));return o}return crypto.getRandomValues(t),Array.from(t,R3e).join("")}function O3e(r){return L(this,null,function*(){let e=new TextEncoder().encode(r),n=yield crypto.subtle.digest("SHA-256",e),o=new Uint8Array(n);return Array.from(o).map(s=>String.fromCharCode(s)).join("")})}function M3e(r){return btoa(r).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function hm(r){return L(this,null,function*(){if(!(typeof crypto<"u"&&typeof crypto.subtle<"u"&&typeof TextEncoder<"u"))return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."),r;let e=yield O3e(r);return M3e(e)})}var Bw=class extends Error{constructor(t,e){super(t),this.__isAuthError=!0,this.name="AuthError",this.status=e}};function Gt(r){return typeof r=="object"&&r!==null&&"__isAuthError"in r}var fN=class extends Bw{constructor(t,e){super(t,e),this.name="AuthApiError",this.status=e}toJSON(){return{name:this.name,message:this.message,status:this.status}}};function rie(r){return Gt(r)&&r.name==="AuthApiError"}var Rx=class extends Bw{constructor(t,e){super(t),this.name="AuthUnknownError",this.originalError=e}},rp=class extends Bw{constructor(t,e,n){super(t),this.name=e,this.status=n}toJSON(){return{name:this.name,message:this.message,status:this.status}}},np=class extends rp{constructor(){super("Auth session missing!","AuthSessionMissingError",400)}},Ox=class extends rp{constructor(){super("Auth session or user missing","AuthInvalidTokenResponseError",500)}},mm=class extends rp{constructor(t){super(t,"AuthInvalidCredentialsError",400)}},gm=class extends rp{constructor(t,e=null){super(t,"AuthImplicitGrantRedirectError",500),this.details=null,this.details=e}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}},Vw=class extends rp{constructor(t,e=null){super(t,"AuthPKCEGrantCodeExchangeError",500),this.details=null,this.details=e}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}},Mx=class extends rp{constructor(t,e){super(t,"AuthRetryableFetchError",e)}};function mN(r){return Gt(r)&&r.name==="AuthRetryableFetchError"}var hN=class extends rp{constructor(t,e,n){super(t,"AuthWeakPasswordError",e),this.reasons=n}};var F3e=function(r,t){var e={};for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&t.indexOf(n)<0&&(e[n]=r[n]);if(r!=null&&typeof Object.getOwnPropertySymbols=="function")for(var o=0,n=Object.getOwnPropertySymbols(r);o<n.length;o++)t.indexOf(n[o])<0&&Object.prototype.propertyIsEnumerable.call(r,n[o])&&(e[n[o]]=r[n[o]]);return e},Fx=r=>r.msg||r.message||r.error_description||r.error||JSON.stringify(r),$3e=[502,503,504];function nie(r){return L(this,null,function*(){if(!Jse(r))throw new Mx(Fx(r),0);if($3e.includes(r.status))throw new Mx(Fx(r),r.status);let t;try{t=yield r.json()}catch(e){throw new Rx(Fx(e),e)}throw typeof t=="object"&&t&&typeof t.weak_password=="object"&&t.weak_password&&Array.isArray(t.weak_password.reasons)&&t.weak_password.reasons.length&&t.weak_password.reasons.reduce((e,n)=>e&&typeof n=="string",!0)?new hN(Fx(t),r.status,t.weak_password.reasons):new fN(Fx(t),r.status||500)})}var P3e=(r,t,e,n)=>{let o={method:r,headers:t?.headers||{}};return r==="GET"?o:(o.headers=Object.assign({"Content-Type":"application/json;charset=UTF-8"},t?.headers),o.body=JSON.stringify(n),Object.assign(Object.assign({},o),e))};function Qt(r,t,e,n){return L(this,null,function*(){var o;let s=Object.assign({},n?.headers);n?.jwt&&(s.Authorization=`Bearer ${n.jwt}`);let i=(o=n?.query)!==null&&o!==void 0?o:{};n?.redirectTo&&(i.redirect_to=n.redirectTo);let a=Object.keys(i).length?"?"+new URLSearchParams(i).toString():"",u=yield L3e(r,t,e+a,{headers:s,noResolveJson:n?.noResolveJson},{},n?.body);return n?.xform?n?.xform(u):{data:Object.assign({},u),error:null}})}function L3e(r,t,e,n,o,s){return L(this,null,function*(){let i=P3e(t,n,o,s),a;try{a=yield r(e,i)}catch(u){throw console.error(u),new Mx(Fx(u),0)}if(a.ok||(yield nie(a)),n?.noResolveJson)return a;try{return yield a.json()}catch(u){yield nie(u)}})}function bf(r){var t;let e=null;z3e(r)&&(e=Object.assign({},r),r.expires_at||(e.expires_at=Zse(r.expires_in)));let n=(t=r.user)!==null&&t!==void 0?t:r;return{data:{session:e,user:n},error:null}}function NP(r){let t=bf(r);return!t.error&&r.weak_password&&typeof r.weak_password=="object"&&Array.isArray(r.weak_password.reasons)&&r.weak_password.reasons.length&&r.weak_password.message&&typeof r.weak_password.message=="string"&&r.weak_password.reasons.reduce((e,n)=>e&&typeof n=="string",!0)&&(t.data.weak_password=r.weak_password),t}function ec(r){var t;return{data:{user:(t=r.user)!==null&&t!==void 0?t:r},error:null}}function oie(r){return{data:r,error:null}}function sie(r){let{action_link:t,email_otp:e,hashed_token:n,redirect_to:o,verification_type:s}=r,i=F3e(r,["action_link","email_otp","hashed_token","redirect_to","verification_type"]),a={action_link:t,email_otp:e,hashed_token:n,redirect_to:o,verification_type:s},u=Object.assign({},i);return{data:{properties:a,user:u},error:null}}function iie(r){return r}function z3e(r){return r.access_token&&r.refresh_token&&r.expires_in}var B3e=function(r,t){var e={};for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&t.indexOf(n)<0&&(e[n]=r[n]);if(r!=null&&typeof Object.getOwnPropertySymbols=="function")for(var o=0,n=Object.getOwnPropertySymbols(r);o<n.length;o++)t.indexOf(n[o])<0&&Object.prototype.propertyIsEnumerable.call(r,n[o])&&(e[n[o]]=r[n[o]]);return e},$x=class{constructor({url:t="",headers:e={},fetch:n}){this.url=t,this.headers=e,this.fetch=pN(n),this.mfa={listFactors:this._listFactors.bind(this),deleteFactor:this._deleteFactor.bind(this)}}signOut(t,e="global"){return L(this,null,function*(){try{return yield Qt(this.fetch,"POST",`${this.url}/logout?scope=${e}`,{headers:this.headers,jwt:t,noResolveJson:!0}),{data:null,error:null}}catch(n){if(Gt(n))return{data:null,error:n};throw n}})}inviteUserByEmail(n){return L(this,arguments,function*(t,e={}){try{return yield Qt(this.fetch,"POST",`${this.url}/invite`,{body:{email:t,data:e.data},headers:this.headers,redirectTo:e.redirectTo,xform:ec})}catch(o){if(Gt(o))return{data:{user:null},error:o};throw o}})}generateLink(t){return L(this,null,function*(){try{let{options:e}=t,n=B3e(t,["options"]),o=Object.assign(Object.assign({},n),e);return"newEmail"in n&&(o.new_email=n?.newEmail,delete o.newEmail),yield Qt(this.fetch,"POST",`${this.url}/admin/generate_link`,{body:o,headers:this.headers,xform:sie,redirectTo:e?.redirectTo})}catch(e){if(Gt(e))return{data:{properties:null,user:null},error:e};throw e}})}createUser(t){return L(this,null,function*(){try{return yield Qt(this.fetch,"POST",`${this.url}/admin/users`,{body:t,headers:this.headers,xform:ec})}catch(e){if(Gt(e))return{data:{user:null},error:e};throw e}})}listUsers(t){return L(this,null,function*(){var e,n,o,s,i,a,u;try{let l={nextPage:null,lastPage:0,total:0},c=yield Qt(this.fetch,"GET",`${this.url}/admin/users`,{headers:this.headers,noResolveJson:!0,query:{page:(n=(e=t?.page)===null||e===void 0?void 0:e.toString())!==null&&n!==void 0?n:"",per_page:(s=(o=t?.perPage)===null||o===void 0?void 0:o.toString())!==null&&s!==void 0?s:""},xform:iie});if(c.error)throw c.error;let p=yield c.json(),d=(i=c.headers.get("x-total-count"))!==null&&i!==void 0?i:0,f=(u=(a=c.headers.get("link"))===null||a===void 0?void 0:a.split(","))!==null&&u!==void 0?u:[];return f.length>0&&(f.forEach(h=>{let m=parseInt(h.split(";")[0].split("=")[1].substring(0,1)),g=JSON.parse(h.split(";")[1].split("=")[1]);l[`${g}Page`]=m}),l.total=parseInt(d)),{data:Object.assign(Object.assign({},p),l),error:null}}catch(l){if(Gt(l))return{data:{users:[]},error:l};throw l}})}getUserById(t){return L(this,null,function*(){try{return yield Qt(this.fetch,"GET",`${this.url}/admin/users/${t}`,{headers:this.headers,xform:ec})}catch(e){if(Gt(e))return{data:{user:null},error:e};throw e}})}updateUserById(t,e){return L(this,null,function*(){try{return yield Qt(this.fetch,"PUT",`${this.url}/admin/users/${t}`,{body:e,headers:this.headers,xform:ec})}catch(n){if(Gt(n))return{data:{user:null},error:n};throw n}})}deleteUser(t,e=!1){return L(this,null,function*(){try{return yield Qt(this.fetch,"DELETE",`${this.url}/admin/users/${t}`,{headers:this.headers,body:{should_soft_delete:e},xform:ec})}catch(n){if(Gt(n))return{data:{user:null},error:n};throw n}})}_listFactors(t){return L(this,null,function*(){try{let{data:e,error:n}=yield Qt(this.fetch,"GET",`${this.url}/admin/users/${t.userId}/factors`,{headers:this.headers,xform:o=>({data:{factors:o},error:null})});return{data:e,error:n}}catch(e){if(Gt(e))return{data:null,error:e};throw e}})}_deleteFactor(t){return L(this,null,function*(){try{return{data:yield Qt(this.fetch,"DELETE",`${this.url}/admin/users/${t.userId}/factors/${t.id}`,{headers:this.headers}),error:null}}catch(e){if(Gt(e))return{data:null,error:e};throw e}})}};var gN="2.61.0";var aie="http://localhost:9999",uie="supabase.auth.token";var lie={"X-Client-Info":`gotrue-js/${gN}`},DP=10;var cie={getItem:r=>xf()?globalThis.localStorage.getItem(r):null,setItem:(r,t)=>{xf()&&globalThis.localStorage.setItem(r,t)},removeItem:r=>{xf()&&globalThis.localStorage.removeItem(r)}};function AP(r={}){return{getItem:t=>r[t]||null,setItem:(t,e)=>{r[t]=e},removeItem:t=>{delete r[t]}}}function pie(){if(typeof globalThis!="object")try{Object.defineProperty(Object.prototype,"__magic__",{get:function(){return this},configurable:!0}),__magic__.globalThis=__magic__,delete Object.prototype.__magic__}catch{typeof self<"u"&&(self.globalThis=self)}}var V3e={debug:!!(globalThis&&xf()&&globalThis.localStorage&&globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug")==="true")},yN=class extends Error{constructor(t){super(t),this.isAcquireTimeout=!0}};pie();var U3e={url:aie,storageKey:uie,autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,headers:lie,flowType:"implicit",debug:!1},Uw=30*1e3,die=3;function G3e(r,t,e){return L(this,null,function*(){return yield e()})}var RP=(()=>{class r{constructor(e){var n;this.memoryStorage=null,this.stateChangeEmitters=new Map,this.autoRefreshTicker=null,this.visibilityChangedCallback=null,this.refreshingDeferred=null,this.initializePromise=null,this.detectSessionInUrl=!0,this.lockAcquired=!1,this.pendingInLock=[],this.broadcastChannel=null,this.logger=console.log,this.instanceID=r.nextInstanceID,r.nextInstanceID+=1,this.instanceID>0&&mu()&&console.warn("Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.");let o=Object.assign(Object.assign({},U3e),e);if(this.logDebugMessages=!!o.debug,typeof o.debug=="function"&&(this.logger=o.debug),this.persistSession=o.persistSession,this.storageKey=o.storageKey,this.autoRefreshToken=o.autoRefreshToken,this.admin=new $x({url:o.url,headers:o.headers,fetch:o.fetch}),this.url=o.url,this.headers=o.headers,this.fetch=pN(o.fetch),this.lock=o.lock||G3e,this.detectSessionInUrl=o.detectSessionInUrl,this.flowType=o.flowType,this.mfa={verify:this._verify.bind(this),enroll:this._enroll.bind(this),unenroll:this._unenroll.bind(this),challenge:this._challenge.bind(this),listFactors:this._listFactors.bind(this),challengeAndVerify:this._challengeAndVerify.bind(this),getAuthenticatorAssuranceLevel:this._getAuthenticatorAssuranceLevel.bind(this)},this.persistSession?o.storage?this.storage=o.storage:xf()?this.storage=cie:(this.memoryStorage={},this.storage=AP(this.memoryStorage)):(this.memoryStorage={},this.storage=AP(this.memoryStorage)),mu()&&globalThis.BroadcastChannel&&this.persistSession&&this.storageKey){try{this.broadcastChannel=new globalThis.BroadcastChannel(this.storageKey)}catch(s){console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available",s)}(n=this.broadcastChannel)===null||n===void 0||n.addEventListener("message",s=>L(this,null,function*(){this._debug("received broadcast notification from other tab or client",s),yield this._notifyAllSubscribers(s.data.event,s.data.session,!1)}))}this.initialize()}_debug(...e){return this.logDebugMessages&&this.logger(`GoTrueClient@${this.instanceID} (${gN}) ${new Date().toISOString()}`,...e),this}initialize(){return L(this,null,function*(){return this.initializePromise?yield this.initializePromise:(this.initializePromise=L(this,null,function*(){return yield this._acquireLock(-1,()=>L(this,null,function*(){return yield this._initialize()}))}),yield this.initializePromise)})}_initialize(){return L(this,null,function*(){try{let e=mu()?yield this._isPKCEFlow():!1;if(this._debug("#_initialize()","begin","is PKCE flow",e),e||this.detectSessionInUrl&&this._isImplicitGrantFlow()){let{data:n,error:o}=yield this._getSessionFromURL(e);if(o)return this._debug("#_initialize()","error detecting session from URL",o),o?.message==="Identity is already linked"||o?.message==="Identity is already linked to another user"?{error:o}:(yield this._removeSession(),{error:o});let{session:s,redirectType:i}=n;return this._debug("#_initialize()","detected session in URL",s,"redirect type",i),yield this._saveSession(s),setTimeout(()=>L(this,null,function*(){i==="recovery"?yield this._notifyAllSubscribers("PASSWORD_RECOVERY",s):yield this._notifyAllSubscribers("SIGNED_IN",s)}),0),{error:null}}return yield this._recoverAndRefresh(),{error:null}}catch(e){return Gt(e)?{error:e}:{error:new Rx("Unexpected error during initialization",e)}}finally{yield this._handleVisibilityChange(),this._debug("#_initialize()","end")}})}signUp(e){return L(this,null,function*(){var n,o,s;try{yield this._removeSession();let i;if("email"in e){let{email:p,password:d,options:f}=e,h=null,m=null;if(this.flowType==="pkce"){let g=fm();yield vf(this.storage,`${this.storageKey}-code-verifier`,g),h=yield hm(g),m=g===h?"plain":"s256"}i=yield Qt(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,redirectTo:f?.emailRedirectTo,body:{email:p,password:d,data:(n=f?.data)!==null&&n!==void 0?n:{},gotrue_meta_security:{captcha_token:f?.captchaToken},code_challenge:h,code_challenge_method:m},xform:bf})}else if("phone"in e){let{phone:p,password:d,options:f}=e;i=yield Qt(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{phone:p,password:d,data:(o=f?.data)!==null&&o!==void 0?o:{},channel:(s=f?.channel)!==null&&s!==void 0?s:"sms",gotrue_meta_security:{captcha_token:f?.captchaToken}},xform:bf})}else throw new mm("You must provide either an email or phone number and a password");let{data:a,error:u}=i;if(u||!a)return{data:{user:null,session:null},error:u};let l=a.session,c=a.user;return a.session&&(yield this._saveSession(a.session),yield this._notifyAllSubscribers("SIGNED_IN",l)),{data:{user:c,session:l},error:null}}catch(i){if(Gt(i))return{data:{user:null,session:null},error:i};throw i}})}signInWithPassword(e){return L(this,null,function*(){try{yield this._removeSession();let n;if("email"in e){let{email:i,password:a,options:u}=e;n=yield Qt(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{email:i,password:a,gotrue_meta_security:{captcha_token:u?.captchaToken}},xform:NP})}else if("phone"in e){let{phone:i,password:a,options:u}=e;n=yield Qt(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{phone:i,password:a,gotrue_meta_security:{captcha_token:u?.captchaToken}},xform:NP})}else throw new mm("You must provide either an email or phone number and a password");let{data:o,error:s}=n;return s?{data:{user:null,session:null},error:s}:!o||!o.session||!o.user?{data:{user:null,session:null},error:new Ox}:(o.session&&(yield this._saveSession(o.session),yield this._notifyAllSubscribers("SIGNED_IN",o.session)),{data:Object.assign({user:o.user,session:o.session},o.weak_password?{weakPassword:o.weak_password}:null),error:s})}catch(n){if(Gt(n))return{data:{user:null,session:null},error:n};throw n}})}signInWithOAuth(e){return L(this,null,function*(){var n,o,s,i;return yield this._removeSession(),yield this._handleProviderSignIn(e.provider,{redirectTo:(n=e.options)===null||n===void 0?void 0:n.redirectTo,scopes:(o=e.options)===null||o===void 0?void 0:o.scopes,queryParams:(s=e.options)===null||s===void 0?void 0:s.queryParams,skipBrowserRedirect:(i=e.options)===null||i===void 0?void 0:i.skipBrowserRedirect})})}exchangeCodeForSession(e){return L(this,null,function*(){return yield this.initializePromise,this._acquireLock(-1,()=>L(this,null,function*(){return this._exchangeCodeForSession(e)}))})}_exchangeCodeForSession(e){return L(this,null,function*(){let n=yield zw(this.storage,`${this.storageKey}-code-verifier`),[o,s]=(n??"").split("/"),{data:i,error:a}=yield Qt(this.fetch,"POST",`${this.url}/token?grant_type=pkce`,{headers:this.headers,body:{auth_code:e,code_verifier:o},xform:bf});return yield dN(this.storage,`${this.storageKey}-code-verifier`),a?{data:{user:null,session:null,redirectType:null},error:a}:!i||!i.session||!i.user?{data:{user:null,session:null,redirectType:null},error:new Ox}:(i.session&&(yield this._saveSession(i.session),yield this._notifyAllSubscribers("SIGNED_IN",i.session)),{data:Object.assign(Object.assign({},i),{redirectType:s??null}),error:a})})}signInWithIdToken(e){return L(this,null,function*(){yield this._removeSession();try{let{options:n,provider:o,token:s,access_token:i,nonce:a}=e,u=yield Qt(this.fetch,"POST",`${this.url}/token?grant_type=id_token`,{headers:this.headers,body:{provider:o,id_token:s,access_token:i,nonce:a,gotrue_meta_security:{captcha_token:n?.captchaToken}},xform:bf}),{data:l,error:c}=u;return c?{data:{user:null,session:null},error:c}:!l||!l.session||!l.user?{data:{user:null,session:null},error:new Ox}:(l.session&&(yield this._saveSession(l.session),yield this._notifyAllSubscribers("SIGNED_IN",l.session)),{data:l,error:c})}catch(n){if(Gt(n))return{data:{user:null,session:null},error:n};throw n}})}signInWithOtp(e){return L(this,null,function*(){var n,o,s,i,a;try{if(yield this._removeSession(),"email"in e){let{email:u,options:l}=e,c=null,p=null;if(this.flowType==="pkce"){let f=fm();yield vf(this.storage,`${this.storageKey}-code-verifier`,f),c=yield hm(f),p=f===c?"plain":"s256"}let{error:d}=yield Qt(this.fetch,"POST",`${this.url}/otp`,{headers:this.headers,body:{email:u,data:(n=l?.data)!==null&&n!==void 0?n:{},create_user:(o=l?.shouldCreateUser)!==null&&o!==void 0?o:!0,gotrue_meta_security:{captcha_token:l?.captchaToken},code_challenge:c,code_challenge_method:p},redirectTo:l?.emailRedirectTo});return{data:{user:null,session:null},error:d}}if("phone"in e){let{phone:u,options:l}=e,{data:c,error:p}=yield Qt(this.fetch,"POST",`${this.url}/otp`,{headers:this.headers,body:{phone:u,data:(s=l?.data)!==null&&s!==void 0?s:{},create_user:(i=l?.shouldCreateUser)!==null&&i!==void 0?i:!0,gotrue_meta_security:{captcha_token:l?.captchaToken},channel:(a=l?.channel)!==null&&a!==void 0?a:"sms"}});return{data:{user:null,session:null,messageId:c?.message_id},error:p}}throw new mm("You must provide either an email or phone number.")}catch(u){if(Gt(u))return{data:{user:null,session:null},error:u};throw u}})}verifyOtp(e){return L(this,null,function*(){var n,o;try{e.type!=="email_change"&&e.type!=="phone_change"&&(yield this._removeSession());let s,i;"options"in e&&(s=(n=e.options)===null||n===void 0?void 0:n.redirectTo,i=(o=e.options)===null||o===void 0?void 0:o.captchaToken);let{data:a,error:u}=yield Qt(this.fetch,"POST",`${this.url}/verify`,{headers:this.headers,body:Object.assign(Object.assign({},e),{gotrue_meta_security:{captcha_token:i}}),redirectTo:s,xform:bf});if(u)throw u;if(!a)throw new Error("An error occurred on token verification.");let l=a.session,c=a.user;return l?.access_token&&(yield this._saveSession(l),yield this._notifyAllSubscribers("SIGNED_IN",l)),{data:{user:c,session:l},error:null}}catch(s){if(Gt(s))return{data:{user:null,session:null},error:s};throw s}})}signInWithSSO(e){return L(this,null,function*(){var n,o,s;try{yield this._removeSession();let i=null,a=null;if(this.flowType==="pkce"){let u=fm();yield vf(this.storage,`${this.storageKey}-code-verifier`,u),i=yield hm(u),a=u===i?"plain":"s256"}return yield Qt(this.fetch,"POST",`${this.url}/sso`,{body:Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},"providerId"in e?{provider_id:e.providerId}:null),"domain"in e?{domain:e.domain}:null),{redirect_to:(o=(n=e.options)===null||n===void 0?void 0:n.redirectTo)!==null&&o!==void 0?o:void 0}),!((s=e?.options)===null||s===void 0)&&s.captchaToken?{gotrue_meta_security:{captcha_token:e.options.captchaToken}}:null),{skip_http_redirect:!0,code_challenge:i,code_challenge_method:a}),headers:this.headers,xform:oie})}catch(i){if(Gt(i))return{data:null,error:i};throw i}})}reauthenticate(){return L(this,null,function*(){return yield this.initializePromise,yield this._acquireLock(-1,()=>L(this,null,function*(){return yield this._reauthenticate()}))})}_reauthenticate(){return L(this,null,function*(){try{return yield this._useSession(e=>L(this,null,function*(){let{data:{session:n},error:o}=e;if(o)throw o;if(!n)throw new np;let{error:s}=yield Qt(this.fetch,"GET",`${this.url}/reauthenticate`,{headers:this.headers,jwt:n.access_token});return{data:{user:null,session:null},error:s}}))}catch(e){if(Gt(e))return{data:{user:null,session:null},error:e};throw e}})}resend(e){return L(this,null,function*(){try{e.type!="email_change"&&e.type!="phone_change"&&(yield this._removeSession());let n=`${this.url}/resend`;if("email"in e){let{email:o,type:s,options:i}=e,{error:a}=yield Qt(this.fetch,"POST",n,{headers:this.headers,body:{email:o,type:s,gotrue_meta_security:{captcha_token:i?.captchaToken}},redirectTo:i?.emailRedirectTo});return{data:{user:null,session:null},error:a}}else if("phone"in e){let{phone:o,type:s,options:i}=e,{data:a,error:u}=yield Qt(this.fetch,"POST",n,{headers:this.headers,body:{phone:o,type:s,gotrue_meta_security:{captcha_token:i?.captchaToken}}});return{data:{user:null,session:null,messageId:a?.message_id},error:u}}throw new mm("You must provide either an email or phone number and a type")}catch(n){if(Gt(n))return{data:{user:null,session:null},error:n};throw n}})}getSession(){return L(this,null,function*(){return yield this.initializePromise,this._acquireLock(-1,()=>L(this,null,function*(){return this._useSession(e=>L(this,null,function*(){return e}))}))})}_acquireLock(e,n){return L(this,null,function*(){this._debug("#_acquireLock","begin",e);try{if(this.lockAcquired){let o=this.pendingInLock.length?this.pendingInLock[this.pendingInLock.length-1]:Promise.resolve(),s=L(this,null,function*(){return yield o,yield n()});return this.pendingInLock.push(L(this,null,function*(){try{yield s}catch{}})),s}return yield this.lock(`lock:${this.storageKey}`,e,()=>L(this,null,function*(){this._debug("#_acquireLock","lock acquired for storage key",this.storageKey);try{this.lockAcquired=!0;let o=n();for(this.pendingInLock.push(L(this,null,function*(){try{yield o}catch{}})),yield o;this.pendingInLock.length;){let s=[...this.pendingInLock];yield Promise.all(s),this.pendingInLock.splice(0,s.length)}return yield o}finally{this._debug("#_acquireLock","lock released for storage key",this.storageKey),this.lockAcquired=!1}}))}finally{this._debug("#_acquireLock","end")}})}_useSession(e){return L(this,null,function*(){this._debug("#_useSession","begin");try{let n=yield this.__loadSession();return yield e(n)}finally{this._debug("#_useSession","end")}})}__loadSession(){return L(this,null,function*(){this._debug("#__loadSession()","begin"),this.lockAcquired||this._debug("#__loadSession()","used outside of an acquired lock!",new Error().stack);try{let e=null,n=yield zw(this.storage,this.storageKey);if(this._debug("#getSession()","session from storage",n),n!==null&&(this._isValidSession(n)?e=n:(this._debug("#getSession()","session from storage is not valid"),yield this._removeSession())),!e)return{data:{session:null},error:null};let o=e.expires_at?e.expires_at<=Date.now()/1e3:!1;if(this._debug("#__loadSession()",`session has${o?"":" not"} expired`,"expires_at",e.expires_at),!o)return{data:{session:e},error:null};let{session:s,error:i}=yield this._callRefreshToken(e.refresh_token);return i?{data:{session:null},error:i}:{data:{session:s},error:null}}finally{this._debug("#__loadSession()","end")}})}getUser(e){return L(this,null,function*(){return e?yield this._getUser(e):(yield this.initializePromise,this._acquireLock(-1,()=>L(this,null,function*(){return yield this._getUser()})))})}_getUser(e){return L(this,null,function*(){try{return e?yield Qt(this.fetch,"GET",`${this.url}/user`,{headers:this.headers,jwt:e,xform:ec}):yield this._useSession(n=>L(this,null,function*(){var o,s;let{data:i,error:a}=n;if(a)throw a;return yield Qt(this.fetch,"GET",`${this.url}/user`,{headers:this.headers,jwt:(s=(o=i.session)===null||o===void 0?void 0:o.access_token)!==null&&s!==void 0?s:void 0,xform:ec})}))}catch(n){if(Gt(n))return{data:{user:null},error:n};throw n}})}updateUser(o){return L(this,arguments,function*(e,n={}){return yield this.initializePromise,yield this._acquireLock(-1,()=>L(this,null,function*(){return yield this._updateUser(e,n)}))})}_updateUser(o){return L(this,arguments,function*(e,n={}){try{return yield this._useSession(s=>L(this,null,function*(){let{data:i,error:a}=s;if(a)throw a;if(!i.session)throw new np;let u=i.session,l=null,c=null;if(this.flowType==="pkce"&&e.email!=null){let f=fm();yield vf(this.storage,`${this.storageKey}-code-verifier`,f),l=yield hm(f),c=f===l?"plain":"s256"}let{data:p,error:d}=yield Qt(this.fetch,"PUT",`${this.url}/user`,{headers:this.headers,redirectTo:n?.emailRedirectTo,body:Object.assign(Object.assign({},e),{code_challenge:l,code_challenge_method:c}),jwt:u.access_token,xform:ec});if(d)throw d;return u.user=p.user,yield this._saveSession(u),yield this._notifyAllSubscribers("USER_UPDATED",u),{data:{user:u.user},error:null}}))}catch(s){if(Gt(s))return{data:{user:null},error:s};throw s}})}_decodeJWT(e){return kP(e)}setSession(e){return L(this,null,function*(){return yield this.initializePromise,yield this._acquireLock(-1,()=>L(this,null,function*(){return yield this._setSession(e)}))})}_setSession(e){return L(this,null,function*(){try{if(!e.access_token||!e.refresh_token)throw new np;let n=Date.now()/1e3,o=n,s=!0,i=null,a=kP(e.access_token);if(a.exp&&(o=a.exp,s=o<=n),s){let{session:u,error:l}=yield this._callRefreshToken(e.refresh_token);if(l)return{data:{user:null,session:null},error:l};if(!u)return{data:{user:null,session:null},error:null};i=u}else{let{data:u,error:l}=yield this._getUser(e.access_token);if(l)throw l;i={access_token:e.access_token,refresh_token:e.refresh_token,user:u.user,token_type:"bearer",expires_in:o-n,expires_at:o},yield this._saveSession(i),yield this._notifyAllSubscribers("SIGNED_IN",i)}return{data:{user:i.user,session:i},error:null}}catch(n){if(Gt(n))return{data:{session:null,user:null},error:n};throw n}})}refreshSession(e){return L(this,null,function*(){return yield this.initializePromise,yield this._acquireLock(-1,()=>L(this,null,function*(){return yield this._refreshSession(e)}))})}_refreshSession(e){return L(this,null,function*(){try{return yield this._useSession(n=>L(this,null,function*(){var o;if(!e){let{data:a,error:u}=n;if(u)throw u;e=(o=a.session)!==null&&o!==void 0?o:void 0}if(!e?.refresh_token)throw new np;let{session:s,error:i}=yield this._callRefreshToken(e.refresh_token);return i?{data:{user:null,session:null},error:i}:s?{data:{user:s.user,session:s},error:null}:{data:{user:null,session:null},error:null}}))}catch(n){if(Gt(n))return{data:{user:null,session:null},error:n};throw n}})}_getSessionFromURL(e){return L(this,null,function*(){try{if(!mu())throw new gm("No browser detected.");if(this.flowType==="implicit"&&!this._isImplicitGrantFlow())throw new gm("Not a valid implicit grant flow url.");if(this.flowType=="pkce"&&!e)throw new Vw("Not a valid PKCE flow url.");let n=cN(window.location.href);if(e){if(!n.code)throw new Vw("No code detected.");let{data:w,error:C}=yield this._exchangeCodeForSession(n.code);if(C)throw C;let I=new URL(window.location.href);return I.searchParams.delete("code"),window.history.replaceState(window.history.state,"",I.toString()),{data:{session:w.session,redirectType:null},error:null}}if(n.error||n.error_description||n.error_code)throw new gm(n.error_description||"Error in URL with unspecified error_description",{error:n.error||"unspecified_error",code:n.error_code||"unspecified_code"});let{provider_token:o,provider_refresh_token:s,access_token:i,refresh_token:a,expires_in:u,expires_at:l,token_type:c}=n;if(!i||!u||!a||!c)throw new gm("No session defined in URL");let p=Math.round(Date.now()/1e3),d=parseInt(u),f=p+d;l&&(f=parseInt(l));let h=f-p;h*1e3<=Uw&&console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${h}s, should have been closer to ${d}s`);let m=f-d;p-m>=120?console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale",m,f,p):p-m<0&&console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clok for skew",m,f,p);let{data:g,error:y}=yield this._getUser(i);if(y)throw y;let x={provider_token:o,provider_refresh_token:s,access_token:i,expires_in:d,expires_at:f,refresh_token:a,token_type:c,user:g.user};return window.location.hash="",this._debug("#_getSessionFromURL()","clearing window.location.hash"),{data:{session:x,redirectType:n.type},error:null}}catch(n){if(Gt(n))return{data:{session:null,redirectType:null},error:n};throw n}})}_isImplicitGrantFlow(){let e=cN(window.location.href);return!!(mu()&&(e.access_token||e.error_description))}_isPKCEFlow(){return L(this,null,function*(){let e=cN(window.location.href),n=yield zw(this.storage,`${this.storageKey}-code-verifier`);return!!(e.code&&n)})}signOut(){return L(this,arguments,function*(e={scope:"global"}){return yield this.initializePromise,yield this._acquireLock(-1,()=>L(this,null,function*(){return yield this._signOut(e)}))})}_signOut(){return L(this,arguments,function*({scope:e}={scope:"global"}){return yield this._useSession(n=>L(this,null,function*(){var o;let{data:s,error:i}=n;if(i)return{error:i};let a=(o=s.session)===null||o===void 0?void 0:o.access_token;if(a){let{error:u}=yield this.admin.signOut(a,e);if(u&&!(rie(u)&&(u.status===404||u.status===401)))return{error:u}}return e!=="others"&&(yield this._removeSession(),yield dN(this.storage,`${this.storageKey}-code-verifier`),yield this._notifyAllSubscribers("SIGNED_OUT",null)),{error:null}}))})}onAuthStateChange(e){let n=Qse(),o={id:n,callback:e,unsubscribe:()=>{this._debug("#unsubscribe()","state change callback with id removed",n),this.stateChangeEmitters.delete(n)}};return this._debug("#onAuthStateChange()","registered callback with id",n),this.stateChangeEmitters.set(n,o),L(this,null,function*(){yield this.initializePromise,yield this._acquireLock(-1,()=>L(this,null,function*(){this._emitInitialSession(n)}))}),{data:{subscription:o}}}_emitInitialSession(e){return L(this,null,function*(){return yield this._useSession(n=>L(this,null,function*(){var o,s;try{let{data:{session:i},error:a}=n;if(a)throw a;yield(o=this.stateChangeEmitters.get(e))===null||o===void 0?void 0:o.callback("INITIAL_SESSION",i),this._debug("INITIAL_SESSION","callback id",e,"session",i)}catch(i){yield(s=this.stateChangeEmitters.get(e))===null||s===void 0?void 0:s.callback("INITIAL_SESSION",null),this._debug("INITIAL_SESSION","callback id",e,"error",i),console.error(i)}}))})}resetPasswordForEmail(o){return L(this,arguments,function*(e,n={}){let s=null,i=null;if(this.flowType==="pkce"){let a=fm();yield vf(this.storage,`${this.storageKey}-code-verifier`,`${a}/PASSWORD_RECOVERY`),s=yield hm(a),i=a===s?"plain":"s256"}try{return yield Qt(this.fetch,"POST",`${this.url}/recover`,{body:{email:e,code_challenge:s,code_challenge_method:i,gotrue_meta_security:{captcha_token:n.captchaToken}},headers:this.headers,redirectTo:n.redirectTo})}catch(a){if(Gt(a))return{data:null,error:a};throw a}})}getUserIdentities(){return L(this,null,function*(){var e;try{let{data:n,error:o}=yield this.getUser();if(o)throw o;return{data:{identities:(e=n.user.identities)!==null&&e!==void 0?e:[]},error:null}}catch(n){if(Gt(n))return{data:null,error:n};throw n}})}linkIdentity(e){return L(this,null,function*(){var n;try{let{data:o,error:s}=yield this._useSession(i=>L(this,null,function*(){var a,u,l,c,p;let{data:d,error:f}=i;if(f)throw f;let h=yield this._getUrlForProvider(`${this.url}/user/identities/authorize`,e.provider,{redirectTo:(a=e.options)===null||a===void 0?void 0:a.redirectTo,scopes:(u=e.options)===null||u===void 0?void 0:u.scopes,queryParams:(l=e.options)===null||l===void 0?void 0:l.queryParams,skipBrowserRedirect:!0});return yield Qt(this.fetch,"GET",h,{headers:this.headers,jwt:(p=(c=d.session)===null||c===void 0?void 0:c.access_token)!==null&&p!==void 0?p:void 0})}));if(s)throw s;return mu()&&!(!((n=e.options)===null||n===void 0)&&n.skipBrowserRedirect)&&window.location.assign(o?.url),{data:{provider:e.provider,url:o?.url},error:null}}catch(o){if(Gt(o))return{data:{provider:e.provider,url:null},error:o};throw o}})}unlinkIdentity(e){return L(this,null,function*(){try{return yield this._useSession(n=>L(this,null,function*(){var o,s;let{data:i,error:a}=n;if(a)throw a;return yield Qt(this.fetch,"DELETE",`${this.url}/user/identities/${e.identity_id}`,{headers:this.headers,jwt:(s=(o=i.session)===null||o===void 0?void 0:o.access_token)!==null&&s!==void 0?s:void 0})}))}catch(n){if(Gt(n))return{data:null,error:n};throw n}})}_refreshAccessToken(e){return L(this,null,function*(){let n=`#_refreshAccessToken(${e.substring(0,5)}...)`;this._debug(n,"begin");try{let o=Date.now();return yield tie(s=>L(this,null,function*(){return yield eie(s*200),this._debug(n,"refreshing attempt",s),yield Qt(this.fetch,"POST",`${this.url}/token?grant_type=refresh_token`,{body:{refresh_token:e},headers:this.headers,xform:bf})}),(s,i,a)=>a&&a.error&&mN(a.error)&&Date.now()+(s+1)*200-o<Uw)}catch(o){if(this._debug(n,"error",o),Gt(o))return{data:{session:null,user:null},error:o};throw o}finally{this._debug(n,"end")}})}_isValidSession(e){return typeof e=="object"&&e!==null&&"access_token"in e&&"refresh_token"in e&&"expires_at"in e}_handleProviderSignIn(e,n){return L(this,null,function*(){let o=yield this._getUrlForProvider(`${this.url}/authorize`,e,{redirectTo:n.redirectTo,scopes:n.scopes,queryParams:n.queryParams});return this._debug("#_handleProviderSignIn()","provider",e,"options",n,"url",o),mu()&&!n.skipBrowserRedirect&&window.location.assign(o),{data:{provider:e,url:o},error:null}})}_recoverAndRefresh(){return L(this,null,function*(){var e;let n="#_recoverAndRefresh()";this._debug(n,"begin");try{let o=yield zw(this.storage,this.storageKey);if(this._debug(n,"session from storage",o),!this._isValidSession(o)){this._debug(n,"session is not valid"),o!==null&&(yield this._removeSession());return}let s=Math.round(Date.now()/1e3),i=((e=o.expires_at)!==null&&e!==void 0?e:1/0)<s+DP;if(this._debug(n,`session has${i?"":" not"} expired with margin of ${DP}s`),i){if(this.autoRefreshToken&&o.refresh_token){let{error:a}=yield this._callRefreshToken(o.refresh_token);a&&(console.error(a),mN(a)||(this._debug(n,"refresh failed with a non-retryable error, removing the session",a),yield this._removeSession()))}}else yield this._notifyAllSubscribers("SIGNED_IN",o)}catch(o){this._debug(n,"error",o),console.error(o);return}finally{this._debug(n,"end")}})}_callRefreshToken(e){return L(this,null,function*(){var n,o;if(!e)throw new np;if(this.refreshingDeferred)return this.refreshingDeferred.promise;let s=`#_callRefreshToken(${e.substring(0,5)}...)`;this._debug(s,"begin");try{this.refreshingDeferred=new Lw;let{data:i,error:a}=yield this._refreshAccessToken(e);if(a)throw a;if(!i.session)throw new np;yield this._saveSession(i.session),yield this._notifyAllSubscribers("TOKEN_REFRESHED",i.session);let u={session:i.session,error:null};return this.refreshingDeferred.resolve(u),u}catch(i){if(this._debug(s,"error",i),Gt(i)){let a={session:null,error:i};return mN(i)||(yield this._removeSession(),yield this._notifyAllSubscribers("SIGNED_OUT",null)),(n=this.refreshingDeferred)===null||n===void 0||n.resolve(a),a}throw(o=this.refreshingDeferred)===null||o===void 0||o.reject(i),i}finally{this.refreshingDeferred=null,this._debug(s,"end")}})}_notifyAllSubscribers(e,n,o=!0){return L(this,null,function*(){let s=`#_notifyAllSubscribers(${e})`;this._debug(s,"begin",n,`broadcast = ${o}`);try{this.broadcastChannel&&o&&this.broadcastChannel.postMessage({event:e,session:n});let i=[],a=Array.from(this.stateChangeEmitters.values()).map(u=>L(this,null,function*(){try{yield u.callback(e,n)}catch(l){i.push(l)}}));if(yield Promise.all(a),i.length>0){for(let u=0;u<i.length;u+=1)console.error(i[u]);throw i[0]}}finally{this._debug(s,"end")}})}_saveSession(e){return L(this,null,function*(){this._debug("#_saveSession()",e),yield vf(this.storage,this.storageKey,e)})}_removeSession(){return L(this,null,function*(){this._debug("#_removeSession()"),yield dN(this.storage,this.storageKey)})}_removeVisibilityChangedCallback(){this._debug("#_removeVisibilityChangedCallback()");let e=this.visibilityChangedCallback;this.visibilityChangedCallback=null;try{e&&mu()&&window?.removeEventListener&&window.removeEventListener("visibilitychange",e)}catch(n){console.error("removing visibilitychange callback failed",n)}}_startAutoRefresh(){return L(this,null,function*(){yield this._stopAutoRefresh(),this._debug("#_startAutoRefresh()");let e=setInterval(()=>this._autoRefreshTokenTick(),Uw);this.autoRefreshTicker=e,e&&typeof e=="object"&&typeof e.unref=="function"?e.unref():typeof Deno<"u"&&typeof Deno.unrefTimer=="function"&&Deno.unrefTimer(e),setTimeout(()=>L(this,null,function*(){yield this.initializePromise,yield this._autoRefreshTokenTick()}),0)})}_stopAutoRefresh(){return L(this,null,function*(){this._debug("#_stopAutoRefresh()");let e=this.autoRefreshTicker;this.autoRefreshTicker=null,e&&clearInterval(e)})}startAutoRefresh(){return L(this,null,function*(){this._removeVisibilityChangedCallback(),yield this._startAutoRefresh()})}stopAutoRefresh(){return L(this,null,function*(){this._removeVisibilityChangedCallback(),yield this._stopAutoRefresh()})}_autoRefreshTokenTick(){return L(this,null,function*(){this._debug("#_autoRefreshTokenTick()","begin");try{yield this._acquireLock(0,()=>L(this,null,function*(){try{let e=Date.now();try{return yield this._useSession(n=>L(this,null,function*(){let{data:{session:o}}=n;if(!o||!o.refresh_token||!o.expires_at){this._debug("#_autoRefreshTokenTick()","no session");return}let s=Math.floor((o.expires_at*1e3-e)/Uw);this._debug("#_autoRefreshTokenTick()",`access token expires in ${s} ticks, a tick lasts ${Uw}ms, refresh threshold is ${die} ticks`),s<=die&&(yield this._callRefreshToken(o.refresh_token))}))}catch(n){console.error("Auto refresh tick failed with error. This is likely a transient error.",n)}}finally{this._debug("#_autoRefreshTokenTick()","end")}}))}catch(e){if(e.isAcquireTimeout||e instanceof yN)this._debug("auto refresh token tick lock not available");else throw e}})}_handleVisibilityChange(){return L(this,null,function*(){if(this._debug("#_handleVisibilityChange()"),!mu()||!window?.addEventListener)return this.autoRefreshToken&&this.startAutoRefresh(),!1;try{this.visibilityChangedCallback=()=>L(this,null,function*(){return yield this._onVisibilityChanged(!1)}),window?.addEventListener("visibilitychange",this.visibilityChangedCallback),yield this._onVisibilityChanged(!0)}catch(e){console.error("_handleVisibilityChange",e)}})}_onVisibilityChanged(e){return L(this,null,function*(){let n=`#_onVisibilityChanged(${e})`;this._debug(n,"visibilityState",document.visibilityState),document.visibilityState==="visible"?(this.autoRefreshToken&&this._startAutoRefresh(),e||(yield this.initializePromise,yield this._acquireLock(-1,()=>L(this,null,function*(){if(document.visibilityState!=="visible"){this._debug(n,"acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");return}yield this._recoverAndRefresh()})))):document.visibilityState==="hidden"&&this.autoRefreshToken&&this._stopAutoRefresh()})}_getUrlForProvider(e,n,o){return L(this,null,function*(){let s=[`provider=${encodeURIComponent(n)}`];if(o?.redirectTo&&s.push(`redirect_to=${encodeURIComponent(o.redirectTo)}`),o?.scopes&&s.push(`scopes=${encodeURIComponent(o.scopes)}`),this.flowType==="pkce"){let i=fm();yield vf(this.storage,`${this.storageKey}-code-verifier`,i);let a=yield hm(i),u=i===a?"plain":"s256";this._debug("PKCE","code verifier",`${i.substring(0,5)}...`,"code challenge",a,"method",u);let l=new URLSearchParams({code_challenge:`${encodeURIComponent(a)}`,code_challenge_method:`${encodeURIComponent(u)}`});s.push(l.toString())}if(o?.queryParams){let i=new URLSearchParams(o.queryParams);s.push(i.toString())}return o?.skipBrowserRedirect&&s.push(`skip_http_redirect=${o.skipBrowserRedirect}`),`${e}?${s.join("&")}`})}_unenroll(e){return L(this,null,function*(){try{return yield this._useSession(n=>L(this,null,function*(){var o;let{data:s,error:i}=n;return i?{data:null,error:i}:yield Qt(this.fetch,"DELETE",`${this.url}/factors/${e.factorId}`,{headers:this.headers,jwt:(o=s?.session)===null||o===void 0?void 0:o.access_token})}))}catch(n){if(Gt(n))return{data:null,error:n};throw n}})}_enroll(e){return L(this,null,function*(){try{return yield this._useSession(n=>L(this,null,function*(){var o,s;let{data:i,error:a}=n;if(a)return{data:null,error:a};let{data:u,error:l}=yield Qt(this.fetch,"POST",`${this.url}/factors`,{body:{friendly_name:e.friendlyName,factor_type:e.factorType,issuer:e.issuer},headers:this.headers,jwt:(o=i?.session)===null||o===void 0?void 0:o.access_token});return l?{data:null,error:l}:(!((s=u?.totp)===null||s===void 0)&&s.qr_code&&(u.totp.qr_code=`data:image/svg+xml;utf-8,${u.totp.qr_code}`),{data:u,error:null})}))}catch(n){if(Gt(n))return{data:null,error:n};throw n}})}_verify(e){return L(this,null,function*(){return this._acquireLock(-1,()=>L(this,null,function*(){try{return yield this._useSession(n=>L(this,null,function*(){var o;let{data:s,error:i}=n;if(i)return{data:null,error:i};let{data:a,error:u}=yield Qt(this.fetch,"POST",`${this.url}/factors/${e.factorId}/verify`,{body:{code:e.code,challenge_id:e.challengeId},headers:this.headers,jwt:(o=s?.session)===null||o===void 0?void 0:o.access_token});return u?{data:null,error:u}:(yield this._saveSession(Object.assign({expires_at:Math.round(Date.now()/1e3)+a.expires_in},a)),yield this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED",a),{data:a,error:u})}))}catch(n){if(Gt(n))return{data:null,error:n};throw n}}))})}_challenge(e){return L(this,null,function*(){return this._acquireLock(-1,()=>L(this,null,function*(){try{return yield this._useSession(n=>L(this,null,function*(){var o;let{data:s,error:i}=n;return i?{data:null,error:i}:yield Qt(this.fetch,"POST",`${this.url}/factors/${e.factorId}/challenge`,{headers:this.headers,jwt:(o=s?.session)===null||o===void 0?void 0:o.access_token})}))}catch(n){if(Gt(n))return{data:null,error:n};throw n}}))})}_challengeAndVerify(e){return L(this,null,function*(){let{data:n,error:o}=yield this._challenge({factorId:e.factorId});return o?{data:null,error:o}:yield this._verify({factorId:e.factorId,challengeId:n.id,code:e.code})})}_listFactors(){return L(this,null,function*(){let{data:{user:e},error:n}=yield this.getUser();if(n)return{data:null,error:n};let o=e?.factors||[],s=o.filter(i=>i.factor_type==="totp"&&i.status==="verified");return{data:{all:o,totp:s},error:null}})}_getAuthenticatorAssuranceLevel(){return L(this,null,function*(){return this._acquireLock(-1,()=>L(this,null,function*(){return yield this._useSession(e=>L(this,null,function*(){var n,o;let{data:{session:s},error:i}=e;if(i)return{data:null,error:i};if(!s)return{data:{currentLevel:null,nextLevel:null,currentAuthenticationMethods:[]},error:null};let a=this._decodeJWT(s.access_token),u=null;a.aal&&(u=a.aal);let l=u;((o=(n=s.user.factors)===null||n===void 0?void 0:n.filter(d=>d.status==="verified"))!==null&&o!==void 0?o:[]).length>0&&(l="aal2");let p=a.amr||[];return{data:{currentLevel:u,nextLevel:l,currentAuthenticationMethods:p},error:null}}))}))})}}return r.nextInstanceID=0,r})();var W3e=RP,OP=W3e;var xN=class extends OP{constructor(t){super(t)}};var j3e=function(r,t,e,n){function o(s){return s instanceof e?s:new e(function(i){i(s)})}return new(e||(e=Promise))(function(s,i){function a(c){try{l(n.next(c))}catch(p){i(p)}}function u(c){try{l(n.throw(c))}catch(p){i(p)}}function l(c){c.done?s(c.value):o(c.value).then(a,u)}l((n=n.apply(r,t||[])).next())})},vN=class{constructor(t,e,n){var o,s,i;if(this.supabaseUrl=t,this.supabaseKey=e,!t)throw new Error("supabaseUrl is required.");if(!e)throw new Error("supabaseKey is required.");let a=Xse(t);this.realtimeUrl=`${a}/realtime/v1`.replace(/^http/i,"ws"),this.authUrl=`${a}/auth/v1`,this.storageUrl=`${a}/storage/v1`,this.functionsUrl=`${a}/functions/v1`;let u=`sb-${new URL(this.authUrl).hostname.split(".")[0]}-auth-token`,l={db:jse,realtime:qse,auth:Object.assign(Object.assign({},Hse),{storageKey:u}),global:Wse},c=Yse(n??{},l);this.storageKey=(o=c.auth.storageKey)!==null&&o!==void 0?o:"",this.headers=(s=c.global.headers)!==null&&s!==void 0?s:{},c.accessToken?(this.accessToken=c.accessToken,this.auth=new Proxy({},{get:(p,d)=>{throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(d)} is not possible`)}})):this.auth=this._initSupabaseAuthClient((i=c.auth)!==null&&i!==void 0?i:{},this.headers,c.global.fetch),this.fetch=Kse(e,this._getAccessToken.bind(this),c.global.fetch),this.realtime=this._initRealtimeClient(Object.assign({headers:this.headers},c.realtime)),this.rest=new Ase(`${a}/rest/v1`,{headers:this.headers,schema:c.db.schema,fetch:this.fetch}),c.accessToken||this._listenForAuthEvents()}get functions(){return new Iw(this.functionsUrl,{headers:this.headers,customFetch:this.fetch})}get storage(){return new $w(this.storageUrl,this.headers,this.fetch)}from(t){return this.rest.from(t)}schema(t){return this.rest.schema(t)}rpc(t,e={},n={}){return this.rest.rpc(t,e,n)}channel(t,e={config:{}}){return this.realtime.channel(t,e)}getChannels(){return this.realtime.getChannels()}removeChannel(t){return this.realtime.removeChannel(t)}removeAllChannels(){return this.realtime.removeAllChannels()}_getAccessToken(){var t,e;return j3e(this,void 0,void 0,function*(){if(this.accessToken)return yield this.accessToken();let{data:n}=yield this.auth.getSession();return(e=(t=n.session)===null||t===void 0?void 0:t.access_token)!==null&&e!==void 0?e:null})}_initSupabaseAuthClient({autoRefreshToken:t,persistSession:e,detectSessionInUrl:n,storage:o,storageKey:s,flowType:i,lock:a,debug:u},l,c){var p;let d={Authorization:`Bearer ${this.supabaseKey}`,apikey:`${this.supabaseKey}`};return new xN({url:this.authUrl,headers:Object.assign(Object.assign({},d),l),storageKey:s,autoRefreshToken:t,persistSession:e,detectSessionInUrl:n,storage:o,flowType:i,lock:a,debug:u,fetch:c,hasCustomAuthorizationHeader:(p="Authorization"in this.headers)!==null&&p!==void 0?p:!1})}_initRealtimeClient(t){return new Mw(this.realtimeUrl,Object.assign(Object.assign({},t),{params:Object.assign({apikey:this.supabaseKey},t?.params)}))}_listenForAuthEvents(){return this.auth.onAuthStateChange((e,n)=>{this._handleTokenChanged(e,"CLIENT",n?.access_token)})}_handleTokenChanged(t,e,n){(t==="TOKEN_REFRESHED"||t==="SIGNED_IN")&&this.changedAccessToken!==n?(this.realtime.setAuth(n??null),this.changedAccessToken=n):t==="SIGNED_OUT"&&(this.realtime.setAuth(this.supabaseKey),e=="STORAGE"&&this.auth.signOut(),this.changedAccessToken=void 0)}};var fie=(r,t,e)=>new vN(r,t,e);var Px=class r{static supabase;constructor(){}client(){return r.supabase||(r.supabase=fie(nm.supabaseProjectURL,nm.supabaseApiKey)),r.supabase}findAll(t){return L(this,null,function*(){let{data:e,error:n}=yield this.client().from(t).select("*");return n?(console.error("Error fetching data:",n),[]):e})}addOne(t,e){return L(this,null,function*(){let{data:n,error:o}=yield this.client().from(t).insert([e]).select();return o?console.error("Error inserting data:",o.message):console.log("Record added successfully:",n),n&&n[0]})}findOne(t,e,n="id"){return L(this,null,function*(){let{data:o,error:s}=yield this.client().from(t).select("*").eq(n,e).single();return s?(console.error(`Error fetching ${t} with ${n} ${e}:`,s.message),null):o})}static \u0275fac=function(e){return new(e||r)};static \u0275prov=Qe({token:r,factory:r.\u0275fac,providedIn:"root"})};function H3e(r,t){r&1&&(Me(0,"span"),ot(1,"\u2714\uFE0F"),Fe())}function q3e(r,t){r&1&&(Me(0,"span"),ot(1,"\u2714\uFE0F"),Fe())}function K3e(r,t){if(r&1&&(Me(0,"div",11)(1,"p"),ot(2," Step 2: Setting up your game session. Almost there... "),qo(3,q3e,2,0,"span",4),Fe()()),r&2){let e=vo();qt(3),Er("ngIf",e.gameSession)}}function X3e(r,t){r&1&&(Me(0,"div",12)(1,"p"),ot(2," Step 3: Your game session is ready! Click the PLAY button below to start playing, and be sure to share the link with the other player. "),Me(3,"span"),ot(4,"\u2714\uFE0F"),Fe()()())}var bN=class r{constructor(t,e,n,o){this.data=t;this.route=e;this.router=n;this.events=o}sessions=[];gameType;gameSession;gameURL="";title="Assembling the game parts...";ngOnInit(){this.route.paramMap.subscribe(t=>L(this,null,function*(){let e=t.get("gameName");e&&(this.events.track("game.lobby",{gameName:e,step:0,name:"start"}),yield this.loadGameTypeDetails(e),yield this.createSession(),this.generateGameURL(),this.events.track("game.lobby",{gameName:e,step:2,name:"end",gameURL:this.gameURL}))}))}generateGameURL(){if(!this.gameSession){console.error("No game session created");return}let t=nm.applicationLinkURLPreffix,e=this.gameType.name,n=this.gameSession.external_id;this.events.track("game.lobby",{gameName:e,step:1,name:"generate-url",preffix:t,id:n}),this.gameURL=`${t}/play/${e}/${n}`}loadGameTypeDetails(t){return L(this,null,function*(){let n=(yield this.data.findAll("game_type")).filter(o=>o.name===t);n.length>0?(this.gameType=n[0],console.log(`${t} found`,this.gameType)):console.error(`${t} not found`)})}createSession(){return L(this,null,function*(){if(!this.gameType){console.error("No game type selected");return}this.gameSession=yield this.data.addOne("game_session",{game_type:this.gameType.id})})}play(){this.router.navigate(["/play/tic-tac-toe",this.gameSession.external_id])}static \u0275fac=function(e){return new(e||r)(it(Px),it(gs),it(Do),it(Ql))};static \u0275cmp=or({type:r,selectors:[["app-game-lobby"]],standalone:!0,features:[sr],decls:20,vars:4,consts:[[1,"section"],[1,"container"],[1,"content","is-large"],["id","step1"],[4,"ngIf"],["id","step2",4,"ngIf"],["id","step3",4,"ngIf"],[1,"box","content","is-large"],[1,"button","is-large","is-primary","big-buttons",3,"click"],[1,"mt-4"],[1,"is-link",3,"click"],["id","step2"],["id","step3"]],template:function(e,n){e&1&&(Me(0,"section",0)(1,"div",1)(2,"div",2)(3,"h1"),ot(4,"Get in the Game: As Easy as 1-2-3!"),Fe(),Me(5,"div",3)(6,"p"),ot(7," Step 1: Let's find your game. Loading details now... "),qo(8,H3e,2,0,"span",4),Fe()(),qo(9,K3e,4,1,"div",5)(10,X3e,5,0,"div",6),Fe(),Me(11,"div",7)(12,"button",8),zr("click",function(){return n.play()}),ot(13," PLAY "),Fe(),Me(14,"p",9),ot(15," Link to the game "),Wt(16,"br"),Me(17,"a",10),zr("click",function(){return n.play()}),ot(18),Fe()()()()(),Wt(19,"app-footer")),e&2&&(qt(8),Er("ngIf",n.gameType),qt(),Er("ngIf",n.gameType),qt(),Er("ngIf",n.gameSession),qt(8),fv(n.gameURL))},dependencies:[Ko,wp,Ao]})};var wN=class r{constructor(t){this.poseState=t;this.refresh=Ip.getInstance()}canvas;ctx;board=[["cross","circle","cross"],["cross","circle","circle"],["cross","cross","circle"]];handTimestamps=[[null,null,null],[null,null,null],[null,null,null]];refresh;ngOnInit(){this.setup(),this.start(),this.poseState.handDetected.subscribe(t=>{this.detectHandPosition(t)})}detectHandPosition(t){let e=this.canvas.width/3,n=this.canvas.height/3,o=Math.floor(t.x/e),s=Math.floor(t.y/n);o>=0&&o<3&&s>=0&&s<3&&this.handTimestamps[s][o]===null&&(this.resetHandTimestamps(),this.handTimestamps[s][o]=Date.now())}resetHandTimestamps(){for(let t=0;t<3;t++)for(let e=0;e<3;e++)this.handTimestamps[t][e]=null}setup(){this.canvas=document.getElementById("gameCanvas");let t=this.canvas.getContext("2d");if(!t)throw new Error("Not able to get canvas context");this.ctx=t}start(){this.refresh.setup(20),this.refresh.render.subscribe(t=>{this.update()}),this.refresh.start()}update(){this.clearScreen(),this.drawBoard(),this.highlightQuadrant(),this.drawElements()}clearScreen(){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height)}highlightQuadrant(){let t=this.canvas.width/3,e=this.canvas.height/3;this.ctx.fillStyle="rgba(128, 128, 128, 0.5)";for(let n=0;n<3;n++)for(let o=0;o<3;o++)if(this.handTimestamps[n][o]!==null){let s=o*t,i=n*e;this.ctx.fillRect(s,i,t,e)}}drawElements(){let t=this.canvas.width/3,e=this.canvas.height/3;for(let n=0;n<3;n++)for(let o=0;o<3;o++){let s=o*t,i=n*e;this.board[n][o]==="circle"?this.drawCircle(s+t/2,i+e/2,t/4):this.board[n][o]==="cross"&&this.drawCross(s+t/2,i+e/2,t/4)}}drawBoard(){let t=this.canvas.width,e=this.canvas.height,n=t/3,o=e/3;this.ctx.beginPath(),this.ctx.moveTo(n,0),this.ctx.lineTo(n,e),this.ctx.moveTo(2*n,0),this.ctx.lineTo(2*n,e),this.ctx.moveTo(0,o),this.ctx.lineTo(t,o),this.ctx.moveTo(0,2*o),this.ctx.lineTo(t,2*o),this.ctx.strokeStyle="#00FFFF",this.ctx.lineWidth=4,this.ctx.stroke()}drawCircle(t,e,n){this.ctx.beginPath(),this.ctx.arc(t,e,n,0,Math.PI*2),this.ctx.strokeStyle="#00FFFF",this.ctx.lineWidth=4,this.ctx.stroke()}drawCross(t,e,n){this.ctx.beginPath(),this.ctx.moveTo(t-n,e-n),this.ctx.lineTo(t+n,e+n),this.ctx.moveTo(t+n,e-n),this.ctx.lineTo(t-n,e+n),this.ctx.strokeStyle="#00FFFF",this.ctx.lineWidth=4,this.ctx.stroke()}static \u0275fac=function(e){return new(e||r)(it(Tp))};static \u0275cmp=or({type:r,selectors:[["app-tic-tac-toe-game-render"]],standalone:!0,features:[sr],decls:2,vars:0,consts:[[1,"canvas-container"],["id","gameCanvas","width","640","height","480"]],template:function(e,n){e&1&&(Me(0,"div",0),Wt(1,"canvas",1),Fe())},styles:[".canvas-container[_ngcontent-%COMP%]{width:100%;height:100%;position:relative}canvas[_ngcontent-%COMP%]{width:100%;height:100%;display:block}"]})};var CN=class r{constructor(t,e){this.dataStorage=t;this.appState=e}findGameSession(t){return L(this,null,function*(){return yield this.dataStorage.findOne("game_session",t,"external_id")})}createGameParticipation(t){return L(this,null,function*(){let e=this.appState.getParticipantId(),n={game_session:t,participant:e};console.log("participationRecord",n);let o=yield this.dataStorage.addOne("game_session_participation",n);return o?(console.log("Participation record created successfully:",o),o):this.findGameParticipation(t,e)})}findGameParticipation(t,e){return L(this,null,function*(){let n=yield this.dataStorage.client().from("game_session_participation").select("*").eq("game_session",t).eq("participant",e).single();return n.data?(console.log("Found existing participation record:",n.data),n.data):(console.error("No existing participation record found."),null)})}determineSymbol(t){return L(this,null,function*(){let{data:e,error:n}=yield this.dataStorage.client().from("game_session_participation").select("*").eq("game_session",t.game_session).order("created_at",{ascending:!0});if(n)return console.error("Error fetching participation records:",n),"observer";let o=e.findIndex(s=>s.id===t.id);return o===0?"circle":o===1?"cross":"observer"})}static \u0275fac=function(e){return new(e||r)(St(Px),St(yf))};static \u0275prov=Qe({token:r,factory:r.\u0275fac,providedIn:"root"})};function Z3e(r,t){if(r&1&&(Me(0,"div",1)(1,"p"),ot(2),Fe()()),r&2){let e=vo();qt(2),ci("You are playing with ",e.symbol,"")}}var SN=class r{constructor(t,e,n,o,s){this.route=t;this.router=e;this.appStateService=n;this.cdr=o;this.service=s}externalID=null;gameSessionParticipation;selectedCameraID=null;video=new Mr;symbol=null;ngAfterViewInit(){this.selectedCameraID=this.appStateService.getSelectedCamera(),this.cdr.detectChanges()}onVideoReady(t){console.log("video updated",t),this.video.next(t)}onCameraSelected(t){this.selectedCameraID=t,this.appStateService.saveSelectedCamera(t)}ngOnInit(){return L(this,null,function*(){if(this.externalID=this.route.snapshot.paramMap.get("externalID"),!this.externalID){this.router.navigate(["/play/error"]);return}let t=yield this.service.findGameSession(this.externalID);if(!t){this.router.navigate(["/play/error/invalid-session-id",this.externalID]);return}this.gameSessionParticipation=yield this.service.createGameParticipation(t.id),this.symbol=yield this.service.determineSymbol(this.gameSessionParticipation)})}static \u0275fac=function(e){return new(e||r)(it(gs),it(Do),it(yf),it(uc),it(CN))};static \u0275cmp=or({type:r,selectors:[["app-tic-tac-toe-game"]],standalone:!0,features:[sr],decls:19,vars:4,consts:[[1,"section"],[1,"container"],[1,"title"],[1,"notification","is-warning"],[3,"cameraSelected","selectedCameraID"],["class","container",4,"ngIf"],[1,"video-preview",3,"videoReady","selectedCameraID"],[1,"pose-preview",3,"video"],[1,"game"]],template:function(e,n){e&1&&(Me(0,"section",0)(1,"div",1)(2,"h1",2),ot(3,"Move your hand to play tic-tac-toe"),Fe(),Me(4,"div",3)(5,"p"),ot(6," TIC TAC TOE IS UNDER DEVELOPMENT, our current challenge is to define how to move your body to choose your move in the game. Ideas are welcome \u{1F60A} "),Fe()(),Me(7,"app-video-source-selector",4),zr("cameraSelected",function(s){return n.onCameraSelected(s)}),Fe()()(),Me(8,"section",0),qo(9,Z3e,3,1,"div",5),Me(10,"div",1)(11,"app-video-preview",6),zr("videoReady",function(s){return n.onVideoReady(s)}),Fe(),Wt(12,"app-pose-preview",7),Me(13,"div",8),Wt(14,"app-tic-tac-toe-game-render"),Fe()()(),Me(15,"section",0)(16,"div",1),Wt(17,"app-notification"),Fe()(),Wt(18,"app-footer")),e&2&&(qt(7),Er("selectedCameraID",n.selectedCameraID),qt(2),Er("ngIf",n.symbol),qt(2),Er("selectedCameraID",n.selectedCameraID),qt(),Er("video",n.video))},dependencies:[Ko,wp,Ao,ig,Tx,Sx,Ix,wN],styles:[".video-preview[_ngcontent-%COMP%], .pose-preview[_ngcontent-%COMP%], .game[_ngcontent-%COMP%]{position:absolute;top:0;left:0}"]})};var IN=class r{constructor(t,e){this.route=t;this.router=e}sessionID=null;ngOnInit(){return L(this,null,function*(){this.sessionID=this.route.snapshot.paramMap.get("externalID")})}home(){this.router.navigate(["/"])}static \u0275fac=function(e){return new(e||r)(it(gs),it(Do))};static \u0275cmp=or({type:r,selectors:[["app-invalid-game-session-page"]],standalone:!0,features:[sr],decls:16,vars:1,consts:[[1,"section"],[1,"container"],[1,"content","is-large"],[1,"title"],[3,"click"]],template:function(e,n){e&1&&(Me(0,"section",0)(1,"div",1)(2,"div",2)(3,"h1",3),ot(4,"MOVE PLAYGROUND"),Fe(),Me(5,"h1"),ot(6,"Invalid game session"),Fe(),Me(7,"p"),ot(8," There was and error trying to join the game session with the identifier:"),Wt(9,"br"),ot(10),Fe(),Me(11,"p"),ot(12,"Please check the URL or return to the homepage."),Fe(),Me(13,"a",4),zr("click",function(){return n.home()}),ot(14,"Go to Homepage"),Fe()()()(),Wt(15,"app-footer")),e&2&&(qt(10),ci(" [",n.sessionID,"]. "))},dependencies:[Ao]})};var TN=class r{constructor(t){this.router=t}home(){this.router.navigate(["/"])}static \u0275fac=function(e){return new(e||r)(it(Do))};static \u0275cmp=or({type:r,selectors:[["app-empty-game-session-idpage"]],standalone:!0,features:[sr],decls:12,vars:0,consts:[[1,"section"],[1,"container"],[1,"content","is-large"],[1,"title"],[3,"click"]],template:function(e,n){e&1&&(Me(0,"section",0)(1,"div",1)(2,"div",2)(3,"h1",3),ot(4,"MOVE PLAYGROUND"),Fe(),Me(5,"h1"),ot(6,"Invalid game session"),Fe(),Me(7,"p"),ot(8," The link you used to join the game is invalid, please check it again, or return to the homepage. "),Fe(),Me(9,"a",4),zr("click",function(){return n.home()}),ot(10,"Go to Homepage"),Fe()()()(),Wt(11,"app-footer"))},dependencies:[Ao]})};var mie=[{path:"",component:j0},{path:"balloons",component:qk},{path:"lobby/:gameName",component:bN},{path:"play/tic-tac-toe/:externalID",component:SN},{path:"play/error/invalid-session-id/:externalID",component:IN},{path:"play/error/empty-session-id",component:TN},{path:"**",component:Kk}];var gie={providers:[LB({eventCoalescing:!0}),HV(mie)]};var _N=class r{constructor(t,e){this.router=t;this.events=e}allRoutePaths=[];initAutoTracking(){this.router.events.pipe(hs(t=>t instanceof pc)).subscribe(t=>L(this,null,function*(){let e=this.removeParamFromUrl(t.urlAfterRedirects);this.events.track("page.viewed",{page:e})})),this.allRoutePaths=this.getAllRoutePaths(),console.log("allRoutePaths",this.allRoutePaths)}getAllRoutePaths(){let t=[],e=this.router.config;return this.extractPaths(e,"",t),t}extractPaths(t,e,n){t.forEach(o=>{let s=e+(o.path?`/${o.path}`:"");n.push(s),o.children&&this.extractPaths(o.children,s,n)})}removeParamFromUrl(t){for(let e of this.allRoutePaths){if(e.includes("*"))continue;let n=e.replace(/:\w+/g,"[^/]+");if(new RegExp(`^${n}$`).test(t))return t.replace(/\/[^/]+$/,"")}return t}static \u0275fac=function(e){return new(e||r)(St(Do),St(Ql))};static \u0275prov=Qe({token:r,factory:r.\u0275fac,providedIn:"root"})};var EN=class r{constructor(t,e,n){this.events=t;this.activatedRoute=e;this.pageNavigationTracking=n}currentUserId=null;ngOnInit(){this.pageNavigationTracking.initAutoTracking(),this.activatedRoute.queryParams.pipe(oi(1)).subscribe(t=>{let e=t.name;this.identifyUser(e)})}identifyUser(t){this.currentUserId=localStorage.getItem("userId"),this.currentUserId||(t?(this.currentUserId=t,localStorage.setItem("userId",this.currentUserId)):(this.currentUserId=crypto.randomUUID(),localStorage.setItem("userId",this.currentUserId))),this.events.identify(this.currentUserId)}static \u0275fac=function(e){return new(e||r)(it(Ql),it(gs),it(_N))};static \u0275cmp=or({type:r,selectors:[["app-root"]],standalone:!0,features:[sr],decls:1,vars:0,template:function(e,n){e&1&&Wt(0,"router-outlet")},dependencies:[ZR]})};cV(EN,gie).catch(r=>console.error(r));
